diff --git a/.gitignore b/.gitignore
index 47dcd58be3..d4649503b1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,6 +23,9 @@
 # in Git 1.8.2 (March 2013).
 
 
+# Personal customization.
+.dir-locals-2.el
+
 # Built by 'autogen.sh'.
 /aclocal.m4
 /configure
@@ -256,7 +259,6 @@ gnustmp*
 ChangeLog
 [0-9]*.patch
 [0-9]*.txt
-.dir-locals?.el
 /vc-dwim-log-*
 
 # Built by 'make install'.
diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index b022e4b8af..df48764c52 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -21,7 +21,7 @@
 # any particular service that uses that protocol.  Also, it is intended for
 # evaluation purposes, thus possibly temporary.
 
-# Maintainer: tzz@lifelogs.com
+# Maintainer: Ted Zlatanov <tzz@lifelogs.com>
 # URL: https://emba.gnu.org/emacs/emacs
 
 image: debian:stretch
@@ -53,13 +53,15 @@ test-filenotify-gio:
   only:
     changes:
       - .gitlab-ci.yml
+      - lisp/autorevert.el
       - lisp/filenotify.el
       - lisp/net/tramp-sh.el
       - src/gfilenotify.c
+      - test/lisp/autorevert-tests.el
       - test/lisp/filenotify-tests.el
   script:
     - DEBIAN_FRONTEND=noninteractive apt install --no-install-recommends -y -qq -o=Dpkg::Use-Pty=0 libglib2.0-dev libglib2.0-bin libglib2.0-0
     - ./autogen.sh autoconf
     - ./configure --without-makeinfo --with-file-notification=gfile
     - make bootstrap
-    - make -C test filenotify-tests
+    - make -C test autorevert-tests filenotify-tests
diff --git a/CONTRIBUTE b/CONTRIBUTE
index a5433e30d3..f257fc57f0 100644
--- a/CONTRIBUTE
+++ b/CONTRIBUTE
@@ -7,11 +7,14 @@ or run the shell command 'info "(emacs)Contributing"'.)
 ** The Emacs repository
 
 Emacs development uses Git on Savannah for its main repository.
-Briefly, the following shell commands build and run Emacs from scratch:
+To configure Git for Emacs development, you can run the following:
 
 	git config --global user.name 'Your Name'
 	git config --global user.email 'your.name@example.com'
 	git config --global transfer.fsckObjects true
+
+The following shell commands then build and run Emacs from scratch:
+
 	git clone git://git.sv.gnu.org/emacs.git
 	cd emacs
 	./autogen.sh
diff --git a/ChangeLog.3 b/ChangeLog.3
index e7f4d86632..fbaf813852 100644
--- a/ChangeLog.3
+++ b/ChangeLog.3
@@ -1,3 +1,11 @@
+2019-05-25  Eric S. Raymond <esr@thyrsus.com>
+
+	Implement and document XDG-style startup files under ~/.config.
+
+	* lisp/startup.el (command-line): Allow XDG-style as well as old
+	style paths.
+	* doc/startup.texi: Document the above change.
+
 2019-04-11  Eli Zaretskii  <eliz@gnu.org>
 
 	Improve documentation of 'read-command'
diff --git a/GNUmakefile b/GNUmakefile
index e878dbbb55..a67624e1f7 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -27,10 +27,10 @@
 # newly-built Makefile.  If the source tree is already configured,
 # this file defers to the existing Makefile.
 
-# If you are using a non-GNU 'make', or if you want non-default build
-# options, or if you want to build in an out-of-source tree, please
-# run "configure" by hand.  But run autogen.sh first, if the source
-# was checked out directly from the repository.
+# If you want non-default build options, or if you want to build in an
+# out-of-source tree, you should run 'configure' before running 'make'.
+# But run 'autogen.sh' first, if the source was checked out directly
+# from the repository.
 
 # If a Makefile already exists, just use it.
 
diff --git a/INSTALL b/INSTALL
index 8022385010..6934022c4e 100644
--- a/INSTALL
+++ b/INSTALL
@@ -34,11 +34,12 @@ some of the steps manually.  The more detailed description in the other
 sections of this guide will help you do that, so please refer to those
 sections if you need to.
 
-  1. Unpacking the Emacs release requires about 200 MB of free
-  disk space.  Building Emacs uses about another 200 MB of space.
-  The final installed Emacs uses about 150 MB of disk space.
-  This includes the space-saving that comes from automatically
-  compressing the Lisp source files on installation.
+  1.  Obtain and unpack the Emacs release, with commands like this:
+
+		 wget https://ftp.gnu.org/gnu/emacs/emacs-VERSION.tar.xz
+		 tar -xf emacs-VERSION.tar.xz
+
+      where VERSION is the Emacs version number.
 
   2a. 'cd' to the directory where you unpacked Emacs and invoke the
       'configure' script:
@@ -81,13 +82,17 @@ sections if you need to.
 
 		 src/emacs -Q
 
+     To test Emacs further (intended mostly to help developers):
+
+		 make check
+
   6. Assuming that the program 'src/emacs' starts and displays its
      opening screen, you can install the program and its auxiliary
      files into their installation directories:
 
 		 make install
 
-  You are now ready to use Emacs.  If you wish to conserve disk space,
+  You are now ready to use Emacs.  If you wish to conserve space,
   you may remove the program binaries and object files from the
   directory where you built Emacs:
 
@@ -118,7 +123,7 @@ packages.  Note that if there is a separate 'dev' or 'devel' package,
 for use at compilation time rather than run time, you will need that
 as well as the corresponding run time package; typically the dev
 package will contain header files and a library archive.  Otherwise,
-you can download the libraries from <http://www.nongnu.org/m17n/>.
+you can download the libraries from <https://www.nongnu.org/m17n/>.
 
 Note that Emacs cannot support complex scripts on a TTY, unless the
 terminal includes such a support.
@@ -162,14 +167,14 @@ can be found (in the unlikely event that your distribution does not
 provide them).  By default, libraries marked with an X are required if
 X11 is being used.
 
-    libXaw3d          https://directory.fsf.org/project/xaw3d/
-  X libxpm for XPM:   http://www.x.org/releases/current/src/lib/
+    libXaw3d          https://directory.fsf.org/project/Xaw3d
+  X libxpm for XPM:   https://www.x.org/releases/current/src/lib/
   X libpng for PNG:   http://www.libpng.org/
-    libz (for PNG):   http://www.zlib.net/
-  X libjpeg for JPEG: http://www.ijg.org/
-  X libtiff for TIFF: http://www.remotesensing.org/libtiff/
-  X libgif for GIF:   http://sourceforge.net/projects/giflib/
-    librsvg2 for SVG: http://wiki.gnome.org/action/show/Projects/LibRsvg
+    libz (for PNG):   https://www.zlib.net/
+  X libjpeg for JPEG: https://www.ijg.org/
+  X libtiff for TIFF: http://www.simplesystems.org/libtiff/
+  X libgif for GIF:   http://giflib.sourceforge.net/
+    librsvg2 for SVG: https://wiki.gnome.org/Projects/LibRsvg
 
 If you supply the appropriate --without-LIB option, 'configure' will
 omit the corresponding library from Emacs, even if that makes for a
@@ -213,7 +218,7 @@ DETAILED BUILDING AND INSTALLATION:
 see nextstep/INSTALL.  For non-ancient versions of MS Windows, see
 the file nt/INSTALL.  For MS-DOS and MS Windows 3.X, see msdos/INSTALL.)
 
-1) See the basic installation summary above for the disk space requirements.
+1) See BASIC INSTALLATION above for getting and configuring Emacs.
 
 2) In the unlikely event that 'configure' does not detect your system
 type correctly, consult './etc/MACHINES' to see what --host, --build
@@ -294,7 +299,9 @@ or more of these options:
   --without-gif          for GIF image support
   --without-png          for PNG image support
   --without-rsvg         for SVG image support
-  --without-imagemagick  for Imagemagick support
+
+Although ImageMagick support is disabled by default due to security
+and stability concerns, you can enable it with --with-imagemagick.
 
 Use --without-toolkit-scroll-bars to disable Motif or Xaw3d scroll bars.
 
@@ -352,7 +359,7 @@ Use --enable-link-time-optimization to enable link-time optimization.
 With GCC, you need GCC 4.5.0 and later, and 'configure' arranges for
 linking to be parallelized if possible.  With Clang, you need GNU
 binutils with the gold linker and plugin support, along with the LLVM
-gold plugin <http://llvm.org/docs/GoldPlugin.html>.  Link time
+gold plugin <https://llvm.org/docs/GoldPlugin.html>.  Link time
 optimization is not the default as it tends to cause crashes and to
 make Emacs slower.
 
diff --git a/INSTALL.REPO b/INSTALL.REPO
index 6dca9dd714..48faa81fbb 100644
--- a/INSTALL.REPO
+++ b/INSTALL.REPO
@@ -1,8 +1,15 @@
 	     Building and Installing Emacs from the Repository
 
-Simply run 'make'.  This should work if your files are freshly checked
-out from the repository, and if you have the proper tools installed.
-If it doesn't work, or if you have special build requirements, the
+The Emacs repository is hosted on Savannah.  The following Git command
+will clone the repository to the 'emacs' subdirectory of the current
+directory on your local machine:
+
+    git clone git://git.sv.gnu.org/emacs.git
+
+To build the repository code, simply run 'make' in the 'emacs'
+directory.  This should work if your files are freshly checked out
+from the repository, and if you have the proper tools installed.  If
+it doesn't work, or if you have special build requirements, the
 following information may be helpful.
 
 Building Emacs from the source-code repository requires some tools
@@ -32,8 +39,8 @@ can invoke './configure -C'.  After configuring, build Emacs as follows:
 
   $ make
 
-If you want to install Emacs, type 'make install' instead of 'make' in
-the last command.
+You can also type 'make check' to test and 'make install' to install
+Emacs.
 
 Occasionally the file 'lisp/loaddefs.el' (and similar automatically
 generated files, such as 'esh-groups.el', and '*-loaddefs.el' in some
diff --git a/Makefile.in b/Makefile.in
index 53703638c4..21362a9196 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -320,7 +320,8 @@ SUBDIR_MAKEFILES = $(patsubst ${srcdir}/%,%,${SUBDIR_MAKEFILES_IN:.in=})
 # Non-makefile files created by config.status.
 CONFIG_STATUS_FILES_IN = \
  ${srcdir}/nt/emacs.rc.in ${srcdir}/nt/emacsclient.rc.in \
- ${srcdir}/doc/man/emacs.1.in
+ ${srcdir}/doc/man/emacs.1.in ${srcdir}/src/emacs-module.h.in \
+ ${srcdir}/src/module-env-*.h
 
 # Subdirectories to install, and where they'll go.  lib-src's and nt's
 # makefiles know how to install them, so we don't do that here.
@@ -869,7 +870,7 @@ top_bootclean=\
 top_distclean=\
 	${top_bootclean}; \
 	rm -f config.status config.log~ \
-	  Makefile lib/gnulib.mk ${SUBDIR_MAKEFILES}
+	  Makefile makefile lib/gnulib.mk ${SUBDIR_MAKEFILES}
 
 distclean_dirs = $(clean_dirs) leim lisp
 
@@ -949,17 +950,15 @@ extraclean: $(extraclean_dirs:=_extraclean)
 TAGS tags: lib lib-src # src
 	$(MAKE) -C src tags
 
-.PHONY: have-tests
-have-tests:
-	@if test ! -d test; then \
-	  echo "You do not seem to have the test/ directory."; \
-	  echo "Maybe you are using a release tarfile, rather than a repository checkout."; \
-	 exit 1; \
-	fi
-
-.PHONY: check check-maybe check-expensive check-all
-check check-maybe check-expensive check-all: have-tests all
+CHECK_TARGETS = check check-maybe check-expensive check-all
+.PHONY: $(CHECK_TARGETS)
+$(CHECK_TARGETS): all
+ifeq ($(wildcard test),test)
 	$(MAKE) -C test $@
+else
+	@echo "You do not seem to have the test/ directory."
+	@echo "Maybe you used a release tarfile that lacks tests."
+endif
 
 dist:
 	cd ${srcdir}; ./make-dist
diff --git a/admin/admin.el b/admin/admin.el
index 650cf47b80..d3a477fde8 100644
--- a/admin/admin.el
+++ b/admin/admin.el
@@ -138,7 +138,10 @@ Root must be the root of an Emacs source tree."
                               (if (eq 2 (length newversion)) 0 1))))
          (majorbump (and oldversion (not (equal oldmajor newmajor))))
          (minorbump (and oldversion (not majorbump)
-                         (not (equal (cadr oldversion) (cadr newversion)))))
+                         (or (not (equal (cadr oldversion) (cadr newversion)))
+                             ;; Eg 26.2 -> 26.2.50.
+                             (and (> (length newversion)
+                                     (length oldversion))))))
          (newsfile (expand-file-name "etc/NEWS" root))
          (oldnewsfile (expand-file-name (format "etc/NEWS.%s" oldmajor) root)))
     (unless (> (length newversion) 2)   ; pretest or release candidate?
@@ -696,6 +699,7 @@ style=\"text-align:left\">")
     (if (file-directory-p stem)
 	(delete-directory stem t))
     (make-directory stem)
+    (setq stem (file-name-as-directory stem))
     (copy-file "../doc/misc/texinfo.tex" stem)
     (unless (equal type "emacs")
       (copy-file "../doc/emacs/emacsver.texi" stem)
@@ -718,7 +722,7 @@ style=\"text-align:left\">")
 	  (setq ats t)
 	  (message "Unexpanded: %s" (match-string 0)))
 	(if ats (error "Unexpanded configure variables in Makefile?")))
-      (write-region nil nil (expand-file-name (format "%s/Makefile" stem))
+      (write-region nil nil (expand-file-name (format "%sMakefile" stem))
 		    nil 'silent))
     (call-process "tar" nil nil nil "-cf" tarfile stem)
     (delete-directory stem t)
diff --git a/admin/authors.el b/admin/authors.el
index a3f8bdde84..eb4843e3cb 100644
--- a/admin/authors.el
+++ b/admin/authors.el
@@ -1,4 +1,3 @@
-
 ;;; authors.el --- utility for maintaining Emacs's AUTHORS file
 
 ;; Copyright (C) 2000-2019 Free Software Foundation, Inc.
diff --git a/admin/cus-test.el b/admin/cus-test.el
index f9fd53d98e..f7fbd75ac7 100644
--- a/admin/cus-test.el
+++ b/admin/cus-test.el
@@ -2,8 +2,7 @@
 
 ;; Copyright (C) 1998, 2000, 2002-2019 Free Software Foundation, Inc.
 
-;; Author: Markus Rost <markus.rost@mathematik.uni-regensburg.de>
-;; Maintainer: Markus Rost <rost@math.ohio-state.edu>
+;; Author: Markus Rost <rost@math.uni-bielefeld.de>
 ;; Created: 13 Sep 1998
 ;; Keywords: maint
 
diff --git a/admin/grammars/grammar.wy b/admin/grammars/grammar.wy
index f7664de655..5b06917d7d 100644
--- a/admin/grammars/grammar.wy
+++ b/admin/grammars/grammar.wy
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2002-2019 Free Software Foundation, Inc.
 ;;
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 26 Aug 2002
 ;; Keywords: syntax
 ;; X-RCS: $Id: semantic-grammar.wy,v 1.16 2005/09/30 20:20:27 zappo Exp $
diff --git a/admin/grammars/java-tags.wy b/admin/grammars/java-tags.wy
index 88beafeddb..db4f61c5b0 100644
--- a/admin/grammars/java-tags.wy
+++ b/admin/grammars/java-tags.wy
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2002-2019 Free Software Foundation, Inc.
 ;;
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 26 Aug 2002
 ;; Keywords: syntax
 
diff --git a/admin/grammars/python.wy b/admin/grammars/python.wy
index 5e5bdc194c..695e612942 100644
--- a/admin/grammars/python.wy
+++ b/admin/grammars/python.wy
@@ -5,7 +5,6 @@
 ;; 2009, 2010 Python Software Foundation; All Rights Reserved
 
 ;; Author: Richard Kim <ryk@dspwiz.com>
-;; Maintainer: Richard Kim <ryk@dspwiz.com>
 ;; Created: June 2002
 ;; Keywords: syntax
 ;;
diff --git a/admin/grammars/srecode-template.wy b/admin/grammars/srecode-template.wy
index fb56d23af5..b5481865ad 100644
--- a/admin/grammars/srecode-template.wy
+++ b/admin/grammars/srecode-template.wy
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2005-2019 Free Software Foundation, Inc.
 
-;; Author: Eric Ludlam <zappo@gnu.org>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 ;; Keywords: syntax
 ;; X-RCS: $Id: srecode-template.wy,v 1.10 2009-01-09 23:01:54 zappo Exp $
 
diff --git a/admin/make-tarball.txt b/admin/make-tarball.txt
index 47b60173f8..43992a0bb2 100644
--- a/admin/make-tarball.txt
+++ b/admin/make-tarball.txt
@@ -115,7 +115,7 @@ General steps (for each step, check for possible errors):
     results against the new tar contents.
 
 7.   tar -xf emacs-NEW.tar; cd emacs-NEW
-     ./configure --prefix=/tmp/emacs && make && make install
+     ./configure --prefix=/tmp/emacs && make check && make install
     Use 'script' or M-x compile to save the compilation log in
     compile-NEW.log and compare it against an old one.  The easiest way
     to do that is to visit the old log in Emacs, change the version
diff --git a/admin/merge-gnulib b/admin/merge-gnulib
index 055e791d62..4a69310d83 100755
--- a/admin/merge-gnulib
+++ b/admin/merge-gnulib
@@ -36,7 +36,7 @@ GNULIB_MODULES='
   filemode filevercmp flexmember fpieee fstatat fsusage fsync
   getloadavg getopt-gnu gettime gettimeofday gitlog-to-changelog
   ieee754-h ignore-value intprops largefile lstat
-  manywarnings memrchr minmax mkostemp mktime nstrftime
+  manywarnings memmem-simple memrchr minmax mkostemp mktime nstrftime
   pipe2 pselect pthread_sigmask putenv qcopy-acl readlink readlinkat regex
   sig2str socklen stat-time std-gnu11 stdalign stddef stdio
   stpcpy strtoimax symlink sys_stat sys_time
@@ -47,7 +47,7 @@ GNULIB_MODULES='
 
 AVOIDED_MODULES='
   btowc close dup fchdir fstat langinfo lock
-  malloc-posix mbrtowc mbsinit mkdir msvc-inval msvc-nothrow nl_langinfo
+  malloc-posix mbrtowc mbsinit memchr mkdir msvc-inval msvc-nothrow nl_langinfo
   openat-die opendir raise
   save-cwd select setenv sigprocmask stat stdarg stdbool
   threadlib tzset unsetenv utime utime-h
diff --git a/admin/nt/dist-build/build-zips.sh b/admin/nt/dist-build/build-zips.sh
index 4404c77962..cff6fdec3e 100755
--- a/admin/nt/dist-build/build-zips.sh
+++ b/admin/nt/dist-build/build-zips.sh
@@ -58,10 +58,10 @@ function build_zip {
             --without-dbus \
             --host=$HOST --without-compress-install \
             $CACHE \
-            CFLAGS="-O2 -static -g3"
+            CFLAGS="$CFLAGS"
     fi
 
-    make -j 2 install \
+    make -j 4 $INSTALL_TARGET \
          prefix=$HOME/emacs-build/install/emacs-$VERSION/$ARCH
     cd $HOME/emacs-build/install/emacs-$VERSION/$ARCH
     cp $HOME/emacs-build/deps/libXpm/$ARCH/libXpm-noX4.dll bin
@@ -107,6 +107,8 @@ BUILD_32=1
 BUILD_64=1
 GIT_UP=0
 CONFIG=1
+CFLAGS="-O2 -static"
+INSTALL_TARGET="install-strip"
 
 while getopts "36gb:hnsiV:" opt; do
   case $opt in
@@ -141,6 +143,8 @@ while getopts "36gb:hnsiV:" opt; do
         ;;
     s)
         SNAPSHOT="-snapshot"
+        CFLAGS="-O2 -static -g3"
+        INSTALL_TARGET="install"
         ;;
     h)
         echo "build-zips.sh"
@@ -200,6 +204,8 @@ else
     OF_VERSION="$VERSION-`date +%Y-%m-%d`"
     ## Use snapshot dependencies
     SNAPSHOT=1
+    CFLAGS="-O2 -static -g3"
+    INSTALL_TARGET="install"
 fi
 
 if (($GIT_UP))
diff --git a/admin/update-copyright b/admin/update-copyright
index 44cb84d8cc..9f360904ce 100755
--- a/admin/update-copyright
+++ b/admin/update-copyright
@@ -50,6 +50,7 @@ repo_files=$(git ls-files) &&
 # Do not update the copyright of files that have one or more of the
 # following problems:
 # . They are license files, maintained by the FSF, with their own dates.
+# . They are GMP files, maintained by the GMP project, with their own dates.
 # . Their format cannot withstand changing the contents of copyright strings.
 
 updatable_files=$(find $repo_files \
@@ -70,6 +71,7 @@ updatable_files=$(find $repo_files \
   ! -name hand.cur \
   ! -name key.pub \
   ! -name key.sec \
+  ! -name 'mini-gmp.[ch]' \
   -print) &&
 
 build-aux/update-copyright $updatable_files
diff --git a/autogen.sh b/autogen.sh
index 40d0c37b11..374f7a9fe2 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -316,8 +316,16 @@ git_config transfer.fsckObjects true
 
 # Configure 'git diff' hunk header format.
 
+# This xfuncname is based on Git's built-in 'cpp' pattern.
+# The first line rejects jump targets and access declarations.
+# The second line matches top-level functions and methods.
+# The third line matches preprocessor and DEFUN macros.
+git_config diff.cpp.xfuncname \
+'!^[ \t]*[A-Za-z_][A-Za-z_0-9]*:[[:space:]]*($|/[/*])
+^((::[[:space:]]*)?[A-Za-z_][A-Za-z_0-9]*[[:space:]]*\(.*)$
+^((#define[[:space:]]|DEFUN).*)$'
 git_config diff.elisp.xfuncname \
-	   '^\(def[^[:space:]]+[[:space:]]+([^()[:space:]]+)'
+           '^\([^[:space:]]*def[^[:space:]]+[[:space:]]+([^()[:space:]]+)'
 git_config 'diff.m4.xfuncname' '^((m4_)?define|A._DEFUN(_ONCE)?)\([^),]*'
 git_config 'diff.make.xfuncname' \
 	   '^([$.[:alnum:]_].*:|[[:alnum:]_]+[[:space:]]*([*:+]?[:?]?|!?)=|define .*)'
@@ -332,7 +340,7 @@ git_config diff.texinfo.xfuncname \
 tailored_hooks=
 sample_hooks=
 
-for hook in commit-msg pre-commit; do
+for hook in commit-msg pre-commit prepare-commit-msg; do
     cmp -- build-aux/git-hooks/$hook "$hooks/$hook" >/dev/null 2>&1 ||
 	tailored_hooks="$tailored_hooks $hook"
 done
diff --git a/build-aux/config.guess b/build-aux/config.guess
index 79d1317f52..ae713942d8 100755
--- a/build-aux/config.guess
+++ b/build-aux/config.guess
@@ -2,7 +2,7 @@
 # Attempt to guess a canonical system name.
 #   Copyright 1992-2019 Free Software Foundation, Inc.
 
-timestamp='2019-03-04'
+timestamp='2019-05-28'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -1325,38 +1325,39 @@ EOF
 	echo "$UNAME_MACHINE"-apple-rhapsody"$UNAME_RELEASE"
 	exit ;;
     *:Darwin:*:*)
-	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	set_cc_for_build
-	if test "$UNAME_PROCESSOR" = unknown ; then
-	    UNAME_PROCESSOR=powerpc
+	UNAME_PROCESSOR=`uname -p`
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	if command -v xcode-select > /dev/null 2> /dev/null && \
+		! xcode-select --print-path > /dev/null 2> /dev/null ; then
+	    # Avoid executing cc if there is no toolchain installed as
+	    # cc will be a stub that puts up a graphical alert
+	    # prompting the user to install developer tools.
+	    CC_FOR_BUILD=no_compiler_found
+	else
+	    set_cc_for_build
 	fi
-	if test "`echo "$UNAME_RELEASE" | sed -e 's/\..*//'`" -le 10 ; then
-	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
-		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
-		       grep IS_64BIT_ARCH >/dev/null
-		then
-		    case $UNAME_PROCESSOR in
-			i386) UNAME_PROCESSOR=x86_64 ;;
-			powerpc) UNAME_PROCESSOR=powerpc64 ;;
-		    esac
-		fi
-		# On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
-		if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
-		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
-		       grep IS_PPC >/dev/null
-		then
-		    UNAME_PROCESSOR=powerpc
-		fi
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_64BIT_ARCH >/dev/null
+	    then
+		case $UNAME_PROCESSOR in
+		    i386) UNAME_PROCESSOR=x86_64 ;;
+		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		esac
+	    fi
+	    # On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
+	    if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_PPC >/dev/null
+	    then
+		UNAME_PROCESSOR=powerpc
 	    fi
 	elif test "$UNAME_PROCESSOR" = i386 ; then
-	    # Avoid executing cc on OS X 10.9, as it ships with a stub
-	    # that puts up a graphical alert prompting to install
-	    # developer tools.  Any system running Mac OS X 10.7 or
-	    # later (Darwin 11 and later) is required to have a 64-bit
-	    # processor. This is not true of the ARM version of Darwin
-	    # that Apple uses in portable devices.
-	    UNAME_PROCESSOR=x86_64
+	    # uname -m returns i386 or x86_64
+	    UNAME_PROCESSOR=$UNAME_MACHINE
 	fi
 	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
 	exit ;;
@@ -1468,6 +1469,14 @@ cat > "$dummy.c" <<EOF
 #include <sys/types.h>
 #include <sys/utsname.h>
 #endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#include <signal.h>
+#if defined(_SIZE_T_) || defined(SIGLOST)
+#include <sys/utsname.h>
+#endif
+#endif
+#endif
 main ()
 {
 #if defined (sony)
@@ -1554,19 +1563,24 @@ main ()
 #else
   printf ("vax-dec-bsd\n"); exit (0);
 #endif
+#else
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname un;
+  uname (&un);
+  printf ("vax-dec-ultrix%s\n", un.release); exit (0);
 #else
   printf ("vax-dec-ultrix\n"); exit (0);
 #endif
 #endif
+#endif
 #if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
 #if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
-#include <signal.h>
-#if defined(_SIZE_T_) /* >= ULTRIX4 */
-  printf ("mips-dec-ultrix4\n"); exit (0);
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname *un;
+  uname (&un);
+  printf ("mips-dec-ultrix%s\n", un.release); exit (0);
 #else
-#if defined(ULTRIX3) || defined(ultrix3) || defined(SIGLOST)
-  printf ("mips-dec-ultrix3\n"); exit (0);
-#endif
+  printf ("mips-dec-ultrix\n"); exit (0);
 #endif
 #endif
 #endif
diff --git a/build-aux/config.sub b/build-aux/config.sub
index 3b4c7624b6..5b158ac41c 100755
--- a/build-aux/config.sub
+++ b/build-aux/config.sub
@@ -2,7 +2,7 @@
 # Configuration validation subroutine script.
 #   Copyright 1992-2019 Free Software Foundation, Inc.
 
-timestamp='2019-01-05'
+timestamp='2019-05-23'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -822,7 +822,9 @@ case $basic_machine in
 		cpu=m68k
 		vendor=next
 		case $os in
-		    nextstep* )
+		    openstep*)
+		        ;;
+		    nextstep*)
 			;;
 		    ns2*)
 		      os=nextstep2
@@ -1170,7 +1172,7 @@ case $cpu-$vendor in
 			| asmjs \
 			| ba \
 			| be32 | be64 \
-			| bfin | bs2000 \
+			| bfin | bpf | bs2000 \
 			| c[123]* | c30 | [cjt]90 | c4x \
 			| c8051 | clipper | craynv | csky | cydra \
 			| d10v | d30v | dlx | dsp16xx \
@@ -1245,7 +1247,8 @@ case $cpu-$vendor in
 			| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \
 			| vax \
 			| visium \
-			| w65 | wasm32 \
+			| w65 \
+			| wasm32 | wasm64 \
 			| we32k \
 			| x86 | x86_64 | xc16x | xgate | xps100 \
 			| xstormy16 | xtensa* \
@@ -1365,7 +1368,7 @@ case $os in
 	     | powermax* | dnix* | nx6 | nx7 | sei* | dragonfly* \
 	     | skyos* | haiku* | rdos* | toppers* | drops* | es* \
 	     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \
-	     | midnightbsd* | amdhsa* | unleashed* | emscripten*)
+	     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	qnx*)
diff --git a/build-aux/git-hooks/prepare-commit-msg b/build-aux/git-hooks/prepare-commit-msg
new file mode 100755
index 0000000000..3562a80223
--- /dev/null
+++ b/build-aux/git-hooks/prepare-commit-msg
@@ -0,0 +1,45 @@
+#!/bin/sh
+# Check the format of GNU Emacs change log entries.
+
+# Copyright 2019 Free Software Foundation, Inc.
+
+# This file is part of GNU Emacs.
+
+# GNU Emacs is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+
+# GNU Emacs is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+# Prefer gawk if available, as it handles NUL bytes properly.
+if type gawk >/dev/null 2>&1; then
+  awk=gawk
+else
+  awk=awk
+fi
+
+exec $awk '
+  # Catch the case when someone ran git-commit with -s option,
+  # which automatically adds Signed-off-by.
+  /^Signed-off-by: / {
+    print "'\''Signed-off-by:'\'' in commit message"
+    status = 1
+  }
+  END {
+    if (status != 0) {
+      print "Commit aborted; please see the file 'CONTRIBUTE'"
+    }
+    exit status
+  }
+' <"$COMMIT_MSG_FILE"
diff --git a/configure.ac b/configure.ac
index d060c92496..c057bfe0cb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -379,8 +379,12 @@ if test "$with_dumping" = "unexec" && test "$with_unexec" = "no"; then
 fi
 
 if test "$with_pdumper" = "yes"; then
-    AC_DEFINE(HAVE_PDUMPER, 1, [Define to build with portable dumper support])
+  AC_DEFINE([HAVE_PDUMPER], 1, [Define to build with portable dumper support])
+  HAVE_PDUMPER=yes
+else
+  HAVE_PDUMPER=no
 fi
+AC_SUBST([HAVE_PDUMPER])
 
 DUMPING=$with_dumping
 AC_SUBST(DUMPING)
@@ -428,7 +432,7 @@ OPTION_DEFAULT_ON([lcms2],[don't compile with Little CMS support])
 OPTION_DEFAULT_ON([libsystemd],[don't compile with libsystemd support])
 OPTION_DEFAULT_OFF([cairo],[compile with Cairo drawing (experimental)])
 OPTION_DEFAULT_ON([xml2],[don't compile with XML parsing support])
-OPTION_DEFAULT_ON([imagemagick],[don't compile with ImageMagick image support])
+OPTION_DEFAULT_OFF([imagemagick],[compile with ImageMagick image support])
 OPTION_DEFAULT_ON([json], [don't compile with native JSON support])
 
 OPTION_DEFAULT_ON([xft],[don't use XFT for anti aliased fonts])
@@ -541,7 +545,7 @@ AC_ARG_ENABLE(checking,
 		 enable only specific categories of checks.
 		 Categories are: all,yes,no.
 		 Flags are: stringbytes, stringoverrun, stringfreelist,
-		 structs, xmallocoverrun, conslist, glyphs])],
+		 structs, glyphs])],
 [ac_checking_flags="${enableval}"],[])
 IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS="$IFS,"
 CHECK_STRUCTS=false
@@ -555,24 +559,18 @@ do
 			ac_gc_check_stringbytes= ;
 	                ac_gc_check_string_overrun= ;
 	                ac_gc_check_string_free_list= ;
-	                ac_xmalloc_overrun= ;
-	                ac_gc_check_cons_list= ;
 			ac_glyphs_debug= ;;
 	all)		ac_enable_checking=1 ;
 			CHECK_STRUCTS=true
 			ac_gc_check_stringbytes=1 ;
 	                ac_gc_check_string_overrun=1 ;
 	                ac_gc_check_string_free_list=1 ;
-	                ac_xmalloc_overrun=1 ;
-	                ac_gc_check_cons_list=1 ;
 			ac_glyphs_debug=1 ;;
 	# these enable particular checks
 	stringbytes)	ac_gc_check_stringbytes=1 ;;
 	stringoverrun)	ac_gc_check_string_overrun=1 ;;
 	stringfreelist) ac_gc_check_string_free_list=1 ;;
 	structs)	CHECK_STRUCTS=true ;;
-	xmallocoverrun)	ac_xmalloc_overrun=1 ;;
-	conslist)	ac_gc_check_cons_list=1 ;;
 	glyphs)		ac_glyphs_debug=1 ;;
 	*)	AC_MSG_ERROR(unknown check category $check) ;;
 	esac
@@ -606,14 +604,6 @@ if test x$ac_gc_check_string_free_list != x ; then
   AC_DEFINE(GC_CHECK_STRING_FREE_LIST, 1,
 [Define this to check the string free list.])
 fi
-if test x$ac_xmalloc_overrun != x ; then
-  AC_DEFINE(XMALLOC_OVERRUN_CHECK, 1,
-[Define this to check for malloc buffer overrun.])
-fi
-if test x$ac_gc_check_cons_list != x ; then
-  AC_DEFINE(GC_CHECK_CONS_LIST, 1,
-[Define this to check for errors in cons list.])
-fi
 if test x$ac_glyphs_debug != x ; then
   AC_DEFINE(GLYPH_DEBUG, 1,
 [Define this to enable glyphs debugging code.])
@@ -1064,6 +1054,9 @@ AS_IF([test $gl_gcc_warnings = no],
   # Emacs's use of alloca inhibits protecting the stack.
   nw="$nw -Wstack-protector"
 
+  # Emacs's use of __attribute__ ((cold)) causes false alarms with this option.
+  nw="$nw -Wsuggest-attribute=cold"
+
   # Emacs's use of partly-const functions such as Fgnutls_available_p
   # make this option problematic.
   nw="$nw -Wsuggest-attribute=const"
@@ -2688,8 +2681,8 @@ check_gtk2=no
 gtk3_pkg_errors=
 if test "${opsys}" != "mingw32"; then
   if test "${with_gtk3}" = "yes" || test "${with_gtk}" = "yes" || test "$USE_X_TOOLKIT" = "maybe"; then
-    GLIB_REQUIRED=2.28
-    GTK_REQUIRED=3.0
+    GLIB_REQUIRED=2.37.5
+    GTK_REQUIRED=3.10
     GTK_MODULES="gtk+-3.0 >= $GTK_REQUIRED glib-2.0 >= $GLIB_REQUIRED"
 
     dnl Checks for libraries.
@@ -2716,8 +2709,8 @@ if test "${opsys}" != "mingw32"; then
   fi
 
   if test "${with_gtk2}" = "yes" || test "$check_gtk2" = "yes"; then
-    GLIB_REQUIRED=2.10
-    GTK_REQUIRED=2.10
+    GLIB_REQUIRED=2.28
+    GTK_REQUIRED=2.24
     GTK_MODULES="gtk+-2.0 >= $GTK_REQUIRED glib-2.0 >= $GLIB_REQUIRED"
 
     dnl Checks for libraries.
@@ -2792,44 +2785,25 @@ if test "${HAVE_GTK}" = "yes"; then
     with_toolkit_scroll_bars=yes
   fi
 
-  dnl  Check if we have the old file selection dialog declared and
-  dnl  in the link library.  In 2.x it may be in the library,
-  dnl  but not declared if deprecated featured has been selected out.
-  dnl  AC_CHECK_DECL checks for a macro, so check for GTK_TYPE_FILE_SELECTION.
-  HAVE_GTK_FILE_SELECTION=no
-  AC_CHECK_DECL(GTK_TYPE_FILE_SELECTION, HAVE_GTK_FILE_SELECTION=yes,
-                   HAVE_GTK_FILE_SELECTION=no, [AC_INCLUDES_DEFAULT
-#include <gtk/gtk.h>])
-  if test "$HAVE_GTK_FILE_SELECTION" = yes; then
-    AC_CHECK_FUNCS(gtk_file_selection_new)
-  fi
+  term_header=gtkutil.h
 
-  dnl Same as above for gtk_handle_box.
-  HAVE_GTK_HANDLE_BOX=no
-  AC_CHECK_DECL(GTK_TYPE_HANDLE_BOX, HAVE_GTK_HANDLE_BOX=yes,
-                   HAVE_GTK_HANDLE_BOX=no, [AC_INCLUDES_DEFAULT
-#include <gtk/gtk.h>])
-  if test "$HAVE_GTK_HANDLE_BOX" = yes; then
-    AC_CHECK_FUNCS(gtk_handle_box_new)
-  fi
+  if test "${USE_GTK_TOOLKIT}" = GTK2; then
 
-  dnl Same as above for gtk_tearoff_menu_item.
-  HAVE_GTK_TEAROFF_MENU_ITEM=no
-  AC_CHECK_DECL(GTK_TYPE_TEAROFF_MENU_ITEM, HAVE_GTK_TEAROFF_MENU_ITEM=yes,
-                   HAVE_GTK_TEAROFF_MENU_ITEM=no, [AC_INCLUDES_DEFAULT
+    dnl  Check if we have the old file selection dialog declared and
+    dnl  in the link library.  In 2.x it may be in the library,
+    dnl  but not declared if deprecated featured has been selected out.
+    dnl  AC_CHECK_DECL checks for a macro, so check for GTK_TYPE_FILE_SELECTION.
+    HAVE_GTK_FILE_SELECTION=no
+    AC_CHECK_DECL(GTK_TYPE_FILE_SELECTION, HAVE_GTK_FILE_SELECTION=yes,
+                     HAVE_GTK_FILE_SELECTION=no, [AC_INCLUDES_DEFAULT
 #include <gtk/gtk.h>])
-  if test "$HAVE_GTK_TEAROFF_MENU_ITEM" = yes; then
-    AC_CHECK_FUNCS(gtk_tearoff_menu_item_new)
-  fi
-
-  dnl Check for functions introduced in 2.14 and later.
-  AC_CHECK_FUNCS(gtk_widget_get_window gtk_widget_set_has_window \
-                 gtk_dialog_get_action_area gtk_widget_get_sensitive \
-                 gtk_widget_get_mapped gtk_adjustment_get_page_size \
-                 gtk_orientable_set_orientation \
-		 gtk_window_set_has_resize_grip)
+    if test "$HAVE_GTK_FILE_SELECTION" = yes; then
+      AC_CHECK_FUNCS(gtk_file_selection_new)
+    fi
 
- term_header=gtkutil.h
+    dnl This procedure causes a bug on certain Ubuntu GTK+2 builds
+    AC_CHECK_FUNCS(gtk_window_set_has_resize_grip)
+  fi
 fi
 
 
@@ -3356,12 +3330,44 @@ if test "${HAVE_X11}" = "yes"; then
   fi
 fi
 
+HAVE_CAIRO=no
+if test "${HAVE_X11}" = "yes"; then
+  if test "${with_cairo}" != "no"; then
+    CAIRO_REQUIRED=1.12.0
+    CAIRO_MODULE="cairo >= $CAIRO_REQUIRED"
+    EMACS_CHECK_MODULES(CAIRO, $CAIRO_MODULE)
+    if test $HAVE_CAIRO = yes; then
+      AC_DEFINE(USE_CAIRO, 1, [Define to 1 if using cairo.])
+    else
+      AC_MSG_ERROR([cairo requested but not found.])
+    fi
+
+    CFLAGS="$CFLAGS $CAIRO_CFLAGS"
+    LIBS="$LIBS $CAIRO_LIBS"
+    AC_SUBST(CAIRO_CFLAGS)
+    AC_SUBST(CAIRO_LIBS)
+  fi
+fi
+
 ### Start of font-backend (under any platform) section.
 # (nothing here yet -- this is a placeholder)
 ### End of font-backend (under any platform) section.
 
 ### Start of font-backend (under X11) section.
 if test "${HAVE_X11}" = "yes"; then
+  if test $HAVE_CAIRO = yes; then
+    dnl Strict linkers fail with
+    dnl ftfont.o: undefined reference to symbol 'FT_New_Face'
+    dnl if -lfreetype is not specified.
+    dnl The following is needed to set FREETYPE_LIBS.
+    EMACS_CHECK_MODULES([FREETYPE], [freetype2])
+
+    test "$HAVE_FREETYPE" = "no" && AC_MSG_ERROR(cairo requires libfreetype)
+
+    EMACS_CHECK_MODULES([FONTCONFIG], [fontconfig >= 2.2.0])
+
+    test "$HAVE_FONTCONFIG" = "no" && AC_MSG_ERROR(cairo requires libfontconfig)
+  else
     ## Use -lXft if available, unless '--with-xft=no'.
     HAVE_XFT=maybe
     if test "x${with_x}" = "xno"; then
@@ -3418,6 +3424,7 @@ if test "${HAVE_X11}" = "yes"; then
 
        test "$HAVE_FREETYPE" = "no" && AC_MSG_ERROR(libxft requires libfreetype)
     fi
+  fi				  # $HAVE_CAIRO != yes
 
     HAVE_LIBOTF=no
     if test "${HAVE_FREETYPE}" = "yes"; then
@@ -3471,25 +3478,6 @@ AC_SUBST(LIBOTF_LIBS)
 AC_SUBST(M17N_FLT_CFLAGS)
 AC_SUBST(M17N_FLT_LIBS)
 
-HAVE_CAIRO=no
-if test "${HAVE_X11}" = "yes"; then
-  if test "${with_cairo}" != "no"; then
-    CAIRO_REQUIRED=1.12.0
-    CAIRO_MODULE="cairo >= $CAIRO_REQUIRED"
-    EMACS_CHECK_MODULES(CAIRO, $CAIRO_MODULE)
-    if test $HAVE_CAIRO = yes; then
-      AC_DEFINE(USE_CAIRO, 1, [Define to 1 if using cairo.])
-    else
-      AC_MSG_ERROR([cairo requested but not found.])
-    fi
-
-    CFLAGS="$CFLAGS $CAIRO_CFLAGS"
-    LIBS="$LIBS $CAIRO_LIBS"
-    AC_SUBST(CAIRO_CFLAGS)
-    AC_SUBST(CAIRO_LIBS)
-  fi
-fi
-
 if test "${HAVE_X11}" = "yes"; then
   AC_CHECK_HEADER(X11/Xlib-xcb.h,
     AC_CHECK_LIB(xcb, xcb_translate_coordinates, HAVE_XCB=yes))
@@ -3727,6 +3715,8 @@ AC_SUBST_FILE([module_env_snippet_27])
 module_env_snippet_25="$srcdir/src/module-env-25.h"
 module_env_snippet_26="$srcdir/src/module-env-26.h"
 module_env_snippet_27="$srcdir/src/module-env-27.h"
+emacs_major_version="${PACKAGE_VERSION%%.*}"
+AC_SUBST(emacs_major_version)
 
 ### Use -lpng if available, unless '--with-png=no'.
 HAVE_PNG=no
@@ -5755,9 +5745,8 @@ m4_define([subdir_makefiles],
 SUBDIR_MAKEFILES="subdir_makefiles"
 AC_CONFIG_FILES(subdir_makefiles)
 
-dnl test/ is not present in release tarfiles.
+dnl The test/ directory is missing if './make-dist --no-tests' was used.
 opt_makefile=test/Makefile
-
 if test -f "$srcdir/$opt_makefile.in"; then
   SUBDIR_MAKEFILES="$SUBDIR_MAKEFILES $opt_makefile"
   dnl Again, it's best not to use a variable.  Though you can add
@@ -5859,4 +5848,12 @@ you can continue to support by using '$0 --with-pop'.])
   esac
 fi
 
-test "$MAKE" = make || AC_MSG_NOTICE([Now you can run '$MAKE'.])
+# Let plain 'make' work.
+test "$MAKE" = make || test -f makefile || cat >makefile <<EOF
+.POSIX:
+MAKE = $MAKE
+all:
+	\$(MAKE) -f Makefile \$?
+.DEFAULT:
+	\$(MAKE) -f Makefile \$<
+EOF
diff --git a/doc/emacs/arevert-xtra.texi b/doc/emacs/arevert-xtra.texi
index cd7c1ff895..37e2f9e581 100644
--- a/doc/emacs/arevert-xtra.texi
+++ b/doc/emacs/arevert-xtra.texi
@@ -4,8 +4,9 @@
 @c
 @c This file is included either in emacs-xtra.texi (when producing the
 @c printed version) or in the main Emacs manual (for the on-line version).
-@node Autorevert
-@section Auto Reverting Non-File Buffers
+
+@node Non-File Buffers
+@subsection Auto Reverting Non-File Buffers
 
 Global Auto Revert Mode normally only reverts file buffers.  There are
 two ways to auto-revert certain non-file buffers: by enabling Auto
@@ -34,6 +35,14 @@ the Buffer Menu.)  In this case, Auto Revert does not print any
 messages while reverting, even when @code{auto-revert-verbose} is
 non-@code{nil}.
 
+@vindex buffer-auto-revert-by-notification
+Some non-file buffers can be updated reliably by file notification on
+their default directory; Dired buffers is an example.  The major mode
+can indicate this by setting @code{buffer-auto-revert-by-notification}
+to a non-@code{nil} value in that buffer, allowing Auto Revert to
+avoid periodic polling.  Such notification does not include changes to
+files in that directory, only to the directory itself.
+
 The details depend on the particular types of buffers and are
 explained in the corresponding sections.
 
@@ -43,7 +52,7 @@ explained in the corresponding sections.
 @end menu
 
 @node Auto Reverting the Buffer Menu
-@subsection Auto Reverting the Buffer Menu
+@subsubsection Auto Reverting the Buffer Menu
 
 If auto-reverting of non-file buffers is enabled, the Buffer Menu
 @iftex
@@ -65,7 +74,7 @@ adding marks sets the buffer's modified flag prevents Auto Revert from
 automatically erasing the marks.
 
 @node Auto Reverting Dired
-@subsection Auto Reverting Dired buffers
+@subsubsection Auto Reverting Dired buffers
 
 Dired buffers only auto-revert when the file list of the buffer's main
 directory changes (e.g., when a new file is added or deleted).  They
diff --git a/doc/emacs/buffers.texi b/doc/emacs/buffers.texi
index 27fcb7369a..14a0a01ca8 100644
--- a/doc/emacs/buffers.texi
+++ b/doc/emacs/buffers.texi
@@ -568,10 +568,10 @@ mode in this buffer, as long as it is not marked modified.  Global
 Auto Revert mode applies to the @file{*Buffer List*} buffer only if
 @code{global-auto-revert-non-file-buffers} is non-@code{nil}.
 @iftex
-@inforef{Autorevert,, emacs-xtra}, for details.
+@inforef{Auto Reverting the Buffer Menu,, emacs-xtra}, for details.
 @end iftex
 @ifnottex
-@xref{Autorevert, global-auto-revert-non-file-buffers}, for details.
+@xref{Auto Reverting the Buffer Menu, global-auto-revert-non-file-buffers}, for details.
 @end ifnottex
 
 @node Indirect Buffers
diff --git a/doc/emacs/building.texi b/doc/emacs/building.texi
index 78d07b8d39..6e16588861 100644
--- a/doc/emacs/building.texi
+++ b/doc/emacs/building.texi
@@ -151,6 +151,20 @@ with the mouse (@pxref{Mouse References}), to visit the @dfn{locus} of
 the error message in a separate window.  The locus is the specific
 position in a file where that error occurred.
 
+@cindex compilation mode faces
+@vindex compilation-error
+@vindex compilation-warning
+  The appearance of the @file{*compilation*} buffer can be controlled
+by customizing the faces which are used to highlight parts of the
+@file{*compilation*} buffer, e.g., @code{compilation-error} or
+@code{compilation-warning}, for error and warning messages
+respectively.  Note that since those faces inherit from the
+@code{error} and @code{warning} faces, it is also possible to
+customize the parent face directly instead.
+
+  Use @w{@kbd{M-x customize-group RET compilation}} to see the entire
+list of customization variables and faces.
+
 @findex compile-goto-error
 @vindex compilation-auto-jump-to-first-error
   If you change the variable
@@ -1507,6 +1521,12 @@ library lets Emacs properly set up the hyperlinks in the @file{*Help*}
 buffer).  To disable this feature, change the variable
 @code{help-enable-auto-load} to @code{nil}.
 
+@vindex help-enable-completion-auto-load
+Automatic loading also occurs when completing names for
+@code{describe-variable} and @code{describe-function}, based on the
+prefix being completed.  To disable this feature, change the variable
+@code{help-enable-completion-auto-load} to @code{nil}.
+
 @vindex load-dangerous-libraries
 @cindex Lisp files byte-compiled by XEmacs
   By default, Emacs refuses to load compiled Lisp files which were
diff --git a/doc/emacs/cmdargs.texi b/doc/emacs/cmdargs.texi
index 00d5be70eb..34a5ff5f2c 100644
--- a/doc/emacs/cmdargs.texi
+++ b/doc/emacs/cmdargs.texi
@@ -39,7 +39,7 @@ corresponding long form.
 
   The long forms with @samp{--} are easier to remember, but longer to
 type.  However, you don't have to spell out the whole option name; any
-unambiguous abbreviation is enough.  When a long option takes an
+unambiguous abbreviation is enough.  When a long option requires an
 argument, you can use either a space or an equal sign to separate the
 option name and the argument.  Thus, for the option @samp{--display},
 you can write either @samp{--display sugar-bombs:0.0} or
@@ -347,13 +347,15 @@ Start Emacs with minimum customizations.  This is similar to using
 @itemx --bg-daemon[=@var{name}]
 @itemx --fg-daemon[=@var{name}]
 Start Emacs as a daemon: after Emacs starts up, it starts the Emacs
-server without opening any frames.
-(Optionally, you can specify an explicit @var{name} for the server.)
-You can then use the @command{emacsclient} command to connect to Emacs
-for editing.  @xref{Emacs Server}, for information about using Emacs
-as a daemon.  A ``background'' daemon disconnects from the terminal
-and runs in the background (@samp{--daemon} is an alias for
-@samp{--bg-daemon}).
+server without opening any frames.  You can then use the
+@command{emacsclient} command to connect to Emacs for editing.
+(Optionally, you can specify an explicit @var{name} for the server; if
+you do, you will need to specify the same @var{name} when you invoke
+@command{emacsclient}, via its @option{--socket-name} option, see
+@ref{emacsclient Options}.)  @xref{Emacs Server}, for information
+about using Emacs as a daemon.  A ``background'' daemon disconnects
+from the terminal and runs in the background (@samp{--daemon} is an
+alias for @samp{--bg-daemon}).
 
 @item --no-desktop
 @opindex --no-desktop
diff --git a/doc/emacs/custom.texi b/doc/emacs/custom.texi
index c649c17029..982cea1f21 100644
--- a/doc/emacs/custom.texi
+++ b/doc/emacs/custom.texi
@@ -380,7 +380,7 @@ lines of code to your initialization file, to set the variable
 file.  For example:
 
 @example
-(setq custom-file "~/.emacs-custom.el")
+(setq custom-file "~/.config/emacs-custom.el")
 (load custom-file)
 @end example
 
@@ -390,14 +390,14 @@ Emacs versions, like this:
 @example
 (cond ((< emacs-major-version 22)
        ;; @r{Emacs 21 customization.}
-       (setq custom-file "~/.custom-21.el"))
+       (setq custom-file "~/.config/custom-21.el"))
       ((and (= emacs-major-version 22)
             (< emacs-minor-version 3))
        ;; @r{Emacs 22 customization, before version 22.3.}
-       (setq custom-file "~/.custom-22.el"))
+       (setq custom-file "~/.config/custom-22.el"))
       (t
        ;; @r{Emacs version 22.3 or later.}
-       (setq custom-file "~/.emacs-custom.el")))
+       (setq custom-file "~/.config/emacs-custom.el")))
 
 (load custom-file)
 @end example
@@ -801,6 +801,7 @@ Its value is 70
   Automatically becomes buffer-local when set.
   This variable is safe as a file local variable if its value
   satisfies the predicate ‘integerp’.
+  Probably introduced at or before Emacs version 18.
 
 Documentation:
 Column beyond which automatic line-wrapping should happen.
@@ -1331,7 +1332,7 @@ On MS-DOS, the name of this file should be @file{_dir-locals.el}, due
 to limitations of the DOS filesystems.  If the filesystem is limited
 to 8+3 file names, the name of the file will be truncated by the OS to
 @file{_dir-loc.el}.
-}in a directory.  Whenever Emacs visits any file in that directory or
+} in a directory.  Whenever Emacs visits any file in that directory or
 any of its subdirectories, it will apply the directory-local variables
 specified in @file{.dir-locals.el}, as though they had been defined as
 file-local variables for that file (@pxref{File Variables}).  Emacs
@@ -1377,6 +1378,28 @@ be applied in the current directory, not in any subdirectories.
 Finally, it specifies a different @file{ChangeLog} file name for any
 file in the @file{src/imported} subdirectory.
 
+If the @file{.dir-locals.el} file contains multiple different values
+for a variable using different mode names or directories, the values
+will be applied in an order such that the values for more specific
+modes take priority over more generic modes.  Values specified under a
+directory have even more priority.  For example:
+
+@example
+((nil . ((fill-column . 40)))
+ (c-mode . ((fill-column . 50)))
+ (prog-mode . ((fill-column . 60)))
+ ("narrow-files" . ((nil . ((fill-column . 20))))))
+@end example
+
+Files that use @code{c-mode} also match @code{prog-mode} because the
+former inherits from the latter.  The value used for
+@code{fill-column} in C files will however be @code{50} because the
+mode name is more specific than @code{prog-mode}.  Files using other
+modes inheriting from @code{prog-mode} will use @code{60}.  Any file
+under the directory @file{narrow-files} will use the value @code{20}
+even if they use @code{c-mode} because directory entries have priority
+over mode entries.
+
 You can specify the variables @code{mode}, @code{eval}, and
 @code{unibyte} in your @file{.dir-locals.el}, and they have the same
 meanings as they would have in file local variables.  @code{coding}
@@ -2192,16 +2215,28 @@ as a function from Lisp programs.
 @cindex init file
 @cindex .emacs file
 @cindex ~/.emacs file
+@cindex ~/.config/emacs file
 @cindex Emacs initialization file
 @cindex startup (init file)
 
   When Emacs is started, it normally tries to load a Lisp program from
 an @dfn{initialization file}, or @dfn{init file} for short.  This
 file, if it exists, specifies how to initialize Emacs for you.  Emacs
-looks for your init file using the filenames @file{~/.emacs},
-@file{~/.emacs.el}, or @file{~/.emacs.d/init.el}; you can choose to
-use any one of these three names (@pxref{Find Init}).  Here, @file{~/}
-stands for your home directory.
+looks for your init file using the filenames
+@file{~/.config/emacs},. @file{~/.emacs}, @file{~/.config/emacs.el},
+@file{~/.emacs.el}, @file{~/.config/emacs.d/init.el} or
+@file{~/.emacs.d/init.el}; you can choose to use any one of these
+names (@pxref{Find Init}).  Here, @file{~/} stands for your home
+directory.
+
+  While the @file{~/.emacs} and @file{~/.emacs.d/init.el} locations
+are backward-compatible to older Emacs versions, and the rest of this
+chapter will use them to name your initialization file, it is better practice
+to group all of your dotfiles under @file{.config} so that if you have
+to troubleshoot a problem that might be due to a bad init file, or
+archive a collection of them, it can be done by renaming or
+copying that directory.  Note that the @file{.config} versions
+don't have a leading dot on the basename part of the file.
 
   You can use the command line switch @samp{-q} to prevent loading
 your init file, and @samp{-u} (or @samp{--user}) to specify a
@@ -2607,14 +2642,16 @@ library.  @xref{Hooks}.
 @node Find Init
 @subsection How Emacs Finds Your Init File
 
-  Normally Emacs uses your home directory to find @file{~/.emacs};
-that's what @samp{~} means in a file name.  @xref{General Variables, HOME}.
-If neither @file{~/.emacs} nor @file{~/.emacs.el} is found, Emacs looks for
-@file{~/.emacs.d/init.el} (which, like @file{~/.emacs.el}, can be
-byte-compiled).
+  Normally Emacs uses your home directory to find
+@file{~/.config/emacs} or @file{~/.emacs}; that's what @samp{~} means
+in a file name.  @xref{General Variables, HOME}.  If none of
+@file{~/.config/emacs}, @file{~/.emacs}, @file{~/.config/emacs.el} nor
+@file{~/.emacs.el} is found, Emacs looks for
+@file{~/.config/emacs.d/init.el} or @file{~/.emacs.d/init.el} (these,
+like @file{~/.emacs.el}, can be byte-compiled).
 
   However, if you run Emacs from a shell started by @code{su}, Emacs
-tries to find your own @file{.emacs}, not that of the user you are
+tries to find your own initialization files, not that of the user you are
 currently pretending to be.  The idea is that you should get your own
 editor customizations even if you are running as the super user.
 
@@ -2665,10 +2702,10 @@ Type @kbd{C-q}, followed by the key you want to bind, to insert @var{char}.
 @cindex early init file
 
   Most customizations for Emacs should be put in the normal init file,
-@file{.emacs} or @file{~/.emacs.d/init.el}.  However, it is sometimes desirable
+@file{.config/emacs} or @file{~/.config/emacs.d/init.el}.  However, it is sometimes desirable
 to have customizations that take effect during Emacs startup earlier than the
 normal init file is processed.  Such customizations can be put in the early
-init file, @file{~/.emacs.d/early-init.el}.  This file is loaded before the
+init file, @file{~/.config/emacs.d/early-init.el} or @file{~/.emacs.d/early-init.el}.  This file is loaded before the
 package system and GUI is initialized, so in it you can customize variables
 that affect frame appearance as well as the package initialization process,
 such as @code{package-enable-at-startup}, @code{package-load-list}, and
diff --git a/doc/emacs/display.texi b/doc/emacs/display.texi
index f464a3a59f..4985fabd54 100644
--- a/doc/emacs/display.texi
+++ b/doc/emacs/display.texi
@@ -1141,6 +1141,55 @@ right-to-left paragraphs.
 @node Displaying Boundaries
 @section Displaying Boundaries
 
+@cindex mode, display-fill-column-indicator
+@findex display-fill-column-indicator-mode
+@findex global-display-fill-column-indicator-mode
+  Emacs can add an indicator to display a fill column position.  The
+fill column indicator is a useful functionality specially in
+prog-mode to indicate the position of an specific column.
+
+  You can set the buffer-local variables @code{display-fill-column-indicator}
+and @code{display-fill-column-indicator-character} to activate the
+indicator and controls how the indicator looks.
+
+Alternatively you can type @w{@kbd{M-x display-fill-column-indicator-mode}}
+or @w{@kbd{M-x global-display-fill-column-indicator-mode}} which enables the
+indicator locally and globally respectively and also chooses the
+character to use if none is set already.  It is possible to use the
+first one to activate the indicator in a hook or the second one to
+enable it globally.
+
+There are 2 buffer local variables and 1 face to customize this mode:
+
+@table @code
+@item display-fill-column-indicator-column
+@vindex display-fill-column-indicator-column
+Specifies the column number where the indicator should be set.  It can
+take positive numerical values for the column or the special value
+@code{t} which means that the variable @code{fill-column} will be
+used.
+
+Any other value disables the indicator.  The default value is @code{t}.
+
+@item display-fill-column-indicator-char
+@vindex display-fill-column-indicator-char
+Specifies the character used for the indicator.  This character can be
+any valid char including unicode ones if the actual font supports
+them.
+
+When the mode is enabled through the functions
+@code{display-fill-column-indicator-mode} or
+@code{global-display-fill-column-indicator-mode}, the initialization
+functions check if this variable is @code{non-nil}, otherwise the
+initialization tries to set it to U+2502 or @samp{|}.
+
+@item fill-column-indicator
+@vindex fill-column-indicator
+Specifies the face used to display the indicator.  It inherits its
+default values from shadow but without background color.  To change
+the indicator color you need to set only the foreground color of this face.
+@end table
+
 @vindex indicate-buffer-boundaries
   On graphical displays, Emacs can indicate the buffer boundaries in
 the fringes.  If you enable this feature, the first line and the last
diff --git a/doc/emacs/emacs-xtra.texi b/doc/emacs/emacs-xtra.texi
index dcd8fae1b6..e9231b4e3a 100644
--- a/doc/emacs/emacs-xtra.texi
+++ b/doc/emacs/emacs-xtra.texi
@@ -59,7 +59,7 @@ modify this GNU manual.''
 * Picture Mode::        Editing pictures made up of characters using
                          the quarter-plane screen model.
 
-* Autorevert::          Auto Reverting non-file buffers.
+* Non-File Buffers::    Auto Reverting non-file buffers.
 * Subdir Switches::     Subdirectory switches in Dired.
 * Advanced Calendar/Diary Usage:: Advanced Calendar/Diary customization.
 * Emerge::              A convenient way of merging two versions of a program.
diff --git a/doc/emacs/emacs.texi b/doc/emacs/emacs.texi
index 58ec373029..a34cef221e 100644
--- a/doc/emacs/emacs.texi
+++ b/doc/emacs/emacs.texi
@@ -443,9 +443,7 @@ File Handling
 * Visiting::            Visiting a file prepares Emacs to edit the file.
 * Saving::              Saving makes your changes permanent.
 * Reverting::           Reverting cancels all the changes not saved.
-@ifnottex
-* Autorevert::          Auto Reverting non-file buffers.
-@end ifnottex
+* Auto Revert::         Keeping buffers automatically up-to-date.
 * Auto Save::           Auto Save periodically protects against loss of data.
 * File Aliases::        Handling multiple names for one file.
 * Directories::         Creating, deleting, and listing file directories.
diff --git a/doc/emacs/files.texi b/doc/emacs/files.texi
index a57428230c..36ef1dcea2 100644
--- a/doc/emacs/files.texi
+++ b/doc/emacs/files.texi
@@ -25,9 +25,7 @@ on file directories.
 * Visiting::            Visiting a file prepares Emacs to edit the file.
 * Saving::              Saving makes your changes permanent.
 * Reverting::           Reverting cancels all the changes not saved.
-@ifnottex
-* Autorevert::          Auto Reverting non-file buffers.
-@end ifnottex
+* Auto Revert::         Keeping buffers automatically up-to-date.
 * Auto Save::           Auto Save periodically protects against loss of data.
 * File Aliases::        Handling multiple names for one file.
 * Directories::         Creating, deleting, and listing file directories.
@@ -955,6 +953,11 @@ revert it automatically if it has changed---provided the buffer itself
 is not modified.  (If you have edited the text, it would be wrong to
 discard your changes.)
 
+  You can also tell Emacs to revert buffers automatically when their
+visited files change on disk; @pxref{Auto Revert}.
+
+@node Auto Revert
+@section Auto Revert: Keeping buffers automatically up-to-date
 @cindex Global Auto Revert mode
 @cindex mode, Global Auto Revert
 @cindex Auto Revert mode
@@ -962,22 +965,39 @@ discard your changes.)
 @findex global-auto-revert-mode
 @findex auto-revert-mode
 @findex auto-revert-tail-mode
-@vindex auto-revert-interval
-@vindex auto-revert-remote-files
+
+  A buffer can get out of sync with respect to its visited file on
+disk if that file is changed by another program.  To keep it up to
+date, you can enable Auto Revert mode by typing @kbd{M-x auto-revert-mode}.
+This automatically reverts the buffer when its visited file changes on
+disk.  To do the same for all file buffers, type
+@kbd{M-x global-auto-revert-mode} to enable Global Auto Revert mode.
+
+  Auto Revert will not revert a buffer if it has unsaved changes, or if
+its file on disk is deleted or renamed.
+
+  One use of Auto Revert mode is to ``tail'' a file such as a system
+log, so that changes made to that file by other programs are
+continuously displayed.  To do this, just move the point to the end of
+the buffer, and it will stay there as the file contents change.
+However, if you are sure that the file will only change by growing at
+the end, use Auto Revert Tail mode instead
+(@code{auto-revert-tail-mode}).  It is more efficient for this.
+Auto Revert Tail mode also works for remote files.
+
 @vindex auto-revert-verbose
-  You can also tell Emacs to revert buffers periodically.  To do this
-for a specific buffer, enable the minor mode Auto-Revert mode by
-typing @kbd{M-x auto-revert-mode}.  This automatically reverts the
-current buffer when its visited file changes on disk.  To do the same
-for all file buffers, type @kbd{M-x global-auto-revert-mode} to enable
-Global Auto-Revert mode.  These minor modes do not check or revert
-remote files, because that is usually too slow.  This behavior can be
-changed by setting the variable @code{auto-revert-remote-files} to
-non-@code{nil}.
+  When a buffer is auto-reverted, a message is generated.  This can be
+suppressed by setting @code{auto-revert-verbose} to @code{nil}.
+
+@vindex auto-revert-remote-files
+  The Auto Revert modes do not check or revert remote files, because
+that is usually too slow.  This behavior can be changed by setting the
+variable @code{auto-revert-remote-files} to non-@code{nil}.
 
 @cindex file notifications
 @vindex auto-revert-use-notify
-  By default, Auto-Revert mode works using @dfn{file notifications},
+@vindex auto-revert-interval
+  By default, Auto Revert mode works using @dfn{file notifications},
 whereby changes in the filesystem are reported to Emacs by the OS.
 You can disable use of file notifications by customizing the variable
 @code{auto-revert-use-notify} to a @code{nil} value, then Emacs will
@@ -988,19 +1008,22 @@ the polling interval through the variable @code{auto-revert-interval}.
 supported, @code{auto-revert-use-notify} will be @code{nil} by
 default.
 
-  One use of Auto-Revert mode is to ``tail'' a file such as a system
-log, so that changes made to that file by other programs are
-continuously displayed.  To do this, just move the point to the end of
-the buffer, and it will stay there as the file contents change.
-However, if you are sure that the file will only change by growing at
-the end, use Auto-Revert Tail mode instead
-(@code{auto-revert-tail-mode}).  It is more efficient for this.
-Auto-Revert Tail mode works also for remote files.
-
-  When a buffer is auto-reverted, a message is generated.  This can be
-suppressed by setting @code{auto-revert-verbose} to @code{nil}.
-
-  In Dired buffers (@pxref{Dired}), Auto-Revert mode refreshes the
+@vindex auto-revert-avoid-polling
+@vindex auto-revert-notify-exclude-dir-regexp
+  By default, Auto Revert mode will poll files for changes
+periodically even when file notifications are used.  Polling is
+unnecessary in many cases, and turning it off may save power by
+relying on notifications only.  To do so, set the variable
+@code{auto-revert-avoid-polling} to non-@code{nil}.  However,
+notification is ineffective on certain file systems; mainly network
+file system on Unix-like machines, where files can be altered from
+other machines.  For such file systems, polling may be necessary.
+To force polling when
+@code{auto-revert-avoid-polling} is non-@code{nil}, set
+@code{auto-revert-notify-exclude-dir-regexp} to match files that
+should be excluded from using notification.
+
+  In Dired buffers (@pxref{Dired}), Auto Revert mode refreshes the
 buffer when a file is created or deleted in the buffer's directory.
 
   @xref{VC Undo}, for commands to revert to earlier versions of files
@@ -1008,6 +1031,9 @@ under version control.  @xref{VC Mode Line}, for Auto Revert
 peculiarities when visiting files under version control.
 
 @ifnottex
+@menu
+* Non-File Buffers::    Auto Reverting Non-File Buffers.
+@end menu
 @include arevert-xtra.texi
 @end ifnottex
 
diff --git a/doc/emacs/maintaining.texi b/doc/emacs/maintaining.texi
index fd0119e98c..0fbf91ae61 100644
--- a/doc/emacs/maintaining.texi
+++ b/doc/emacs/maintaining.texi
@@ -1033,6 +1033,7 @@ systems support modifying change comments.
 Visit the revision indicated at the current line.
 
 @item d
+@itemx =
 Display a diff between the revision at point and the next earlier
 revision, for the specific file.
 
@@ -1047,6 +1048,16 @@ L}), toggle between showing and hiding the full log entry for the
 revision at point.
 @end table
 
+To compare two arbitrary revisions, activate the region: set the
+beginning of the region to the line with the first revision and the
+end of the region to the line with the second revision to compare,
+then type @kbd{d} or @kbd{=}.  When the beginning of the region is on
+the top line that has no revision, it uses the current working revision
+as the first revision to compare.  When the end of the region is on
+the bottom non-revision line after the last revision line, then it
+uses the next earlier revision after the last displayed revision as
+the second revision to compare.
+
 @vindex vc-log-show-limit
 Because fetching many log entries can be slow, the
 @file{*vc-change-log*} buffer displays no more than 2000 revisions by
@@ -1093,8 +1104,7 @@ started editing, and asks for confirmation for discarding the changes.
 If you agree, the fileset is reverted.  If you don't want @kbd{C-x v
 u} to show a diff, set the variable @code{vc-revert-show-diff} to
 @code{nil} (you can still view the diff directly with @kbd{C-x v =};
-@pxref{Old Revisions}).  Note that @kbd{C-x v u} cannot be reversed
-with the usual undo commands (@pxref{Undo}), so use it with care.
+@pxref{Old Revisions}).
 
   On locking-based version control systems, @kbd{C-x v u} leaves files
 unlocked; you must lock again to resume editing.  You can also use
diff --git a/doc/emacs/mark.texi b/doc/emacs/mark.texi
index aa753888e5..5ffe7264a3 100644
--- a/doc/emacs/mark.texi
+++ b/doc/emacs/mark.texi
@@ -76,7 +76,7 @@ Set point and the mark around the text you drag across.
 @item mouse-3
 Set the mark at point, then move point to where you click
 (@code{mouse-save-then-kill}).
-@item @samp{Shifted cursor motion keys}
+@item @r{Shifted cursor motion keys}
 Set the mark at point if the mark is inactive, then move point.
 @xref{Shift Selection}.
 @end table
diff --git a/doc/emacs/misc.texi b/doc/emacs/misc.texi
index 7d7065a441..cfc50d33b5 100644
--- a/doc/emacs/misc.texi
+++ b/doc/emacs/misc.texi
@@ -775,6 +775,13 @@ documentation for more possibilities.
 displayed only when the command generates output, set
 @code{async-shell-command-display-buffer} to @code{nil}.
 
+@vindex async-shell-command-width
+  The option @code{async-shell-command-width} defines the number of display
+columns available for output of asynchronous shell commands.
+A positive integer tells the shell to use that number of columns for
+command output.  The default value is @code{nil} that means to use
+the same number of columns as provided by the shell.
+
 @kindex M-|
 @findex shell-command-on-region
   @kbd{M-|} (@code{shell-command-on-region}) is like @kbd{M-!}, but
@@ -1976,6 +1983,9 @@ omitted, @command{emacsclient} connects to the first server it finds.
 If you set @code{server-name} of the Emacs server to an absolute file
 name, give the same absolute file name as @var{server-name} to this
 option to instruct @command{emacsclient} to connect to that server.
+You need to use this option if you started Emacs as daemon
+(@pxref{Initial Options}) and specified the name for the server
+started by the daemon.
 
 Alternatively, you can set the @env{EMACS_SOCKET_NAME} environment
 variable to point to the server socket.  (The command-line option
@@ -2475,10 +2485,13 @@ automatically back to binary.
 into hex.  This is useful if you visit a file normally and then discover
 it is a binary file.
 
-  Ordinary text characters overwrite in Hexl mode.  This is to reduce
+  Inserting text always overwrites in Hexl mode.  This is to reduce
 the risk of accidentally spoiling the alignment of data in the file.
-There are special commands for insertion.  Here is a list of the
-commands of Hexl mode:
+Ordinary text characters insert themselves (i.e., overwrite with
+themselves).  There are commands for insertion of special characters
+by their code.  Most cursor motion keys, as well as @kbd{C-x C-s}, are
+bound in Hexl mode to commands that produce the same effect.  Here is
+a list of other important commands special to Hexl mode:
 
 @c I don't think individual index entries for these commands are useful--RMS.
 @table @kbd
@@ -2491,6 +2504,12 @@ Insert a byte with a code typed in octal.
 @item C-M-x
 Insert a byte with a code typed in hex.
 
+@item C-M-a
+Move to the beginning of a 512-byte page.
+
+@item C-M-e
+Move to the end of a 512-byte page.
+
 @item C-x [
 Move to the beginning of a 1k-byte page.
 
diff --git a/doc/emacs/programs.texi b/doc/emacs/programs.texi
index c1ad5b5702..28bfa5b578 100644
--- a/doc/emacs/programs.texi
+++ b/doc/emacs/programs.texi
@@ -1298,8 +1298,11 @@ count as blocks.
 @findex hs-show-block
 @findex hs-show-region
 @findex hs-hide-level
+@findex hs-toggle-hiding
+@findex hs-mouse-toggle-hiding
 @kindex C-c @@ C-h
 @kindex C-c @@ C-s
+@kindex C-c @@ C-c
 @kindex C-c @@ C-M-h
 @kindex C-c @@ C-M-s
 @kindex C-c @@ C-r
@@ -1312,7 +1315,7 @@ Hide the current block (@code{hs-hide-block}).
 @item C-c @@ C-s
 Show the current block (@code{hs-show-block}).
 @item C-c @@ C-c
-@itemx C-x @@ C-e
+@itemx C-c @@ C-e
 Either hide or show the current block (@code{hs-toggle-hiding}).
 @item S-mouse-2
 Toggle hiding for the block you click on (@code{hs-mouse-toggle-hiding}).
diff --git a/doc/emacs/text.texi b/doc/emacs/text.texi
index 96492783b9..7892b346d2 100644
--- a/doc/emacs/text.texi
+++ b/doc/emacs/text.texi
@@ -644,6 +644,10 @@ or before @samp{)}, @samp{:} or @samp{?}); and
 @code{fill-polish-nobreak-p} (don't break after a one letter word,
 even if preceded by a non-whitespace character).
 
+  Emacs can display an indicator in the @code{fill-column} position
+using the Display fill column indicator mode 
+(@pxref{Displaying Boundaries, display-fill-column-indicator}).
+
 @node Fill Prefix
 @subsection The Fill Prefix
 
diff --git a/doc/emacs/trouble.texi b/doc/emacs/trouble.texi
index 1bdd9fa014..2fe5487805 100644
--- a/doc/emacs/trouble.texi
+++ b/doc/emacs/trouble.texi
@@ -1400,9 +1400,10 @@ to the FSF@.  For the reasons behind this, see
 @url{https://www.gnu.org/licenses/why-assign.html}.
 
 Copyright assignment is a simple process.  Residents of some countries
-can do it entirely electronically.  We can help you get started, and
-answer any questions you may have (or point you to the people with the
-answers), at the @email{emacs-devel@@gnu.org} mailing list.
+can do it entirely electronically.  We can help you get started,
+including sending you the forms you should fill, and answer any
+questions you may have (or point you to the people with the answers),
+at the @email{emacs-devel@@gnu.org} mailing list.
 
 (Please note: general discussion about why some GNU projects ask
 for a copyright assignment is off-topic for emacs-devel.
diff --git a/doc/lispintro/emacs-lisp-intro.texi b/doc/lispintro/emacs-lisp-intro.texi
index 519decb1d0..c03fbfc47b 100644
--- a/doc/lispintro/emacs-lisp-intro.texi
+++ b/doc/lispintro/emacs-lisp-intro.texi
@@ -9014,26 +9014,24 @@ Lisp; it is written in C and is one of the primitives of the GNU Emacs
 system.  Since it is very simple, I will digress briefly from Lisp and
 describe it here.
 
-@c GNU Emacs 24  in src/editfns.c
-@c the DEFUN for  delete-and-extract-region
-
 @need 1500
 Like many of the other Emacs primitives,
 @code{delete-and-extract-region} is written as an instance of a C
 macro, a macro being a template for code.  The complete macro looks
 like this:
 
+@c This is a copy of editfns.c's DEFUN for delete-and-extract-region.
 @smallexample
 @group
 DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
        Sdelete_and_extract_region, 2, 2, 0,
        doc: /* Delete the text between START and END and return it.  */)
-       (Lisp_Object start, Lisp_Object end)
+  (Lisp_Object start, Lisp_Object end)
 @{
   validate_region (&start, &end);
-  if (XINT (start) == XINT (end))
+  if (XFIXNUM (start) == XFIXNUM (end))
     return empty_unibyte_string;
-  return del_range_1 (XINT (start), XINT (end), 1, 1);
+  return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
 @}
 @end group
 @end smallexample
@@ -9097,9 +9095,9 @@ consists of the following four lines:
 @smallexample
 @group
 validate_region (&start, &end);
-if (XINT (start) == XINT (end))
+if (XFIXNUM (start) == XFIXNUM (end))
   return empty_unibyte_string;
-return del_range_1 (XINT (start), XINT (end), 1, 1);
+return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
 @end group
 @end smallexample
 
@@ -9111,27 +9109,28 @@ then return an empty string.
 The @code{del_range_1} function actually deletes the text.  It is a
 complex function we will not look into.  It updates the buffer and
 does other things.  However, it is worth looking at the two arguments
-passed to @code{del_range_1}.  These are @w{@code{XINT (start)}} and
-@w{@code{XINT (end)}}.
+passed to @code{del_range_1}.  These are @w{@code{XFIXNUM (start)}} and
+@w{@code{XFIXNUM (end)}}.
 
 As far as the C language is concerned, @code{start} and @code{end} are
-two integers that mark the beginning and end of the region to be
-deleted@footnote{More precisely, and requiring more expert knowledge
-to understand, the two integers are of type @code{Lisp_Object}, which can
-also be a C union instead of an integer type.}.
+two opaque values that mark the beginning and end of the region to be
+deleted.  More precisely, and requiring more expert knowledge
+to understand, the two values are of type @code{Lisp_Object}, which
+might be a C pointer, a C integer, or a C @code{struct}; C code
+ordinarily should not care how @code{Lisp_Object} is implemented.
 
-Integer widths depend on the machine, and are typically 32 or 64 bits.
-A few of the bits are used to specify the type of information; the
-remaining bits are used as content.
+@code{Lisp_Object} widths depend on the machine, and are typically 32
+or 64 bits.  A few of the bits are used to specify the type of
+information; the remaining bits are used as content.
 
-@samp{XINT} is a C macro that extracts the relevant number from the
+@samp{XFIXNUM} is a C macro that extracts the relevant integer from the
 longer collection of bits; the type bits are discarded.
 
 @need 800
 The command in @code{delete-and-extract-region} looks like this:
 
 @smallexample
-del_range_1 (XINT (start), XINT (end), 1, 1);
+del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
 @end smallexample
 
 @noindent
@@ -21858,14 +21857,17 @@ MENU ENTRY: NODE NAME.
 @end ifnottex
 
 @quotation
-Robert J. Chassell has worked with GNU Emacs since 1985.  He writes
-and edits, teaches Emacs and Emacs Lisp, and speaks throughout the
+Robert J. Chassell (1946--2017) started working with GNU Emacs in 1985.  He wrote
+and edited, taught Emacs and Emacs Lisp, and spoke throughout the
 world on software freedom.  Chassell was a founding Director and
-Treasurer of the Free Software Foundation, Inc.  He is co-author of
-the @cite{Texinfo} manual, and has edited more than a dozen other
-books.  He graduated from Cambridge University, in England.  He has an
-abiding interest in social and economic history and flies his own
+Treasurer of the Free Software Foundation, Inc.  He was co-author of
+the @cite{Texinfo} manual, and edited more than a dozen other
+books.  He graduated from Cambridge University, in England.  He had an
+abiding interest in social and economic history and flew his own
 airplane.
+
+@uref{https://www.fsf.org/blogs/community/goodbye-to-bob-chassell,
+"Goodbye to Bob Chassell"}
 @end quotation
 
 @c @page
diff --git a/doc/lispref/commands.texi b/doc/lispref/commands.texi
index cd44c1c87e..5ea0be2667 100644
--- a/doc/lispref/commands.texi
+++ b/doc/lispref/commands.texi
@@ -1047,12 +1047,9 @@ and meaning of input events in detail.
 This function returns non-@code{nil} if @var{object} is an input event
 or event type.
 
-Note that any symbol might be used as an event or an event type.
-@code{eventp} cannot distinguish whether a symbol is intended by Lisp
-code to be used as an event.  Instead, it distinguishes whether the
-symbol has actually been used in an event that has been read as input in
-the current Emacs session.  If a symbol has not yet been so used,
-@code{eventp} returns @code{nil}.
+Note that any non-@code{nil} symbol might be used as an event or an
+event type; @code{eventp} cannot distinguish whether a symbol is
+intended by Lisp code to be used as an event.
 @end defun
 
 @menu
diff --git a/doc/lispref/control.texi b/doc/lispref/control.texi
index 5d4184e3fb..e308d68b75 100644
--- a/doc/lispref/control.texi
+++ b/doc/lispref/control.texi
@@ -1451,7 +1451,7 @@ Run @var{body} with @var{var} bound to each value that
 @end defmac
 
 The Common Lisp loop facility also contains features for working with
-iterators.  See @xref{Loop Facility,,,cl,Common Lisp Extensions}.
+iterators.  @xref{Loop Facility,,,cl,Common Lisp Extensions}.
 
 The following piece of code demonstrates some important principles of
 working with iterators.
diff --git a/doc/lispref/customize.texi b/doc/lispref/customize.texi
index f71dedfd8b..02eefe0f58 100644
--- a/doc/lispref/customize.texi
+++ b/doc/lispref/customize.texi
@@ -950,10 +950,10 @@ possibilities:
 
 @itemize @bullet
 @item
-A predicate---that is, a function of one argument that has no side
-effects, and returns either @code{nil} or non-@code{nil} according to
-the argument.  Using a predicate in the list says that objects for which
-the predicate returns non-@code{nil} are acceptable.
+A predicate---that is, a function of one argument that returns either
+@code{nil} or non-@code{nil} according to the argument.  Using a
+predicate in the list says that objects for which the predicate
+returns non-@code{nil} are acceptable.
 
 @item
 A quoted constant---that is, @code{'@var{object}}.  This sort of element
diff --git a/doc/lispref/display.texi b/doc/lispref/display.texi
index a97aabe9df..82af02fc38 100644
--- a/doc/lispref/display.texi
+++ b/doc/lispref/display.texi
@@ -426,7 +426,7 @@ This function calls @code{progress-reporter-update}, so the first
 message is printed immediately.
 @end defun
 
-@defun progress-reporter-update reporter &optional value
+@defun progress-reporter-update reporter &optional value suffix
 This function does the main work of reporting progress of your
 operation.  It displays the message of @var{reporter}, followed by
 progress percentage determined by @var{value}.  If percentage is zero,
@@ -440,6 +440,11 @@ state of your operation and must be between @var{min-value} and
 @code{make-progress-reporter}.  For instance, if you scan a buffer,
 then @var{value} should be the result of a call to @code{point}.
 
+Optional argument @var{suffix} is a string to be displayed after
+@var{reporter}'s main message and progress text.  If @var{reporter} is
+a non-numerical reporter, then @var{value} should be @code{nil}, or a
+string to use instead of @var{suffix}.
+
 This function respects @var{min-change} and @var{min-time} as passed
 to @code{make-progress-reporter} and so does not output new messages
 on every invocation.  It is thus very fast and normally you should not
@@ -447,11 +452,11 @@ try to reduce the number of calls to it: resulting overhead will most
 likely negate your effort.
 @end defun
 
-@defun progress-reporter-force-update reporter &optional value new-message
+@defun progress-reporter-force-update reporter &optional value new-message suffix
 This function is similar to @code{progress-reporter-update} except
 that it prints a message in the echo area unconditionally.
 
-The first two arguments have the same meaning as for
+@var{reporter}, @var{value}, and @var{suffix} have the same meaning as for
 @code{progress-reporter-update}.  Optional @var{new-message} allows
 you to change the message of the @var{reporter}.  Since this function
 always updates the echo area, such a change will be immediately
@@ -5176,6 +5181,9 @@ values.  If both @code{:scale} and @code{:height}/@code{:width} are
 specified, the height/width will be adjusted by the specified scaling
 factor.
 
+@item :rotation @var{angle}
+Specifies a rotation angle in degrees.
+
 @item :index @var{frame}
 @xref{Multi-Frame Images}.
 
@@ -5318,14 +5326,15 @@ This function returns @code{t} if image @var{spec} has a mask bitmap.
 (@pxref{Input Focus}).
 @end defun
 
-@defun image-scaling-p &optional frame
-This function returns @code{t} if @var{frame} supports image scaling.
-@var{frame} @code{nil} or omitted means to use the selected frame
-(@pxref{Input Focus}).
+@defun image-transforms-p &optional frame
+This function returns @code{t} if @var{frame} supports image scaling
+and rotation.  @var{frame} @code{nil} or omitted means to use the
+selected frame (@pxref{Input Focus}).
 
-If image scaling is not supported, @code{:width}, @code{:height},
-@code{:scale}, @code{:max-width} and @code{:max-height} will only be
-usable through ImageMagick, if available (@pxref{ImageMagick Images}).
+If image transforms are not supported, @code{:rotation},
+@code{:width}, @code{:height}, @code{:scale}, @code{:max-width} and
+@code{:max-height} will only be usable through ImageMagick, if
+available (@pxref{ImageMagick Images}).
 @end defun
 
 @node XBM Images
@@ -5469,9 +5478,6 @@ The value, @var{type}, should be a symbol specifying the type of the
 image data, as found in @code{image-format-suffixes}.  This is used
 when the image does not have an associated file name, to provide a
 hint to ImageMagick to help it detect the image type.
-
-@item :rotation @var{angle}
-Specifies a rotation angle in degrees.
 @end table
 
 @node SVG Images
@@ -5909,8 +5915,8 @@ This function returns the size of an image as a pair
 specification.  @var{pixels} non-@code{nil} means return sizes measured
 in pixels, otherwise return sizes measured in the default character size
 of @var{frame} (@pxref{Frame Font}).  @var{frame} is the frame on which
-the image will be displayed.  @var{frame} null or omitted means use the
-selected frame (@pxref{Input Focus}).
+the image will be displayed.  @var{frame} @code{nil} or omitted means
+use the selected frame (@pxref{Input Focus}).
 @end defun
 
 @defvar max-image-size
diff --git a/doc/lispref/eval.texi b/doc/lispref/eval.texi
index db42dfb637..39c5a1ec50 100644
--- a/doc/lispref/eval.texi
+++ b/doc/lispref/eval.texi
@@ -87,6 +87,7 @@ also temporarily alter the environment by binding variables
 (@pxref{Local Variables}).
 
 @cindex side effect
+@anchor{Definition of side effect}
   Evaluating a form may also make changes that persist; these changes
 are called @dfn{side effects}.  An example of a form that produces a
 side effect is @code{(setq foo 1)}.
diff --git a/doc/lispref/functions.texi b/doc/lispref/functions.texi
index 222f863c98..ab07d38928 100644
--- a/doc/lispref/functions.texi
+++ b/doc/lispref/functions.texi
@@ -38,11 +38,16 @@ define them.
 @cindex return value
 @cindex value of function
 @cindex argument
+@cindex pure function
   In a general sense, a function is a rule for carrying out a
 computation given input values called @dfn{arguments}.  The result of
 the computation is called the @dfn{value} or @dfn{return value} of the
 function.  The computation can also have side effects, such as lasting
-changes in the values of variables or the contents of data structures.
+changes in the values of variables or the contents of data structures
+(@pxref{Definition of side effect}).  A @dfn{pure function} is a
+function which, in addition to having no side effects, always returns
+the same value for the same combination of arguments, regardless of
+external factors such as machine type or system state.
 
   In most computer languages, every function has a name.  But in Lisp,
 a function in the strictest sense has no name: it is an object which
@@ -1117,6 +1122,10 @@ a byte-code function object (@pxref{Byte Compilation}).
 When lexical binding is enabled, @var{function-object} is converted
 into a closure.  @xref{Closures}.
 @end itemize
+
+When @var{function-object} is a symbol and the code is byte compiled,
+the byte-compiler will warn if that function is not defined or might
+not be known at run time.
 @end defspec
 
 @cindex @samp{#'} syntax
@@ -2369,7 +2378,7 @@ safe.
 A form that creates temporary bindings (@code{condition-case},
 @code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or
 @code{let*}), if all args are safe and the symbols to be bound are not
-explicitly risky (see @pxref{File Local Variables}).
+explicitly risky (@pxref{File Local Variables}).
 @item
 An assignment using @code{add-to-list}, @code{setq}, @code{push}, or
 @code{pop}, if all args are safe and the symbols to be assigned are
diff --git a/doc/lispref/hooks.texi b/doc/lispref/hooks.texi
index 71992464e0..f775aa4d4b 100644
--- a/doc/lispref/hooks.texi
+++ b/doc/lispref/hooks.texi
@@ -251,6 +251,7 @@ I thought did not need to be mentioned here:
 
 Lisp:
 after-load-functions
+after-set-visited-file-name-hook
 auto-coding-functions
 choose-completion-string-functions
 completing-read-function
diff --git a/doc/lispref/internals.texi b/doc/lispref/internals.texi
index 8ebe47d9ad..cfeb492af4 100644
--- a/doc/lispref/internals.texi
+++ b/doc/lispref/internals.texi
@@ -1031,10 +1031,9 @@ number of arguments.  They work by calling @code{Ffuncall}.
 @file{lisp.h} contains the definitions for some important macros and
 functions.
 
-  If you define a function which is side-effect free, update the code
-in @file{byte-opt.el} that binds @code{side-effect-free-fns} and
-@code{side-effect-and-error-free-fns} so that the compiler optimizer
-knows about it.
+  If you define a function which is side-effect free or pure, give it
+a non-@code{nil} @code{side-effect-free} or @code{pure} property,
+respectively (@pxref{Standard Properties}).
 
 @node Writing Dynamic Modules
 @section Writing Dynamically-Loaded Modules
@@ -1192,6 +1191,17 @@ grow with new Emacs releases.  Given the version of Emacs, the module
 can use only the parts of the module @acronym{API} that existed in
 that version, since those parts are identical in later versions.
 
+@file{emacs-module.h} defines a preprocessor macro
+@code{EMACS_MAJOR_VERSION}.  It expands to an integer literal which is
+the latest major version of Emacs supported by the header.
+@xref{Version Info}.  Note that the value of
+@code{EMACS_MAJOR_VERSION} is a compile-time constant and does not
+represent the version of Emacs that is currently running and has
+loaded your module.  If you want your module to be compatible with
+various versions of @file{emacs-module.h} as well as various versions
+of Emacs, you can use conditional compilation based on
+@code{EMACS_MAJOR_VERSION}.
+
 We recommend that modules always perform the compatibility
 verification, unless they do their job entirely in the initialization
 function, and don't access any Lisp objects or use any Emacs functions
@@ -1378,7 +1388,9 @@ can be used to obtain the type of a @code{emacs_value} object.
 This function returns the value of a Lisp integer specified by
 @var{arg}.  The C data type of the return value, @code{intmax_t}, is
 the widest integral data type supported by the C compiler, typically
-@w{@code{long long}}.
+@w{@code{long long}}.  If the value of @var{arg} doesn't fit into an
+@code{intmax_t}, the function signals an error using the error symbol
+@code{overflow-error}.
 @end deftypefn
 
 @deftypefn Function double extract_float (emacs_env *@var{env}, emacs_value @var{arg})
@@ -1386,6 +1398,38 @@ This function returns the value of a Lisp float specified by
 @var{arg}, as a C @code{double} value.
 @end deftypefn
 
+@deftypefn Function struct timespec extract_time (emacs_env *@var{env}, emacs_value @var{time})
+This function, which is available since Emacs 27, interprets
+@var{time} as an Emacs Lisp time value and returns the corresponding
+@code{struct timespec}.  @xref{Time of Day}.  @code{struct timespec}
+represents a timestamp with nanosecond precision.  It has the
+following members:
+
+@table @code
+@item time_t tv_sec
+Whole number of seconds.
+@item long tv_nsec
+Fractional seconds as number of nanoseconds, always less than one
+billion.
+@end table
+
+@noindent
+@xref{Elapsed Time,,,libc}.
+
+If @var{time} has higher precision than nanoseconds, then this
+function truncates it to nanosecond precision towards negative
+infinity.  This function signals an error if @var{time} (truncated to
+nanoseconds) cannot be represented by @code{struct timespec}.  For
+example, if @code{time_t} is a 32-bit integral type, then a @var{time}
+value of ten billion seconds would signal an error, but a @var{time}
+value of 600 picoseconds would get truncated to zero.
+
+If you need to deal with time values that are not representable by
+@code{struct timespec}, or if you want higher precision, call the Lisp
+function @code{encode-time} and work with its return value.
+@xref{Time Conversion}.
+@end deftypefn
+
 @deftypefn Function bool copy_string_contents (emacs_env *@var{env}, emacs_value @var{arg}, char *@var{buf}, ptrdiff_t *@var{len})
 This function stores the UTF-8 encoded text of a Lisp string specified
 by @var{arg} in the array of @code{char} pointed by @var{buf}, which
@@ -1440,11 +1484,10 @@ objects from basic C data types.  They all return the created
 
 @deftypefn Function emacs_value make_integer (emacs_env *@var{env}, intmax_t @var{n})
 This function takes an integer argument @var{n} and returns the
-corresponding @code{emacs_value} object.  It raises the
-@code{overflow-error} error condition if the value of @var{n} cannot
-be represented as an Emacs integer, i.e.@: is not inside the limits
-set by @code{most-negative-fixnum} and @code{most-positive-fixnum}
-(@pxref{Integer Basics}).
+corresponding @code{emacs_value} object.  It returns either a fixnum
+or a bignum depending on whether the value of @var{n} is inside the
+limits set by @code{most-negative-fixnum} and
+@code{most-positive-fixnum} (@pxref{Integer Basics}).
 @end deftypefn
 
 @deftypefn Function emacs_value make_float (emacs_env *@var{env}, double @var{d})
@@ -1452,6 +1495,18 @@ This function takes a @code{double} argument @var{d} and returns the
 corresponding Emacs floating-point value.
 @end deftypefn
 
+@deftypefn Function emacs_value make_time (emacs_env *@var{env}, struct timespec @var{time})
+This function, which is available since Emacs 27, takes a @code{struct
+timespec} argument @var{time} and returns the corresponding Emacs
+timestamp as a pair @code{(@var{ticks} . @var{hz})}.  @xref{Time of
+Day}.  The return value represents exactly the same timestamp as
+@var{time}: all input values are representable, and there is never a
+loss of precision.  @code{@var{time}.tv_sec} and
+@code{@var{time}.tv_nsec} can be arbitrary values.  In particular,
+there's no requirement that @var{time} be normalized.  This means that
+@code{@var{time}.tv_nsec} can be negative or larger than 999,999,999.
+@end deftypefn
+
 @deftypefn Function emacs_value make_string (emacs_env *@var{env}, const char *@var{str}, ptrdiff_t @var{strlen})
 This function creates an Emacs string from C text string pointed by
 @var{str} whose length in bytes, not including the terminating null
@@ -1464,6 +1519,66 @@ function raises the @code{overflow-error} error condition if
 string.
 @end deftypefn
 
+If you define the preprocessor macro @code{EMACS_MODULE_GMP} before
+including the header @file{emacs-module.h}, you can also convert
+between Emacs integers and GMP @code{mpz_t} values.  @xref{GMP
+Basics,,,gmp}.  If @code{EMACS_MODULE_GMP} is defined,
+@file{emacs-module.h} wraps @code{mpz_t} in the following structure:
+
+@deftp struct emacs_mpz value
+struct emacs_mpz @{ mpz_t value; @};
+@end deftp
+
+@noindent
+Then you can use the following additional functions:
+
+@deftypefn Function bool extract_big_integer (emacs_env *@var{env}, emacs_value @var{arg}, struct emacs_mpz *@var{result})
+This function, which is available since Emacs 27, extracts the
+integral value of @var{arg} into @var{result}.  @var{result} must not
+be @code{NULL}.  @code{@var{result}->value} must be an initialized
+@code{mpz_t} object.  @xref{Initializing Integers,,,gmp}.  If
+@var{arg} is an integer, Emacs will store its value into
+@code{@var{result}->value}.  After you have finished using
+@code{@var{result}->value}, you should free it using @code{mpz_clear}
+or similar.
+@end deftypefn
+
+@deftypefn Function emacs_value make_big_integer (emacs_env *@var{env}, const struct emacs_mpz *@var{value})
+This function, which is available since Emacs 27, takes an
+arbitrary-sized integer argument and returns a corresponding
+@code{emacs_value} object.  @var{value} must not be @code{NULL}.
+@code{@var{value}->value} must be an initialized @code{mpz_t} object.
+@xref{Initializing Integers,,,gmp}.  Emacs will return a corresponding
+integral object.  After you have finished using
+@code{@var{value}->value}, you should free it using @code{mpz_clear}
+or similar.
+@end deftypefn
+
+The following example uses GMP to calculate the next probable prime
+after a given integer:
+
+@example
+#include <assert.h>
+#include <gmp.h>
+
+#define EMACS_MODULE_GMP
+#include <emacs-module.h>
+
+static emacs_value
+next_prime (emacs_env *env, ptrdiff_t nargs, emacs_value *args,
+            void *data)
+@{
+  assert (nargs == 1);
+  emacs_mpz p;
+  mpz_init (p.value);
+  env->extract_big_integer (env, args[0], &p);
+  mpz_nextprime (p.value, p.value);
+  emacs_value result = env->make_big_integer (env, &p);
+  mpz_clear (p.value);
+  return result;
+@}
+@end example
+
 The @acronym{API} does not provide functions to manipulate Lisp data
 structures, for example, create lists with @code{cons} and @code{list}
 (@pxref{Building Lists}), extract list members with @code{car} and
diff --git a/doc/lispref/loading.texi b/doc/lispref/loading.texi
index 6f1213f097..3261e6d188 100644
--- a/doc/lispref/loading.texi
+++ b/doc/lispref/loading.texi
@@ -466,9 +466,11 @@ first call to the function automatically loads the proper library, in
 order to install the real definition and other associated code, then
 runs the real definition as if it had been loaded all along.
 Autoloading can also be triggered by looking up the documentation of
-the function or macro (@pxref{Documentation Basics}).
+the function or macro (@pxref{Documentation Basics}), and completion
+of variable and function names (@pxref{Autoload by Prefix} below).
 
 @menu
+* Autoload by Prefix:: Autoload by Prefix.
 * When to Autoload::   When to Use Autoload.
 @end menu
 
@@ -703,6 +705,25 @@ symbol's new function value.  If the value of the optional argument
 function, only a macro.
 @end defun
 
+@node Autoload by Prefix
+@subsection Autoload by Prefix
+@cindex autoload by prefix
+
+@vindex definition-prefixes
+@findex register-definition-prefixes
+@vindex autoload-compute-prefixes
+During completion for the commands @code{describe-variable} and
+@code{describe-function}, Emacs will try to load files which may
+contain definitions matching the prefix being completed.  The variable
+@code{definition-prefixes} holds a hashtable which maps a prefix to
+the corresponding list of files to load for it.  Entries to this
+mapping are added by calls to @code{register-definition-prefixes}
+which are generated by @code{update-file-autoloads}
+(@pxref{Autoload}).  Files which don't contain any definitions worth
+loading (test files, for examples), should set
+@code{autoload-compute-prefixes} to @code{nil} as a file-local
+variable.
+
 @node When to Autoload
 @subsection When to Use Autoload
 @cindex autoload, when to use
diff --git a/doc/lispref/modes.texi b/doc/lispref/modes.texi
index 4315b70ed7..f41607c5dc 100644
--- a/doc/lispref/modes.texi
+++ b/doc/lispref/modes.texi
@@ -142,7 +142,7 @@ in Lisp Interaction mode:
 (add-hook 'lisp-interaction-mode-hook 'auto-fill-mode)
 @end example
 
-@defun add-hook hook function &optional append local
+@defun add-hook hook function &optional depth local
 This function is the handy way to add function @var{function} to hook
 variable @var{hook}.  You can use it for abnormal hooks as well as for
 normal hooks.  @var{function} can be any Lisp function that can accept
@@ -167,9 +167,18 @@ For a normal hook, hook functions should be designed so that the order
 in which they are executed does not matter.  Any dependence on the order
 is asking for trouble.  However, the order is predictable: normally,
 @var{function} goes at the front of the hook list, so it is executed
-first (barring another @code{add-hook} call).  If the optional argument
-@var{append} is non-@code{nil}, the new hook function goes at the end of
-the hook list and is executed last.
+first (barring another @code{add-hook} call).
+
+In some cases, it is important to control the relative ordering of functions
+on the hook.  The optional argument @var{depth} lets you indicate where the
+function should be inserted in the list: it should then be a number
+between -100 and 100 where the higher the value, the closer to the end of the
+list the function should go.  The @var{depth} defaults to 0 and for backward
+compatibility when @var{depth} is a non-nil symbol it is interpreted as a depth
+of 90.  Furthermore, when @var{depth} is strictly greater than 0 the function
+is added @emph{after} rather than before functions of the same depth.
+One should never use a depth of 100 (or -100), because one can never be
+sure that no other function will ever need to come before (or after) us.
 
 @code{add-hook} can handle the cases where @var{hook} is void or its
 value is a single function; it sets or changes the value to a list of
@@ -3014,7 +3023,7 @@ Its value should have one of the forms described in this table.
 
 @strong{Warning:} Do not design an element of @code{font-lock-keywords}
 to match text which spans lines; this does not work reliably.
-For details, see @xref{Multiline Font Lock}.
+For details, @pxref{Multiline Font Lock}.
 
 You can use @var{case-fold} in @code{font-lock-defaults} to specify
 the value of @code{font-lock-keywords-case-fold-search} which says
@@ -3238,7 +3247,12 @@ is disabled, @code{font-lock-face} has no effect on the display.
   It is ok for a mode to use @code{font-lock-face} for some text and
 also use the normal Font Lock machinery.  But if the mode does not use
 the normal Font Lock machinery, it should not set the variable
-@code{font-lock-defaults}.
+@code{font-lock-defaults}.  In this case the @code{face} property will
+not be overriden, so using the @code{face} property could work too.
+However, using @code{font-lock-face} is generally preferable as it
+allows the user to control the fontification by toggling
+@code{font-lock-mode}, and lets the code work regardless of whether
+the mode uses Font Lock machinery or not.
 
 @node Faces for Font Lock
 @subsection Faces for Font Lock
diff --git a/doc/lispref/nonascii.texi b/doc/lispref/nonascii.texi
index 9c64c3cf2c..8b0750abbf 100644
--- a/doc/lispref/nonascii.texi
+++ b/doc/lispref/nonascii.texi
@@ -1049,7 +1049,7 @@ is like @code{undecided}, but it prefers to choose @code{utf-8} when
 possible.
 
   In general, a coding system doesn't guarantee roundtrip identity:
-decoding a byte sequence using coding system, then encoding the
+decoding a byte sequence using a coding system, then encoding the
 resulting text in the same coding system, can produce a different byte
 sequence.  But some coding systems do guarantee that the byte sequence
 will be the same as what you originally decoded.  Here are a few
@@ -1912,7 +1912,10 @@ the command returns the decoded text as a multibyte string without
 inserting it.
 
 If decoded text is inserted in some buffer, this command returns the
-length of the decoded text.
+length of the decoded text.  If that buffer is a unibyte buffer
+(@pxref{Selecting a Representation}), the internal representation of
+the decoded text (@pxref{Text Representations}) is inserted into the
+buffer as individual bytes.
 
 This command puts a @code{charset} text property on the decoded text.
 The value of the property states the character set used to decode the
@@ -1931,7 +1934,9 @@ contains 8-bit bytes in their multibyte form).
 
 If optional argument @var{buffer} specifies a buffer, the decoded text
 is inserted in that buffer after point (point does not move).  In this
-case, the return value is the length of the decoded text.
+case, the return value is the length of the decoded text.  If that
+buffer is a unibyte buffer, the internal representation of the decoded
+text is inserted into it as individual bytes.
 
 @cindex @code{charset}, text property
 This function puts a @code{charset} text property on the decoded text.
diff --git a/doc/lispref/numbers.texi b/doc/lispref/numbers.texi
index fbdd83fa86..cae8babcb4 100644
--- a/doc/lispref/numbers.texi
+++ b/doc/lispref/numbers.texi
@@ -191,19 +191,19 @@ on 64-bit platforms.
 @cindex integer range
 @cindex number of bignum bits, limit on
 @defvar integer-width
-The value of this variable is a nonnegative integer that is an upper
-bound on the number of bits in a bignum.  Integers outside the fixnum
-range are limited to absolute values less than
+The value of this variable is a nonnegative integer that controls
+whether Emacs signals a range error when a large integer would be
+calculated.  Integers with absolute values less than
 @ifnottex
 2**@var{n},
 @end ifnottex
 @tex
 @math{2^{n}},
 @end tex
-where @var{n} is this variable's value.  Attempts to create bignums outside
-this range signal a range error.  Setting this variable
-to zero disables creation of bignums; setting it to a large number can
-cause Emacs to consume large quantities of memory if a computation
+where @var{n} is this variable's value, do not signal a range error.
+Attempts to create larger integers typically signal a range error,
+although there might be no signal if a larger integer can be created cheaply.
+Setting this variable to a large number can be costly if a computation
 creates huge integers.
 @end defvar
 
diff --git a/doc/lispref/os.texi b/doc/lispref/os.texi
index 59cd5a8fe8..fef954eb7a 100644
--- a/doc/lispref/os.texi
+++ b/doc/lispref/os.texi
@@ -2197,7 +2197,7 @@ is the character Emacs currently uses for quitting, usually @kbd{C-g}.
 @subsection Recording Input
 @cindex recording input
 
-@defun recent-keys
+@defun recent-keys &optional include-cmds
 This function returns a vector containing the last 300 input events from
 the keyboard or mouse.  All input events are included, whether or not
 they were used as parts of key sequences.  Thus, you always get the last
@@ -2205,6 +2205,11 @@ they were used as parts of key sequences.  Thus, you always get the last
 (These are excluded because they are less interesting for debugging; it
 should be enough to see the events that invoked the macros.)
 
+If @var{include-cmds} is non-@code{nil}, complete key sequences in the
+result vector are interleaved with pseudo-events of the form
+@code{(nil . @var{COMMAND})}, where @var{COMMAND} is the binding of
+the key sequence (@pxref{Command Overview}).
+
 A call to @code{clear-this-command-keys} (@pxref{Command Loop Info})
 causes this function to return an empty vector immediately afterward.
 @end defun
diff --git a/doc/lispref/positions.texi b/doc/lispref/positions.texi
index 527a3ab420..7707793467 100644
--- a/doc/lispref/positions.texi
+++ b/doc/lispref/positions.texi
@@ -840,8 +840,8 @@ The argument @var{character-set} is a string, like the inside of a
 terminate it, and @samp{\} quotes @samp{^}, @samp{-} or @samp{\}.
 Thus, @code{"a-zA-Z"} skips over all letters, stopping before the
 first nonletter, and @code{"^a-zA-Z"} skips nonletters stopping before
-the first letter.  See @xref{Regular Expressions}.  Character classes
-can also be used, e.g., @code{"[:alnum:]"}.  See @pxref{Char Classes}.
+the first letter (@pxref{Regular Expressions}).  Character classes
+can also be used, e.g., @code{"[:alnum:]"} (@pxref{Char Classes}).
 
 If @var{limit} is supplied (it must be a number or a marker), it
 specifies the maximum position in the buffer that point can be skipped
diff --git a/doc/lispref/processes.texi b/doc/lispref/processes.texi
index 6be311b563..b73401a62a 100644
--- a/doc/lispref/processes.texi
+++ b/doc/lispref/processes.texi
@@ -678,8 +678,11 @@ Initialize the process query flag to @var{query-flag}.
 @xref{Query Before Exit}.
 
 @item :stop @var{stopped}
-If @var{stopped} is non-@code{nil}, start the process in the
-stopped state.
+If provided, @var{stopped} must be @code{nil}; it is an error to use
+any non-@code{nil} value.  The @code{:stop} key is ignored otherwise
+and is retained for compatibility with other process types such as
+pipe processes.  Asynchronous subprocesses never start in the stopped
+state.
 
 @item :filter @var{filter}
 Initialize the process filter to @var{filter}.  If not specified, a
@@ -698,6 +701,19 @@ created with @code{make-pipe-process}, described below.  If
 @var{stderr} is @code{nil}, standard error is mixed with standard
 output, and both are sent to @var{buffer} or @var{filter}.
 
+@cindex standard error process
+If @var{stderr} is a buffer, Emacs will create a pipe process, the
+@dfn{standard error process}.  This process will have the default
+filter (@pxref{Filter Functions}), sentinel (@pxref{Sentinels}), and
+coding systems (@pxref{Default Coding Systems}).  On the other hand,
+it will use @var{query-flag} as its query-on-exit flag (@pxref{Query
+Before Exit}).  It will be associated with the @var{stderr} buffer
+(@pxref{Process Buffers}) and send its output (which is the standard
+error of the main process) there.
+
+If @var{stderr} is a pipe process, Emacs will use it as standard error
+process for the new process.
+
 @item :file-handler @var{file-handler}
 If @var{file-handler} is non-@code{nil}, then look for a file name
 handler for the current buffer's @code{default-directory}, and invoke
@@ -718,7 +734,11 @@ current working directory is the local name component of
 
 Depending on the implementation of the file name handler, it might not
 be possible to apply @var{filter} or @var{sentinel} to the resulting
-process object.  @xref{Filter Functions}, and @ref{Sentinels}.
+process object.  The @code{:stderr} argument cannot be a pipe process,
+file name handlers do not support pipe processes for this.  A buffer
+as @code{:stderr} argument is accepted, its contents is shown without
+the use of pipe processes.  @xref{Filter Functions}, @ref{Sentinels},
+and @ref{Accepting Output}.
 
 Some file name handlers may not support @code{make-process}.  In such
 cases, this function does nothing and returns @code{nil}.
@@ -1668,7 +1688,7 @@ how to do these things:
         (save-excursion
           ;; @r{Insert the text, advancing the process marker.}
           (goto-char (process-mark proc))
-          (insert string)
+          (insert-before-markers string)
           (set-marker (process-mark proc) (point)))
         (if moving (goto-char (process-mark proc)))))))
 @end group
@@ -1879,6 +1899,22 @@ like this:
 (while (accept-process-output process))
 @end example
 
+If you have passed a non-@code{nil} @var{stderr} to
+@code{make-process}, it will have a standard error process.
+@xref{Asynchronous Processes}.  In that case, waiting for process
+output from the main process doesn't wait for output from the standard
+error process.  To make sure you have received both all of standard
+output and all of standard error from a process, use the following
+code:
+
+@example
+(while (accept-process-output process))
+(while (accept-process-output stderr-process))
+@end example
+
+Reading pending standard error from a process running on a remote host
+is not possible this way.
+
 @node Processes and Threads
 @subsection Processes and Threads
 @cindex processes, threads
diff --git a/doc/lispref/searching.texi b/doc/lispref/searching.texi
index 8775254dd0..24f30b4dac 100644
--- a/doc/lispref/searching.texi
+++ b/doc/lispref/searching.texi
@@ -1070,6 +1070,13 @@ list of characters @var{chars}.
 
 @c Internal functions: regexp-opt-group
 
+@defvar regexp-unmatchable
+This variable contains a regexp that is guaranteed not to match any
+string at all.  It is particularly useful as default value for
+variables that may be set to a pattern that actually matches
+something.
+@end defvar
+
 @node Regexp Search
 @section Regular Expression Searching
 @cindex regular expression searching
diff --git a/doc/lispref/sequences.texi b/doc/lispref/sequences.texi
index a7f270c068..4b67a5f9f1 100644
--- a/doc/lispref/sequences.texi
+++ b/doc/lispref/sequences.texi
@@ -601,7 +601,7 @@ returned value is a list.
 @defun seq-mapn function &rest sequences
   This function returns the result of applying @var{function} to each
 element of @var{sequences}.  The arity (@pxref{What Is a Function,
-sub-arity}) of @var{function} must match the number of sequences.
+subr-arity}) of @var{function} must match the number of sequences.
 Mapping stops at the end of the shortest sequence, and the returned
 value is a list.
 
diff --git a/doc/lispref/spellfile b/doc/lispref/spellfile
index 590d356d2d..45a122d26a 100644
--- a/doc/lispref/spellfile
+++ b/doc/lispref/spellfile
@@ -10,29 +10,22 @@ Beverly
 Boyes
 Brian
 CL
-CSWKg
 Carl
 Carroll
 Chris
 Cleanups
-DEC
-DStandard
 Dan
 Dired's
 Disassembly
 Duff
-EMAC
 EMACSLOADPATH
 Eckelkamp
 Edward
 Eirik
-Emacses
 Eric
 Erlebacher
 Fcar
 Fcdr
-Fcons
-Fcoordinates
 Feval
 Frazzle
 Frederick
@@ -42,14 +35,12 @@ Gentlemen
 HAL
 HATTED
 HS
-HU
 Hanchrow
 Hartzell
 Hess
 Hewlett
 IBM
 ISBN
-Impl
 Interning
 Ithought
 J's
@@ -65,13 +56,9 @@ Kirman
 Knighten
 Korz
 Krawitz
-LTsHm
 LaLiberte
-LaTeX
 Lammens
-Local'
 MAC
-MONIES
 MSS
 Maclisp
 Magill
@@ -80,69 +67,44 @@ Matthew
 Minibuf
 Misc
 Miscellany
-Mocklisp
 Montanaro
 Myers
 NFS
 Nathan
-Nope
 OS
-OSITIONS
 Oct
-Ovwrt
-PURESIZE
 Packard
-Qlistp
 Qnil
-RMAIL
 Raul
 Resizing
 Robbins
 Rockwell
-SCO
 SIGCONT
 SIGHUP
 SIGINT
 SIGKILL
 SIGQUIT
 SIGTSTP
-SLOAD
-Scoordinates
-Set'
 Setcar
 Setcdr
 Shinichirou
 Snarf
 Sor
 SourceFile
-Stops'
 Subprocess
 Sugou
-Sunview
 Suominen
-T's
 TCP
 ThXs
 Tharp
-Thu
 Trost
-UCB
 UNEVALLED
-UNGCPRO
-UniPlus
-UniSoft's
-VMS
-Vip
-Void'
 Warren
 Welty
 Wethought
 Wilding
 Worley
 Wright
-XDVI
-XFASTINT
-XINT
 XWINDOW
 Xs
 Yo
@@ -156,22 +118,13 @@ abc
 abcdefg
 abcxyz
 abd
-above'
 abracadabra
-address'
-after'
 alist
 alists
-anchored'
-and'
 ar
 aref
-arg'th
-argdecl
 arith
 arrayp
-arrow'
-asa
 asdZasfd
 asdf
 asdfasfd
@@ -181,28 +134,22 @@ assq
 at'
 aug
 autoload
-automatic'
-automatically'
 avector
 bBuffer
 bFrobnicate
 ba
-back'
 bananana
 barfoo
 barx
 bballs
-before'
 beforep
 bfoo
-bil
 binding's
 bish
 bobp
 bolp
 bottommost
 boundp
-brief'
 buf
 buffer'
 bufferp
@@ -215,11 +162,8 @@ cadr
 callable
 cbreak
 ce
-cell'
 cells'
 cf
-chaprm
-character'
 childp
 chistory
 ck
@@ -230,31 +174,22 @@ cond
 conses
 consing
 consp
-constant'
-contains'
 continuable
-convert'
 copyleft
-correct'
 counterintuitive
 cr
 creatable
 customize
 deactivate
 deactivated
-deassigns
-decrement'
 deffnx
 definition'
 defmacro
 defsubr
 deletable
-deletion'
 delq
 depiction
 deselecting
-destructive'
-destructively'
 diffs
 ding
 directory'
@@ -273,10 +208,8 @@ dribble
 dup
 ef
 efg
-electric'
 elided
 elt
-enablement
 endkeyfun
 endrecfun
 environment'
@@ -286,27 +219,18 @@ eol
 eolp
 eq
 eqlsign
-erminal
 erste
 etags
 eval
 evalled
-evals
 evaluate'
-excess'
 exec
 exitcode
-expression'
-extra'
-fails'
-fascist
 fboundp
 featurep
-ff
 fg
 fi
 file'
-filespec
 filesystems
 fillarray
 firstchar
@@ -316,41 +240,27 @@ fixit
 fixup
 floatp
 fmakunbound
-fns
 fo
 fol
-folded'
 following'
 fooba
 foobaz
 foox
-for'
 formfeed
-forms'
 forw
-found'
 frob
-from'
-front'
 fset
 fstab
 ftp
 fu
 garbles
 gc
-gcpro
-gd
 getenv
-getprv
 gid
-gnuemacs
 gp
 grep
 gtr
-halves'
 hand'
-hashes'
-hd
 hexadecimal
 hf
 hfil
@@ -359,16 +269,12 @@ horsechestnut
 hostname
 hpux
 hscroll
-ibmapa
 ick
 id
 idiom
 ii
-indrm
 inode
-input'
 inputinput
-inserting'
 integerp
 intermixed
 ints
@@ -378,31 +284,21 @@ keymapp
 kill'
 killed'
 killp
-kludge
 kolstad
-language'
 lastchar
 lcl
-ledit
 leif
 lessp
 level'
 lewis
-library'
-link'
-lisplib
-listexp
 loadable
-loadst
 loadup
 logand
 logior
 lognot
 logxor
-long'
 loop's
 lru
-lrwxrwxrwx
 ls
 lsh
 m's
@@ -412,43 +308,31 @@ malloc
 mapatoms
 mapconcat
 mapvar
-mark'
 marker's
 markerp
 mathsurround
-medit
 memq
 mh
-mim
 mini
 minibuffer's
 minibuffers
 misalignment
-misnamed
 mode's
 modename
-modes'
 mods
 modtime
-mqueue
 msg
-multicharacter
 myfile
 nCount
-nXExpression
 na
 name's
 natnump
 nb
-nbBuffer
 nconc
 newdef
 newelt
 newname
 nextrecfun
-nfsusr
-ninett
-nlines
 nlinks
 nlistp
 noconfirm
@@ -456,7 +340,6 @@ nodigits
 noerror
 noforce
 nomessage
-nominees
 nomsg
 nonblank
 nonconstant
@@ -473,10 +356,7 @@ nonprinting
 nonselected
 nonsequentially
 nonvoid
-nonwarranty
 nonwritable
-noop
-noprint
 norecord
 normal'
 noselect
@@ -495,32 +375,19 @@ numberp
 nums
 obarray
 obarrays
-object'
 oldbuf
 olddef
 oldname
-oo
-oops
 op
-or'
 otl
 out'
-over'
-overful
-overfullrule
-overstrike
-overstriking
-overstruck
 p'
 paren
-part'
 passwd
-pe
 ped
 perverse
 pid
 plist
-pnt
 pointer'
 pointm
 pos
@@ -530,7 +397,6 @@ prepend
 prepended
 prepends
 pretty'
-prin
 princ
 print'
 printenv
@@ -538,9 +404,7 @@ printer'
 proc
 process'
 processp
-programmer'
 prolog
-protect'
 ps
 psf
 psychotherapy
@@ -550,12 +414,9 @@ qu
 quux
 rassq
 reader'
-readin
 rebind
 rec
 rechecking
-recursively'
-recycler'
 redo
 redrawing
 redraws
@@ -563,10 +424,8 @@ redump
 reenabled
 reexposed
 reg
-region'
 reindent
 reindents
-reinitialization
 reinitialize
 reinitialized
 reinstall
@@ -576,44 +435,30 @@ resized
 resizes
 reversibly
 reworded
-rhetorical
-right'
 ring'
 risky
-rmailedit
 rms
 rplaca
 rplacd
-rtu
 runnable
 rw
-rwxrwxrwx
 sDescribe
 sans
 se
-searching'
-section'
-seed'
 sequence'
 sequencep
-setp
 setplist
-setprv
 settable
 setuid
 sexp
 sexps
-shape'
 shell's
 sideline
-special'
 specpdl
 st
-stanford
 startkeyfun
 str
 stringp
-stty
 subcategories
 subcommands
 subexp
@@ -627,104 +472,63 @@ subr'
 subroutine'
 subrp
 subrs
-subwindows
-sugar'
-suid
 supersession
-suspension'
 symbolp
 symlink
 syms
 syntactic
 tabname
 temacs
-temporarily'
 tempvar
 tenths
-termcap
-termcaps
-terminfo
 termscript
-termtype
 terpri
 text'
-textrm
-textsl
-texttt
-than'
-the'
 tildes
 time's
-to'
 towards
 transportable
 txt
-types'
 uid
 unbind
 unbinding
 unbinds
-unchanged'
 unclutters
 undefine
 undefines
 underfull
-undo's
-unevaluated'
 unexec
 unexpand
 unhesitatingly
 uninterned
-unisoft
-unpaired
 unread
 unreadable
 unreading
 unsaved
-untyped
-ununderline
 up'
 uptime
-usecount
 used'
-user'
 userlock
 usg
 val
 varbind
-varname
 varref
 vars
 varset
 vb
 vconcat
 vectorp
-vfil
-vi
 vn
 voidness
-vrs
-vt
 window'
 windowing
 windowp
-wrapped'
-xSpecify
-xcoord
 xcssun
-xemacs
-xenix
-xf
-xfirst
 xoff
 xon
 xx
 xxxxx
-xxxxxxxxx
 xy
-xyz
-ycoord
 yes'
 zA
-zap
 zerop
diff --git a/doc/lispref/symbols.texi b/doc/lispref/symbols.texi
index a214a2d3fd..5d71fb39a2 100644
--- a/doc/lispref/symbols.texi
+++ b/doc/lispref/symbols.texi
@@ -558,9 +558,12 @@ deleted from the local value of a hook variable when changing major
 modes.  @xref{Setting Hooks}.
 
 @item pure
+@cindex @code{pure} property
 If the value is non-@code{nil}, the named function is considered to be
-side-effect free.  Calls with constant arguments can be evaluated at
-compile time.  This may shift run time errors to compile time.
+pure (@pxref{What Is a Function}).  Calls with constant arguments can
+be evaluated at compile time.  This may shift run time errors to
+compile time.  Not to be confused with pure storage (@pxref{Pure
+Storage}).
 
 @item risky-local-variable
 If the value is non-@code{nil}, the named variable is considered risky
@@ -579,9 +582,13 @@ The value specifies a function for determining safe file-local values
 for the named variable.  @xref{File Local Variables}.
 
 @item side-effect-free
+@cindex @code{side-effect-free} property
 A non-@code{nil} value indicates that the named function is free of
-side-effects, for determining function safety (@pxref{Function
-Safety}) as well as for byte compiler optimizations.  Do not set it.
+side effects (@pxref{What Is a Function}), so the byte compiler may
+ignore a call whose value is unused.  If the property's value is
+@code{error-free}, the byte compiler may even delete such unused
+calls.  In addition to byte compiler optimizations, this property is
+also used for determining function safety (@pxref{Function Safety}).
 
 @item variable-documentation
 If non-@code{nil}, this specifies the named variable's documentation
diff --git a/doc/lispref/text.texi b/doc/lispref/text.texi
index 500df1f8f0..278bc3c268 100644
--- a/doc/lispref/text.texi
+++ b/doc/lispref/text.texi
@@ -2252,9 +2252,11 @@ If it is impossible to move to column @var{column} because that is in
 the middle of a multicolumn character such as a tab, point moves to the
 end of that character.  However, if @var{force} is non-@code{nil}, and
 @var{column} is in the middle of a tab, then @code{move-to-column}
-converts the tab into spaces so that it can move precisely to column
-@var{column}.  Other multicolumn characters can cause anomalies despite
-@var{force}, since there is no way to split them.
+either converts the tab into spaces (when @code{indent-tabs-mode} is
+@code{nil}), or inserts enough spaces before it (otherwise), so that
+point can move precisely to column @var{column}.  Other multicolumn
+characters can cause anomalies despite @var{force}, since there is no
+way to split them.
 
 The argument @var{force} also has an effect if the line isn't long
 enough to reach column @var{column}; if it is @code{t}, that means to
diff --git a/doc/lispref/tips.texi b/doc/lispref/tips.texi
index d41fe82572..30f2c983ad 100644
--- a/doc/lispref/tips.texi
+++ b/doc/lispref/tips.texi
@@ -1013,7 +1013,7 @@ etc.).
 
 If there is no maintainer line, the person(s) in the Author field
 is/are presumed to be the maintainers.  Some files in Emacs use
-@samp{FSF} for the maintainer.  This means that the original author is
+@samp{emacs-devel@@gnu.org} for the maintainer, which means the author is
 no longer responsible for the file, and that it is maintained as part
 of Emacs.
 
diff --git a/doc/lispref/variables.texi b/doc/lispref/variables.texi
index aca7d2f5e9..5e1bfbd714 100644
--- a/doc/lispref/variables.texi
+++ b/doc/lispref/variables.texi
@@ -1847,6 +1847,11 @@ variables have @code{safe-local-variable} properties; these include
 For boolean-valued variables that are safe, use @code{booleanp} as the
 property value.
 
+  If you want to define @code{safe-local-variable} properties for
+variables defined in C source code, add the names and the properties
+of those variables to the list in the ``Safe local variables'' section
+of @file{files.el}.
+
 @cindex autoload cookie, and safe values of variable
   When defining a user option using @code{defcustom}, you can set its
 @code{safe-local-variable} property by adding the arguments
@@ -2009,7 +2014,7 @@ all files in those directories.  The list in @var{variables} can be of
 one of the two forms: @code{(@var{major-mode} . @var{alist})} or
 @code{(@var{directory} . @var{list})}.  With the first form, if the
 file's buffer turns on a mode that is derived from @var{major-mode},
-then the all the variables in the associated @var{alist} are applied;
+then all the variables in the associated @var{alist} are applied;
 @var{alist} should be of the form @code{(@var{name} . @var{value})}.
 A special value @code{nil} for @var{major-mode} means the settings are
 applicable to any mode.  In @var{alist}, you can use a special
diff --git a/doc/lispref/windows.texi b/doc/lispref/windows.texi
index 32e8c2afa3..96e42a148c 100644
--- a/doc/lispref/windows.texi
+++ b/doc/lispref/windows.texi
@@ -2601,6 +2601,63 @@ window and displaying the buffer in that window.  It can fail if all
 windows are dedicated to other buffers (@pxref{Dedicated Windows}).
 @end defun
 
+@defun display-buffer-in-direction buffer alist
+This function tries to display @var{buffer} at a location specified by
+@var{alist}.  For this purpose, @var{alist} should contain a
+@code{direction} entry whose value is one of @code{left}, @code{above}
+(or @code{up}), @code{right} and @code{below} (or @code{down}).  Other
+values are usually interpreted as @code{below}.
+
+If @var{alist} also contains a @code{window} entry, its value
+specifies a reference window.  That value can be a special symbol like
+@code{main} which stands for the selected frame's main window
+(@pxref{Side Window Options and Functions}) or @code{root} standing
+for the selected frame's root window (@pxref{Windows and Frames}).  It
+can also specify an arbitrary valid window.  Any other value (or
+omitting the @code{window} entry entirely) means to use the selected
+window as reference window.
+
+This function first tries to reuse a window in the specified direction
+that already shows @var{buffer}.  If no such window exists, it tries
+to split the reference window in order to produce a new window in the
+specified direction.  If this fails as well, it will try to display
+@var{buffer} in an existing window in the specified direction.  In
+either case, the window chosen will appear on the side of the
+reference window specified by the @code{direction} entry, sharing at
+least one edge with the reference window.
+
+If the reference window is live, the edge the chosen window will share
+with it is always the opposite of the one specified by the
+@code{direction} entry.  For example, if the value of the
+@code{direction} entry is @code{left}, the chosen window's right edge
+coordinate (@pxref{Coordinates and Windows}) will equal the reference
+window's left edge coordinate.
+
+If the reference window is internal, a reused window must share with
+it the edge specified by the @code{direction} entry.  Hence if, for
+example, the reference window is the frame's root window and the value
+of the @code{direction} entry is @code{left}, a reused window must be
+on the left of the frame.  This means that the left edge coordinate of
+the chosen window and that of the reference window are the same.
+
+A new window, however, will be created by splitting the reference
+window such that the chosen window will share the opposite edge with
+the reference window.  In our example, a new root window would be
+created with a new live window and the reference window as its
+children.  The chosen window's right edge coordinate would then equal
+the left edge coordinate of the reference window.  Its left edge
+coordinate would equal the left edge coordinate of the frame's new
+root window.
+
+Four special values for @code{direction} entries allow to implicitly
+specify the selected frame's main window as the reference window:
+@code{leftmost}, @code{top}, @code{rightmost} and @code{bottom}.  This
+means that instead of, for example, @w{@code{(direction . left)
+(window . main)}} one can just specify @w{@code{(direction
+. leftmost)}}.  An existing @code{window} @var{alist} entry is ignored
+in such cases.
+@end defun
+
 @defun display-buffer-below-selected buffer alist
 This function tries to display @var{buffer} in a window below the
 selected window.  If there is a window below the selected one and that
@@ -2934,12 +2991,20 @@ If non-@code{nil}, the value specifies the slot of the side window
 supposed to display the buffer.  This entry is used only by
 @code{display-buffer-in-side-window}.
 
+@vindex direction@r{, a buffer display action alist entry}
+@item direction
+The value specifies a direction which, together with a @code{window}
+entry, allows @code{display-buffer-in-direction} to determine the
+location of the window to display the buffer.
+
 @vindex window@r{, a buffer display action alist entry}
 @item window
 The value specifies a window that is in some way related to the window
 chosen by @code{display-buffer}.  This entry is currently used by
 @code{display-buffer-in-atom-window} to indicate the window on whose
-side the new window shall be created.
+side the new window shall be created.  It is also used by
+@code{display-buffer-in-direction} to specify the reference window on
+whose side the resulting window shall appear.
 
 @vindex allow-no-window@r{, a buffer display action alist entry}
 @item allow-no-window
diff --git a/doc/misc/calc.texi b/doc/misc/calc.texi
index ca322f2172..75bbae58b2 100644
--- a/doc/misc/calc.texi
+++ b/doc/misc/calc.texi
@@ -14661,7 +14661,7 @@ conventions of Yacas, a free computer algebra system.  While the
 operators and functions in Yacas are similar to those of Calc, the names
 of built-in functions in Yacas are capitalized.  The Calc formula
 @samp{sin(2 x)}, for example, is entered and displayed @samp{Sin(2 x)}
-in Yacas mode,  and `@samp{arcsin(x^2)} is @samp{ArcSin(x^2)} in Yacas
+in Yacas mode,  and @samp{arcsin(x^2)} is @samp{ArcSin(x^2)} in Yacas
 mode.  Complex numbers are written  are written @samp{3 + 4 I}.
 The standard special constants are written @code{Pi}, @code{E},
 @code{I}, @code{GoldenRatio} and @code{Gamma}.  @code{Infinity}
diff --git a/doc/misc/cc-mode.texi b/doc/misc/cc-mode.texi
index f73a7fb57c..ab1c8e6f52 100644
--- a/doc/misc/cc-mode.texi
+++ b/doc/misc/cc-mode.texi
@@ -1060,7 +1060,7 @@ there's a piece of normal text without having to think much about it.
 and so on.
 
 You can configure the exact way comments get filled and broken, and
-where Emacs does auto-filling (see @pxref{Custom Filling and
+where Emacs does auto-filling (@pxref{Custom Filling and
 Breaking}).  Typically, the style system (@pxref{Styles}) will have
 set this up for you, so you probably won't have to bother.
 
@@ -1478,7 +1478,7 @@ normal, with no @kbd{C-u} prefix).
 @end itemize
 
 You can configure the precise circumstances in which newlines get
-inserted (see @pxref{Custom Auto-newlines}).  Typically, the style
+inserted (@pxref{Custom Auto-newlines}).  Typically, the style
 system (@pxref{Styles}) will have set this up for you, so you probably
 won't have to bother.
 
@@ -2140,7 +2140,10 @@ with @code{c-doc-comment-style}: Supply a variable or function
 in @code{c-doc-comment-style}.  If it's a variable, it's prepended to
 @code{font-lock-keywords}.  If it's a function, it's called at mode
 initialization and the result is prepended.  For an example, see
-@code{javadoc-font-lock-keywords} in @file{cc-fonts.el}.
+@code{javadoc-font-lock-keywords} in @file{cc-fonts.el}.  It is even
+possible, to a limited extent, to fontify constructs inside a doc
+comment with other faces.  For an example, see pike autodoc comment
+style towards the end of @file{cc-fonts-el}.
 
 If you add support for another doc comment style, please consider
 contributing it: send a note to @email{bug-cc-mode@@gnu.org}.
@@ -6850,7 +6853,7 @@ custom line-up function associated with it.
 @comment !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 To configure macros which you invoke without a terminating @samp{;},
-see @xref{Macros with ;}.
+@pxref{Macros with ;}.
 
 Here are the remaining odds and ends regarding indentation:
 
@@ -7428,13 +7431,15 @@ could amend your C++ Mode hook like this:
 @emph{How do I stop my C++ lambda expressions being indented way over
 to the right?}
 
-Change the offset associated with @code{inlambda} from its default,
-the function @code{c-lineup-inexpr-block}, to 0.  For example, if you
-are setting offsets in a hook function you might include the following
-line:
+This is now the default, so you don't need to do anything.  To restore
+the previous default, indenting lambda expressions to the right of the
+constructs which introduce them, change the offset associated with
+@code{inlambda} from 0 to @code{c-lineup-inexpr-block}.  For example,
+if you are setting offsets in a hook function you might include the
+following line:
 
 @example
-(c-set-offset 'inlambda 0)
+(c-set-offset 'inlambda 'c-lineup-inexpr-block)
 @end example
 
 For details of the different ways you can make this setting,
diff --git a/doc/misc/cl.texi b/doc/misc/cl.texi
index eb06791ba9..ee73c65b78 100644
--- a/doc/misc/cl.texi
+++ b/doc/misc/cl.texi
@@ -1359,7 +1359,8 @@ Because of the nature of macros, @code{cl-macrolet} is always lexically
 scoped.  The @code{cl-macrolet} binding will
 affect only calls that appear physically within the body
 @var{forms}, possibly after expansion of other macros in the
-body.
+body.  Calls of @code{cl-macrolet} bound macros are expanded in the
+global environment.
 @end defmac
 
 @defmac cl-symbol-macrolet (bindings@dots{}) forms@dots{}
diff --git a/doc/misc/dbus.texi b/doc/misc/dbus.texi
index c7d499884d..7c7612f579 100644
--- a/doc/misc/dbus.texi
+++ b/doc/misc/dbus.texi
@@ -1928,7 +1928,7 @@ This executes @var{forms} exactly like a @code{progn}, except that
 errors can be made visible when @code{dbus-debug} is set to @code{t}.
 @end defspec
 
-Incoming D-Bus messages are handled as Emacs events, see @pxref{Misc
+Incoming D-Bus messages are handled as Emacs events, @pxref{Misc
 Events, , , elisp}.  They are retrieved only, when Emacs runs in
 interactive mode.  The generated event has this form:
 
@@ -1952,7 +1952,7 @@ of the D-Bus object emitting the message.  @var{interface} and
 @var{member} denote the message which has been sent.
 
 @var{handler} is the callback function which has been registered for
-this message (see @pxref{Signals}).  When a @code{dbus-event} event
+this message (@pxref{Signals}).  When a @code{dbus-event} event
 arrives, @var{handler} is called with @var{args} as arguments.
 
 In order to inspect the @code{dbus-event} data, you could extend the
diff --git a/doc/misc/dired-x.texi b/doc/misc/dired-x.texi
index b6a9d23f7d..1e3414563f 100644
--- a/doc/misc/dired-x.texi
+++ b/doc/misc/dired-x.texi
@@ -896,7 +896,7 @@ should not bind @code{dired-x-find-file-other-window} over
 @code{find-file-other-window}.  If you change this variable after
 @file{dired-x.el} is loaded then do @kbd{M-x dired-x-bind-find-file}.  The
 default value of this variable is @code{t}; by default, the binding is not
-done.  See @xref{Optional Installation File At Point}.
+done.  @xref{Optional Installation File At Point}.
 
 @item dired-x-bind-find-file
 @findex dired-x-bind-find-file
@@ -904,7 +904,7 @@ A function, which can be called interactively or in your @file{~/.emacs} file,
 that uses the value of @code{dired-x-hands-off-my-keys} to determine if
 @code{dired-x-find-file} should be bound over @code{find-file} and
 @code{dired-x-find-file-other-window} bound over
-@code{find-file-other-window}.  See @xref{Optional Installation File At Point}.
+@code{find-file-other-window}.  @xref{Optional Installation File At Point}.
 @end table
 
 @node Miscellaneous Commands
diff --git a/doc/misc/ediff.texi b/doc/misc/ediff.texi
index c4ef1da315..4c698eb7e2 100644
--- a/doc/misc/ediff.texi
+++ b/doc/misc/ediff.texi
@@ -2421,7 +2421,7 @@ Boris Goldowsky <boris@@cs.rochester.edu> made it possible to highlight
 fine differences in Ediff buffers.  Alastair Burt <burt@@dfki.uni-kl.de>
 ported Ediff to XEmacs, Eric Freudenthal <freudent@@jan.ultra.nyu.edu>
 made it work with VC, Marc Paquette <marcpa@@cam.org> wrote the
-toolbar support package for Ediff, and Hrvoje Niksic <hniksic@@xemacs.org>
+toolbar support package for Ediff, and Hrvoje Nikšić <hniksic@@xemacs.org>
 adapted it to the Emacs customization package.
 
 Many people provided help with bug reports, feature suggestions, and advice.
diff --git a/doc/misc/emacs-mime.texi b/doc/misc/emacs-mime.texi
index dd651fff35..6e95013c18 100644
--- a/doc/misc/emacs-mime.texi
+++ b/doc/misc/emacs-mime.texi
@@ -1205,8 +1205,8 @@ plaintext name.
 
 @example
 (mail-header-parse-address
- "Hrvoje Niksic <hniksic@@srce.hr>")
-@result{} ("hniksic@@srce.hr" . "Hrvoje Niksic")
+ "Hrvoje Nikšić <hniksic@@srce.hr>")
+@result{} ("hniksic@@srce.hr" . "Hrvoje Nikšić")
 @end example
 
 @item mail-header-parse-addresses
@@ -1216,8 +1216,8 @@ the one described above.
 
 @example
 (mail-header-parse-addresses
- "Hrvoje Niksic <hniksic@@srce.hr>, Steinar Bang <sb@@metis.no>")
-@result{} (("hniksic@@srce.hr" . "Hrvoje Niksic")
+ "Hrvoje Nikšić <hniksic@@srce.hr>, Steinar Bang <sb@@metis.no>")
+@result{} (("hniksic@@srce.hr" . "Hrvoje Nikšić")
      ("sb@@metis.no" . "Steinar Bang"))
 @end example
 
diff --git a/doc/misc/eudc.texi b/doc/misc/eudc.texi
index 117b62e9ac..568f94ba7c 100644
--- a/doc/misc/eudc.texi
+++ b/doc/misc/eudc.texi
@@ -606,7 +606,7 @@ function that will be passed the corresponding attribute values for
 display.
 @end defvar
 
-This variable has protocol-local definitions (see @pxref{Server/Protocol
+This variable has protocol-local definitions (@pxref{Server/Protocol
 Locals}).  For instance, it is defined as follows for LDAP:
 
 @lisp
@@ -714,7 +714,7 @@ name and the remaining words are all considered as surname constituents.
 @var{format}s are in fact not limited to EUDC attribute names, you can
 use server or protocol specific names in them.  It may be safer if you
 do so, to set the variable @code{eudc-inline-query-format} in a protocol
-or server local fashion (see @pxref{Server/Protocol Locals}).
+or server local fashion (@pxref{Server/Protocol Locals}).
 
 For instance you could use the following to match up to three words
 against the @code{cn} attribute of LDAP servers:
diff --git a/doc/misc/flymake.texi b/doc/misc/flymake.texi
index 894203ca5a..ebb89c3203 100644
--- a/doc/misc/flymake.texi
+++ b/doc/misc/flymake.texi
@@ -87,10 +87,6 @@ Syntax check is done ``on-the-fly''.  It is started whenever
 the buffer is saved, unless @code{flymake-start-on-save-buffer} is
 nil;
 
-@item
-a newline character is added to the buffer, unless
-@code{flymake-start-syntax-check-on-newline} is nil;
-
 @item
 some changes were made to the buffer more than @code{0.5} seconds ago
 (the delay is configurable in @code{flymake-no-changes-timeout}).
@@ -222,10 +218,6 @@ If any changes are made to the buffer, syntax check is automatically
 started after this many seconds, unless the user makes another change,
 which resets the timer.
 
-@item flymake-start-syntax-check-on-newline
-A boolean flag indicating whether to start syntax check immediately
-after a newline character is inserted into the buffer.
-
 @item flymake-start-on-flymake-mode
 A boolean flag indicating whether to start syntax check immediately
 after enabling @code{flymake-mode}.
diff --git a/doc/misc/gnus-faq.texi b/doc/misc/gnus-faq.texi
index 075f521841..840cc08205 100644
--- a/doc/misc/gnus-faq.texi
+++ b/doc/misc/gnus-faq.texi
@@ -707,7 +707,7 @@ retrieves via POP3?
 
 Yes, if the POP3 server supports the UIDL control (maybe almost servers
 do it nowadays).  To do that, add a @code{:leave VALUE} pair to each
-POP3 mail source.  See @pxref{Mail Source Specifiers} for VALUE.
+POP3 mail source.  @xref{Mail Source Specifiers}, for details on VALUE.
 
 @node FAQ 4 - Reading messages
 @subsection Reading messages
diff --git a/doc/misc/gnus.texi b/doc/misc/gnus.texi
index b9c91a02a3..17b1521f48 100644
--- a/doc/misc/gnus.texi
+++ b/doc/misc/gnus.texi
@@ -3094,7 +3094,7 @@ You can also use regexp expansions in the rules:
 (sieve header :regex "list-id" "<c++std-\\1.accu.org>")
 @end example
 
-See @pxref{Sieve Commands} for commands and variables that might be of
+@xref{Sieve Commands}, for commands and variables that might be of
 interest in relation to the sieve parameter.
 
 The Sieve language is described in RFC 3028.  @xref{Top, Emacs Sieve,
@@ -3112,8 +3112,8 @@ conform to RFC2919 @code{List-ID}.
 See @code{nnmail-split-abbrev-alist} for the regular expression
 matching mailing-list headers.
 
-See @pxref{Group Mail Splitting} to automatically split on group
-parameters.
+@xref{Group Mail Splitting}, for details on how to automatically split
+on group parameters.
 
 @item (agent parameters)
 If the agent has been enabled, you can set any of its parameters to
@@ -12856,7 +12856,7 @@ In the case of a string value, if the @code{match} is a regular
 expression, or if it takes the form @code{(header @var{match}
 @var{regexp})}, a @samp{gnus-match-substitute-replacement} is proceed
 on the value to replace the positional parameters @samp{\@var{n}} by
-the corresponding parenthetical matches (see @xref{Replacing Match,,
+the corresponding parenthetical matches (@pxref{Replacing Match,,
 Replacing the Text that Matched, elisp, The Emacs Lisp Reference
 Manual}.)
 
@@ -24242,7 +24242,7 @@ You must read this section to understand how the Spam package works.
 Do not skip, speed-read, or glance through this section.
 
 Make sure you read the section on the @code{spam.el} sequence of
-events.  See @xref{Extending the Spam package}.
+events.  @xref{Extending the Spam package}.
 
 @cindex spam-initialize
 @vindex spam-use-stat
@@ -27113,7 +27113,7 @@ Richard Mlynarik,
 Lantz Moore,
 Morioka Tomohiko, @c Morioka
 Erik Toubro Nielsen,
-Hrvoje Niksic,
+Hrvoje Nikšić,
 Andy Norman,
 Fred Oberhauser,
 C. R. Oldham,
diff --git a/doc/misc/mh-e.texi b/doc/misc/mh-e.texi
index 9907095002..25dd53c4fb 100644
--- a/doc/misc/mh-e.texi
+++ b/doc/misc/mh-e.texi
@@ -6287,24 +6287,24 @@ Emacs navigational keys (like the arrow keys, or @kbd{C-n}) to move
 the cursor over the desired folder and then use the shortcuts for the
 menu items listed in the table below.
 
-@table @samp
+@table @asis
 @findex mh-speed-view
-@item Visit Folder (@key{RET})
+@item @samp{Visit Folder} (@key{RET})
 Visits the selected folder just as if you had used @kbd{F v}
 (@code{mh-speed-view}).
 @c -------------------------
 @findex mh-speed-expand-folder
-@item Expand Nested Folders (@kbd{+})
+@item @samp{Expand Nested Folders} (@kbd{+})
 Expands the selected folder in the speedbar, exposing the children
 folders inside it (@code{mh-speed-expand-folder}).
 @c -------------------------
 @findex mh-speed-contract-folder
-@item Contract Nested Folders (@kbd{-})
+@item @samp{Contract Nested Folders} (@kbd{-})
 Contracts or collapses the selected folder in the speedbar, hiding the
 children folders inside it (@code{mh-speed-contract-folder}).
 @c -------------------------
 @findex mh-speed-refresh
-@item Refresh Speedbar (@kbd{r})
+@item @samp{Refresh Speedbar} (@kbd{r})
 Regenerates the list of folders in the speedbar. Run this command if
 you've added or deleted a folder, or want to update the unseen message
 count before the next automatic update (@code{mh-speed-refresh}).
diff --git a/doc/misc/org.texi b/doc/misc/org.texi
index 7862713f47..de3b7bbed4 100644
--- a/doc/misc/org.texi
+++ b/doc/misc/org.texi
@@ -9687,7 +9687,7 @@ If you are away from your computer, it can be very useful to have a printed
 version of some agenda views to carry around.  Org mode can export custom
 agenda views as plain text, HTML@footnote{You need to install
 @file{htmlize.el} from @uref{https://github.com/hniksic/emacs-htmlize,Hrvoje
-Niksic's repository.}}, Postscript, PDF@footnote{To create PDF output, the
+Nikšić's repository.}}, Postscript, PDF@footnote{To create PDF output, the
 ghostscript @file{ps2pdf} utility must be installed on the system.  Selecting
 a PDF file will also create the postscript file.}, and iCalendar files.  If
 you want to do this only occasionally, use the command
@@ -10290,7 +10290,7 @@ Org mode can contain @LaTeX{} math fragments, and it supports ways to process
 these for several export back-ends.  When exporting to @LaTeX{}, the code is
 left as it is.  When exporting to HTML, Org can use either
 @uref{http://www.mathjax.org, MathJax} (@pxref{Math formatting in HTML
-export}) or transcode the math into images (see @pxref{Previewing @LaTeX{}
+export}) or transcode the math into images (@pxref{Previewing @LaTeX{}
 fragments}).
 
 @LaTeX{} fragments don't need any special marking at all.  The following
@@ -10356,7 +10356,7 @@ or @file{convert} installed@footnote{These are respectively available at
 and from the @file{imagemagick} suite.  Choose the converter by setting the
 variable @code{org-preview-latex-default-process} accordingly.}, @LaTeX{}
 fragments can be processed to produce images of the typeset expressions to be
-used for inclusion while exporting to HTML (see @pxref{@LaTeX{} fragments}),
+used for inclusion while exporting to HTML (@pxref{@LaTeX{} fragments}),
 or for inline previewing within Org mode.
 
 @vindex org-format-latex-options
diff --git a/doc/misc/rcirc.texi b/doc/misc/rcirc.texi
index bbcd0ed462..1482a14fad 100644
--- a/doc/misc/rcirc.texi
+++ b/doc/misc/rcirc.texi
@@ -337,9 +337,10 @@ channel name and join that channel.  (Also @code{/join #emacs}.)
 @cindex disconnect from a channel
 @cindex stop talking on a channel
 @cindex kill channel buffer
-This leaves the current channel.  You can optionally provide a reason
-for parting.  When you kill a channel buffer, you automatically part the
-corresponding channel.  (Also @code{/part you are too weird!}.)
+This leaves the current channel.  You can optionally provide a
+different channel name and reason for parting.  When you kill a
+channel buffer, you automatically part the corresponding channel.
+(Also @code{/part #emacs you are too weird!}.)
 
 @item C-c C-r
 @kindex C-c C-r
diff --git a/doc/misc/reftex.texi b/doc/misc/reftex.texi
index baa8de4b4d..8221abdbba 100644
--- a/doc/misc/reftex.texi
+++ b/doc/misc/reftex.texi
@@ -3697,7 +3697,7 @@ MicroEmacs at the time).
 Here is a summary of @RefTeX{}'s commands which can be executed from
 @LaTeX{} files.  Command which are executed from the special buffers are
 not described here.  All commands are available from the @code{Ref}
-menu.  See @xref{Key Bindings}.
+menu.  @xref{Key Bindings}.
 
 @deffn Command reftex-toc
 Show the table of contents for the current document.  When called with
diff --git a/doc/misc/sc.texi b/doc/misc/sc.texi
index 7d53c6dbe5..d10bdc6426 100644
--- a/doc/misc/sc.texi
+++ b/doc/misc/sc.texi
@@ -249,10 +249,10 @@ And that's what I think too.
 @end menu
 
 Note that multiple inclusions of the original messages result in a
-nesting of the @samp{@code{>}} characters.  This can sometimes be quite
+nesting of the @samp{>} characters.  This can sometimes be quite
 confusing when many levels of citations are included since it may be
 difficult or impossible to figure out who actually participated in the
-thread, and multiple nesting of @samp{@code{>}} characters can sometimes
+thread, and multiple nesting of @samp{>} characters can sometimes
 make the message very difficult for the eye to scan.
 
 @cindex non-nested citations
diff --git a/doc/misc/texinfo.tex b/doc/misc/texinfo.tex
index 667292a96a..53f2fc4835 100644
--- a/doc/misc/texinfo.tex
+++ b/doc/misc/texinfo.tex
@@ -3,7 +3,7 @@
 % Load plain if necessary, i.e., if running under initex.
 \expandafter\ifx\csname fmtname\endcsname\relax\input plain\fi
 %
-\def\texinfoversion{2019-03-23.11}
+\def\texinfoversion{2019-05-18.15}
 %
 % Copyright 1985, 1986, 1988, 1990-2019 Free Software Foundation, Inc.
 %
@@ -2175,7 +2175,7 @@
 % A few fonts for @defun names and args.
 \setfont\defbf\bfshape{10}{\magstep1}{OT1}
 \setfont\deftt\ttshape{10}{\magstep1}{OT1TT}
-\setfont\defsl\slshape{10}{\magstep1}{OT1TT}
+\setfont\defsl\slshape{10}{\magstep1}{OT1}
 \setfont\defttsl\ttslshape{10}{\magstep1}{OT1TT}
 \def\df{\let\ttfont=\deftt \let\bffont = \defbf
 \let\ttslfont=\defttsl \let\slfont=\defsl \bf}
@@ -2323,7 +2323,7 @@
 % A few fonts for @defun names and args.
 \setfont\defbf\bfshape{10}{\magstephalf}{OT1}
 \setfont\deftt\ttshape{10}{\magstephalf}{OT1TT}
-\setfont\defsl\slshape{10}{\magstephalf}{OT1TT}
+\setfont\defsl\slshape{10}{\magstephalf}{OT1}
 \setfont\defttsl\ttslshape{10}{\magstephalf}{OT1TT}
 \def\df{\let\ttfont=\deftt \let\bffont = \defbf
 \let\slfont=\defsl \let\ttslfont=\defttsl \bf}
@@ -3098,9 +3098,9 @@
 % Allow a ragged right output to aid breaking long URL's.  Putting stretch in 
 % between characters of the URL doesn't look good.
 \def\urefallowbreak{%
-  \hskip 0pt plus 1fil\relax
+  \hskip 0pt plus 4 em\relax
   \allowbreak
-  \hskip 0pt plus -1fil\relax
+  \hskip 0pt plus -4 em\relax
 }
 
 \urefbreakstyle after
@@ -4915,6 +4915,7 @@
   % Assorted special characters.
   \definedummyword\atchar
   \definedummyword\arrow
+  \definedummyword\backslashchar
   \definedummyword\bullet
   \definedummyword\comma
   \definedummyword\copyright
@@ -4951,6 +4952,8 @@
   \definedummyword\sup
   \definedummyword\textdegree
   %
+  \definedummyword\subentry
+  %
   % We want to disable all macros so that they are not expanded by \write.
   \macrolist
   \let\value\dummyvalue
@@ -5034,6 +5037,7 @@
 \let\indexlbrace\relax
 \let\indexrbrace\relax
 \let\indexatchar\relax
+\let\indexbackslash\relax
 
 {\catcode`\@=0
 \catcode`\\=13
@@ -5222,13 +5226,18 @@
 }
 
 \def\indexwriteseealso#1{
-  \gdef\pagenumbertext{@seealso{#1}}%
+  \gdef\pagenumbertext{\string\seealso{#1}}%
+}
+\def\indexwriteseeentry#1{
+  \gdef\pagenumbertext{\string\seeentry{#1}}%
 }
 
 % The default definitions
 \def\sortas#1{}%
 \def\seealso#1{\i{\putwordSeeAlso}\ #1}% for sorted index file only
-\def\putwordSeeAlso{see also}
+\def\putwordSeeAlso{See also}
+\def\seeentry#1{\i{\putwordSee}\ #1}% for sorted index file only
+
 
 % Given index entry text like "aaa @subentry bbb @sortas{ZZZ}":
 %   * Set \bracedtext to "{aaa}{bbb}"
@@ -5240,6 +5249,7 @@
   \xdef\bracedtext{}%
   \def\sep{}%
   \def\seealso##1{}%
+  \def\seeentry##1{}%
   \expandafter\doindexsegment#1\subentry\finish\subentry
 }
 
@@ -5261,14 +5271,17 @@
     \bgroup
       \let\sortas\indexwritesortas
       \let\seealso\indexwriteseealso
+      \let\seeentry\indexwriteseeentry
       \indexnofonts
       % The braces around the commands are recognized by texindex.
-      \def\lbracechar{{\indexlbrace}}%
-      \def\rbracechar{{\indexrbrace}}%
+      \def\lbracechar{{\string\indexlbrace}}%
+      \def\rbracechar{{\string\indexrbrace}}%
       \let\{=\lbracechar
       \let\}=\rbracechar
-      \def\@{{\indexatchar}}%
+      \def\@{{\string\indexatchar}}%
       \def\atchar##1{\@}%
+      \def\backslashchar{{\string\indexbackslash}}%
+      \uccode`\~=`\\ \uppercase{\let~\backslashchar}%
       %
       \let\indexsortkey\empty
       \global\let\pagenumbertext\empty
@@ -5298,16 +5311,36 @@
 
 \let\subentry\relax
 
-% Write the entry in \toks0 to the index file.
+% Use \ instead of @ in index files.  To support old texi2dvi and texindex.
+% This works without changing the escape character used in the toc or aux
+% files because the index entries are fully expanded here, and \string uses
+% the current value of \escapechar.
+\def\escapeisbackslash{\escapechar=`\\}
+
+% Use \ in index files by default.  texi2dvi didn't support @ as as the escape 
+% character (as it checked for "\entry" in the files, and not "@entry").  When 
+% the new version of texi2dvi has had a chance to become more prevalent, then 
+% the escape character can change back to @ again.  This should be an easy 
+% change to make now because both @ and \ are only used as escape characters in 
+% index files, never standing for themselves. 
+%
+\set txiindexescapeisbackslash
+
+% Write the entry in \indextext to the index file.
 %
 \def\doindwrite{%
   \maybemarginindex
   %
   \atdummies
   %
+  \expandafter\ifx\csname SETtxiindexescapeisbackslash\endcsname\relax\else
+    \escapeisbackslash
+  \fi
+  %
   % For texindex which always views { and } as separators.
   \def\{{\lbracechar{}}%
   \def\}{\rbracechar{}}%
+  \uccode`\~=`\\ \uppercase{\def~{\backslashchar{}}}%
   %
   % Split the entry into primary entry and any subentries, and get the index 
   % sort key.
@@ -5486,12 +5519,37 @@
 % old index files using \ as the escape character.  Reading this would
 % at best lead to typesetting garbage, at worst a TeX syntax error.
 \def\printindexzz#1#2\finish{%
-  % NB this won't work if the index file starts with a group...
-  \uccode`\~=`\\ \uppercase{\if\noexpand~}\noexpand#1
-    \message{skipping sorted index file}%
-    (Skipped sorted index file in obsolete format)
+  \expandafter\ifx\csname SETtxiindexescapeisbackslash\endcsname\relax
+    \uccode`\~=`\\ \uppercase{\if\noexpand~}\noexpand#1
+      \expandafter\ifx\csname SETtxiskipindexfileswithbackslash\endcsname\relax
+\errmessage{%
+ERROR: A sorted index file in an obsolete format was skipped.  
+To fix this problem, please upgrade your version of 'texi2dvi'
+or 'texi2pdf' to that at <https://ftp.gnu.org/gnu/texinfo>.
+If you are using an old version of 'texindex' (part of the Texinfo 
+distribution), you may also need to upgrade to a newer version (at least 6.0).
+You may be able to typeset the index if you run
+'texindex \jobname.\indexname' yourself.
+You could also try setting the 'txiindexescapeisbackslash' flag by 
+running a command like
+'texi2dvi -t "@set txiindexescapeisbackslash" \jobname.texi'.  If you do 
+this, Texinfo will try to use index files in the old format.
+If you continue to have problems, deleting the index files and starting again 
+might help (with 'rm \jobname.?? \jobname.??s')%
+}%
+      \else
+        (Skipped sorted index file in obsolete format)
+      \fi
+    \else
+      \begindoublecolumns
+      \input \jobname.\indexname s
+      \enddoublecolumns
+    \fi
   \else
+    \message{trying to print index \indexname}%
     \begindoublecolumns
+    \catcode`\\=0\relax
+    \catcode`\@=12\relax
     \input \jobname.\indexname s
     \enddoublecolumns
   \fi
@@ -5508,6 +5566,7 @@
   \let\indexlbrace\{%
   \let\indexrbrace\}%
   \let\indexatchar\@%
+  \def\indexbackslash{\math{\backslash}}%
   %
   % Some changes for non-alphabetic characters.  Using the glyphs from the
   % math fonts looks more consistent than the typewriter font used elsewhere
@@ -8627,8 +8686,16 @@
 }
 \def\wordTop{Top}
 
-% Divert output to a box that is not output until the next @node command.
-\def\ignorenode{\setbox\dummybox\vbox\bgroup\def\node{\egroup\node}}
+% Until the next @node or @bye command, divert output to a box that is not 
+% output.
+\def\ignorenode{\setbox\dummybox\vbox\bgroup\def\node{\egroup\node}%
+\ignorenodebye
+}
+
+{\let\bye\relax
+\gdef\ignorenodebye{\let\bye\ignorenodebyedef}
+\gdef\ignorenodebyedef{\egroup(`Top' node ignored)\bye}}
+% The redefinition of \bye here is because it is declared \outer
 
 \let\lastnode=\empty
 
diff --git a/doc/misc/tramp.texi b/doc/misc/tramp.texi
index e376fc7495..d34c5e0f33 100644
--- a/doc/misc/tramp.texi
+++ b/doc/misc/tramp.texi
@@ -2,9 +2,8 @@
 @setfilename ../../info/tramp.info
 @c %**start of header
 @include docstyle.texi
-@c In the Tramp repository, the version number is auto-frobbed from
-@c configure.ac, so you should edit that file and run
-@c "autoconf && ./configure" to change the version number.
+@c In the Tramp GIT, the version number is auto-frobbed from tramp.el,
+@c and the bug report address is auto-frobbed from configure.ac.
 @include trampver.texi
 @settitle @value{tramp} @value{trampver} User Manual
 @c %**end of header
@@ -28,10 +27,10 @@ copy and modify this GNU manual.''
 @end quotation
 @end copying
 
-@c Entries for @command{install-info} to use
+@c Entries for @command{install-info} to use.  We cannot use @value{tramp}.
 @dircategory Emacs network features
 @direntry
-* @value{tramp}: (tramp).               Transparent Remote Access, Multiple Protocol
+* Tramp: (tramp).               Transparent Remote Access, Multiple Protocol
                                   Emacs remote file access via ssh and scp.
 @end direntry
 
@@ -52,7 +51,7 @@ editing package for Emacs.
 
 @value{tramp} stands for ``Transparent Remote (file) Access, Multiple
 Protocol''.  This package provides remote file editing, similar to
-Ange FTP.
+Ange FTP@.
 
 The difference is that Ange FTP uses FTP to transfer files between the
 local and the remote host, whereas @value{tramp} uses a combination of
@@ -114,8 +113,8 @@ For the developer:
 
 Installing @value{tramp} with your Emacs
 
-* System Requirements::         Prerequisites for :@value{tramp} installation.
-* Basic Installation::          Installation steps.:
+* System Requirements::         Prerequisites for @value{tramp} installation.
+* Basic Installation::          Installation steps.
 * Installation parameters::     Parameters in order to control installation.
 * Testing::                     A test suite for @value{tramp}.
 * Load paths::                  How to plug-in @value{tramp} into your environment.
@@ -309,14 +308,34 @@ behind the scenes when you open a file with @value{tramp}.
 @node Obtaining @value{tramp}
 @chapter Obtaining @value{tramp}
 @cindex obtaining @value{tramp}
+@cindex GNU ELPA
+@vindex tramp-version
 
 @value{tramp} is included as part of Emacs (since Emacs 22.1).
 
 @value{tramp} is also freely packaged for download on the Internet at
-@uref{https://ftp.gnu.org/gnu/tramp/}.
+@uref{https://ftp.gnu.org/gnu/tramp/}.  The version number of
+@value{tramp} can be obtained by the variable @code{tramp-version}.
+For released @value{tramp} versions, this is a three-number string
+like ``2.4.2''.
+
+A @value{tramp} release, which is packaged with Emacs, could differ
+slightly from the corresponding standalone release.  This is because
+it isn't always possible to synchronize release dates between Emacs
+and @value{tramp}.  Such version numbers have the Emacs version number
+as suffix, like ``2.3.5.26.2''.  This means @value{tramp} 2.3.5 as
+integrated in Emacs 26.2.
+
+@value{tramp} is also available as @uref{https://elpa.gnu.org, GNU
+ELPA} package.  Besides the standalone releases, further minor version
+of @value{tramp} will appear on GNU ELPA, until the next @value{tramp}
+release appears.  These minor versions have a four-number string, like
+``2.4.2.1''.
 
 @value{tramp} development versions are available on Git servers.
-Development versions contain new and incomplete features.
+Development versions contain new and incomplete features.  The
+development version of @value{tramp} is always the version number of
+the next release, plus the suffix ``-pre'', like ``2.4.3-pre''.
 
 One way to obtain from Git server is to visit the Savannah project
 page at the following URL and then clicking on the Git link in the
@@ -379,7 +398,7 @@ $ autoconf
 
 
 @c Installation chapter is necessary only in case of standalone
-@c installation.  Text taken from trampinst.texi.
+@c installation.
 @ifset installchapter
 @include trampinst.texi
 @end ifset
@@ -468,6 +487,27 @@ The method @option{sg} stands for ``switch group''; the changed group
 must be used here as user name.  The default host name is the same.
 
 
+@anchor{Quick Start Guide: @option{ssh}, @option{plink}, @option{su}, @option{sudo} and @option{sg} methods}
+@section Combining @option{ssh} or @option{plink} with @option{su} or @option{sudo}
+@cindex method @option{ssh}
+@cindex @option{ssh} method
+@cindex method @option{plink}
+@cindex @option{plink} method
+@cindex method @option{su}
+@cindex @option{su} method
+@cindex method @option{sudo}
+@cindex @option{sudo} method
+
+If the @option{su} or @option{sudo} option shall be performed on
+another host, it could be comnbined with a leading @option{ssh} or
+@option{plink} option.  That means, @value{tramp} connects first to
+the other host with non-administrative credentials, and changes to
+administrative credentials on that host afterwards.  In a simple case,
+the syntax looks like
+@file{@value{prefix}ssh@value{postfixhop}user@@host|sudo@value{postfixhop}@value{postfix}/path/to/file}.
+@xref{Ad-hoc multi-hops}.
+
+
 @anchor{Quick Start Guide: @option{sudoedit} method}
 @section Using @command{sudoedit}
 @cindex method @option{sudoedit}
@@ -525,7 +565,7 @@ file system), @file{@trampfn{dav,user@@host,/path/to/file}} and
 @cindex google drive
 @cindex method @option{nextcloud}
 @cindex @option{nextcloud} method
-@cindex owncloud
+@cindex nextcloud
 
 GVFS-based methods include also @acronym{GNOME} Online Accounts, which
 support the @option{Files} service.  These are the Google Drive file
@@ -968,7 +1008,7 @@ after a predefined timeout.
 @cindex @option{ftp} method
 
 When @value{tramp} uses @option{ftp}, it forwards requests to whatever
-ftp program is specified by Ange FTP.  This external program must be
+ftp program is specified by Ange FTP@.  This external program must be
 capable of servicing requests from @value{tramp}.
 
 @item @option{smb}
@@ -1092,8 +1132,8 @@ numbers are not applicable to Android devices connected through USB@.
 The program @command{rclone} allows to access different system
 storages in the cloud, see @url{https://rclone.org/} for a list of
 supported systems.  If the @command{rclone} program isn't found in
-your @env{PATH} environment variable, you can tell Tramp its absolute
-path via the user option @code{tramp-rclone-program}.
+your @env{PATH} environment variable, you can tell @value{tramp} its
+absolute path via the user option @code{tramp-rclone-program}.
 
 A system storage must be configured via the @command{rclone config}
 command, outside Emacs.  If you have configured a storage in
@@ -1108,7 +1148,7 @@ User names are part of the @command{rclone} configuration, and not
 needed in the remote file name.  If a user name is contained in the
 remote file name, it is ignored.
 
-Internally, Tramp mounts the remote system storage at location
+Internally, @value{tramp} mounts the remote system storage at location
 @file{/tmp/tramp.rclone.storage}, with @file{storage} being the name
 of the configured system storage.
 
@@ -1188,7 +1228,7 @@ directory have the same @code{display-name}, such a situation must be avoided.
 @cindex @acronym{GNOME} Online Accounts
 @cindex method @option{nextcloud}
 @cindex @option{nextcloud} method
-@cindex owncloud
+@cindex nextcloud
 
 As the name indicates, the method @option{nextcloud} allows you to
 access OwnCloud or NextCloud hosted files and directories.  Like the
@@ -1538,8 +1578,8 @@ Host host.other.domain
 @end group
 @end example
 
-@code{nc} is BSD's netcat program, which establishes HTTP tunnels. Any
-other program with such a feature could be used as well.
+@code{nc} is BSD's netcat program, which establishes HTTP tunnels.
+Any other program with such a feature could be used as well.
 
 In the example, opening @file{@trampfn{ssh,host.your.domain,}} passes
 the HTTP proxy server @samp{proxy.your.domain} on port 3128.
@@ -1615,7 +1655,7 @@ Integration for LXD containers.  A container is accessed via
 @cindex method @option{git}
 @cindex @option{git} method
 Browing git repositories with @code{magit}.  A versioned file is accessed via
-@file{@trampfn{git,rev@@root-dir,/path/to/file}}. @samp{rev} is a git
+@file{@trampfn{git,rev@@root-dir,/path/to/file}}.  @samp{rev} is a git
 revision, and @samp{root-dir} is a virtual host name for the root
 directory, specified in @code{magit-tramp-hosts-alist}.
 
@@ -2642,7 +2682,7 @@ names.  Beside the @code{default} value, @var{syntax} can be
 @item @code{simplified}
 @cindex simplified syntax
 
-The remote file name syntax is similar to the syntax used by Ange FTP.
+The remote file name syntax is similar to the syntax used by Ange FTP@.
 A remote file name has the form
 @code{@value{prefix}user@@host@value{postfix}path/to/file}.  The
 @code{user@@} part is optional, and the method is determined by
@@ -3063,6 +3103,8 @@ host.  Example:
 @kbd{M-x auto-revert-tail-mode @key{RET}} runs similarly showing
 continuous output.
 
+@vindex shell-file-name
+@vindex shell-command-switch
 @code{shell-command} uses the variables @code{shell-file-name} and
 @code{shell-command-switch} in order to determine which shell to run.
 For remote hosts, their default values are @file{/bin/sh} and
@@ -3071,6 +3113,15 @@ uses @file{/system/bin/sh}).  Like the variables in the previous
 section, these variables can be changed via connection-local
 variables.
 
+@vindex async-shell-command-width
+@vindex COLUMNS@r{, environment variable}
+If Emacs supports the variable @code{async-shell-command-width} (since
+Emacs 27.1), @value{tramp} cares about its value for asynchronous
+shell commands.  It specifies the number of display columns for
+command output.  For synchronous shell commands, a similar effect can
+be achieved by adding the environment variable @env{COLUMNS} to
+@code{tramp-remote-process-environment}.
+
 
 @subsection Running @code{eshell} on a remote host
 @cindex @code{eshell}
@@ -4372,7 +4423,7 @@ handlers.
 @vindex non-essential
 Sometimes, it is not convenient to open a new connection to a remote
 host, including entering the password and alike.  For example, this is
-nasty for packages providing file name completion. Such a package
+nasty for packages providing file name completion.  Such a package
 could signal to @value{tramp}, that they don't want it to establish a
 new connection.  Use the variable @code{non-essential} temporarily and
 bind it to non-@code{nil} value.
@@ -4427,6 +4478,7 @@ root-directory, it is most likely sufficient to make the
 
 @node Traces and Profiles
 @chapter How to Customize Traces
+@vindex tramp-verbose
 
 @value{tramp} messages are raised with verbosity levels ranging from 0
 to 10.  @value{tramp} does not display all messages; only those with a
diff --git a/etc/ChangeLog.1 b/etc/ChangeLog.1
index 24b8b39ec1..4317cfcb03 100644
--- a/etc/ChangeLog.1
+++ b/etc/ChangeLog.1
@@ -3395,7 +3395,7 @@
 
 	* MORE.STUFF: Update some links, remove some dead ones.
 
-2007-04-04  Slawomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>
+2007-04-04  Sławomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>
 
 	* emacs.py (format_exception): New function.
 	(eexecfile): Use it instead of traceback.print_exception.
@@ -3770,7 +3770,7 @@
 	(section{TODO Items and Checkboxes}): Checkbox keys moved to this
 	section, added documentation for the key `C-c #'.
 
-2006-11-05  Slawomir Nowaczyk  <slawek@cs.lth.se>
+2006-11-05  Sławomir Nowaczyk  <slawek@cs.lth.se>
 
 	* emacs.py (eargs): Provide eldoc message for builtin types.
 	Make sure eargs always outputs sentinel, to avoid Emacs freeze.
@@ -3861,7 +3861,7 @@
 	(eimport): Use __main__ rather than `emacs' namespace.
 	(modpath): New fun.
 
-2006-08-20  Slawomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>
+2006-08-20  Sławomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>
 
 	* emacs.py (eexecfile): Use the __main__ rather than `emacs' namespace.
 
@@ -4122,7 +4122,7 @@
 	Stefan Monnier <monnier@iro.umontreal.ca>.
 
 	* pl-refcard.tex (section{Info}): Ditto.  Translation suggested by
-	Slawomir Nowaczyk <slawomir.nowaczyk.847@student.lu.se>.
+	Sławomir Nowaczyk <slawomir.nowaczyk.847@student.lu.se>.
 
 	* cs-refcard.tex (section{Info}): Use `s' instead of `M-s'.
 	Entry for `i' is not translated yet.
@@ -4854,7 +4854,7 @@
 
 	* NEWS: Lots of clarifications and cleanups.
 
-2005-05-05  Slawomir Nowaczyk  <slawek@cs.lth.se>
+2005-05-05  Sławomir Nowaczyk  <slawek@cs.lth.se>
 
 	* TUTORIAL.pl: Updated header.
 
@@ -5777,7 +5777,7 @@
 
 	* ps-prin0.ps: Changed comment version (6.0).
 
-2000-08-24  Wlodzimierz Bzyl  <matwb@univ.gda.pl>
+2000-08-24  Włodzimierz Bzyl  <matwb@univ.gda.pl>
 
 	* survival.tex: New file.
 
@@ -5852,7 +5852,7 @@
 
 	* refcard.bit: Removed.
 
-2000-04-10  Wlodzimierz Bzyl  <matwb@monika.univ.gda.pl>
+2000-04-10  Włodzimierz Bzyl  <matwb@monika.univ.gda.pl>
 
 	* refcard-pl.ps: New file.
 	* refcard-pl.tex: New file.
diff --git a/etc/DEBUG b/etc/DEBUG
index d401d0be90..836e820e4a 100644
--- a/etc/DEBUG
+++ b/etc/DEBUG
@@ -12,24 +12,21 @@ debugging techniques.
 *** Configuring Emacs for debugging
 
 It is best to configure and build Emacs with special options that will
-make the debugging easier.  Here's the configure-time options we
+make the debugging easier.  Here are the configure-time options we
 recommend (they are in addition to any other options you might need,
 such as --prefix):
 
   ./configure --enable-checking='yes,glyphs' --enable-check-lisp-object-type \
     CFLAGS='-O0 -g3'
 
-The CFLAGS value is important: debugging optimized code can be very
-hard.  (If the problem only happens with optimized code, you may need
-to enable optimizations.  If that happens, try using -Og first,
-instead of -O2, as the former will disable some optimizations that
-make debugging some code exceptionally hard.)
+The -O0 flag is important, as debugging optimized code can be hard.
+If the problem happens only with optimized code, you may need to
+enable optimizations.  If that happens, try using -Og first instead of
+-O2, as -Og disables some optimizations that make debugging some code
+exceptionally hard.
 
-Modern versions of GCC support more elaborate debug info that is
-available by just using the -g3 compiler switch.  Try using -gdwarf-4
-in addition to -g3, and if that fails, try -gdwarf-3.  This is
-especially important if you have to debug optimized code.  More info
-about this is available below; search for "analyze failed assertions".
+Older versions of GCC may need more than just the -g3 flag.  For more,
+search for "analyze failed assertions" below.
 
 The 2 --enable-* switches are optional.  They don't have any effect on
 debugging with GDB, but will compile additional code that might catch
@@ -184,20 +181,15 @@ Good luck!
 
 ** When you are trying to analyze failed assertions or backtraces, it
 is essential to compile Emacs with flags suitable for debugging.
-With GCC 4.8 or later, you can invoke 'make' with CFLAGS="-Og -g3".
-With older GCC or non-GCC compilers, you can use CFLAGS="-O0 -g3".
+Although CFLAGS="-O0 -g3" often suffices with modern compilers,
+you may benefit further by using CFLAGS="-O0 -g3 -gdwarf-4", replacing
+"4" by the highest version of DWARF that your compiler supports;
+this is especially important for GCC versions older than 4.8.
 With GCC and higher optimization levels such as -O2, the
 -fno-omit-frame-pointer and -fno-crossjumping options are often
 essential.  The latter prevents GCC from using the same abort call for
 all assertions in a given function, rendering the stack backtrace
 useless for identifying the specific failed assertion.
-Some versions of GCC support recent versions of the DWARF standard for
-debugging info, but default to older versions; for example, they could
-support -gdwarf-4 compiler option (for DWARF v4), but default to
-version 2 of the DWARF standard.  For best results in debugging
-abilities, find out the highest version of DWARF your GCC can support,
-and use the corresponding -gdwarf-N switch instead of just -g (you
-will still need -g3, as in "-gdwarf-4 -g3").
 
 ** It is a good idea to run Emacs under GDB (or some other suitable
 debugger) *all the time*.  Then, when Emacs crashes, you will be able
@@ -923,41 +915,97 @@ setting the new-console option before running Emacs under GDB:
   (gdb) set new-console 1
   (gdb) run
 
-** Running Emacs built with malloc debugging packages
+** Running Emacs with undefined-behavior sanitization
 
-If Emacs exhibits bugs that seem to be related to use of memory
-allocated off the heap, it might be useful to link Emacs with a
-special debugging library, such as Electric Fence (a.k.a. efence) or
-GNU Checker, which helps find such problems.
+Building Emacs with undefined-behavior sanitization can help find
+several kinds of low-level problems in C code, including:
 
-Emacs compiled with such packages might not run without some hacking,
-because Emacs replaces the system's memory allocation functions with
-its own versions, and because the dumping process might be
-incompatible with the way these packages use to track allocated
-memory.  Here are some of the changes you might find necessary:
+  * Out-of-bounds access of many (but not all) arrays.
+  * Signed integer overflow, e.g., (INT_MAX + 1).
+  * Integer shifts by a negative or wider-than-word value.
+  * Misaligned pointers and pointer overflow.
+  * Loading a bool or enum value that is out of range for its type.
+  * Passing NULL to or returning NULL from a function requiring nonnull.
+  * Passing a size larger than the corresponding array to memcmp etc.
+  * Passing invalid values to some builtin functions, e.g., __builtin_clz (0).
+  * Reaching __builtin_unreachable calls (in Emacs, 'eassume' failure).
 
-  - Make sure unexec is disabled, e.g., './configure --without-unexec'.
+To use UndefinedBehaviorSanitizer with GCC and similar compilers,
+append '-fsanitize=undefined' to CFLAGS, either when running
+'configure' or running 'make'.  When supported, you can also specify
+'bound-strict' and 'float-cast-overflow'.  For example:
 
-  - Configure with a different --prefix= option.  If you use GCC,
-    version 2.7.2 is preferred, as some malloc debugging packages
-    work a lot better with it than with 2.95 or later versions.
+  ./configure \
+    CFLAGS='-O0 -g3 -fsanitize=undefined,bounds-strict,float-cast-overflow'
 
-  - Type "make" then "make -k install".
+You may need to append '-static-libubsan' to CFLAGS if your version of
+GCC is installed in an unusual location.
 
-  - If required, invoke the package-specific command to prepare
-    src/temacs for execution.
+When using GDB to debug an executable with undefined-behavior
+sanitization, the GDB command:
 
-  - cd ..; src/temacs
+  (gdb) rbreak ^__ubsan_handle_
 
-(Note that this runs 'temacs' instead of the usual 'emacs' executable.
-This avoids problems with dumping Emacs mentioned above.)
+will let you gain control when an error is detected and before
+UndefinedBehaviorSanitizer outputs to stderr or terminates the
+program.
 
-Some malloc debugging libraries might print lots of false alarms for
-bitfields used by Emacs in some data structures.  If you want to get
-rid of the false alarms, you will have to hack the definitions of
-these data structures on the respective headers to remove the ':N'
-bitfield definitions (which will cause each such field to use a full
-int).
+** Running Emacs with address sanitization
+
+Building Emacs with address sanitization can help debug memory-use
+problems, such as freeing the same object twice.  To use
+AddressSanitizer with GCC and similar compilers, append
+'-fsanitize=address' to CFLAGS, either when running 'configure' or
+running 'make'.  Configure, build and run Emacs with
+ASAN_OPTIONS='detect_leaks=0' in the environment to suppress
+diagnostics of minor memory leaks in Emacs.  For example:
+
+  export ASAN_OPTIONS='detect_leaks=0'
+  ./configure CFLAGS='-O0 -g3 -fsanitize=address'
+  make
+  src/emacs
+
+You may need to append '-static-libasan' to CFLAGS if your version of
+GCC is installed in an unusual location.
+
+When using GDB to debug an executable with address sanitization, the
+GDB command:
+
+  (gdb) rbreak ^__asan_report_
+
+will let you gain control when an error is detected and before
+AddressSanitizer outputs to stderr or terminates the program.
+
+Address sanitization is incompatible with undefined-behavior
+sanitization, unfortunately.  Address sanitization is also
+incompatible with the --with-dumping=unexec option of 'configure'.
+
+** Running Emacs under Valgrind
+
+Valgrind <http://valgrind.org/> is free software that can be useful
+when debugging low-level Emacs problems.  Unlike GCC sanitizers,
+Valgrind does not need you to compile Emacs with special debugging
+flags, so it can be helpful in investigating problems that vanish when
+Emacs is recompiled with debugging enabled.  However, by default
+Valgrind generates many false alarms with Emacs, and you will need to
+maintain a suppressions file to suppress these false alarms and use
+Valgrind effectively.  For example, you might invoke Valgrind this
+way:
+
+   valgrind --suppressions=valgrind.supp ./emacs
+
+where valgrind.supp contains groups of lines like the following, which
+suppresses some Valgrind false alarms during Emacs garbage collection:
+
+   {
+     Fgarbage_collect Cond - conservative garbage collection
+     Memcheck:Cond
+     ...
+     fun:Fgarbage_collect
+   }
+
+Unfortunately Valgrind suppression files tend to be system-dependent,
+so you will need to keep one around that matches your system.
 
 ** How to recover buffer contents from an Emacs core dump file
 
diff --git a/etc/HELLO b/etc/HELLO
index a56a73bc1d..33e664e834 100644
--- a/etc/HELLO
+++ b/etc/HELLO
@@ -124,4 +124,5 @@ along with GNU Emacs.  If not, see <<https://www.gnu.org/licenses/>.
 ;;; tab-width: 32
 ;;; bidi-display-reordering: t
 ;;; coding: utf-8
+;;; inhibit-compacting-font-caches: t
 ;;; End:</x-charset>
diff --git a/etc/NEWS b/etc/NEWS
index 021d7d0179..e47c30565f 100644
--- a/etc/NEWS
+++ b/etc/NEWS
@@ -37,11 +37,15 @@ functions 'json-serialize', 'json-insert', 'json-parse-string', and
 'json-parse-buffer' are typically much faster than their Lisp
 counterparts from json.el.
 
+** Emacs no longer defaults to using ImageMagick to display images,
+due to security and stability concerns.  To override the default, use
+'configure --with-imagemagick'.
+
 ** Several configure options now accept an option-argument 'ifavailable'.
 For example, './configure --with-xpm=ifavailable' now configures Emacs
-to attempt to use libxpm but to continue building even if libxpm is absent.
-The other affected options are --with-gif, --with-gnutls, --with-jpeg,
---with-png, and --with-tiff.
+to attempt to use libxpm but to continue building even if libxpm is
+absent.  The other affected options are '--with-gif', '--with-gnutls',
+'--with-jpeg', '--with-png', and '--with-tiff'.
 
 ** The etags program now uses the C library's regular expression matcher
 when possible, and a compatible regex substitute otherwise.  This will
@@ -89,6 +93,22 @@ Options" in the Emacs manual for more information.
 check that the portable dumper code has been updated to match the last
 change to one of the data structures that it relies on.
 
++++
+** The configure options '--enable-checking=conslist' and
+'--enable-checking=xmallocoverrun' have been withdrawn.  The former
+made Emacs irredeemably slow, and the latter made it crash.  Neither
+option was useful with modern debugging tools such as AddressSanitizer.
+(See etc/DEBUG for the details of using the modern replacements of the
+removed configure options.)
+
++++
+** The distribution tarball now has test cases; 'make check' runs them.
+This is intended mostly to help developers.
+
+---
+** Emacs now requires GTK 2.24 and GTK 3.10 for the GTK 2 and GTK 3
+builds respectively.
+
 
 * Startup Changes in Emacs 27.1
 
@@ -116,13 +136,14 @@ file, which was previously done when Emacs was started.  As a result
 of this change, it is no longer necessary to call 'package-initialize'
 in your init file.
 
-However, if your init file changes the values of 'package-load-list' or
-'package-user-dir', or sets 'package-enable-at-startup' to nil then it won't
-work right without some adjustment:
-- you can move that code to the early init file (see above), so those settings
-  apply before Emacs tries to activate the packages.
-- you can use the new 'package-quickstart' so activation of packages does not
-  need to pay attention to 'package-load-list' or 'package-user-dir' any more.
+However, if your init file changes the values of 'package-load-list'
+or 'package-user-dir', or sets 'package-enable-at-startup' to nil then
+it won't work right without some adjustment:
+- You can move that code to the early init file (see above), so those
+  settings apply before Emacs tries to activate the packages.
+- You can use the new 'package-quickstart' so activation of packages
+  does not need to pay attention to 'package-load-list' or
+  'package-user-dir' any more.
 
 ---
 ** Emacs now notifies systemd when startup finishes or shutdown begins.
@@ -132,6 +153,12 @@ after Emacs has finished initialization and is ready for use.
 emacs.service file to eg "~/.config/systemd/user/", you will need to copy
 the new version of the file again.)
 
++++
+** New option 'help-enable-completion-auto-load'.
+This allows disabling the new feature introduced in Emacs 26.1 which
+loads files during completion of 'C-h f' and 'C-h v' according to
+'definition-prefixes'.
+
 
 * Changes in Emacs 27.1
 
@@ -141,16 +168,16 @@ the new version of the file again.)
 *** emacsclient now supports the 'EMACS_SOCKET_NAME' environment variable.
 The behavior is identical to 'EMACS_SERVER_FILE', in that the
 command-line value specified via '--socket-name' will override the
-environment, and the natural default to TMPDIR, then "/tmp", continues
+environment, and the natural default to 'TMPDIR', then "/tmp", continues
 to apply.
 
 +++
-*** Emacs and emacsclient now default to $XDG_RUNTIME_DIR/emacs
+*** Emacs and emacsclient now default to "$XDG_RUNTIME_DIR/emacs"
 as the directory for client/server sockets, if Emacs is running
-under an X Window System desktop that sets the XDG_RUNTIME_DIR
+under an X Window System desktop that sets the 'XDG_RUNTIME_DIR'
 environment variable to indicate where session sockets should go.
 To get the old, less-secure behavior, you can set the
-EMACS_SOCKET_NAME environment variable to an appropriate value.
+'EMACS_SOCKET_NAME' environment variable to an appropriate value.
 
 ---
 *** When run by root, emacsclient no longer connects to non-root sockets.
@@ -164,7 +191,11 @@ be controlled via the new variable 'face-near-same-color-threshold'.
 The default value is 30000, as the previously hard-coded threshold.
 
 +++
-** The function 'read-passwd' uses '*' as default character to hide passwords.
+** The function 'read-passwd' uses "*" as default character to hide passwords.
+
+** Lexical binding is now used when evaluating interactive Elisp forms.
+More specifically, lexical-binding is now used for 'M-:', '--eval', as
+well as in the "*scratch*" and "*ielm*" buffers.
 
 ---
 ** The new option 'tooltip-resize-echo-area' avoids truncating tooltip text
@@ -199,7 +230,7 @@ indirectly, e.g., by checking that functions like
 'libxml-parse-html-region' return nil.
 
 +++
-** 'libxml-parse-xml-region' and 'libxml-parse-html' region take
+** 'libxml-parse-xml-region' and 'libxml-parse-html-region' take
 a parameter that's called DISCARD-COMMENTS, but it really only
 discards the top-level comment.  Therefore this parameter is now
 obsolete, and the new utility function 'xml-remove-comments' can be
@@ -225,7 +256,7 @@ security level (assuming you use the 'medium' level).
 +++
 ** Native GnuTLS connections can now use client certificates.
 Previously, this support was only available when using the external
-gnutls-cli command.  Call 'open-network-stream' with
+'gnutls-cli' command.  Call 'open-network-stream' with
 ':client-certificate t' to trigger looking up of per-server
 certificates via 'auth-source'.
 
@@ -305,12 +336,43 @@ and directory-local variables.
 
 +++
 *** The macro 'with-connection-local-variables' has been renamed from
-'with-connection-local-profiles'.  No argument 'profiles' needed any
-longer.
+'with-connection-local-profiles'.  No argument PROFILES needed any longer.
+
+---
+** New variable 'next-error-verbose' controls when 'next-error' outputs
+a message about the error locus.
+
+---
+** New variable 'grep-search-path' defines the directories searched for
+grep hits (this used to be controlled by 'compilation-search-path').
 
 ---
-** next-error-verbosity controls when `next-error' outputs a message
-   about the error locus.
+** New variable 'emacs-lisp-compilation-search-path' defines the
+directories searched for byte-compiler error messages (this used to
+be controlled by 'compilation-search-path').
+
+** Multicolor fonts such as "Noto Color Emoji" can be displayed on
+Emacs configured with Cairo drawing and linked with cairo >= 1.16.0.
+
++++
+** Emacs now optionally displays a fill column indicator.
+
+This is similar to what 'fill-column-indicator' package provides, but
+much faster and compatible with 'show-trailing-whitespace'.
+
+Customize the buffer-local variables 'display-fill-column-indicator'
+and 'display-fill-column-indicator-character' to activate the
+indicator.
+
+The indicator is not displayed at all in minibuffer windows and
+in tooltips, as it is not useful there.
+
+There are 2 new buffer local variables and 1 face to customize this
+mode they are described in the manual "(emacs) Display".
+
++++
+** 'progress-reporter-update' accepts a suffix string to display.
+
 
 
 * Editing Changes in Emacs 27.1
@@ -371,41 +433,54 @@ syntax that you can see in the example of a ".dir-locals.el" file in
 the node "(emacs) Directory Variables" of the user manual.
 
 +++
-** Network connections using 'local can now use IPv6.
+** Network connections using 'local' can now use IPv6.
 'make-network-process' now uses the correct loopback address when
-asked to use :host 'local and :family 'ipv6.
+asked to use ':host 'local' and ':family 'ipv6'.
 
 +++
-** The new function `replace-region-contents' replaces the current
+** The new function 'replace-region-contents' replaces the current
 region using a given replacement-function in a non-destructive manner
-(in terms of `replace-buffer-contents').
+(in terms of 'replace-buffer-contents').
 
 +++
-** The command `replace-buffer-contents' now has two optional
+** The command 'replace-buffer-contents' now has two optional
 arguments mitigating performance issues when operating on huge
 buffers.
 
++++
 ** The command 'delete-indentation' now operates on the active region.
 If the region is active, the command joins all the lines in the
 region.  When there's no active region, the command works on the
 current and the previous or the next line, as before.
 
-+++
 
 * Changes in Specialized Modes and Packages in Emacs 27.1
 
 ** compile.el
 ---
-*** In compilation-error-regexp-alist, 'line' (and 'end-line') can be functions
+*** In 'compilation-error-regexp-alist', 'line' (and 'end-line') can
+be functions.
 
-** cl-lib
+** cl-lib.el
 +++
-*** cl-defstruct has a new :noinline argument to prevent inlining its functions
+*** 'cl-defstruct' has a new ':noinline' argument to prevent inlining
+its functions.
 
-** doc-view-mode
-*** New commands doc-view-presentation and doc-view-fit-window-to-page
+** doc-view.el
+*** New commands 'doc-view-presentation' and 'doc-view-fit-window-to-page'.
 *** Added support for password-protected PDF files
 
+** Ido
+*** New user option 'ido-big-directories' to mark directories whose
+names match certain regular expressions as big.  Ido won't attempt to
+list the contents of such directories when completing file names.
+
+** Minibuffer
+
+---
+*** Minibuffer now uses 'minibuffer-message' to display error messages
+at the end of the active minibuffer.
+
 ** map.el
 *** Now also understands plists.
 *** Now defined via generic functions that can be extended via 'cl-defmethod'.
@@ -440,10 +515,10 @@ that display the next buffer in the window at the specified direction.
 This is like 'windmove-default-keybindings' that binds keys to commands
 that select the window in the specified direction, but additionally it
 displays the buffer from the next command in that window.  For example,
-'S-M-right C-h i' displays the *Info* buffer in the right window,
+'S-M-right C-h i' displays the "*Info*" buffer in the right window,
 creating the window if necessary.  A special key can be customized to
 display the buffer in the same window, for example, 'S-M-0 C-h e'
-displays the *Messages* buffer in the same window.
+displays the "*Messages*" buffer in the same window.
 
 *** Windmove also supports directional window deletion.
 The new command 'windmove-delete-default-keybindings' binds default
@@ -463,8 +538,11 @@ The mode is automatically enabled in files that start with the
 'function' keyword.
 
 ** project.el
+
 *** New commands 'project-search' and 'project-query-replace-regexp'.
 
+*** New customizable variable 'project-read-file-name-function'.
+
 ** Etags
 
 +++
@@ -508,7 +586,7 @@ With non-nil, 'vc-find-revision' doesn't write the created buffer to file.
 This new variable allows customizing the default arguments passed to
 'git-grep' when 'vc-git-grep' is used.
 
-*** Command 'vc-git-stash' now respects marks in the '*vc-dir*' buffer.
+*** Command 'vc-git-stash' now respects marks in the "*vc-dir*" buffer.
 When some files are marked, only those are stashed.
 When no files are marked, all modified files are stashed, as before.
 
@@ -526,7 +604,7 @@ values.
 and compares their entire trees.
 
 *** New user option 'vc-hg-revert-switches' specifies switches to pass
-to hg revert.
+to Hg revert.
 
 *** 'C-x v M D' ('vc-diff-mergebase') and 'C-x v M L' ('vc-log-mergebase')
 print diffs and logs between the merge base (common ancestor) of two
@@ -535,9 +613,10 @@ given revisions.
 ** Diff mode
 +++
 *** Hunks are now automatically refined by font-lock.
-To disable refinement, set the new defcustom 'diff-refine' to nil.
+To disable refinement, set the new user option 'diff-refine' to nil.
 To get back the old behavior where hunks are refined as you navigate
 through a diff, set 'diff-refine' to the symbol 'navigate'.
+
 +++
 *** 'diff-auto-refine-mode' is deprecated in favor of 'diff-refine'.
 It is no longer enabled by default and binding it no longer has any
@@ -550,7 +629,7 @@ according to the appropriate major mode.  Customize the new option
 'diff-font-lock-syntax' to nil to disable this.
 
 *** File headers can be shortened, mimicking Magit's diff format.
-To enable it, set the new defcustom 'diff-font-lock-prettify' to t.
+To enable it, set the new user option 'diff-font-lock-prettify' to t.
 
 +++
 *** Prefix arg of 'diff-goto-source' means jump to the old revision
@@ -560,11 +639,11 @@ or to the new revision of the file otherwise.
 ** Texinfo
 
 +++
-*** New function for inserting @pxref, @xref, or @ref commands.
+*** New function for inserting '@pxref', '@xref', or '@ref' commands.
 The function 'texinfo-insert-dwim-@ref', bound to 'C-c C-c r' by
 default, inserts one of three types of references based on the text
-surrounding point, namely @pxref near a parenthesis, @xref at the
-start of a sentence or at (point-min), else @ref.
+surrounding point, namely '@pxref' near a parenthesis, '@xref' at the
+start of a sentence or at '(point-min)', else '@ref'.
 
 ** Browse-url
 
@@ -598,7 +677,6 @@ end.
 ** SQL
 
 *** SQL Indent Minor Mode
-
 SQL Mode now supports the ELPA 'sql-indent' package for assisting
 sophisticated SQL indenting rules.  Note, however, that SQL is not
 like other programming languages like C, Java, or Python where code is
@@ -620,7 +698,6 @@ default values. If you have existing customizations to these variables,
 you should make sure that the new default entry is included.
 
 *** Connection Wallet
-
 Database passwords can now by stored in NETRC or JSON data files that
 may optionally be encrypted. When establishing an interactive session
 with the database via 'sql-connect' or a product specific function,
@@ -630,9 +707,9 @@ searched for the password. The 'sql-product', 'sql-server',
 appropriate authorization. This eliminates the discouraged practice of
 embedding database passwords in your Emacs initialization.
 
-See the `auth-source' module for complete documentation on the file
+See the 'auth-source' module for complete documentation on the file
 formats.  By default, the wallet file is expected to be in the
-`user-emacs-directory', named 'sql-wallet' or '.sql-wallet', with
+'user-emacs-directory', named 'sql-wallet' or '.sql-wallet', with
 '.json' (JSON) or no (NETRC) suffix.  Both file formats can optionally
 be encrypted with GPG by adding an additional '.gpg' suffix.
 
@@ -655,6 +732,10 @@ Control whether Flymake starts checking the buffer on save.
 This enables more efficient backends.  See the docstring of
 'flymake-diagnostic-functions' or the Flymake manual for details.
 
++++
+*** 'flymake-start-syntax-check-on-newline' is now obsolete,
+use 'post-self-insert-hook' to check on newline.
+
 ** Ruby
 
 *** The Rubocop Flymake diagnostic function will only run Lint cops if
@@ -662,18 +743,27 @@ it can't find the config file.
 
 *** Rubocop is called with 'bundle exec' if Gemfile mentions it.
 
+*** New command 'ruby-find-library-file' bound to 'C-c C-f'.
+
 ** Package
 
+*** Change of 'package-check-signature' for packages with multiple sigs
+In previous Emacsen, 't' checked that all signatures are valid.
+Now 't' only checks that at least one signature is valid and the new 'all'
+value needs to be used if you want to enforce that all signatures
+are valid.  This only affects packages with multiple signatures.
+
 *** New function 'package-get-version' lets packages query their own version.
 Example use in auctex.el: '(defconst auctex-version (package-get-version))'
 
 *** New 'package-quickstart' feature.
-When 'package-quickstart' is non-nil, package.el precomputes a big autoloads
-file so that activation of packages can be done much faster, which can speed up
-your startup significantly.
-It also causes variables like 'package-user-dir' and 'package-load-list' to be
-consulted when 'package-quickstart-refresh' is run rather than at startup so
-you don't need to set them in your early init file.
+When 'package-quickstart' is non-nil, package.el precomputes a big
+autoloads file so that activation of packages can be done much faster,
+which can speed up your startup significantly.
+It also causes variables like 'package-user-dir' and
+'package-load-list' to be consulted when 'package-quickstart-refresh'
+is run rather than at startup so you don't need to set them in your
+early init file.
 
 *** New function 'package-activate-all'.
 
@@ -699,16 +789,33 @@ Previously, setting 'xref-marker-ring-length' would only take effect
 if set before 'xref.el' was loaded.
 
 ---
-*** xref-find-definitions now sets the mark at the buffer position
-where it was invoked
+*** 'xref-find-definitions' now sets the mark at the buffer position
+where it was invoked.
+
+---
+*** New xref faces 'xref-file-header', 'xref-line-number', 'xref-match'.
+
+*** New variable 'xref-show-definitions-function'.
+It encapsulates the logic pertinent to showing the result of
+'xref-find-definitions'.  The user can change it to customize its
+behavior and the display of results.
+
+*** Search results show the buffer even for one hit.
+The search-type Xref commands (e.g. 'xref-find-references' or
+'project-find-regexp') now show the results buffer even when there is
+only one hit.  This can be altered by changing
+'xref-show-xrefs-function'.
+
+*** Xref buffers support refreshing the search results.
+A new command 'xref-revert-buffer' is bound to 'g'.
 
 ** Ecomplete
 
 *** The ecomplete sorting has changed to a decay-based algorithm.
 This can be controlled by the new 'ecomplete-sort-predicate' variable.
 
-*** The 'ecompleterc' file is now placed in ~/.emacs.d/ecompleterc by default.
-Of course it will still find it if you have it in ~/.ecompleterc
+*** The 'ecompleterc' file is now placed in '~/.emacs.d/ecompleterc' by default.
+Of course it will still find it if you have it in '~/.ecompleterc'.
 
 ** Gnus
 
@@ -755,7 +862,7 @@ This option controls whether and how to use Gnus search groups as
 ** erc
 
 ---
-*** 'erc-button-google-url' has been renamed 'erc-button-search-url'
+*** 'erc-button-google-url' has been renamed to 'erc-button-search-url'
 and its value has been changed to Duck Duck Go.
 
 ** EUDC
@@ -847,7 +954,7 @@ directories in the destination.
 ** Help
 
 ---
-*** Description of variables and functions give an estimated first release
+*** Description of variables and functions give an estimated first release.
 
 ---
 *** Output format of 'C-h l' ('view-lossage') has changed.
@@ -926,7 +1033,7 @@ and case-sensitivity together with search strings in the search ring.
 *** Isearch now has its own tool-bar and menu-bar menu.
 
 +++
-*** flush-lines prints and returns the number of deleted matching lines.
+*** 'flush-lines' prints and returns the number of deleted matching lines.
 
 ** Debugger
 
@@ -969,7 +1076,7 @@ by default.
 ** Grep
 
 +++
-*** rgrep, lgrep and zrgrep now hide part of the command line
+*** 'rgrep', 'lgrep' and 'zrgrep' now hide part of the command line
 that contains a list of ignored directories and files.
 Clicking on the button with ellipsis unhides it.
 The abbreviation can be disabled by the new option
@@ -1028,10 +1135,10 @@ default, and not just the opening element.
 
 ** Eshell
 
-*** TAB completion uses the standard completion-at-point rather than pcomplete
-Its UI is slightly different but can be customized to behave similarly,
-e.g. Pcomplete's default cycling can be obtained with
-(setq completion-cycle-threshold 5).
+*** TAB completion uses the standard 'completion-at-point' rather than
+'pcomplete'.  Its UI is slightly different but can be customized to
+behave similarly, e.g. Pcomplete's default cycling can be obtained
+with '(setq completion-cycle-threshold 5)'.
 
 ---
 *** Expansion of history event designators is disabled by default.
@@ -1064,6 +1171,12 @@ followed when Emacs writes the relevant history variables to the disk.
 *** The variable 'shell-file-name' can be set now as connection-local
 variable for remote shells.  It still defaults to "/bin/sh".
 
+** Single shell commands
+
++++
+*** 'async-shell-command-width' defines the number of display columns
+available for output of asynchronous shell commands.
+
 ** Pcomplete
 
 *** The function 'pcomplete-uniquify-list' has been renamed from
@@ -1123,7 +1236,13 @@ security reasons.
 Setting this option to an integer causes URLs displayed in Rcirc
 buffers to be truncated to that many characters.
 
+---
+*** The default /quit and /part reasons are now configurable.
+Two new user options are provided for this:
+'rcirc-default-part-reason' and 'rcirc-default-quit-reason'.
+
 ** Register
+
 ---
 *** The return value of method 'register-val-describe' includes the
 names of buffers shown by the windows of a window configuration.
@@ -1205,11 +1324,18 @@ automatically updates.  In the buffer, you can use 's q' or 's e' to
 signal a thread with quit or error respectively, or get a snapshot
 backtrace with 'b'.
 
+
+** thingatpt.el
+
 ---
-** thingatpt.el supports a new "thing" called 'uuid'.
+*** 'thing-at-point' supports a new "thing" called 'uuid'.
 A symbol 'uuid' can be passed to 'thing-at-point' and it returns the
 UUID at point.
 
+---
+*** 'word-at-point' and 'sentence-at-point' accept NO-PROPERTIES.
+Just like 'thing-at-point' itself.
+
 ** Interactive automatic highlighting
 
 +++
@@ -1232,6 +1358,12 @@ when given in a string.  Previously, '(any "\x80-\xff")' would match
 characters U+0080...U+00FF.  Now the expression matches raw bytes in
 the 128...255 range, as expected.
 
+*** The rx 'or' and 'seq' forms no longer require any arguments.
+(or) produces a regexp that never matches anything, while (seq)
+matches the empty string, each being an identity for the operation.
+This also works for their aliases: '|' for 'or'; ':', 'and' and
+'sequence' for 'seq'.
+
 ** Frames
 
 +++
@@ -1246,7 +1378,7 @@ frame when making a frame.
 *** New predicates 'display-blink-cursor-p' and 'display-symbol-keys-p'.
 These predicates are to be preferred over 'display-graphic-p' when
 testing for blinking cursor capability and the capability to have
-symbols (e.g., [return], [tab], [backspace]) as keys respectively.
+symbols (e.g., '[return]', '[tab]', '[backspace]') as keys respectively.
 
 ** Tabulated List mode
 
@@ -1267,8 +1399,8 @@ near the current column in Tabulated Lists (see variables
 ** CUA mode
 
 ---
-*** New defcustom 'cua-rectangle-terminal-modifier-key'.
-This defcustom allows for the customization of the modifier key used
+*** New user option 'cua-rectangle-terminal-modifier-key'.
+This user option allows for the customization of the modifier key used
 in a terminal frame.
 
 ** JS mode
@@ -1281,11 +1413,11 @@ will be supported in 'js-mode' and derivative modes.  ('js-jsx-mode'
 no longer needs to be enabled.)
 
 ---
-*** New defcustom 'js-jsx-detect-syntax' disables automatic detection.
+*** New user option 'js-jsx-detect-syntax' disables automatic detection.
 This is turned on by default.
 
 ---
-*** New defcustom 'js-jsx-syntax' enables JSX syntax unconditionally.
+*** New user option 'js-jsx-syntax' enables JSX syntax unconditionally.
 This is off by default.
 
 ---
@@ -1305,7 +1437,7 @@ of the React developer community (see 'js-jsx-align->-with-<'),
 otherwise still adhering to SGML conventions.
 
 ---
-*** New defcustom 'js-jsx-align->-with-<' controls '>' indents.
+*** New user option 'js-jsx-align->-with-<' controls '>' indents.
 Commonly in JSX code, a '>' on its own line is indented at the same
 level as its opening '<'.  This is the new default for JSX.  This
 behavior is slightly different than that used by SGML in Emacs, where
@@ -1328,12 +1460,12 @@ The old behavior can be emulated by controlling JSX indentation
 independently of JS, by setting 'js-jsx-indent-level'.
 
 ---
-*** New defcustom 'js-jsx-indent-level' for different JSX indentation.
+*** New user option 'js-jsx-indent-level' for different JSX indentation.
 If you wish to indent JSX by a different number of spaces than JS, set
-this variable to the desired number.
+this user option to the desired number.
 
 ---
-*** New defcustom 'js-jsx-attribute-offset' for JSX attribute indents.
+*** New user option 'js-jsx-attribute-offset' for JSX attribute indents.
 
 ---
 *** New variable 'js-syntactic-mode-name' controls mode name display.
@@ -1347,6 +1479,22 @@ Packages deriving from 'js-mode' with 'define-derived-mode' should
 call this function to add enabled syntax extensions to their mode
 name, too.
 
+** Autorevert
+
+*** New variable 'auto-revert-avoid-polling' for saving power.
+When set to a non-nil value, buffers in Auto Revert mode are no longer
+polled for changes periodically.  This reduces the power consumption
+of an idle Emacs, but may fail on some network file systems; set
+'auto-revert-notify-exclude-dir-regexp' to match files where
+notification is not supported.  The default value is nil.
+
+*** New variable 'buffer-auto-revert-by-notification'
+A major mode can declare that notification on the buffer's default
+directory is sufficient to know when updates are required, by setting
+the new variable 'buffer-auto-revert-by-notification' to a non-nil
+value.  Auto Revert mode can use this information to avoid polling the
+buffer periodically when 'auto-revert-avoid-polling' is non-nil.
+
 
 * New Modes and Packages in Emacs 27.1
 
@@ -1377,8 +1525,15 @@ documentation of the new mode and its commands.
 
 * Incompatible Lisp Changes in Emacs 27.1
 
-** In compilation-error-regexp-alist the old undocumented feature where 'line'
-could be a function of 2 arguments has been dropped.
++++
+** add-hook does not always add to the front or the end any more.
+The replacement of `append` with `depth` implies that the function is not
+always added to the very front (when append/depth is nil) or the very end (when
+append/depth is t) any more because other functions on the hook may have
+specified higher/lower depths.
+
+** In 'compilation-error-regexp-alist' the old undocumented feature
+where 'line' could be a function of 2 arguments has been dropped.
 
 ** 'define-fringe-bitmap' is always defined, even when Emacs is built
 without any GUI support.
@@ -1401,11 +1556,11 @@ its default value changed in Emacs 27.1.
 
 ** The REPETITIONS argument of 'benchmark-run' can now also be a variable.
 
-** Interpretation of relative HOME directory has changed.
-If $HOME is set to a relative file name, 'expand-file-name' now
+** Interpretation of relative 'HOME' directory has changed.
+If "$HOME" is set to a relative file name, 'expand-file-name' now
 interprets it relative to the directory where Emacs was started, not
 relative to the 'default-directory' of the current buffer.  We recommend
-always setting $HOME to an absolute file name, so that its meaning is
+always setting "$HOME" to an absolute file name, so that its meaning is
 independent of where Emacs was started.
 
 ** The FILENAME argument to 'file-name-base' is now mandatory and no
@@ -1431,7 +1586,7 @@ old-style backquotes as new-style, bind the new variable
 integer, Emacs now signals an error if the number is too large for the
 implementation to format.
 
-** logb now returns infinity when given an infinite or zero argument,
+** 'logb' now returns infinity when given an infinite or zero argument,
 and returns a NaN when given a NaN.  Formerly, it returned an extreme
 fixnum for such arguments.
 
@@ -1482,11 +1637,11 @@ they are now allocated like any other pseudovector.  As a result, the
 removed.
 
 +++
-** Reversed character ranges are no longer permitted in rx.
+** Reversed character ranges are no longer permitted in 'rx'.
 Previously, ranges where the starting character is greater than the
 ending character were silently omitted.
 For example, '(rx (any "@z-a" (?9 . ?0)))' would match '@' only.
-Now, such rx expressions generate an error.
+Now, such 'rx' expressions generate an error.
 
 +++
 ** 'text-mode' no longer sets the value of 'indent-line-function'.
@@ -1495,13 +1650,27 @@ The global value of 'indent-line-function', which defaults to
 'text-mode'.
 
 To get back the old behavior, add a function to 'text-mode-hook' which
-performs (setq-local indent-line-function #'indent-relative).
+performs '(setq-local indent-line-function #'indent-relative)'.
+
+** 'make-process' no longer accepts a non-nil ':stop' key.  This has
+never worked reliably, and now causes an error.
+
++++
+** 'eventp' no longer returns non-nil for lists whose car is nil.
+This is consistent with the fact that nil, though a symbol, is not a
+valid event type.
 
 
 * Lisp Changes in Emacs 27.1
 
++++
+** The 'append' arg of 'add-hook' is generalized to a finer notion of 'depth'
+This makes it possible to control the ordering of functions more precisely,
+as was already possible in 'add-function' and `advice-add`.
+
+---
 ** New 'help-fns-describe-variable-functions' hook.
-Makes it possible to add metadata information to describe-variable.
+Makes it possible to add metadata information to 'describe-variable'.
 
 ** i18n (internationalization)
 
@@ -1509,7 +1678,7 @@ Makes it possible to add metadata information to describe-variable.
 according to the given numeric value.
 
 +++
-** inhibit-null-byte-detection is renamed to inhibit-nul-byte-detection
+** 'inhibit-null-byte-detection' is renamed to 'inhibit-nul-byte-detection'.
 
 +++
 ** 'self-insert-command' takes the char to insert as (optional) argument.
@@ -1553,8 +1722,10 @@ like 'file-attributes' that compute file sizes and other attributes,
 functions like 'process-id' that compute process IDs, and functions like
 'user-uid' and 'group-gid' that compute user and group IDs.
 
+** Time values
+
 +++
-** Although the default timestamp format is still (HI LO US PS),
+*** Although the default timestamp format is still '(HI LO US PS)',
 it is planned to change in a future Emacs version, to exploit bignums.
 The documentation has been updated to mention that the timestamp
 format may change and that programs should use functions like
@@ -1563,22 +1734,22 @@ probing the innards of a timestamp directly, or creating a timestamp
 by hand.
 
 +++
-** 'encode-time' supports a new API '(encode-time TIME &optional FORM)'.
+*** 'encode-time' supports a new API '(encode-time TIME &optional FORM)'.
 This can convert decoded times and Lisp time values to Lisp timestamps
 of various forms, including a new timestamp form '(TICKS . HZ)', where
 TICKS is an integer and HZ is a positive integer denoting a clock
 frequency.  The old 'encode-time' API is still supported.
 
 +++
-** 'time-add', 'time-subtract', and 'time-less-p' now accept
+*** 'time-add', 'time-subtract', and 'time-less-p' now accept
 infinities and NaNs too, and propagate them or return nil like
 floating-point operators do.
 
 +++
-** New function 'time-equal-p' compares time values for equality.
+*** New function 'time-equal-p' compares time values for equality.
 
 +++
-** 'format-time-string' supports a new conversion specifier flag '+'
+*** 'format-time-string' supports a new conversion specifier flag '+'
 that acts like the '0' flag but also puts a '+' before nonnegative
 years containing more than four digits.  This is for compatibility
 with POSIX.1-2017.
@@ -1631,7 +1802,6 @@ of the Emacs Lisp Reference manual for more detail.
 
 +++
 ** Window change functions have been redesigned.
-
 Hooks reacting to window changes run now only when redisplay detects
 that a change has actually occurred.  Six hooks are now provided:
 'window-buffer-change-functions' (run after window buffers have
@@ -1659,10 +1829,15 @@ See the section "(elisp) Window Hooks" in the Elisp manual for a
 detailed explanation of the new behavior.
 
 +++
-*** New option 'resize-mini-frames'.
+** New option 'resize-mini-frames'.
 This option allows to automatically resize minibuffer-only frames
 similarly to how minibuffer windows are resized on "normal" frames.
 
++++
+** New buffer display action function 'display-buffer-in-direction'.
+This function allows to specify the location of the window chosen by
+'display-buffer' in various ways.
+
 +++
 ** New buffer display action alist entry 'dedicated'.
 Such an entry allows to specify the dedicated status of a window
@@ -1674,6 +1849,16 @@ Such an entry allows to specify a minimum height of the window used
 for displaying a buffer.  'display-buffer-below-selected' is the only
 action function to respect it at the moment.
 
++++
+** New buffer display action alist entry 'direction'.
+This entry is used to specify the location of the window chosen by
+'display-buffer-in-direction'.
+
++++
+** Additional meaning of display action alist entry 'window'.
+A 'window' entry can now also specify a reference window for
+'display-buffer-in-direction'.
+
 +++
 ** The function 'assoc-delete-all' now takes an optional predicate argument.
 
@@ -1690,7 +1875,7 @@ This avoids problems in calls like '(read (format "#x%x" -1))', and is
 more compatible with bignums.  To get the traditional machine-dependent
 behavior, set the experimental variable 'binary-as-unsigned' to t,
 and if the new behavior breaks your code please email
-32252@debbugs.gnu.org.  Because '%o' and '%x' can now format signed
+<32252@debbugs.gnu.org>.  Because '%o' and '%x' can now format signed
 integers, they now support the '+' and space flags.
 
 ** To avoid confusion caused by "smart quotes", the reader signals an
@@ -1819,16 +2004,31 @@ some years back.  It now respects 'imagemagick-types-inhibit' as a way
 to disable that.
 
 ---
-*** Some image-mode variables are now buffer-local.
+*** Some 'image-mode' variables are now buffer-local.
 The image parameters 'image-transform-rotation',
 'image-transform-scale' and 'image-transform-resize' are now declared
 buffer-local, so each buffer could have its own values for these
 parameters.
 
-** The function 'load' now behaves correctly when loading modules.
+** Modules
+
+*** The function 'load' now behaves correctly when loading modules.
 Specifically, it puts the module name into 'load-history', prints
 loading messages if requested, and protects against recursive loads.
 
+*** New module environment function 'process_input' to process user
+input while module code is running.
+
+*** New module environment functions 'make_time' and 'extract_time' to
+convert between timespec structures and Emacs Lisp time values.
+
+*** New module environment functions 'make_big_integer' and
+'extract_big_integer' to create and extract arbitrary-size integer
+values.
+
+*** emacs-module.h now defines a macro 'EMACS_MAJOR_VERSION' that expands
+to the major version of the latest Emacs supported by the header.
+
 +++
 ** The function 'read-variable' now uses its own history list.
 The history of variable names read by 'read-variable' is recorded in
@@ -1851,23 +2051,20 @@ buffer's 'default-directory' and invoke that file name handler to make
 the process.  That way 'make-process' can start remote processes.
 
 +++
-** Emacs now supports resizing (scaling) of images without ImageMagick.
+** Emacs now supports resizing and rotating images without ImageMagick.
 All modern systems are supported by this feature.  (On GNU and Unix
 systems, Cairo drawing or the XRender extension to X11 is required for
 this to be available; the configure script will test for it and, if
 found, enable scaling.)
 
-The new function 'image-scaling-p' can be used to test whether any
-given frame supports resizing.
+The new function 'image-transforms-p' can be used to test whether any
+given frame supports this capability.
 
 +++
-** (locale-info 'paper) now returns the paper size on systems that support it.
+** '(locale-info 'paper)' now returns the paper size on systems that support it.
 This is currently supported on GNUish hosts and on modern versions of
 MS-Windows.
 
-** New module environment function 'process_input' to process user
-input while module code is running.
-
 +++
 ** The function 'regexp-opt' accepts an additional optional argument.
 By default, the regexp returned by 'regexp-opt' may match the strings
@@ -1881,6 +2078,10 @@ returns a regexp that never matches anything, which is an identity for
 this operation.  Previously, the empty string was returned in this
 case.
 
+** New constant 'regexp-unmatchable' contains a never-matching regexp.
+It is a convenient and readable way to specify a regexp that should
+not match anything, and is as fast as any such regexp can be.
+
 
 * Changes in Emacs 27.1 on Non-Free Operating Systems
 
@@ -1928,6 +2129,9 @@ modifier keys in line with Apples guidelines.  This makes the drag and
 drop behaviour more consistent, as previously the sending application
 was able to 'set' modifiers without the knowledge of the user.
 
+** On NS multicolor font display is enabled again since it is also
+implemented in Emacs on free operating systems via Cairo drawing.
+
 
 ----------------------------------------------------------------------
 This file is part of GNU Emacs.
diff --git a/etc/NEWS.24 b/etc/NEWS.24
index 9150e49fd9..049005306f 100644
--- a/etc/NEWS.24
+++ b/etc/NEWS.24
@@ -1117,6 +1117,8 @@ a non-nil `interactive-only' property.
 The value, if non-nil, is a regexp that specifies what to trim from
 the start and end of each substring.
 
+** New function `delete-consecutive-dups'.
+
 ** Completion
 
 *** The separator used by `completing-read-multiple' is now a regexp.
diff --git a/etc/NEWS.26 b/etc/NEWS.26
index f570f759b9..aa583f47c6 100644
--- a/etc/NEWS.26
+++ b/etc/NEWS.26
@@ -16,6 +16,33 @@ You can narrow news to a specific version by calling 'view-emacs-news'
 with a prefix argument or by typing 'C-u C-h C-n'.
 
 
+* Installation Changes in Emacs 26.3
+
+
+* Startup Changes in Emacs 26.3
+
+
+* Changes in Emacs 26.3
+
+
+* Editing Changes in Emacs 26.3
+
+
+* Changes in Specialized Modes and Packages in Emacs 26.3
+
+
+* New Modes and Packages in Emacs 26.3
+
+
+* Incompatible Lisp Changes in Emacs 26.3
+
+
+* Lisp Changes in Emacs 26.3
+
+
+* Changes in Emacs 26.3 on Non-Free Operating Systems
+
+
 * Installation Changes in Emacs 26.2
 
 ** Building Emacs with the '--with-xwidgets' option now requires WebKit2.
@@ -30,9 +57,6 @@ directory as part of the Emacs installation.  This allows to build
 Emacs modules outside of the Emacs source tree.
 
 
-* Startup Changes in Emacs 26.2
-
-
 * Changes in Emacs 26.2
 
 ** Emacs is now compliant with the latest version 11.0 of the Unicode Standard.
@@ -42,9 +66,6 @@ Default t means don't try to load color fonts when using Xft, as they
 often cause crashes.  Set it to nil if you really need those fonts.
 
 
-* Editing Changes in Emacs 26.2
-
-
 * Changes in Specialized Modes and Packages in Emacs 26.2
 
 ** Dired
@@ -116,9 +137,6 @@ hash value.  To get back the previous behavior, customize the new
 option 'vc-hg-symbolic-revision-styles' to the value '("{rev}")'.
 
 
-* New Modes and Packages in Emacs 26.2
-
-
 * Incompatible Lisp Changes in Emacs 26.2
 
 ** shadowfile config files have changed their syntax.
diff --git a/etc/TODO b/etc/TODO
index ccb82cd296..fe2e583a38 100644
--- a/etc/TODO
+++ b/etc/TODO
@@ -143,15 +143,6 @@ See the 'test' directory for examples.
 
 * Small but important fixes needed in existing features:
 
-** Flymake's customization mechanism needs to be both simpler (fewer
-levels of indirection) and better documented, so it is easier to
-understand.  I find it quite hard to figure out what compilation
-command it will use.
-
-I suggest totally rewriting that part of Flymake, using the simplest
-mechanism that suffices for the specific needs.  That will be easy
-for users to customize.
-
 ** Distribute a bar cursor of width > 1 evenly between the two glyphs
    on each side of the bar (what to do at the edges?).
 
@@ -211,7 +202,6 @@ https://lists.gnu.org/r/emacs-devel/2007-04/msg00684.html
 Change them to use report-emacs-bug.
 *** Related functions:
 **** gnus-bug
-**** report-calc-bug
 **** org-submit-bug-report
 **** lm-report-bug
 **** tramp-bug
diff --git a/etc/edt-user.el b/etc/edt-user.el
index 5aede6bfd8..10ea4c458b 100644
--- a/etc/edt-user.el
+++ b/etc/edt-user.el
@@ -4,7 +4,6 @@
 ;; Inc.
 
 ;; Author: Kevin Gallagher <kevin.gal@verizon.net>
-;; Maintainer: Kevin Gallagher <kevin.gal@verizon.net>
 ;; Keywords: emulations
 
 ;; This file is part of GNU Emacs.
diff --git a/etc/package-keyring.gpg b/etc/package-keyring.gpg
index e76e68522f..490dee41a9 100644
Binary files a/etc/package-keyring.gpg and b/etc/package-keyring.gpg differ
diff --git a/etc/refcards/Makefile b/etc/refcards/Makefile
index 469e8fa05c..0ba6db5aa2 100644
--- a/etc/refcards/Makefile
+++ b/etc/refcards/Makefile
@@ -40,7 +40,7 @@ PDF_CZECH = \
 PDF_FRENCH = \
 	fr-dired-ref.pdf \
 	fr-refcard.pdf \
-	fr-survival.pdf \
+	fr-survival.pdf
 
 PDF_GERMAN = de-refcard.pdf
 
diff --git a/etc/refcards/calccard.tex b/etc/refcards/calccard.tex
index 2b85536886..7e28f83057 100644
--- a/etc/refcards/calccard.tex
+++ b/etc/refcards/calccard.tex
@@ -58,14 +58,10 @@
 % Which mode to use is controlled by setting \columnsperpage above.
 %
 % Author (Calc reference card):
-%  Dave Gillespie
-%  UUCP: uunet!synaptx!daveg
-%  Internet: daveg@synaptics.com
+%  Dave Gillespie <daveg@synaptics.com>
 %
 % Author (refcard.tex format):
-%  Stephen Gildea
-%  UUCP: mit-erl!gildea
-%  Internet: gildea@stop.mail-abuse.org
+%  Stephen Gildea <stepheng+emacs@gildea.com>
 
 \input emacsver.tex
 
diff --git a/etc/refcards/cs-refcard.tex b/etc/refcards/cs-refcard.tex
index ca7d833320..ec9e9a9edf 100644
--- a/etc/refcards/cs-refcard.tex
+++ b/etc/refcards/cs-refcard.tex
@@ -3,7 +3,7 @@
 % Copyright (C) 1987, 1993, 1996-1997, 2001-2019 Free Software
 % Foundation, Inc.
 
-% Author: Stephen Gildea <gildea@stop.mail-abuse.org>
+% Author: Stephen Gildea <stepheng+emacs@gildea.com>
 % Czech translation: Jan Buchal <buchal@brailcom.cz>, January 1999
 % 	Milan Zamazal <pdm@zamazal.org>, August 1999
 %	Pavel Janík <Pavel@Janik.cz>, November 2000 (Emacs 21)
diff --git a/etc/refcards/cs-survival.tex b/etc/refcards/cs-survival.tex
index b91c9c927c..bdc35cd20e 100644
--- a/etc/refcards/cs-survival.tex
+++ b/etc/refcards/cs-survival.tex
@@ -2,7 +2,7 @@
 
 % Copyright (C) 2000-2019 Free Software Foundation, Inc.
 
-% Author: Wlodek Bzyl <matwb@univ.gda.pl>
+% Author: Włodek Bzyl <matwb@univ.gda.pl>
 % Czech translation: Pavel Janík <Pavel@Janik.cz>, March 2001
 
 % This document is free software: you can redistribute it and/or modify
diff --git a/etc/refcards/de-refcard.tex b/etc/refcards/de-refcard.tex
index 06b6efe37d..5c8127d073 100644
--- a/etc/refcards/de-refcard.tex
+++ b/etc/refcards/de-refcard.tex
@@ -3,7 +3,7 @@
 % Copyright (C) 1987, 1993, 1996, 2000-2019 Free Software Foundation,
 % Inc.
 
-% Author: Stephen Gildea <gildea@stop.mail-abuse.org>
+% Author: Stephen Gildea <stepheng+emacs@gildea.com>
 % German translation: Sven Joachim <svenjoac@gmx.de>
 
 % This document is free software: you can redistribute it and/or modify
diff --git a/etc/refcards/fr-refcard.tex b/etc/refcards/fr-refcard.tex
index 0ebf791cd8..467c71a86f 100644
--- a/etc/refcards/fr-refcard.tex
+++ b/etc/refcards/fr-refcard.tex
@@ -3,7 +3,7 @@
 % Copyright (C) 1987, 1993, 1996-1997, 2001-2019 Free Software
 % Foundation, Inc.
 
-% Author: Stephen Gildea <gildea@stop.mail-abuse.org>
+% Author: Stephen Gildea <stepheng+emacs@gildea.com>
 % French translation: Eric Jacoboni
 %	Micha\"el Cadilhac
 
diff --git a/etc/refcards/fr-survival.tex b/etc/refcards/fr-survival.tex
index 20755497ff..f0bbc11f12 100644
--- a/etc/refcards/fr-survival.tex
+++ b/etc/refcards/fr-survival.tex
@@ -3,7 +3,7 @@
 
 % Copyright (C) 2000-2019 Free Software Foundation, Inc.
 
-% Author: Wlodek Bzyl <matwb@univ.gda.pl>
+% Author: Włodek Bzyl <matwb@univ.gda.pl>
 % French translation:  \'Eric Jacoboni <jaco@teaser.fr>, November 2001
 
 % This document is free software: you can redistribute it and/or modify
diff --git a/etc/refcards/orgcard.tex b/etc/refcards/orgcard.tex
index ae4e26c286..4a51fe01c5 100644
--- a/etc/refcards/orgcard.tex
+++ b/etc/refcards/orgcard.tex
@@ -60,8 +60,7 @@
 % dvips -t landscape refcard.dvi
 %
 % Author:
-%  Stephen Gildea
-%  Internet: gildea@stop.mail-abuse.org
+%  Stephen Gildea <stepheng+emacs@gildea.com>
 %
 % Thanks to Paul Rubin, Bob Chassell, Len Tower, and Richard Mlynarik
 % for their many good ideas.
diff --git a/etc/refcards/pl-refcard.tex b/etc/refcards/pl-refcard.tex
index 578a8f6251..54b6a10e4b 100644
--- a/etc/refcards/pl-refcard.tex
+++ b/etc/refcards/pl-refcard.tex
@@ -3,8 +3,8 @@
 
 % Copyright (C) 1999, 2001-2019 Free Software Foundation, Inc.
 
-% Author: Stephen Gildea <gildea@stop.mail-abuse.org>
-% Polish translation: W{\l}odek Bzyl <matwb@univ.gda.pl>
+% Author: Stephen Gildea <stepheng+emacs@gildea.com>
+% Polish translation: Włodek Bzyl <matwb@univ.gda.pl>
 
 % This document is free software: you can redistribute it and/or modify
 % it under the terms of the GNU General Public License as published by
@@ -38,7 +38,7 @@
 %    You will still need to cut and paste.
 % Which mode to use is controlled by setting \columnsperpage.
 
-% Translated into Polish language by W{\l}odek Bzyl (matwb@univ.gda.pl)
+% Translated into Polish language by Włodek Bzyl <matwb@univ.gda.pl>
 % who also added new section on `Dired' and added info about Polish
 % support in Emacs to section `International Character Sets'.
 
diff --git a/etc/refcards/pt-br-refcard.tex b/etc/refcards/pt-br-refcard.tex
index 04ce77d032..b7840621ee 100644
--- a/etc/refcards/pt-br-refcard.tex
+++ b/etc/refcards/pt-br-refcard.tex
@@ -3,7 +3,7 @@
 % Copyright (C) 1987, 1993, 1996-1997, 2002-2004, 2006-2019 Free
 % Software Foundation, Inc.
 
-% Author: Stephen Gildea <gildea@stop.mail-abuse.org>
+% Author: Stephen Gildea <stepheng+emacs@gildea.com>
 % Portuguese translation: Rodrigo Real <rreal@ucpel.tche.br>
 
 % This document is free software: you can redistribute it and/or modify
diff --git a/etc/refcards/refcard.tex b/etc/refcards/refcard.tex
index 5089133e95..d03e6654f0 100644
--- a/etc/refcards/refcard.tex
+++ b/etc/refcards/refcard.tex
@@ -3,7 +3,7 @@
 % Copyright (C) 1987, 1993, 1996-1997, 2001-2019 Free Software
 % Foundation, Inc.
 
-% Author: Stephen Gildea <gildea@stop.mail-abuse.org>
+% Author: Stephen Gildea <stepheng+emacs@gildea.com>
 
 % This document is free software: you can redistribute it and/or modify
 % it under the terms of the GNU General Public License as published by
diff --git a/etc/refcards/ru-refcard.tex b/etc/refcards/ru-refcard.tex
index 43c18d58e2..59741f31eb 100644
--- a/etc/refcards/ru-refcard.tex
+++ b/etc/refcards/ru-refcard.tex
@@ -1,6 +1,6 @@
 % Copyright (C) 1997, 2002-2019 Free Software Foundation, Inc.
 
-% Author: Stephen Gildea <gildea@stop.mail-abuse.org>
+% Author: Stephen Gildea <stepheng+emacs@gildea.com>
 % Russian translation: Alex Ott <alexott@gmail.com>
 
 % This document is free software: you can redistribute it and/or modify
diff --git a/etc/refcards/sk-refcard.tex b/etc/refcards/sk-refcard.tex
index 823913affc..7ec1598334 100644
--- a/etc/refcards/sk-refcard.tex
+++ b/etc/refcards/sk-refcard.tex
@@ -3,7 +3,7 @@
 % Copyright (C) 1987, 1993, 1996-1997, 2001-2019 Free Software
 % Foundation, Inc.
 
-% Author: Stephen Gildea <gildea@stop.mail-abuse.org>
+% Author: Stephen Gildea <stepheng+emacs@gildea.com>
 % Czech translation: Jan Buchal <buchal@brailcom.cz>, January 1999
 % 	Milan Zamazal <pdm@zamazal.org>, August 1999
 %	Pavel Janík <Pavel@Janik.cz>, November 2000 (Emacs 21)
diff --git a/etc/refcards/sk-survival.tex b/etc/refcards/sk-survival.tex
index b63a618b06..80eb2aee08 100644
--- a/etc/refcards/sk-survival.tex
+++ b/etc/refcards/sk-survival.tex
@@ -2,7 +2,7 @@
 
 % Copyright (C) 2000-2019 Free Software Foundation, Inc.
 
-% Author: Wlodek Bzyl <matwb@univ.gda.pl>
+% Author: Włodek Bzyl <matwb@univ.gda.pl>
 % Czech translation: Pavel Janík <Pavel@Janik.cz>, March 2001
 % Slovak translation: Miroslav Vasko <vasko@debian.cz>, March 2001
 
diff --git a/etc/refcards/survival.tex b/etc/refcards/survival.tex
index 5dbe788ee6..b25c9af76b 100644
--- a/etc/refcards/survival.tex
+++ b/etc/refcards/survival.tex
@@ -3,7 +3,7 @@
 
 % Copyright (C) 2000-2019 Free Software Foundation, Inc.
 
-% Author: Wlodek Bzyl <matwb@univ.gda.pl>
+% Author: Włodek Bzyl <matwb@univ.gda.pl>
 
 % This document is free software: you can redistribute it and/or modify
 % it under the terms of the GNU General Public License as published by
diff --git a/etc/refcards/viperCard.tex b/etc/refcards/viperCard.tex
index fb116d41f9..00d9e3b7f5 100644
--- a/etc/refcards/viperCard.tex
+++ b/etc/refcards/viperCard.tex
@@ -2,7 +2,7 @@
 
 % Copyright (C) 1995-1997, 2001-2019 Free Software Foundation, Inc.
 
-% Author: Michael Kifer <kifer@cs.sunysb.edu> (Viper)
+% Author: Michael Kifer <kifer@cs.stonybrook.edu> (Viper)
 %	Aamod Sane <sane@cs.uiuc.edu> (VIP 4.3)
 %	Masahiko Sato <ms@sail.stanford.edu> (VIP 3.5)
 
diff --git a/etc/srecode/c.srt b/etc/srecode/c.srt
index d1710c9bb8..58b931b520 100644
--- a/etc/srecode/c.srt
+++ b/etc/srecode/c.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2010, 2012-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/cpp.srt b/etc/srecode/cpp.srt
index 79b62b3458..bac247c701 100644
--- a/etc/srecode/cpp.srt
+++ b/etc/srecode/cpp.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/default.srt b/etc/srecode/default.srt
index 693cc9504c..c896326c80 100644
--- a/etc/srecode/default.srt
+++ b/etc/srecode/default.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/doc-cpp.srt b/etc/srecode/doc-cpp.srt
index f7a0af65cf..15c5c19536 100644
--- a/etc/srecode/doc-cpp.srt
+++ b/etc/srecode/doc-cpp.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/doc-default.srt b/etc/srecode/doc-default.srt
index 1f1cb4e9cc..2c7403e118 100644
--- a/etc/srecode/doc-default.srt
+++ b/etc/srecode/doc-default.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/doc-java.srt b/etc/srecode/doc-java.srt
index 659a8e9f34..3cd4d24fa6 100644
--- a/etc/srecode/doc-java.srt
+++ b/etc/srecode/doc-java.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/ede-autoconf.srt b/etc/srecode/ede-autoconf.srt
index 1f5a2711ef..c203536d77 100644
--- a/etc/srecode/ede-autoconf.srt
+++ b/etc/srecode/ede-autoconf.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2010, 2012-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/ede-make.srt b/etc/srecode/ede-make.srt
index edf34a087f..5cef78eac0 100644
--- a/etc/srecode/ede-make.srt
+++ b/etc/srecode/ede-make.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/el.srt b/etc/srecode/el.srt
index 5d5a2ecf35..baa7c59fe3 100644
--- a/etc/srecode/el.srt
+++ b/etc/srecode/el.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric Ludlam <zappo@gnu.org>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/getset-cpp.srt b/etc/srecode/getset-cpp.srt
index cdb06dcc5a..78946a75b6 100644
--- a/etc/srecode/getset-cpp.srt
+++ b/etc/srecode/getset-cpp.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/java.srt b/etc/srecode/java.srt
index f9e67b7801..95935449b7 100644
--- a/etc/srecode/java.srt
+++ b/etc/srecode/java.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/make.srt b/etc/srecode/make.srt
index 1288acb7d3..4aa1c0a283 100644
--- a/etc/srecode/make.srt
+++ b/etc/srecode/make.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/template.srt b/etc/srecode/template.srt
index a651e324d3..f0855da1b4 100644
--- a/etc/srecode/template.srt
+++ b/etc/srecode/template.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2005, 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric Ludlam <zappo@gnu.org>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/test.srt b/etc/srecode/test.srt
index 79f9dd027b..3bbc33e72d 100644
--- a/etc/srecode/test.srt
+++ b/etc/srecode/test.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/texi.srt b/etc/srecode/texi.srt
index d696cc09f7..17f4c5a112 100644
--- a/etc/srecode/texi.srt
+++ b/etc/srecode/texi.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/srecode/wisent.srt b/etc/srecode/wisent.srt
index 40fe942384..27c65bef57 100644
--- a/etc/srecode/wisent.srt
+++ b/etc/srecode/wisent.srt
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/etc/tutorials/TUTORIAL.translators b/etc/tutorials/TUTORIAL.translators
index 2747d39d35..b6b9578706 100644
--- a/etc/tutorials/TUTORIAL.translators
+++ b/etc/tutorials/TUTORIAL.translators
@@ -41,8 +41,8 @@ Maintainer: Alfredo Finelli <alfredofnl@tiscali.it>
 	    Italian GNU Translation Group <tp@lists.linux.it>
 
 * TUTORIAL.ja:
-Author:     Kenichi Handa <handa@m17n.org>
-Maintainer: Kenichi Handa <handa@m17n.org>
+Author:     Kenichi Handa <handa@gnu.org>
+Maintainer: Kenichi Handa <handa@gnu.org>
 
 * TUTORIAL.ko:
 Author:     Koaunghi Un <koaunghi@ling.cnu.ac.kr>
@@ -94,4 +94,3 @@ Maintainer: Chao-Hong Liu <chliu@gnu.org>
 ;;; Local Variables:
 ;;; coding: utf-8
 ;;; End:
-
diff --git a/leim/ChangeLog.1 b/leim/ChangeLog.1
index c11ba302e6..37c2e23ff0 100644
--- a/leim/ChangeLog.1
+++ b/leim/ChangeLog.1
@@ -1254,7 +1254,7 @@
 	* quail/pypunct-b5.el ("chinese-py-punct-b5"): Change the title
 	Chinese characters from GB to Big5.
 
-2003-05-01  Wlodzimierz Bzyl  <matwb@julia.univ.gda.pl>  (tiny change)
+2003-05-01  Włodzimierz Bzyl  <matwb@julia.univ.gda.pl>  (tiny change)
 
 	* quail/latin-pre.el ("polish-slash"): Add the rule "//"->?/.
 
@@ -1977,7 +1977,7 @@
 	* quail/tibetan.el: Change all tibetan-1-column characters to
 	tibetan.  Quail map for "tibetan-wylie" fixed.
 
-2000-03-31  Wlodzimierz Bzyl  <matwb@monika.univ.gda.pl>
+2000-03-31  Włodzimierz Bzyl  <matwb@monika.univ.gda.pl>
 
 	* quail/latin-pre.el ("polish-slash"): New input method.
 
diff --git a/leim/SKK-DIC/README b/leim/SKK-DIC/README
index fa51a57fe1..36236b2bb3 100644
--- a/leim/SKK-DIC/README
+++ b/leim/SKK-DIC/README
@@ -1,6 +1,12 @@
-This directory contains a copy of the following file:
+This directory contains an uncompressed copy of the following file:
 
-http://openlab.ring.gr.jp/skk/skk/dic/SKK-JISYO.L
+https://skk-dev.github.io/dict/SKK-JISYO.L.gz
 
 This file is free software distributed under the terms
 of the GNU General Public License.
+
+For more information about this file, please see:
+
+http://openlab.ring.gr.jp/skk/dic.html
+https://skk-dev.github.io/dict/
+https://github.com/skk-dev/dict
diff --git a/leim/SKK-DIC/SKK-JISYO.L b/leim/SKK-DIC/SKK-JISYO.L
index 44d86448fd..6b024e3dc4 100644
--- a/leim/SKK-DIC/SKK-JISYO.L
+++ b/leim/SKK-DIC/SKK-JISYO.L
@@ -1,6 +1,6 @@
 ;; -*- mode: fundamental; coding: euc-jp -*-
 ;; Large size dictionary for SKK system
-;; Copyright (C) 1988-1995, 1997, 1999-2010
+;; Copyright (C) 1988-1995, 1997, 1999-2014
 ;;
 ;; Masahiko Sato <masahiko@kuis.kyoto-u.ac.jp>
 ;; Hironobu Takahashi <takahasi@tiny.or.jp>,
@@ -13,9 +13,7 @@
 ;; SKK Development Team <skk@ring.gr.jp>
 ;;
 ;; Maintainer: SKK Development Team <skk@ring.gr.jp>
-;; Version: $Id: SKK-JISYO.L,v 1.1216 2014/12/13 00:10:02 czkmt Exp $
 ;; Keywords: japanese
-;; Last Modified: $Date: 2014/12/13 00:10:02 $
 ;;
 ;; This dictionary is free software; you can redistribute it and/or
 ;; modify it under the terms of the GNU General Public License as
@@ -669,7 +667,7 @@
 褤Ĥr /줤/
 褤är /ĥ/
 褤r /줤/
-褤m /줤;/줤//
+褤m /줤/줤//
 褤s //
 褢k //
 褢b /ͷ/
@@ -16076,7 +16074,7 @@
 #d /#0/
 #door /#0ɥ/#1ɥ/
 #f /#0/#1/#1/
-#feet /(skk-gadget-units-conversion "feet" (string-to-number (car skk-num-list)) "cm")/
+#feet /#1ե/
 #fu /#9/
 #g /#0G/#1/
 #gatu /#1/
@@ -16089,7 +16087,7 @@
 #hi /#9/
 #hisha /#9/
 #hu /#9/
-#inch /#1/(skk-gadget-units-conversion "inch" (string-to-number (car skk-num-list)) "cm")/(skk-gadget-units-conversion "inch" (string-to-number (car skk-num-list)) "feet")/
+#inch /#1/
 #ji /#1/
 #k /#0/
 #ka /#1/
@@ -16104,7 +16102,7 @@
 #m#d /#0#0/
 #mega /#1ᥬ/
 #mei /#1̾/
-#mile /(skk-gadget-units-conversion "mile" (string-to-number (car skk-num-list)) "km")/(skk-gadget-units-conversion "mile" (string-to-number (car skk-num-list)) "yard")/
+#mile /#1ޥ/
 #min /#0ʬ/
 #mm /#1/#2/
 #narigin /#9/
@@ -16120,10 +16118,9 @@
 #t /#1/#0/
 #to /#9/
 #uma /#9/
-#x# /(skk-times)/
 #y /#0ǯ/
 #y#m#d /#0ǯ#0#0/
-#yard /(skk-gadget-units-conversion "yard" (string-to-number (car skk-num-list)) "cm")/(skk-gadget-units-conversion "yard" (string-to-number (car skk-num-list)) "feet")/
+#yard /#1䡼/
 #yen /#1/#0/#8/
 ## /#1#1/
 ##Ƥ /#1#1/
@@ -19316,7 +19313,7 @@ baobab /
 baptisma /Хץƥ/
 baptist /Хץƥ/Хץƥ/
 baptiste /Хץƥ/Хƥ/
-bar /С/С;-Τ褦ʤ/;minus/;pipe//(make-string (- fill-column 1) ?-)/
+bar /С/С;-Τ褦ʤ/;minus/;pipe//
 barabbas /Х/
 baraja /Х/
 barb /С/
@@ -33984,7 +33981,7 @@ november /
 novice /Ρӥ/
 novo /Υ/
 novosibirsk /Υܥӥ륹/Υӥ륹/
-now /ʥ/(current-time-string)/(substring (current-time-string) 11 16)/(substring (current-time-string) 11 19)/
+now /ʥ/
 nowait /Ρ/Ρ/
 nox /Υå/ǻʪ/
 nozzle /Υ/
@@ -36477,7 +36474,6 @@ putting /
 puyol /ץ硼/
 puzzle /ѥ/
 puzzlegame /ѥ륲/
-pwd /(pwd)/
 pygmalion /ԥޥꥪ/
 pygmy /ԥߡ/
 pyjamas /ѥ/
@@ -39142,7 +39138,7 @@ skiresort /
 skirt //
 skit /å/
 skiware //
-skk /SKK/(skk-version)/Simple Kana to Kanji conversion program/
+skk /SKK/Simple Kana to Kanji conversion program/
 skolem //
 skopje /ԥ/
 skryabin /㡼ӥ/
@@ -40970,6 +40966,7 @@ testosterone /
 testpattern /ƥȥѥ/
 testrun /ƥȥ/
 testset /ƥȥå/
+tethering /ƥ/
 tetra /ƥȥ;4/
 tetrachloroethylene /ƥȥ饯;C2Cl4/
 tetris /ƥȥꥹ/
@@ -41206,7 +41203,7 @@ tim /
 timbales /ƥХ쥹/
 timber /ƥС/
 timbre /֥/
-time ///(current-time-string)/
+time ///
 timeattack /ॢå/
 timecapsule /५ץ/
 timecard /५/
@@ -41300,7 +41297,7 @@ tocopherol /
 tocotrienol /ȥȥꥨΡ/
 tocqueville /ȥ/
 tod /ȥå/ȡ;() /
-today /ȥǥ/ȥǥ/ȥǡ/(skk-current-date (lambda (date-information format gengo and-time) (skk-default-current-date date-information nil 0 'gengo 0 0 0)))/(skk-current-date (lambda (date-information format gengo and-time) (skk-default-current-date date-information "%s-%s-%s(%s)" 0 nil 0 0 nil)))/(skk-current-date (lambda (date-information format gengo and-time) (skk-default-current-date date-information nil 0 'gengo 1 0 0)))/(skk-current-date (lambda (date-information format gengo and-time) (skk-default-current-date date-information nil 3 'gengo 0 0 0)))/(skk-current-date)/
+today /ȥǥ/ȥǥ/ȥǡ/
 toe /ȥ/ȥ/ȡ/
 toeic /ȡå;Test of English for International Communication/TOEIC/
 toeplitz /ƥץå/
@@ -42379,7 +42376,7 @@ verre /
 versace /륵;ww.versace.com/٥륵/
 versailles /٥륵/륵/
 verse /;λ/
-version /С///(skk-version)/
+version /С///
 version-up /С󥢥å/
 versionup /С󥢥å/󥢥å/
 versus /С//
@@ -45055,6 +45052,7 @@ zyklus /
 ֤ /Ļʸ/
  /Ļ/
  /­/
+ /­/
  //
 Ӥ󤵤 /ӥ/
 夦 //
@@ -46601,7 +46599,7 @@ zyklus /
 Ȥ //Ʈ/
 Ȥ //
 ȤƤΤ /ŷ/
- //
+ ////
 ɤ /ƣ//
 ɤ礦 /ƣ/
 ɤǤ /ƣŵ/
@@ -46791,7 +46789,7 @@ zyklus /
 褦 /;¾ˤä-⤢/
 櫓 ///
 錄 /Ϥ/Ϥ/
- /Ѱ/屡//
+ /Ѱ/屡///
 󤫤 /Ѱ/
 󤫤 /Ѱ/
 󤫤 /Ѱ/
@@ -47310,7 +47308,7 @@ zyklus /
  /۸/
 Ӥ礦 /帶/
  ///
- /;equal/
+ /;equal///
  /Ƥ//
  /ʹ/ܹ/ո/乽//Ҹ/ܹ//θ/۹/θ/߹/ݹ/
  /ܹ԰/
@@ -49362,7 +49360,6 @@ zyklus /
 Ĥ //Ż/
 Ĥ󤽤 /¸ѽ/
 Ĥ /æ/
-Ĥ礦 /ĥ/
 Ĥ /ޤ//5/
 ĤĤФ /޶/
 ĤĤܤ /ޤ; -쥹ȥ/
@@ -51151,6 +51148,7 @@ zyklus /
  /⤭;֥ס-//⤭;֥פ-/ͫ;-ह/
  /ͫ/
 礦 //
+礦 //
 礦 /;[Χ]ϩ¦ιô/
 礦Τ /;[Χ]Ĺ/
 礯 //
@@ -54521,6 +54519,7 @@ zyklus /
 դդ //
 뤹 /륹/
  /ϣң/
+ ///
  //
  ///
 ˤ //
@@ -55126,6 +55125,7 @@ zyklus /
  /繾Τ/
 礦 /繾Į/
  /繾/
+ɤ /繾/
 ɤ⤦ /繾ܺ/
 ɤϤʤ /繾Ͳֲ/
 Τ //
@@ -63405,12 +63405,12 @@ zyklus /
 ߤ //
 ߤ //
 ߤ /̻/
-ߤ礦 //
 ߤ /ȱڤ/
 ߤष /ŷ/ȱ/
 ߤ /ڤ//
 ߤ /;/
 ߤ礦 //
+ߤ礦 //
 ߤ /ڤ/
 ߤ /ȱ;/
 ߤ /쿧/
@@ -70803,6 +70803,7 @@ zyklus /
 礦礯֤ /ɿʪ;[]companion plants/
 礦󤫡 /ɥ󥫡/
 礦ɤ /Ʋ/
+礦ߤ /˿/
 礦⤸ /ʸ/
 礦 //;礦䤯θ?/
 礦 /׸/
@@ -72780,7 +72781,7 @@ zyklus /
 󤷤󤷤夦 /ӿ/
 󤷤󤽤 /괯/
 󤷤󤾤 //
- //;recent///;valet///⼡/⼣/ֻ/ػ/
+ ///;recent///;valet///⼡/⼣/ֻ/ػ/
 > /;-,-ؿ/
 󤸤 //
 󤸤ۤ /ˡ/
@@ -72962,7 +72963,7 @@ zyklus /
  //
  /İ/
 礦 /İ/
- /İ̲/
+ /İ̽/
 ϤҤ /İɧ/
 Ƥ /Ū/
 Ȥ /Ի/
@@ -76850,7 +76851,7 @@ zyklus /
 Ĥ褦 /ٻѸ/
 ĤӤ /ٻͽ/
 Ĥ礯 /ٻ/
- /׻/л//
+ /׻/л////////////
 󤨤 //
 󤫤 /׻/
 󤫤 /׻ʳ;computational SCIENCE/׻;computational CHEMISTRY/
@@ -79122,6 +79123,7 @@ zyklus /
  /θ/
 礦 ///
 礦 /̼/
+礦 //
 礯 //
 礯餽 /褤/
 礯 /ϲ/
@@ -87591,7 +87593,6 @@ zyklus /
  /۵/Ƶ/
 礦 /Ƕ/;/;̡/з;[ƻ]Ȭΰ졣/
 礦 /ƶ/
-礦 //
 礦 /Ƕ/
 礦 //
 礦󤫤 /®/
@@ -90318,7 +90319,7 @@ zyklus /
 󤫤 /ö/
 󤫤󤿤 /϶/
 󤫤Ǥ /;[]/
-󤫤 ///////;/3/
+󤫤 /////////;/3/
 󤫤 //
 󤫤 /Ѳ/
 󤫤󤱤 /Ѵط/
@@ -92079,6 +92080,7 @@ zyklus /
 Τ //
 Τ䤯 /;[̾]/
 Τߤ /Į̆/
+Τߤ /ƻ;ƻ/
 Τ /ë/
 Ϥ //
 Ϥ //
@@ -94707,6 +94709,7 @@ zyklus /
 ⤭ϤȤ /Ⱦ/
 ⤭ /̻/
 ⤮礦 //
+⤮礦 //
 ⤯ //
 ⤯ /Ԣ/
 ⤯ //
@@ -97463,7 +97466,6 @@ zyklus /
 Ǥ /ť/
 Ǥ //
 Ȥ /Ʈ/
-Ȥ /췴/
 ɤ /ư/ƣ/
  //
 ѤĤ礯 /ȯ/
@@ -98743,7 +98745,7 @@ zyklus /
 礦֤Ƥ /ʸ/
 礦ݤ //
 礦 /;ǯ(1926-1989)/;ǯ(1312-1317)/////;ǯ(834-848)//
-礦#ͤ /#0ǯ/#1ǯ/#2ǯ/#3ǯ/(skk-gengo-to-ad "" "ǯ")/(skk-gengo-to-ad "" "ǯ")/
+礦#ͤ /#0ǯ/#1ǯ/#2ǯ/#3ǯ/
 礦狼褦 /²ػ/
 礦來 /´/
 礦來 /´/
@@ -100856,7 +100858,7 @@ zyklus /
 󤷤褦 /»//
 󤷤 //
 󤷤 /»Ͽ/
-󤷤 ////š;̣-/;㤬-ȹߤ/;mind.-Ӽ//;󤸤?/
+󤷤 ////š;̣-/;㤬-ȹߤ/;mind.-Ӽ//;󤸤?//
 󤷤󤭤 /ʵ/
 󤷤󤳤㤯 /׼/
 󤷤󤵤ä /ʺ/
@@ -100946,6 +100948,7 @@ zyklus /
 󤸤 /Ϻ/Ϻ/
 󤸤 ///////;=/
 󤸤󤨤󤲤礦 /ͱ/
+󤸤󤪤 /Ͳ/
 󤸤 //
 󤸤󤫤 /Ͳμ/
 󤸤󤭤 /͵/
@@ -103587,7 +103590,7 @@ zyklus /
 ɤ /ưϿ/
 ɤ /ưϪ/
 ɤ /ưϪ/
-ɤ /Ϸ/ϼ/
+ɤ /Ϸ/ϼ/;ʬ(selfie)/
 ʤ ////
 ʤ礦 /Į/
 ʤ餷 /϶Ѥ/
@@ -105348,6 +105351,7 @@ zyklus /
 礦 //////////ġ///Ƚ;[Χ]/;[Χ](ޱܤ)=Ƚ/;10/;Ĥ/п;ʼ/;ھ/;˭/;/;/;־פε/;־פε(̾Ѵ)/ڷ;ºڷ/;(Ϥ餦)///;־פε(̾Ѵ)/;־פε(̾Ѵ)/;־פε(̾Ѵ)/;/;̮/;Ȥ/;־פε(̾Ѵ)/;šפε(̾Ѵ)/;/;־פε(̾Ѵ)/Ы;־פε(̾Ѵ)/;Ƥ/;ļ/;/;α///;/;/;/;/;/;(=)/;־פε(̾Ѵ)/;Τ/;/;(դ)/;/;/̼/л;ʤ/վ;䤫/;ʤ֡/;?/;ʸ/;פε/;־פΰλ/;־פε(̾Ѵ)/;־פε2/;־פε3/;(Ѳ)ʼ/;(ⲻ)ʩ/;(ⲻ)//;/
 礦> //̼;̼,̼˦/
 礦 ///
+礦 /ﰵ/
 礦 //ڷ///;-ã///
 礦> /;-ǰ,-ʬ,-ӥå/
 礦 /Ƥ/
@@ -108764,6 +108768,7 @@ zyklus /
 Ƥ /Ŵ/
  //
 Ȥ //
+Ȥ /췴/
  //
 ɤ /ߤ/
 ˡ /ˡ/
@@ -110807,7 +110812,7 @@ zyklus /
 줤Ƥ /ŵ/
 줤Ȥ /Ի/
 줭 //
-줭#ͤ /#0ǯ/#1ǯ/#2ǯ/#3ǯ/(skk-ad-to-gengo 0 nil "ǯ")/(skk-ad-to-gengo 1 nil "ǯ")/
+줭#ͤ /#0ǯ/#1ǯ/#2ǯ/#3ǯ/
 줭ʤͤ /ǯ/
 줭ͤ󤬤ä /ǯ/
  /;line up/;limpid//
@@ -112168,7 +112173,7 @@ zyklus /
 󤱤Ĥ //
 󤱤Ĥ //
 󤱤ĤϤΤ /ȿ/
-󤱤 /踯/踫/츢/踳//ɸ;׵//կ;-//ڣ//ϣ;abbrev/
+󤱤 /踯/踫/츢/踳//ɸ;׵//կ;-//ڣ//ϣ;abbrev/
 󤱤󤵤 //
 󤱤󤸤 /츢/
 󤱤󤻤 /踫/
@@ -113415,7 +113420,7 @@ zyklus /
  ////;-/;Zen Buddhism//;(Ϣ)///;Ҥ/;©/;ư/;//;/;פΰλ/;/;פε(̾Ѵ)/
 > ///
 󤢤 //
-󤢤 //
+󤢤 ///
  ////
 󤤤 /Ѱ/
 󤤤 //
@@ -117112,7 +117117,7 @@ zyklus /
  /н/;//;[󽽻ᵤ]7.23///;//
 礢 /н/
 礦 /о;target.ָ-/;ǯ(1912-26)//羭/о;contrast.-¸/о;symmetry.-/羡//о;-ˡ/⾦/羹;羡//;[ʩ]/
-礦#ͤ /#0ǯ/#1ǯ/#2ǯ/#3ǯ/(skk-gengo-to-ad "" "ǯ")/(skk-gengo-to-ad "" "ǯ")/
+礦#ͤ /#0ǯ/#1ǯ/#2ǯ/#3ǯ/
 礦> /о;-,-,-/
 礦 //
 礦 /Ϸ/
@@ -123708,7 +123713,6 @@ zyklus /
 夦夦ؤ //
 夦礦 //润/涧/
 夦礦 //
-夦礦 //
 夦礦Ф礦 /Ͼ/
 夦礦 //
 夦礦 /涵;[ά]鿳Ĳ/
@@ -127373,6 +127377,7 @@ zyklus /
 Ĥ //
 Ĥ֤ //
 Ĥ /ʼ//
+Ĥ //
 Ĥɤ //Ѥ/;ɡ׵/
 Ĥ /ϸ/
 Ĥܤ /ϸ/
@@ -127747,6 +127752,7 @@ zyklus /
 Ƥ夦Ϥ /ȿ/
 Ƥ夫Ѥ //
 Ƥ夯 //
+Ƥä /л/
 Ƥ //;excel/
 ƤĤ /д/
 ƤĤ /и/
@@ -133759,6 +133765,7 @@ zyklus /
 Ȥ褸 /˭/
 Ȥ褹 /˭/
 Ȥ褹 /˭/
+Ȥ褹礦 /˭Ծ/
 Ȥ褹դȤ /˭Ƭ/
 Ȥ褿 /˭/
 Ȥ褿 /˭;פ̾/
@@ -135927,6 +135934,7 @@ zyklus /
 ʤ ///
 ʤ //
 ʤ礦 //
+ʤ礦 //
 ʤ ///
 ʤ //
 ʤ /ţ/
@@ -138070,11 +138078,11 @@ zyklus /
 ˤ /°/
 ˤΤߤϤ /Ӥθ/
 ˤ /Ӹ/
+ˤ礦 //
 ˤ礦 //
 ˤ礦夦礦 /˵/
 ˤ夦 //
 ˤ夦 //
-ˤ礦 //
 ˤ //
 ˤ //
 ˤ礦 //
@@ -140222,6 +140230,7 @@ zyklus /
 ˤ /ǧε/
 ˤΤ /ǧεǽ/
 ˤ󤴤 /ǧθ/
+ˤ礦 /ǧξ/
 ˤ /ǧν/
 ˤ /ǧο/
 ˤ꤬ /ǧο/
@@ -144351,7 +144360,6 @@ zyklus /
 Ϥޤʤ //;͡׵/
 Ϥޤʤ /̾/
 ϤޤʤϤ /̾綶/
-Ϥޤʤᤤ /̾̾/
 Ϥޤʤ /;=Ϥޤʤ/
 Ϥޤʤ /Ͳػ//
 Ϥޤ ///
@@ -145654,7 +145662,6 @@ zyklus /
  //////////;ξ/;־פΰλ/;ֿϡפΰλ/
 Сꤦ /Bk/Berkelium/
 С㡼Ӥ礦 /С㡼;[]Buerger's disease/
-С /(skk-version)/
 СФ󤴤 /Сֹ/
 СȤ /С/
 Ф //
@@ -146042,7 +146049,7 @@ zyklus /
 Фä餯 /ȴͿ/
 Фä /ȴ/
 Фä //
-Фä /Ȳ/Ȳ/
+Фä /Ȳ/
 Фä /ȴ/
 Фä /ȴ/ȴ//
 Фä /ȴ/
@@ -146887,6 +146894,7 @@ zyklus /
 Ҥ //
 ҤĤ /Ȭ/
 Ҥ /컳/
+Ҥޤ /컳/
 Ҥޤ /컳/
 Ҥޤ礦 /컳޾/
 Ҥޤ󤸤礦 /컳/
@@ -147046,7 +147054,7 @@ zyklus /
 Ҥɤ /жĻ/
 Ҥ //㿷/
 Ҥ //
-ҤƤ ///
+ҤƤ //
 ҤϤ⤸ /ʸ/
 Ҥ /ܶ/
 Ҥ //
@@ -148446,6 +148454,7 @@ zyklus /
 Ҥ //
 ҤФ ///
 ҤФҤ //
+ҤФ //
 ҤФ //
 ҤФ /;ȯˤ/;ˤ餵/;⤤//
 ҤФ /;ָ-/;ǽϳ-/
@@ -149487,6 +149496,7 @@ zyklus /
 Ҥ줤ܤ /˼/
 Ҥ줭 ///
 Ҥ //
+ҤĤ //
 Ҥˤ /ҥ/
 Ҥ //
 Ҥ󤱤 /Ϣ/
@@ -150943,6 +150953,7 @@ zyklus /
 դ礦 /Ĺ/
 դ礦 //
 դ /ʢ/
+դ礦 /ʢж/
 դä /ʣ/
 դߤ礦 /ȹĹ/
 դ //
@@ -151264,6 +151275,7 @@ zyklus /
 դȤ /ʡ/
 դȤޤ /ʡ/
 դȤ /Կ/
+դȤ󤻤 /Կ/
 դȤ /ʡ/
 դȤ /ʡα/
 դ /ʤ/
@@ -154798,7 +154810,7 @@ zyklus /
 ؤ /ʼ/
 ؤ /ʿ/ʿʹ/
 ؤ /ʿ;ǯ(1989-)/ʿ/ʼ/ʾ//
-ؤ#ͤ /ʿ#0ǯ/ʿ#1ǯ/ʿ#2ǯ/ʿ#3ǯ/(skk-gengo-to-ad "" "ǯ")/(skk-gengo-to-ad "" "ǯ")/
+ؤ#ͤ /ʿ#0ǯ/ʿ#1ǯ/ʿ#2ǯ/ʿ#3ǯ/
 ؤ#ͤ /ʿ#0ǯ/
 ؤ /ʿݿ/
 ؤͤ /ʿǯ/
@@ -159542,6 +159554,7 @@ zyklus /
 ޤ礦Ǥ󤻤 /ⶭ/
 ޤ /ų/
 ޤ //
+ޤ㤯 //
 ޤ礦 /޹/޹/
 ޤ /ʶ/
 ޤ路 /ʶ路/
@@ -159936,6 +159949,7 @@ zyklus /
 ޤ /ְ㤤õ/
 ޤǤ /ְ㤤/
 ޤ /ְ㤨/
+ޤ //Į/
 ޤ礦 /Ԥ/Թ/
 ޤ //
 ޤ /λ/Į/һ/λ/һ//һ/
@@ -161081,7 +161095,7 @@ zyklus /
 ߤ碌 //
 ߤ錄Ϥ館 /ĸ/
 ߤۤ //
-ߤ䤭 //
+ߤ䤭 //
 ߤ٤ //
 ߤ /ϼ/
 ߤΤ /ʪ/
@@ -162913,6 +162927,7 @@ zyklus /
 ߤ勞Ƥ /̥Ū/
 ߤ櫓 /ʬ/ʬ/
 ߤ盧 /»/
+ߤ虜 //
 ߤ魯 /˺/
 ߤ錄 //
 ߤ //
@@ -164347,7 +164362,7 @@ zyklus /
 ᤤ /¿/
 ᤤ󤳤 /̾®/
 ᤤ /;ǯ(1868-1912)/;specify/̾;term/
-ᤤ#ͤ /#0ǯ/#1ǯ/#2ǯ/#3ǯ/(skk-gengo-to-ad "" "ǯ")/(skk-gengo-to-ad "" "ǯ")/
+ᤤ#ͤ /#0ǯ/#1ǯ/#2ǯ/#3ǯ/
 ᤤ /ʹ/
 ᤤ /ʸ/
 ᤤ /ݿ/
@@ -164479,7 +164494,7 @@ zyklus /
 ᤤФ /̾/
 ᤤҤ /̾ɮ/
 ᤤҤ礦 /̾ɼ/
-ᤤҤ /̾/̾/
+ᤤҤ /̾/̾//
 ᤤ /ջ/
 ᤤӤ夦 /ɵ/
 ᤤӤ //
@@ -167076,7 +167091,7 @@ zyklus /
 ĤϤ󤮤礦 /Ȭ;(1614-1685) ䷶ʲȡϻʤĴ١/
 ĤФ /۸/
 Ĥ /Ȭ/
-Ĥᤦʤ /Ȭܱ//
+Ĥᤦʤ /Ȭܱ/
 Ĥ /Ȭÿ/
 Ĥ椦 /ëͷ/
 Ĥ //ۤ/
@@ -169410,7 +169425,7 @@ zyklus /
 褦Ǥ /Ż/
 褦Ǥ󤷤Τ /ŻƬǾ/
 褦 //
-褦Ȥ /Ƭ/;λ/;lamp//
+褦Ȥ /Ƭ/;λ/;lamp///
 褦Ȥˤ /Ƭ/
 褦Ȥ /Ȥ/
 褦Ȥ /֤/
@@ -170576,7 +170591,7 @@ zyklus /
 ⤹ //
  /;֤ġפϡ֤Ρפΰդγʽ/
 Ĥ //
-ĤҤ餵 /ʿ/
+ĤҤ餵 /ʿ/ɺ;Ż/ʿ;ܽ/
  //
 ޤФʤ //
 䤯 /ͽ/Ю;ͽ׵/
@@ -173618,7 +173633,8 @@ zyklus /
 줤礦 //
 줤礯 //
 줤 //
-줤 //
+줤 /;ǯ(2019-)//
+줤#ͤ /#0ǯ/#1ǯ/#2ǯ/#3ǯ/
 줪 //̾/
 줭 /;history/;calendar/;/;-/ݬ;̥/;pitch/ݮ;̥/;//;(ŷ)/;Ť/
 줭 /㪴/
diff --git a/lib-src/Makefile.in b/lib-src/Makefile.in
index 387a6e3324..40222174bd 100644
--- a/lib-src/Makefile.in
+++ b/lib-src/Makefile.in
@@ -163,7 +163,7 @@ INSTALLABLES = etags${EXEEXT} ctags${EXEEXT} emacsclient${EXEEXT} $(CLIENTW) \
 
 # Things that Emacs runs internally, or during the build process,
 #  which should not be installed in bindir.
-UTILITIES = profile${EXEEXT} hexl${EXEEXT} \
+UTILITIES = hexl${EXEEXT} 			 	 \
 	    $(if $(with_mailutils), , movemail${EXEEXT}) \
             $(and $(use_gamedir), update-game-score${EXEEXT})
 
@@ -204,6 +204,8 @@ LIBRESOLV=@LIBRESOLV@
 LIBS_MAIL=@LIBS_MAIL@
 ## empty or -lrt or -lposix4 if HAVE_CLOCK_GETTIME
 LIB_CLOCK_GETTIME = @LIB_CLOCK_GETTIME@
+## Whatever libraries are needed for euidaccess
+LIB_EACCESS=@LIB_EACCESS@
 ## empty or -lwsock2 for MinGW
 LIB_WSOCK32=@LIB_WSOCK32@
 
@@ -378,10 +380,6 @@ ebrowse${EXEEXT}: ${srcdir}/ebrowse.c ${srcdir}/../lib/min-max.h $(NTLIB) \
 	$(AM_V_CCLD)$(CC) ${ALL_CFLAGS} -DVERSION="\"${version}\"" \
 	  $< $(NTLIB) $(LOADLIBES) -o $@
 
-profile${EXEEXT}: ${srcdir}/profile.c $(NTLIB) $(config_h)
-	$(AM_V_CCLD)$(CC) ${ALL_CFLAGS} $< \
-	  $(NTLIB) $(LOADLIBES) $(LIB_CLOCK_GETTIME) -o $@
-
 make-docfile${EXEEXT}: ${srcdir}/make-docfile.c $(NTLIB) $(config_h)
 	$(AM_V_CCLD)$(CC) ${ALL_CFLAGS} $< $(NTLIB) $(LOADLIBES) -o $@
 
@@ -398,12 +396,12 @@ pop.o: ${srcdir}/pop.c ${srcdir}/pop.h ${srcdir}/../lib/min-max.h $(config_h)
 emacsclient${EXEEXT}: ${srcdir}/emacsclient.c $(NTLIB) $(config_h)
 	$(AM_V_CCLD)$(CC) ${ALL_CFLAGS} $< \
 	   -DVERSION="\"${version}\"" $(NTLIB) $(LOADLIBES) \
-	   $(LIB_WSOCK32) $(LIBS_ECLIENT) -o $@
+	   $(LIB_WSOCK32) $(LIB_EACCESS) $(LIBS_ECLIENT) -o $@
 
 emacsclientw${EXEEXT}: ${srcdir}/emacsclient.c $(NTLIB) $(CLIENTRES) $(config_h)
 	$(AM_V_CCLD)$(CC) ${ALL_CFLAGS} $(CLIENTRES) -mwindows $< \
 	   -DVERSION="\"${version}\"" $(LOADLIBES) \
-	   $(LIB_WSOCK32) $(LIBS_ECLIENT) -o $@
+	   $(LIB_WSOCK32) $(LIB_EACCESS) $(LIBS_ECLIENT) -o $@
 
 NTINC = ${srcdir}/../nt/inc
 NTDEPS = $(NTINC)/ms-w32.h $(NTINC)/sys/stat.h $(NTINC)/inttypes.h \
diff --git a/lib-src/emacsclient.c b/lib-src/emacsclient.c
index f476840898..fd56007b15 100644
--- a/lib-src/emacsclient.c
+++ b/lib-src/emacsclient.c
@@ -1357,6 +1357,7 @@ set_local_socket (char const *server_name)
   int tmpdirlen = -1;
   int socknamelen = -1;
   uid_t uid = geteuid ();
+  bool tmpdir_used = false;
 
   if (strchr (server_name, '/')
       || (ISSLASH ('\\') && strchr (server_name, '\\')))
@@ -1389,6 +1390,7 @@ set_local_socket (char const *server_name)
 	    }
 	  socknamelen = local_sockname (sockname, socknamesize, tmpdirlen,
 					uid, server_name);
+	  tmpdir_used = true;
 	}
     }
 
@@ -1462,11 +1464,27 @@ set_local_socket (char const *server_name)
   if (sock_status < 0)
     message (true, "%s: Invalid socket owner\n", progname);
   else if (sock_status == ENOENT)
-    message (true,
-	     ("%s: can't find socket; have you started the server?\n"
-	      "%s: To start the server in Emacs,"
-	      " type \"M-x server-start\".\n"),
-	     progname, progname);
+    {
+      if (tmpdir_used)
+	{
+	  uintmax_t id = uid;
+	  char sockdirname[socknamesize];
+	  int sockdirnamelen = snprintf (sockdirname, sizeof sockdirname,
+					 "/run/user/%"PRIuMAX, id);
+	  if (0 <= sockdirnamelen && sockdirnamelen < sizeof sockdirname
+	      && faccessat (AT_FDCWD, sockdirname, X_OK, AT_EACCESS) == 0)
+	    message
+	      (true,
+	       ("%s: Should XDG_RUNTIME_DIR='%s' be in the environment?\n"
+		"%s: (Be careful: XDG_RUNTIME_DIR is security-related.)\n"),
+	       progname, sockdirname, progname);
+	}
+      message (true,
+	       ("%s: can't find socket; have you started the server?\n"
+		"%s: To start the server in Emacs,"
+		" type \"M-x server-start\".\n"),
+	       progname, progname);
+    }
   else
     message (true, "%s: can't stat %s: %s\n",
 	     progname, sockname, strerror (sock_status));
diff --git a/lib-src/etags.c b/lib-src/etags.c
index 362897fb0c..6bd04d1f1c 100644
--- a/lib-src/etags.c
+++ b/lib-src/etags.c
@@ -84,10 +84,7 @@ char pot_etags_version[] = "@(#) pot revision number is 17.38.1.4";
 #  undef DEBUG
 #  define DEBUG true
 #else
-#  define DEBUG  false
-#  ifndef NDEBUG
-#   define NDEBUG		/* disable assert */
-#  endif
+#  define DEBUG false
 #endif
 
 #include <config.h>
@@ -131,11 +128,6 @@ char pot_etags_version[] = "@(#) pot revision number is 17.38.1.4";
 #include <c-strcase.h>
 
 #include <assert.h>
-#ifdef NDEBUG
-# undef  assert			/* some systems have a buggy assert.h */
-# define assert(x) ((void) 0)
-#endif
-
 #include <getopt.h>
 #include <regex.h>
 
@@ -4290,7 +4282,7 @@ Yacc_entries (FILE *inf)
   while (perhaps_more_input (file_pointer)				\
 	 && (readline (&(line_buffer), file_pointer),			\
 	     (char_pointer) = (line_buffer).buffer,			\
-	     true))							\
+	     true))
 
 #define LOOKING_AT(cp, kw)  /* kw is the keyword, a literal string */	\
   ((assert ("" kw), true)   /* syntax error if not a literal string */	\
diff --git a/lib-src/make-docfile.c b/lib-src/make-docfile.c
index ccd245e013..4d25b0a6b9 100644
--- a/lib-src/make-docfile.c
+++ b/lib-src/make-docfile.c
@@ -747,6 +747,8 @@ write_globals (void)
 	    printf ("%d", globals[i].v.value);
 	  putchar (')');
 
+	  if (globals[i].flags & DEFUN_noreturn)
+	    fputs (" ATTRIBUTE_COLD", stdout);
 	  if (globals[i].flags & DEFUN_const)
 	    fputs (" ATTRIBUTE_CONST", stdout);
 
diff --git a/lib-src/make-fingerprint.c b/lib-src/make-fingerprint.c
index 35bb8b98a0..5779e0d274 100644
--- a/lib-src/make-fingerprint.c
+++ b/lib-src/make-fingerprint.c
@@ -25,22 +25,41 @@ along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.  */
 
 #include <config.h>
 
+#include <limits.h>
 #include <stdarg.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/stat.h>
+
 #include <sysstdio.h>
-#include <sha256.h>
+
+#include <fingerprint.h>
 #include <getopt.h>
+#include <intprops.h>
+#include <min-max.h>
+#include <sha256.h>
+
+#ifndef SSIZE_MAX
+# define SSIZE_MAX TYPE_MAXIMUM (ssize_t)
+#endif
 
 #ifdef WINDOWSNT
 /* Defined to be sys_fopen in ms-w32.h, but only #ifdef emacs, so this
    is really just insurance.  */
 #undef fopen
 #include <direct.h>
+
+#ifndef MINGW_W64
+# undef fseeko
+# define fseeko fseeko64
+#endif
 #endif /* WINDOWSNT */
 
+/* Static (instead of being local to 'main') to pacify LeakSanitizer.  */
+static char *buf;
+
 int
 main (int argc, char **argv)
 {
@@ -54,41 +73,63 @@ main (int argc, char **argv)
           raw = true;
           break;
         case 'h':
-          printf ("make-fingerprint [-r] FILES...: compute a hash\n");
-          return 0;
+          printf ("make-fingerprint [-r] FILE: replace or compute a hash\n");
+          return EXIT_SUCCESS;
         default:
-          return 1;
+          return EXIT_FAILURE;
         }
     }
 
   struct sha256_ctx ctx;
   sha256_init_ctx (&ctx);
 
-  for (int i = optind; i < argc; ++i)
+  char *prog = argv[0];
+  char *file = argv[optind];
+  if (argc - optind != 1)
     {
-      FILE *f = fopen (argv[i], "r" FOPEN_BINARY);
-      if (!f)
-        {
-          fprintf (stderr, "%s: Error: could not open %s\n",
-                   argv[0], argv[i]);
-          return 1;
-        }
+      fprintf (stderr, "%s: missing or extra file operand\n", prog);
+      return EXIT_FAILURE;
+    }
 
-      char buf[128*1024];
-      do
-        {
-          size_t chunksz = fread (buf, 1, sizeof (buf), f);
-          if (ferror (f))
-            {
-              fprintf (stderr, "%s: Error: could not read %s\n",
-                       argv[0], argv[i]);
-              return 1;
-            }
-          sha256_process_bytes (buf, chunksz, &ctx);
-        } while (!feof (f));
-      fclose (f);
+  FILE *f = fopen (file, raw ? "r" FOPEN_BINARY : "r+" FOPEN_BINARY);
+  struct stat st;
+  if (!f || fstat (fileno (f), &st) != 0)
+    {
+      perror (file);
+      return EXIT_FAILURE;
+    }
+
+  if (!S_ISREG (st.st_mode))
+    {
+      fprintf (stderr, "%s: Error: %s is not a regular file\n",
+	       prog, file);
+      return EXIT_FAILURE;
     }
 
+  ptrdiff_t maxlen = min (min (TYPE_MAXIMUM (off_t), PTRDIFF_MAX),
+			  min (SIZE_MAX, SSIZE_MAX));
+  if (maxlen <= st.st_size)
+    {
+      fprintf (stderr, "%s: %s: file too big\n", prog, file);
+      return EXIT_FAILURE;
+    }
+
+  buf = malloc (st.st_size + 1);
+  if (!buf)
+    {
+      perror ("malloc");
+      return EXIT_FAILURE;
+    }
+
+  size_t chunksz = fread (buf, 1, st.st_size + 1, f);
+  if (ferror (f) || chunksz != st.st_size)
+    {
+      fprintf (stderr, "%s: Error: could not read %s\n", prog, file);
+      return EXIT_FAILURE;
+    }
+
+  sha256_process_bytes (buf, chunksz, &ctx);
+
   unsigned char digest[32];
   sha256_finish_ctx (&ctx, digest);
 
@@ -99,12 +140,33 @@ main (int argc, char **argv)
     }
   else
     {
-      puts ("#include \"fingerprint.h\"\n"
-	    "unsigned char const fingerprint[] =\n"
-	    "{");
-      for (int i = 0; i < 32; ++i)
-        printf ("\t0x%02X,\n", digest[i]);
-      puts ("};");
+      bool fingered = false;
+
+      for (char *finger = buf;
+	   (finger = memmem (finger, buf + chunksz - finger,
+			     fingerprint, sizeof fingerprint));
+	   finger++)
+	{
+	  if (! (fseeko (f, finger - buf, SEEK_SET) == 0
+		 && fwrite (digest, 1, sizeof digest, f) == sizeof digest))
+	    {
+	      perror (file);
+	      return EXIT_FAILURE;
+	    }
+	  fingered = true;
+	}
+
+      if (!fingered)
+	{
+	  fprintf (stderr, "%s: %s: missing fingerprint\n", prog, file);
+	  return EXIT_FAILURE;
+	}
+    }
+
+  if (fclose (f) != 0)
+    {
+      perror (file);
+      return EXIT_FAILURE;
     }
 
   return EXIT_SUCCESS;
diff --git a/lib-src/ntlib.c b/lib-src/ntlib.c
index dbafc47da2..d992f54a0f 100644
--- a/lib-src/ntlib.c
+++ b/lib-src/ntlib.c
@@ -290,8 +290,8 @@ is_exec (const char * name)
 /* FIXME?  This is in configure.ac now - is this still needed?  */
 #define IS_DIRECTORY_SEP(x) ((x) == '/' || (x) == '\\')
 
-/* We need this because nt/inc/sys/stat.h defines struct stat that is
-   incompatible with the MS run-time libraries.  */
+/* We need stat/fsfat below because nt/inc/sys/stat.h defines struct
+   stat that is incompatible with the MS run-time libraries.  */
 int
 stat (const char * path, struct stat * buf)
 {
@@ -377,7 +377,9 @@ stat (const char * path, struct stat * buf)
     buf->st_dev = _getdrive ();
   buf->st_rdev = buf->st_dev;
 
-  buf->st_size = wfd.nFileSizeLow;
+  buf->st_size = wfd.nFileSizeHigh;
+  buf->st_size <<= 32;
+  buf->st_size += wfd.nFileSizeLow;
 
   /* Convert timestamps to Unix format. */
   buf->st_mtime = convert_time (wfd.ftLastWriteTime);
@@ -408,6 +410,98 @@ lstat (const char * path, struct stat * buf)
   return stat (path, buf);
 }
 
+int
+fstat (int desc, struct stat * buf)
+{
+  HANDLE fh = (HANDLE) _get_osfhandle (desc);
+  BY_HANDLE_FILE_INFORMATION info;
+  unsigned __int64 fake_inode;
+  int permission;
+
+  if (!init)
+    {
+      /* Determine the delta between 1-Jan-1601 and 1-Jan-1970. */
+      SYSTEMTIME st;
+
+      st.wYear = 1970;
+      st.wMonth = 1;
+      st.wDay = 1;
+      st.wHour = 0;
+      st.wMinute = 0;
+      st.wSecond = 0;
+      st.wMilliseconds = 0;
+
+      SystemTimeToFileTime (&st, &utc_base_ft);
+      utc_base = (long double) utc_base_ft.dwHighDateTime
+	* 4096.0L * 1024.0L * 1024.0L + utc_base_ft.dwLowDateTime;
+      init = 1;
+    }
+
+  switch (GetFileType (fh) & ~FILE_TYPE_REMOTE)
+    {
+    case FILE_TYPE_DISK:
+      buf->st_mode = S_IFREG;
+      if (!GetFileInformationByHandle (fh, &info))
+	{
+	  errno = EACCES;
+	  return -1;
+	}
+      break;
+    case FILE_TYPE_PIPE:
+      buf->st_mode = S_IFIFO;
+      goto non_disk;
+    case FILE_TYPE_CHAR:
+    case FILE_TYPE_UNKNOWN:
+    default:
+      buf->st_mode = S_IFCHR;
+    non_disk:
+      memset (&info, 0, sizeof (info));
+      info.dwFileAttributes = 0;
+      info.ftCreationTime = utc_base_ft;
+      info.ftLastAccessTime = utc_base_ft;
+      info.ftLastWriteTime = utc_base_ft;
+    }
+
+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+      buf->st_mode = S_IFDIR;
+
+  buf->st_nlink = info.nNumberOfLinks;
+  /* Might as well use file index to fake inode values, but this
+     is not guaranteed to be unique unless we keep a handle open
+     all the time. */
+  fake_inode = info.nFileIndexHigh;
+  fake_inode <<= 32;
+  fake_inode += info.nFileIndexLow;
+  buf->st_ino = fake_inode;
+
+  buf->st_dev = info.dwVolumeSerialNumber;
+  buf->st_rdev = info.dwVolumeSerialNumber;
+
+  buf->st_size = info.nFileSizeHigh;
+  buf->st_size <<= 32;
+  buf->st_size += info.nFileSizeLow;
+
+  /* Convert timestamps to Unix format. */
+  buf->st_mtime = convert_time (info.ftLastWriteTime);
+  buf->st_atime = convert_time (info.ftLastAccessTime);
+  if (buf->st_atime == 0) buf->st_atime = buf->st_mtime;
+  buf->st_ctime = convert_time (info.ftCreationTime);
+  if (buf->st_ctime == 0) buf->st_ctime = buf->st_mtime;
+
+  /* determine rwx permissions */
+  if (info.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
+    permission = S_IREAD;
+  else
+    permission = S_IREAD | S_IWRITE;
+
+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+    permission |= S_IEXEC;
+
+  buf->st_mode |= permission | (permission >> 3) | (permission >> 6);
+
+  return 0;
+}
+
 /* On Windows, you cannot rename into an existing file.  */
 int
 sys_rename (const char *from, const char *to)
diff --git a/lib-src/pop.h b/lib-src/pop.h
index 81fa459d41..ff8a7a9fdb 100644
--- a/lib-src/pop.h
+++ b/lib-src/pop.h
@@ -1,7 +1,7 @@
 /* pop.h: Header file for the "pop.c" client POP3 protocol.
    Copyright (C) 1991, 1993, 2001-2019 Free Software Foundation, Inc.
 
-Author:  Jonathan Kamens <jik@security.ov.com>
+Author: Jonathan Kamens <jik@security.ov.com>
 
 This file is part of GNU Emacs.
 
diff --git a/lib-src/profile.c b/lib-src/profile.c
deleted file mode 100644
index 257008e92d..0000000000
--- a/lib-src/profile.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/* profile.c --- generate periodic events for profiling of Emacs Lisp code.
-   Copyright (C) 1992, 1994, 1999, 2001-2019 Free Software Foundation,
-   Inc.
-
-Author: Boaz Ben-Zvi <boaz@lcs.mit.edu>
-
-This file is part of GNU Emacs.
-
-GNU Emacs is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or (at
-your option) any later version.
-
-GNU Emacs is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
-
-
-/**
- **  To be run as an emacs subprocess.  Input string that starts with:
- **    'z' -- resets the watch (to zero).
- **    'p' -- return time (on stdout) as string with format <sec>.<micro-sec>
- **    'q' -- exit.
- **
- **  abstraction : a stopwatch
- **  operations: reset_watch, get_time
- */
-
-#include <config.h>
-
-#include <inttypes.h>
-#include <stdlib.h>
-
-#include <intprops.h>
-#include <timespec.h>
-#include <unlocked-io.h>
-
-static struct timespec TV1;
-static int watch_not_started = 1; /* flag */
-static char time_string[INT_STRLEN_BOUND (uintmax_t) + sizeof "."
-			+ LOG10_TIMESPEC_HZ];
-
-/* Reset the stopwatch to zero.  */
-
-static void
-reset_watch (void)
-{
-  TV1 = current_timespec ();
-  watch_not_started = 0;
-}
-
-/* This call returns the time since the last reset_watch call.  The time
-   is returned as a string with the format  <seconds>.<nanoseconds>
-   If reset_watch was not called yet, exit.  */
-
-static char *
-get_time (void)
-{
-  struct timespec TV2 = timespec_sub (current_timespec (), TV1);
-  uintmax_t s = TV2.tv_sec;
-  int ns = TV2.tv_nsec;
-  if (watch_not_started)
-    exit (EXIT_FAILURE);  /* call reset_watch first ! */
-  sprintf (time_string, "%"PRIuMAX".%0*d", s, LOG10_TIMESPEC_HZ, ns);
-  return time_string;
-}
-
-int
-main (void)
-{
-  int c;
-  while ((c = getchar ()) != EOF)
-    {
-      switch (c)
-	{
-	case 'z':
-	  reset_watch ();
-	  break;
-	case 'p':
-	  puts (get_time ());
-	  break;
-	case 'q':
-	  return EXIT_SUCCESS;
-	}
-      /* Anything remaining on the line is ignored.  */
-      while (c != '\n' && c != EOF)
-	c = getchar ();
-    }
-  return EXIT_FAILURE;
-}
-
-
-/* profile.c ends here */
diff --git a/lib-src/rcs2log b/lib-src/rcs2log
index 2368780b7c..0e62bf6386 100755
--- a/lib-src/rcs2log
+++ b/lib-src/rcs2log
@@ -4,7 +4,7 @@
 
 # Copyright (C) 1992-1998, 2001-2019 Free Software Foundation, Inc.
 
-# Author: Paul Eggert <eggert@twinsun.com>
+# Author: Paul Eggert <eggert@cs.ucla.edu>
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -25,7 +25,7 @@ This program comes with NO WARRANTY, to the extent permitted by law.
 You may redistribute copies of this program
 under the terms of the GNU General Public License.
 For more information about these matters, see the files named COPYING.
-Author: Paul Eggert <eggert@twinsun.com>'
+Author: Paul Eggert <eggert@cs.ucla.edu>'
 
 Help='
 Generate ChangeLog entries from RCS files (perhaps in a CVS repository)
diff --git a/lib/Makefile.in b/lib/Makefile.in
index f2d203564a..ac32c7070f 100644
--- a/lib/Makefile.in
+++ b/lib/Makefile.in
@@ -84,7 +84,7 @@ Makefile: ../config.status $(srcdir)/Makefile.in
 # and building it would just waste time.
 not_emacs_OBJECTS = regex.o
 
-libgnu_a_OBJECTS = $(gl_LIBOBJS) \
+libgnu_a_OBJECTS = fingerprint.o $(gl_LIBOBJS) \
   $(patsubst %.c,%.o,$(filter %.c,$(libgnu_a_SOURCES)))
 for_emacs_OBJECTS = $(filter-out $(not_emacs_OBJECTS),$(libgnu_a_OBJECTS))
 libegnu_a_OBJECTS = $(patsubst %.o,e-%.o,$(for_emacs_OBJECTS))
diff --git a/lib/_Noreturn.h b/lib/_Noreturn.h
index 7594e4b0c0..db9b45554c 100644
--- a/lib/_Noreturn.h
+++ b/lib/_Noreturn.h
@@ -1,3 +1,19 @@
+/* A C macro for declaring that a function does not return.
+   Copyright (C) 2011-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
 #ifndef _Noreturn
 # if (defined __cplusplus \
       && ((201103 <= __cplusplus && !(__GNUC__ == 4 && __GNUC_MINOR__ == 7)) \
diff --git a/lib/fingerprint.c b/lib/fingerprint.c
new file mode 100644
index 0000000000..e55de9c6da
--- /dev/null
+++ b/lib/fingerprint.c
@@ -0,0 +1,66 @@
+/* Placeholder fingerprint for Emacs
+
+Copyright 2019 Free Software Foundation, Inc.
+
+This file is part of GNU Emacs.
+
+GNU Emacs is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or (at
+your option) any later version.
+
+GNU Emacs is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#include "fingerprint.h"
+
+/* This random fingerprint was generated by the shell command:
+
+   shuf -i 0-255 -n 32 -r | awk '{printf "   0x%.02X,\n", $0}'
+
+   In the final Emacs executable, this random fingerprint is replaced
+   by a fingerprint of the temporary Emacs executable that was built
+   along the way.  */
+
+unsigned char const fingerprint[] =
+  {
+   0xDE,
+   0x86,
+   0xBB,
+   0x99,
+   0xFF,
+   0xF5,
+   0x46,
+   0x9A,
+   0x9E,
+   0x3F,
+   0x9F,
+   0x5D,
+   0x9A,
+   0xDF,
+   0xF0,
+   0x91,
+   0xBD,
+   0xCD,
+   0xC1,
+   0xE8,
+   0x0C,
+   0x16,
+   0x1E,
+   0xAF,
+   0xB8,
+   0x6C,
+   0xE2,
+   0x2B,
+   0xB1,
+   0x24,
+   0xCE,
+   0xB0,
+  };
diff --git a/src/fingerprint.h b/lib/fingerprint.h
similarity index 100%
rename from src/fingerprint.h
rename to lib/fingerprint.h
diff --git a/lib/flexmember.h b/lib/flexmember.h
index 0d65f6da60..af17b41d29 100644
--- a/lib/flexmember.h
+++ b/lib/flexmember.h
@@ -33,11 +33,26 @@
 # define FLEXALIGNOF(type) _Alignof (type)
 #endif
 
-/* Upper bound on the size of a struct of type TYPE with a flexible
-   array member named MEMBER that is followed by N bytes of other data.
-   This is not simply sizeof (TYPE) + N, since it may require
-   alignment on unusually picky C11 platforms, and
-   FLEXIBLE_ARRAY_MEMBER may be 1 on pre-C11 platforms.
+/* Yield a properly aligned upper bound on the size of a struct of
+   type TYPE with a flexible array member named MEMBER that is
+   followed by N bytes of other data.  The result is suitable as an
+   argument to malloc.  For example:
+
+     struct s { int n; char d[FLEXIBLE_ARRAY_MEMBER]; };
+     struct s *p = malloc (FLEXSIZEOF (struct s, d, n * sizeof (char)));
+
+   FLEXSIZEOF (TYPE, MEMBER, N) is not simply (sizeof (TYPE) + N),
+   since FLEXIBLE_ARRAY_MEMBER may be 1 on pre-C11 platforms.  Nor is
+   it simply (offsetof (TYPE, MEMBER) + N), as that might yield a size
+   that causes malloc to yield a pointer that is not properly aligned
+   for TYPE; for example, if sizeof (int) == alignof (int) == 4,
+   malloc (offsetof (struct s, d) + 3 * sizeof (char)) is equivalent
+   to malloc (7) and might yield a pointer that is not a multiple of 4
+   (which means the pointer is not properly aligned for struct s),
+   whereas malloc (FLEXSIZEOF (struct s, d, 3 * sizeof (char))) is
+   equivalent to malloc (8) and must yield a pointer that is a
+   multiple of 4.
+
    Yield a value less than N if and only if arithmetic overflow occurs.  */
 
 #define FLEXSIZEOF(type, member, n) \
diff --git a/lib/gnulib.mk.in b/lib/gnulib.mk.in
index 0d9a885be3..1cbbff212b 100644
--- a/lib/gnulib.mk.in
+++ b/lib/gnulib.mk.in
@@ -44,6 +44,7 @@
 #  --avoid=malloc-posix \
 #  --avoid=mbrtowc \
 #  --avoid=mbsinit \
+#  --avoid=memchr \
 #  --avoid=mkdir \
 #  --avoid=msvc-inval \
 #  --avoid=msvc-nothrow \
@@ -111,6 +112,7 @@
 #  largefile \
 #  lstat \
 #  manywarnings \
+#  memmem-simple \
 #  memrchr \
 #  minmax \
 #  mkostemp \
@@ -179,6 +181,7 @@ CAIRO_LIBS = @CAIRO_LIBS@
 CC = @CC@
 CFLAGS = @CFLAGS@
 CFLAGS_SOUND = @CFLAGS_SOUND@
+CHECK_STRUCTS = @CHECK_STRUCTS@
 CLIENTRES = @CLIENTRES@
 CLIENTW = @CLIENTW@
 CM_OBJ = @CM_OBJ@
@@ -588,6 +591,7 @@ HAVE_OPENAT = @HAVE_OPENAT@
 HAVE_OPENDIR = @HAVE_OPENDIR@
 HAVE_OS_H = @HAVE_OS_H@
 HAVE_PCLOSE = @HAVE_PCLOSE@
+HAVE_PDUMPER = @HAVE_PDUMPER@
 HAVE_PIPE = @HAVE_PIPE@
 HAVE_PIPE2 = @HAVE_PIPE2@
 HAVE_POPEN = @HAVE_POPEN@
@@ -1042,6 +1046,7 @@ datadir = @datadir@
 datarootdir = @datarootdir@
 docdir = @docdir@
 dvidir = @dvidir@
+emacs_major_version = @emacs_major_version@
 etcdir = @etcdir@
 etcdocdir = @etcdocdir@
 exec_prefix = @exec_prefix@
@@ -1052,7 +1057,6 @@ gl_GNULIB_ENABLED_03e0aaad4cb89ca757653bd367a6ccb7 = @gl_GNULIB_ENABLED_03e0aaad
 gl_GNULIB_ENABLED_2049e887c7e5308faad27b3f894bb8c9 = @gl_GNULIB_ENABLED_2049e887c7e5308faad27b3f894bb8c9@
 gl_GNULIB_ENABLED_21ee726a3540c09237a8e70c0baf7467 = @gl_GNULIB_ENABLED_21ee726a3540c09237a8e70c0baf7467@
 gl_GNULIB_ENABLED_260941c0e5dc67ec9e87d1fb321c300b = @gl_GNULIB_ENABLED_260941c0e5dc67ec9e87d1fb321c300b@
-gl_GNULIB_ENABLED_37f71b604aa9c54446783d80f42fe547 = @gl_GNULIB_ENABLED_37f71b604aa9c54446783d80f42fe547@
 gl_GNULIB_ENABLED_5264294aa0a5557541b53c8c741f7f31 = @gl_GNULIB_ENABLED_5264294aa0a5557541b53c8c741f7f31@
 gl_GNULIB_ENABLED_6099e9737f757db36c47fa9d9f02e88c = @gl_GNULIB_ENABLED_6099e9737f757db36c47fa9d9f02e88c@
 gl_GNULIB_ENABLED_682e609604ccaac6be382e4ee3a4eaec = @gl_GNULIB_ENABLED_682e609604ccaac6be382e4ee3a4eaec@
@@ -1962,6 +1966,17 @@ EXTRA_libgnu_a_SOURCES += lstat.c
 endif
 ## end   gnulib module lstat
 
+## begin gnulib module memmem-simple
+ifeq (,$(OMIT_GNULIB_MODULE_memmem-simple))
+
+
+EXTRA_DIST += memmem.c str-two-way.h
+
+EXTRA_libgnu_a_SOURCES += memmem.c
+
+endif
+## end   gnulib module memmem-simple
+
 ## begin gnulib module memrchr
 ifeq (,$(OMIT_GNULIB_MODULE_memrchr))
 
diff --git a/lib/memmem.c b/lib/memmem.c
new file mode 100644
index 0000000000..12ae24f41b
--- /dev/null
+++ b/lib/memmem.c
@@ -0,0 +1,71 @@
+/* Copyright (C) 1991-1994, 1996-1998, 2000, 2004, 2007-2019 Free Software
+   Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+/* This particular implementation was written by Eric Blake, 2008.  */
+
+#ifndef _LIBC
+# include <config.h>
+#endif
+
+/* Specification of memmem.  */
+#include <string.h>
+
+#define RETURN_TYPE void *
+#define AVAILABLE(h, h_l, j, n_l) ((j) <= (h_l) - (n_l))
+#include "str-two-way.h"
+
+/* Return the first occurrence of NEEDLE in HAYSTACK.  Return HAYSTACK
+   if NEEDLE_LEN is 0, otherwise NULL if NEEDLE is not found in
+   HAYSTACK.  */
+void *
+memmem (const void *haystack_start, size_t haystack_len,
+        const void *needle_start, size_t needle_len)
+{
+  /* Abstract memory is considered to be an array of 'unsigned char' values,
+     not an array of 'char' values.  See ISO C 99 section 6.2.6.1.  */
+  const unsigned char *haystack = (const unsigned char *) haystack_start;
+  const unsigned char *needle = (const unsigned char *) needle_start;
+
+  if (needle_len == 0)
+    /* The first occurrence of the empty string is deemed to occur at
+       the beginning of the string.  */
+    return (void *) haystack;
+
+  /* Sanity check, otherwise the loop might search through the whole
+     memory.  */
+  if (__builtin_expect (haystack_len < needle_len, 0))
+    return NULL;
+
+  /* Use optimizations in memchr when possible, to reduce the search
+     size of haystack using a linear algorithm with a smaller
+     coefficient.  However, avoid memchr for long needles, since we
+     can often achieve sublinear performance.  */
+  if (needle_len < LONG_NEEDLE_THRESHOLD)
+    {
+      haystack = memchr (haystack, *needle, haystack_len);
+      if (!haystack || __builtin_expect (needle_len == 1, 0))
+        return (void *) haystack;
+      haystack_len -= haystack - (const unsigned char *) haystack_start;
+      if (haystack_len < needle_len)
+        return NULL;
+      return two_way_short_needle (haystack, haystack_len, needle, needle_len);
+    }
+  else
+    return two_way_long_needle (haystack, haystack_len, needle, needle_len);
+}
+
+#undef LONG_NEEDLE_THRESHOLD
diff --git a/lib/mktime-internal.h b/lib/mktime-internal.h
index d13d89cfae..52ab781442 100644
--- a/lib/mktime-internal.h
+++ b/lib/mktime-internal.h
@@ -1,40 +1,56 @@
-/* mktime variant that also uses an offset guess
-
+/* Internals of mktime and related functions
    Copyright 2016-2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Eggert <eggert@cs.ucla.edu>.
 
-   This program is free software; you can redistribute it and/or
+   The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.
 
-   This program is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
 
    You should have received a copy of the GNU General Public
-   License along with this program; if not, see
+   License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <time.h>
+#ifndef _LIBC
+# include <time.h>
+#endif
 
 /* mktime_offset_t is a signed type wide enough to hold a UTC offset
    in seconds, and used as part of the type of the offset-guess
-   argument to mktime_internal.  Use time_t on platforms where time_t
+   argument to mktime_internal.  In Glibc, it is always long int.
+   When in Gnulib, use time_t on platforms where time_t
    is signed, to be compatible with platforms like BeOS that export
    this implementation detail of mktime.  On platforms where time_t is
    unsigned, GNU and POSIX code can assume 'int' is at least 32 bits
    which is wide enough for a UTC offset.  */
-
-#if TIME_T_IS_SIGNED
+#ifdef _LIBC
+typedef long int mktime_offset_t;
+#elif defined TIME_T_IS_SIGNED
 typedef time_t mktime_offset_t;
 #else
 typedef int mktime_offset_t;
 #endif
 
-time_t mktime_internal (struct tm *,
-                        struct tm * (*) (time_t const *, struct tm *),
-                        mktime_offset_t *);
+/* The source code uses identifiers like __time64_t for glibc
+   timestamps that can contain 64-bit values even when time_t is only
+   32 bits.  These are just macros for the ordinary identifiers unless
+   compiling within glibc when time_t is 32 bits.  */
+#if ! (defined _LIBC && __TIMESIZE != 64)
+# undef __time64_t
+# define __time64_t time_t
+# define __gmtime64_r __gmtime_r
+# define __localtime64_r __localtime_r
+# define __mktime64 mktime
+# define __timegm64 timegm
+#endif
+
+#ifndef _LIBC
 
 /* Although glibc source code uses leading underscores, Gnulib wants
    ordinary names.
@@ -45,9 +61,19 @@ time_t mktime_internal (struct tm *,
    Similarly for gmtime_r.  See the gnulib time_r module for one way
    to implement this.  */
 
-#undef __gmtime_r
-#undef __localtime_r
-#define __gmtime_r gmtime_r
-#define __localtime_r localtime_r
+# undef __gmtime_r
+# undef __localtime_r
+# define __gmtime_r gmtime_r
+# define __localtime_r localtime_r
+
+# define __mktime_internal mktime_internal
+
+#endif
 
-#define __mktime_internal mktime_internal
+/* Subroutine of mktime.  Return the time_t representation of TP and
+   normalize TP, given that a struct tm * maps to a time_t as performed
+   by FUNC.  Record next guess for localtime-gmtime offset in *OFFSET.  */
+extern __time64_t __mktime_internal (struct tm *tp,
+                                     struct tm *(*func) (__time64_t const *,
+                                                         struct tm *),
+                                     mktime_offset_t *offset) attribute_hidden;
diff --git a/lib/mktime.c b/lib/mktime.c
index e3783d7a95..b00af96c8c 100644
--- a/lib/mktime.c
+++ b/lib/mktime.c
@@ -112,11 +112,11 @@ my_tzset (void)
    added to them, and then with another timestamp added, without
    worrying about overflow.
 
-   Much of the code uses long_int to represent time_t values, to
-   lessen the hassle of dealing with platforms where time_t is
+   Much of the code uses long_int to represent __time64_t values, to
+   lessen the hassle of dealing with platforms where __time64_t is
    unsigned, and because long_int should suffice to represent all
-   time_t values that mktime can generate even on platforms where
-   time_t is excessively wide.  */
+   __time64_t values that mktime can generate even on platforms where
+   __time64_t is wider than the int components of struct tm.  */
 
 #if INT_MAX <= LONG_MAX / 4 / 366 / 24 / 60 / 60
 typedef long int long_int;
@@ -144,16 +144,15 @@ shr (long_int a, int b)
 	  : a / (one << b) - (a % (one << b) < 0));
 }
 
-/* Bounds for the intersection of time_t and long_int.  */
+/* Bounds for the intersection of __time64_t and long_int.  */
 
 static long_int const mktime_min
-  = ((TYPE_SIGNED (time_t) && TYPE_MINIMUM (time_t) < TYPE_MINIMUM (long_int))
-     ? TYPE_MINIMUM (long_int) : TYPE_MINIMUM (time_t));
+  = ((TYPE_SIGNED (__time64_t)
+      && TYPE_MINIMUM (__time64_t) < TYPE_MINIMUM (long_int))
+     ? TYPE_MINIMUM (long_int) : TYPE_MINIMUM (__time64_t));
 static long_int const mktime_max
-  = (TYPE_MAXIMUM (long_int) < TYPE_MAXIMUM (time_t)
-     ? TYPE_MAXIMUM (long_int) : TYPE_MAXIMUM (time_t));
-
-verify (TYPE_IS_INTEGER (time_t));
+  = (TYPE_MAXIMUM (long_int) < TYPE_MAXIMUM (__time64_t)
+     ? TYPE_MAXIMUM (long_int) : TYPE_MAXIMUM (__time64_t));
 
 #define EPOCH_YEAR 1970
 #define TM_YEAR_BASE 1900
@@ -252,23 +251,23 @@ tm_diff (long_int year, long_int yday, int hour, int min, int sec,
 }
 
 /* Use CONVERT to convert T to a struct tm value in *TM.  T must be in
-   range for time_t.  Return TM if successful, NULL (setting errno) on
+   range for __time64_t.  Return TM if successful, NULL (setting errno) on
    failure.  */
 static struct tm *
-convert_time (struct tm *(*convert) (const time_t *, struct tm *),
+convert_time (struct tm *(*convert) (const __time64_t *, struct tm *),
 	      long_int t, struct tm *tm)
 {
-  time_t x = t;
+  __time64_t x = t;
   return convert (&x, tm);
 }
 
 /* Use CONVERT to convert *T to a broken down time in *TP.
    If *T is out of range for conversion, adjust it so that
    it is the nearest in-range value and then convert that.
-   A value is in range if it fits in both time_t and long_int.
+   A value is in range if it fits in both __time64_t and long_int.
    Return TP on success, NULL (setting errno) on failure.  */
 static struct tm *
-ranged_convert (struct tm *(*convert) (const time_t *, struct tm *),
+ranged_convert (struct tm *(*convert) (const __time64_t *, struct tm *),
 		long_int *t, struct tm *tp)
 {
   long_int t1 = (*t < mktime_min ? mktime_min
@@ -310,7 +309,7 @@ ranged_convert (struct tm *(*convert) (const time_t *, struct tm *),
 }
 
 
-/* Convert *TP to a time_t value, inverting
+/* Convert *TP to a __time64_t value, inverting
    the monotonic and mostly-unit-linear conversion function CONVERT.
    Use *OFFSET to keep track of a guess at the offset of the result,
    compared to what the result would be for UTC without leap seconds.
@@ -318,9 +317,9 @@ ranged_convert (struct tm *(*convert) (const time_t *, struct tm *),
    If successful, set *TP to the canonicalized struct tm;
    otherwise leave *TP alone, return ((time_t) -1) and set errno.
    This function is external because it is used also by timegm.c.  */
-time_t
+__time64_t
 __mktime_internal (struct tm *tp,
-		   struct tm *(*convert) (const time_t *, struct tm *),
+		   struct tm *(*convert) (const __time64_t *, struct tm *),
 		   mktime_offset_t *offset)
 {
   struct tm tm;
@@ -520,9 +519,9 @@ __mktime_internal (struct tm *tp,
 
 #if defined _LIBC || NEED_MKTIME_WORKING || NEED_MKTIME_WINDOWS
 
-/* Convert *TP to a time_t value.  */
-time_t
-mktime (struct tm *tp)
+/* Convert *TP to a __time64_t value.  */
+__time64_t
+__mktime64 (struct tm *tp)
 {
   /* POSIX.1 8.1.1 requires that whenever mktime() is called, the
      time zone names contained in the external variable 'tzname' shall
@@ -531,7 +530,7 @@ mktime (struct tm *tp)
 
 # if defined _LIBC || NEED_MKTIME_WORKING
   static mktime_offset_t localtime_offset;
-  return __mktime_internal (tp, __localtime_r, &localtime_offset);
+  return __mktime_internal (tp, __localtime64_r, &localtime_offset);
 # else
 #  undef mktime
   return mktime (tp);
@@ -539,11 +538,29 @@ mktime (struct tm *tp)
 }
 #endif /* _LIBC || NEED_MKTIME_WORKING || NEED_MKTIME_WINDOWS */
 
-#ifdef weak_alias
-weak_alias (mktime, timelocal)
+#if defined _LIBC && __TIMESIZE != 64
+
+libc_hidden_def (__mktime64)
+
+time_t
+mktime (struct tm *tp)
+{
+  struct tm tm = *tp;
+  __time64_t t = __mktime64 (&tm);
+  if (in_time_t_range (t))
+    {
+      *tp = tm;
+      return t;
+    }
+  else
+    {
+      __set_errno (EOVERFLOW);
+      return -1;
+    }
+}
+
 #endif
 
-#ifdef _LIBC
+weak_alias (mktime, timelocal)
 libc_hidden_def (mktime)
 libc_hidden_weak (timelocal)
-#endif
diff --git a/lib/str-two-way.h b/lib/str-two-way.h
new file mode 100644
index 0000000000..7078c34bdc
--- /dev/null
+++ b/lib/str-two-way.h
@@ -0,0 +1,452 @@
+/* Byte-wise substring search, using the Two-Way algorithm.
+   Copyright (C) 2008-2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Written by Eric Blake <ebb9@byu.net>, 2008.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+/* Before including this file, you need to include <config.h> and
+   <string.h>, and define:
+     RETURN_TYPE             A macro that expands to the return type.
+     AVAILABLE(h, h_l, j, n_l)
+                             A macro that returns nonzero if there are
+                             at least N_L bytes left starting at H[J].
+                             H is 'unsigned char *', H_L, J, and N_L
+                             are 'size_t'; H_L is an lvalue.  For
+                             NUL-terminated searches, H_L can be
+                             modified each iteration to avoid having
+                             to compute the end of H up front.
+
+  For case-insensitivity, you may optionally define:
+     CMP_FUNC(p1, p2, l)     A macro that returns 0 iff the first L
+                             characters of P1 and P2 are equal.
+     CANON_ELEMENT(c)        A macro that canonicalizes an element right after
+                             it has been fetched from one of the two strings.
+                             The argument is an 'unsigned char'; the result
+                             must be an 'unsigned char' as well.
+
+  This file undefines the macros documented above, and defines
+  LONG_NEEDLE_THRESHOLD.
+*/
+
+#include <limits.h>
+#include <stdint.h>
+
+/* We use the Two-Way string matching algorithm (also known as
+   Chrochemore-Perrin), which guarantees linear complexity with
+   constant space.  Additionally, for long needles, we also use a bad
+   character shift table similar to the Boyer-Moore algorithm to
+   achieve improved (potentially sub-linear) performance.
+
+   See http://www-igm.univ-mlv.fr/~lecroq/string/node26.html#SECTION00260,
+   https://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm,
+   https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.34.6641&rep=rep1&type=pdf
+*/
+
+/* Point at which computing a bad-byte shift table is likely to be
+   worthwhile.  Small needles should not compute a table, since it
+   adds (1 << CHAR_BIT) + NEEDLE_LEN computations of preparation for a
+   speedup no greater than a factor of NEEDLE_LEN.  The larger the
+   needle, the better the potential performance gain.  On the other
+   hand, on non-POSIX systems with CHAR_BIT larger than eight, the
+   memory required for the table is prohibitive.  */
+#if CHAR_BIT < 10
+# define LONG_NEEDLE_THRESHOLD 32U
+#else
+# define LONG_NEEDLE_THRESHOLD SIZE_MAX
+#endif
+
+#ifndef MAX
+# define MAX(a, b) ((a < b) ? (b) : (a))
+#endif
+
+#ifndef CANON_ELEMENT
+# define CANON_ELEMENT(c) c
+#endif
+#ifndef CMP_FUNC
+# define CMP_FUNC memcmp
+#endif
+
+/* Perform a critical factorization of NEEDLE, of length NEEDLE_LEN.
+   Return the index of the first byte in the right half, and set
+   *PERIOD to the global period of the right half.
+
+   The global period of a string is the smallest index (possibly its
+   length) at which all remaining bytes in the string are repetitions
+   of the prefix (the last repetition may be a subset of the prefix).
+
+   When NEEDLE is factored into two halves, a local period is the
+   length of the smallest word that shares a suffix with the left half
+   and shares a prefix with the right half.  All factorizations of a
+   non-empty NEEDLE have a local period of at least 1 and no greater
+   than NEEDLE_LEN.
+
+   A critical factorization has the property that the local period
+   equals the global period.  All strings have at least one critical
+   factorization with the left half smaller than the global period.
+   And while some strings have more than one critical factorization,
+   it is provable that with an ordered alphabet, at least one of the
+   critical factorizations corresponds to a maximal suffix.
+
+   Given an ordered alphabet, a critical factorization can be computed
+   in linear time, with 2 * NEEDLE_LEN comparisons, by computing the
+   shorter of two ordered maximal suffixes.  The ordered maximal
+   suffixes are determined by lexicographic comparison while tracking
+   periodicity.  */
+static size_t
+critical_factorization (const unsigned char *needle, size_t needle_len,
+                        size_t *period)
+{
+  /* Index of last byte of left half, or SIZE_MAX.  */
+  size_t max_suffix, max_suffix_rev;
+  size_t j; /* Index into NEEDLE for current candidate suffix.  */
+  size_t k; /* Offset into current period.  */
+  size_t p; /* Intermediate period.  */
+  unsigned char a, b; /* Current comparison bytes.  */
+
+  /* Special case NEEDLE_LEN of 1 or 2 (all callers already filtered
+     out 0-length needles.  */
+  if (needle_len < 3)
+    {
+      *period = 1;
+      return needle_len - 1;
+    }
+
+  /* Invariants:
+     0 <= j < NEEDLE_LEN - 1
+     -1 <= max_suffix{,_rev} < j (treating SIZE_MAX as if it were signed)
+     min(max_suffix, max_suffix_rev) < global period of NEEDLE
+     1 <= p <= global period of NEEDLE
+     p == global period of the substring NEEDLE[max_suffix{,_rev}+1...j]
+     1 <= k <= p
+  */
+
+  /* Perform lexicographic search.  */
+  max_suffix = SIZE_MAX;
+  j = 0;
+  k = p = 1;
+  while (j + k < needle_len)
+    {
+      a = CANON_ELEMENT (needle[j + k]);
+      b = CANON_ELEMENT (needle[max_suffix + k]);
+      if (a < b)
+        {
+          /* Suffix is smaller, period is entire prefix so far.  */
+          j += k;
+          k = 1;
+          p = j - max_suffix;
+        }
+      else if (a == b)
+        {
+          /* Advance through repetition of the current period.  */
+          if (k != p)
+            ++k;
+          else
+            {
+              j += p;
+              k = 1;
+            }
+        }
+      else /* b < a */
+        {
+          /* Suffix is larger, start over from current location.  */
+          max_suffix = j++;
+          k = p = 1;
+        }
+    }
+  *period = p;
+
+  /* Perform reverse lexicographic search.  */
+  max_suffix_rev = SIZE_MAX;
+  j = 0;
+  k = p = 1;
+  while (j + k < needle_len)
+    {
+      a = CANON_ELEMENT (needle[j + k]);
+      b = CANON_ELEMENT (needle[max_suffix_rev + k]);
+      if (b < a)
+        {
+          /* Suffix is smaller, period is entire prefix so far.  */
+          j += k;
+          k = 1;
+          p = j - max_suffix_rev;
+        }
+      else if (a == b)
+        {
+          /* Advance through repetition of the current period.  */
+          if (k != p)
+            ++k;
+          else
+            {
+              j += p;
+              k = 1;
+            }
+        }
+      else /* a < b */
+        {
+          /* Suffix is larger, start over from current location.  */
+          max_suffix_rev = j++;
+          k = p = 1;
+        }
+    }
+
+  /* Choose the shorter suffix.  Return the index of the first byte of
+     the right half, rather than the last byte of the left half.
+
+     For some examples, 'banana' has two critical factorizations, both
+     exposed by the two lexicographic extreme suffixes of 'anana' and
+     'nana', where both suffixes have a period of 2.  On the other
+     hand, with 'aab' and 'bba', both strings have a single critical
+     factorization of the last byte, with the suffix having a period
+     of 1.  While the maximal lexicographic suffix of 'aab' is 'b',
+     the maximal lexicographic suffix of 'bba' is 'ba', which is not a
+     critical factorization.  Conversely, the maximal reverse
+     lexicographic suffix of 'a' works for 'bba', but not 'ab' for
+     'aab'.  The shorter suffix of the two will always be a critical
+     factorization.  */
+  if (max_suffix_rev + 1 < max_suffix + 1)
+    return max_suffix + 1;
+  *period = p;
+  return max_suffix_rev + 1;
+}
+
+/* Return the first location of non-empty NEEDLE within HAYSTACK, or
+   NULL.  HAYSTACK_LEN is the minimum known length of HAYSTACK.  This
+   method is optimized for NEEDLE_LEN < LONG_NEEDLE_THRESHOLD.
+   Performance is guaranteed to be linear, with an initialization cost
+   of 2 * NEEDLE_LEN comparisons.
+
+   If AVAILABLE does not modify HAYSTACK_LEN (as in memmem), then at
+   most 2 * HAYSTACK_LEN - NEEDLE_LEN comparisons occur in searching.
+   If AVAILABLE modifies HAYSTACK_LEN (as in strstr), then at most 3 *
+   HAYSTACK_LEN - NEEDLE_LEN comparisons occur in searching.  */
+static RETURN_TYPE
+two_way_short_needle (const unsigned char *haystack, size_t haystack_len,
+                      const unsigned char *needle, size_t needle_len)
+{
+  size_t i; /* Index into current byte of NEEDLE.  */
+  size_t j; /* Index into current window of HAYSTACK.  */
+  size_t period; /* The period of the right half of needle.  */
+  size_t suffix; /* The index of the right half of needle.  */
+
+  /* Factor the needle into two halves, such that the left half is
+     smaller than the global period, and the right half is
+     periodic (with a period as large as NEEDLE_LEN - suffix).  */
+  suffix = critical_factorization (needle, needle_len, &period);
+
+  /* Perform the search.  Each iteration compares the right half
+     first.  */
+  if (CMP_FUNC (needle, needle + period, suffix) == 0)
+    {
+      /* Entire needle is periodic; a mismatch in the left half can
+         only advance by the period, so use memory to avoid rescanning
+         known occurrences of the period in the right half.  */
+      size_t memory = 0;
+      j = 0;
+      while (AVAILABLE (haystack, haystack_len, j, needle_len))
+        {
+          /* Scan for matches in right half.  */
+          i = MAX (suffix, memory);
+          while (i < needle_len && (CANON_ELEMENT (needle[i])
+                                    == CANON_ELEMENT (haystack[i + j])))
+            ++i;
+          if (needle_len <= i)
+            {
+              /* Scan for matches in left half.  */
+              i = suffix - 1;
+              while (memory < i + 1 && (CANON_ELEMENT (needle[i])
+                                        == CANON_ELEMENT (haystack[i + j])))
+                --i;
+              if (i + 1 < memory + 1)
+                return (RETURN_TYPE) (haystack + j);
+              /* No match, so remember how many repetitions of period
+                 on the right half were scanned.  */
+              j += period;
+              memory = needle_len - period;
+            }
+          else
+            {
+              j += i - suffix + 1;
+              memory = 0;
+            }
+        }
+    }
+  else
+    {
+      /* The two halves of needle are distinct; no extra memory is
+         required, and any mismatch results in a maximal shift.  */
+      period = MAX (suffix, needle_len - suffix) + 1;
+      j = 0;
+      while (AVAILABLE (haystack, haystack_len, j, needle_len))
+        {
+          /* Scan for matches in right half.  */
+          i = suffix;
+          while (i < needle_len && (CANON_ELEMENT (needle[i])
+                                    == CANON_ELEMENT (haystack[i + j])))
+            ++i;
+          if (needle_len <= i)
+            {
+              /* Scan for matches in left half.  */
+              i = suffix - 1;
+              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])
+                                       == CANON_ELEMENT (haystack[i + j])))
+                --i;
+              if (i == SIZE_MAX)
+                return (RETURN_TYPE) (haystack + j);
+              j += period;
+            }
+          else
+            j += i - suffix + 1;
+        }
+    }
+  return NULL;
+}
+
+/* Return the first location of non-empty NEEDLE within HAYSTACK, or
+   NULL.  HAYSTACK_LEN is the minimum known length of HAYSTACK.  This
+   method is optimized for LONG_NEEDLE_THRESHOLD <= NEEDLE_LEN.
+   Performance is guaranteed to be linear, with an initialization cost
+   of 3 * NEEDLE_LEN + (1 << CHAR_BIT) operations.
+
+   If AVAILABLE does not modify HAYSTACK_LEN (as in memmem), then at
+   most 2 * HAYSTACK_LEN - NEEDLE_LEN comparisons occur in searching,
+   and sublinear performance O(HAYSTACK_LEN / NEEDLE_LEN) is possible.
+   If AVAILABLE modifies HAYSTACK_LEN (as in strstr), then at most 3 *
+   HAYSTACK_LEN - NEEDLE_LEN comparisons occur in searching, and
+   sublinear performance is not possible.  */
+static RETURN_TYPE
+two_way_long_needle (const unsigned char *haystack, size_t haystack_len,
+                     const unsigned char *needle, size_t needle_len)
+{
+  size_t i; /* Index into current byte of NEEDLE.  */
+  size_t j; /* Index into current window of HAYSTACK.  */
+  size_t period; /* The period of the right half of needle.  */
+  size_t suffix; /* The index of the right half of needle.  */
+  size_t shift_table[1U << CHAR_BIT]; /* See below.  */
+
+  /* Factor the needle into two halves, such that the left half is
+     smaller than the global period, and the right half is
+     periodic (with a period as large as NEEDLE_LEN - suffix).  */
+  suffix = critical_factorization (needle, needle_len, &period);
+
+  /* Populate shift_table.  For each possible byte value c,
+     shift_table[c] is the distance from the last occurrence of c to
+     the end of NEEDLE, or NEEDLE_LEN if c is absent from the NEEDLE.
+     shift_table[NEEDLE[NEEDLE_LEN - 1]] contains the only 0.  */
+  for (i = 0; i < 1U << CHAR_BIT; i++)
+    shift_table[i] = needle_len;
+  for (i = 0; i < needle_len; i++)
+    shift_table[CANON_ELEMENT (needle[i])] = needle_len - i - 1;
+
+  /* Perform the search.  Each iteration compares the right half
+     first.  */
+  if (CMP_FUNC (needle, needle + period, suffix) == 0)
+    {
+      /* Entire needle is periodic; a mismatch in the left half can
+         only advance by the period, so use memory to avoid rescanning
+         known occurrences of the period in the right half.  */
+      size_t memory = 0;
+      size_t shift;
+      j = 0;
+      while (AVAILABLE (haystack, haystack_len, j, needle_len))
+        {
+          /* Check the last byte first; if it does not match, then
+             shift to the next possible match location.  */
+          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];
+          if (0 < shift)
+            {
+              if (memory && shift < period)
+                {
+                  /* Since needle is periodic, but the last period has
+                     a byte out of place, there can be no match until
+                     after the mismatch.  */
+                  shift = needle_len - period;
+                }
+              memory = 0;
+              j += shift;
+              continue;
+            }
+          /* Scan for matches in right half.  The last byte has
+             already been matched, by virtue of the shift table.  */
+          i = MAX (suffix, memory);
+          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])
+                                        == CANON_ELEMENT (haystack[i + j])))
+            ++i;
+          if (needle_len - 1 <= i)
+            {
+              /* Scan for matches in left half.  */
+              i = suffix - 1;
+              while (memory < i + 1 && (CANON_ELEMENT (needle[i])
+                                        == CANON_ELEMENT (haystack[i + j])))
+                --i;
+              if (i + 1 < memory + 1)
+                return (RETURN_TYPE) (haystack + j);
+              /* No match, so remember how many repetitions of period
+                 on the right half were scanned.  */
+              j += period;
+              memory = needle_len - period;
+            }
+          else
+            {
+              j += i - suffix + 1;
+              memory = 0;
+            }
+        }
+    }
+  else
+    {
+      /* The two halves of needle are distinct; no extra memory is
+         required, and any mismatch results in a maximal shift.  */
+      size_t shift;
+      period = MAX (suffix, needle_len - suffix) + 1;
+      j = 0;
+      while (AVAILABLE (haystack, haystack_len, j, needle_len))
+        {
+          /* Check the last byte first; if it does not match, then
+             shift to the next possible match location.  */
+          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];
+          if (0 < shift)
+            {
+              j += shift;
+              continue;
+            }
+          /* Scan for matches in right half.  The last byte has
+             already been matched, by virtue of the shift table.  */
+          i = suffix;
+          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])
+                                        == CANON_ELEMENT (haystack[i + j])))
+            ++i;
+          if (needle_len - 1 <= i)
+            {
+              /* Scan for matches in left half.  */
+              i = suffix - 1;
+              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])
+                                       == CANON_ELEMENT (haystack[i + j])))
+                --i;
+              if (i == SIZE_MAX)
+                return (RETURN_TYPE) (haystack + j);
+              j += period;
+            }
+          else
+            j += i - suffix + 1;
+        }
+    }
+  return NULL;
+}
+
+#undef AVAILABLE
+#undef CANON_ELEMENT
+#undef CMP_FUNC
+#undef MAX
+#undef RETURN_TYPE
diff --git a/lib/timegm.c b/lib/timegm.c
index 2ca57444d4..c440480cb2 100644
--- a/lib/timegm.c
+++ b/lib/timegm.c
@@ -18,17 +18,41 @@
    <http://www.gnu.org/licenses/>.  */
 
 #ifndef _LIBC
-# include <config.h>
+# include <libc-config.h>
 #endif
 
 #include <time.h>
+#include <errno.h>
 
 #include "mktime-internal.h"
 
-time_t
-timegm (struct tm *tmp)
+__time64_t
+__timegm64 (struct tm *tmp)
 {
   static mktime_offset_t gmtime_offset;
   tmp->tm_isdst = 0;
-  return __mktime_internal (tmp, __gmtime_r, &gmtime_offset);
+  return __mktime_internal (tmp, __gmtime64_r, &gmtime_offset);
 }
+
+#if defined _LIBC && __TIMESIZE != 64
+
+libc_hidden_def (__timegm64)
+
+time_t
+timegm (struct tm *tmp)
+{
+  struct tm tm = *tmp;
+  __time64_t t = __timegm64 (&tm);
+  if (in_time_t_range (t))
+    {
+      *tmp = tm;
+      return t;
+    }
+  else
+    {
+      __set_errno (EOVERFLOW);
+      return -1;
+    }
+}
+
+#endif
diff --git a/lib/verify.h b/lib/verify.h
index 6930645a35..f8e4eff026 100644
--- a/lib/verify.h
+++ b/lib/verify.h
@@ -21,29 +21,37 @@
 #define _GL_VERIFY_H
 
 
-/* Define _GL_HAVE__STATIC_ASSERT to 1 if _Static_assert works as per C11.
-   This is supported by GCC 4.6.0 and later, in C mode, and its use
-   here generates easier-to-read diagnostics when verify (R) fails.
-
-   Define _GL_HAVE_STATIC_ASSERT to 1 if static_assert works as per C++11.
-   This is supported by GCC 6.1.0 and later, in C++ mode.
-
-   Use this only with GCC.  If we were willing to slow 'configure'
-   down we could also use it with other compilers, but since this
-   affects only the quality of diagnostics, why bother?  */
-#if (4 < __GNUC__ + (6 <= __GNUC_MINOR__) \
-     && (201112L <= __STDC_VERSION__  || !defined __STRICT_ANSI__) \
-     && !defined __cplusplus)
-# define _GL_HAVE__STATIC_ASSERT 1
-#endif
-#if (6 <= __GNUC__) && defined __cplusplus
-# define _GL_HAVE_STATIC_ASSERT 1
+/* Define _GL_HAVE__STATIC_ASSERT to 1 if _Static_assert (R, DIAGNOSTIC)
+   works as per C11.  This is supported by GCC 4.6.0 and later, in C
+   mode.
+
+   Define _GL_HAVE__STATIC_ASSERT1 to 1 if _Static_assert (R) works as
+   per C2X, and define _GL_HAVE_STATIC_ASSERT1 if static_assert (R)
+   works as per C++17.  This is supported by GCC 9.1 and later.
+
+   Support compilers claiming conformance to the relevant standard,
+   and also support GCC when not pedantic.  If we were willing to slow
+   'configure' down we could also use it with other compilers, but
+   since this affects only the quality of diagnostics, why bother?  */
+#ifndef __cplusplus
+# if (201112L <= __STDC_VERSION__ \
+      || (!defined __STRICT_ANSI__ && 4 < __GNUC__ + (6 <= __GNUC_MINOR__)))
+#  define _GL_HAVE__STATIC_ASSERT 1
+# endif
+# if (202000L <= __STDC_VERSION__ \
+      || (!defined __STRICT_ANSI__ && 9 <= __GNUC__))
+#  define _GL_HAVE__STATIC_ASSERT1 1
+# endif
+#else
+# if 201703L <= __cplusplus || 9 <= __GNUC__
+#  define _GL_HAVE_STATIC_ASSERT1 1
+# endif
 #endif
 
 /* FreeBSD 9.1 <sys/cdefs.h>, included by <stddef.h> and lots of other
    system headers, defines a conflicting _Static_assert that is no
    better than ours; override it.  */
-#ifndef _GL_HAVE_STATIC_ASSERT
+#ifndef _GL_HAVE__STATIC_ASSERT
 # include <stddef.h>
 # undef _Static_assert
 #endif
@@ -141,9 +149,9 @@
      which do not support _Static_assert, also do not warn about the
      last declaration mentioned above.
 
-   * GCC warns if -Wnested-externs is enabled and verify() is used
+   * GCC warns if -Wnested-externs is enabled and 'verify' is used
      within a function body; but inside a function, you can always
-     arrange to use verify_expr() instead.
+     arrange to use verify_expr instead.
 
    * In C++, any struct definition inside sizeof is invalid.
      Use a template type to work around the problem.  */
@@ -167,11 +175,9 @@
 #define _GL_GENSYM(prefix) _GL_CONCAT (prefix, _GL_COUNTER)
 
 /* Verify requirement R at compile-time, as an integer constant expression
-   that returns 1.  If R is false, fail at compile-time, preferably
-   with a diagnostic that includes the string-literal DIAGNOSTIC.  */
+   that returns 1.  If R is false, fail at compile-time.  */
 
-#define _GL_VERIFY_TRUE(R, DIAGNOSTIC) \
-   (!!sizeof (_GL_VERIFY_TYPE (R, DIAGNOSTIC)))
+#define _GL_VERIFY_TRUE(R) (!!sizeof (_GL_VERIFY_TYPE (R)))
 
 #ifdef __cplusplus
 # if !GNULIB_defined_struct__gl_verify_type
@@ -181,40 +187,43 @@ template <int w>
   };
 #  define GNULIB_defined_struct__gl_verify_type 1
 # endif
-# define _GL_VERIFY_TYPE(R, DIAGNOSTIC) \
-    _gl_verify_type<(R) ? 1 : -1>
-#elif defined _GL_HAVE__STATIC_ASSERT
-# define _GL_VERIFY_TYPE(R, DIAGNOSTIC) \
+# define _GL_VERIFY_TYPE(R) _gl_verify_type<(R) ? 1 : -1>
+#elif defined _GL_HAVE__STATIC_ASSERT1
+# define _GL_VERIFY_TYPE(R) \
     struct {                                   \
-      _Static_assert (R, DIAGNOSTIC);          \
+      _Static_assert (R); \
       int _gl_dummy;                          \
     }
 #else
-# define _GL_VERIFY_TYPE(R, DIAGNOSTIC) \
+# define _GL_VERIFY_TYPE(R)                                             \
     struct { unsigned int _gl_verify_error_if_negative: (R) ? 1 : -1; }
 #endif
 
 /* Verify requirement R at compile-time, as a declaration without a
-   trailing ';'.  If R is false, fail at compile-time, preferably
-   with a diagnostic that includes the string-literal DIAGNOSTIC.
+   trailing ';'.  If R is false, fail at compile-time.
+
+   This macro requires three or more arguments but uses at most the first
+   two, so that the _Static_assert macro optionally defined below supports
+   both the C11 two-argument syntax and the C2X one-argument syntax.
 
    Unfortunately, unlike C11, this implementation must appear as an
    ordinary declaration, and cannot appear inside struct { ... }.  */
 
-#ifdef _GL_HAVE__STATIC_ASSERT
-# define _GL_VERIFY _Static_assert
+#if defined _GL_HAVE__STATIC_ASSERT
+# define _GL_VERIFY(R, DIAGNOSTIC, ...) _Static_assert (R, DIAGNOSTIC)
 #else
-# define _GL_VERIFY(R, DIAGNOSTIC)				       \
+# define _GL_VERIFY(R, DIAGNOSTIC, ...)                                \
     extern int (*_GL_GENSYM (_gl_verify_function) (void))	       \
-      [_GL_VERIFY_TRUE (R, DIAGNOSTIC)]
+      [_GL_VERIFY_TRUE (R)]
 #endif
 
 /* _GL_STATIC_ASSERT_H is defined if this code is copied into assert.h.  */
 #ifdef _GL_STATIC_ASSERT_H
-# if !defined _GL_HAVE__STATIC_ASSERT && !defined _Static_assert
-#  define _Static_assert(R, DIAGNOSTIC) _GL_VERIFY (R, DIAGNOSTIC)
+# if !defined _GL_HAVE__STATIC_ASSERT1 && !defined _Static_assert
+#  define _Static_assert(...) \
+     _GL_VERIFY (__VA_ARGS__, "static assertion failed", -)
 # endif
-# if !defined _GL_HAVE_STATIC_ASSERT && !defined static_assert
+# if !defined _GL_HAVE_STATIC_ASSERT1 && !defined static_assert
 #  define static_assert _Static_assert /* C11 requires this #define.  */
 # endif
 #endif
@@ -226,31 +235,24 @@ template <int w>
    assert (R), there is no run-time overhead.
 
    There are two macros, since no single macro can be used in all
-   contexts in C.  verify_true (R) is for scalar contexts, including
+   contexts in C.  verify_expr (R, E) is for scalar contexts, including
    integer constant expression contexts.  verify (R) is for declaration
    contexts, e.g., the top level.  */
 
-/* Verify requirement R at compile-time, as an integer constant expression.
-   Return 1.  This is equivalent to verify_expr (R, 1).
-
-   verify_true is obsolescent; please use verify_expr instead.  */
-
-#define verify_true(R) _GL_VERIFY_TRUE (R, "verify_true (" #R ")")
-
 /* Verify requirement R at compile-time.  Return the value of the
    expression E.  */
 
-#define verify_expr(R, E) \
-   (_GL_VERIFY_TRUE (R, "verify_expr (" #R ", " #E ")") ? (E) : (E))
+#define verify_expr(R, E) (_GL_VERIFY_TRUE (R) ? (E) : (E))
 
 /* Verify requirement R at compile-time, as a declaration without a
-   trailing ';'.  */
+   trailing ';'.  verify (R) acts like static_assert (R) except that
+   it is portable to C11/C++14 and earlier, and its name is shorter
+   and may be more convenient.  */
 
-#ifdef __GNUC__
-# define verify(R) _GL_VERIFY (R, "verify (" #R ")")
+#ifdef _GL_HAVE__STATIC_ASSERT1
+# define verify(R) _Static_assert (R)
 #else
-/* PGI barfs if R is long.  Play it safe.  */
-# define verify(R) _GL_VERIFY (R, "verify (...)")
+# define verify(R) _GL_VERIFY (R, "verify (...)", -)
 #endif
 
 #ifndef __has_builtin
diff --git a/lisp/ChangeLog.12 b/lisp/ChangeLog.12
index 0c0349c9d9..1493825ebd 100644
--- a/lisp/ChangeLog.12
+++ b/lisp/ChangeLog.12
@@ -6156,7 +6156,7 @@
 	* saveplace.el (load-save-place-alist-from-file): Use expanded name
 	in both messages.
 
-2006-09-16  Slawomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>
+2006-09-16  Sławomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>
 
 	* progmodes/python.el (python-preoutput-filter):
 	Fix arg order to string-match.
@@ -6540,7 +6540,7 @@
 	conf-space-keywords-override local.
 	Call conf-space-mode-internal directly as well as via hook.
 
-2006-09-09  Slawomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>  (tiny change)
+2006-09-09  Sławomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>  (tiny change)
 
 	* progmodes/python.el (python-font-lock-keywords): Add `self' and other
 	quasi-keywords.
@@ -12040,7 +12040,7 @@
 	* emacs-lisp/edebug.el (edebug-display): Use `edebug-sit-for-seconds'
 	value instead of a literal constant (1) on more pauses.
 
-2006-03-03  Slawomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>  (tiny change)
+2006-03-03  Sławomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>  (tiny change)
 
 	* textmodes/flyspell.el (flyspell-external-point-words):
 	Be case-sensitive.
@@ -17840,7 +17840,7 @@
 	* man.el (Man-highlight-references): Doc fix.  Reformat code in a
 	more Lisp-ish way.
 
-2005-11-19  Slawomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>  (tiny change)
+2005-11-19  Sławomir Nowaczyk  <slawomir.nowaczyk.847@student.lu.se>  (tiny change)
 
 	* ls-lisp.el (ls-lisp-format-file-size): Format file size with 9
 	digits, not 8, to avoid misalignment for files larger than 100MB.
@@ -18028,7 +18028,7 @@
 
 	* cus-edit.el (face): Enclose %t in %{...%}.
 
-2005-11-16  Hrvoje Niksic  <hniksic@xemacs.org>
+2005-11-16  Hrvoje Nikšić  <hniksic@xemacs.org>
 
 	* savehist.el (savehist-mode-hook): Re-add the var.
 	(savehist-mode): Use it.
@@ -18163,7 +18163,7 @@
 	Use the `variable-documentation' property to give the mode hook a
 	docstring and expand that docstring.
 
-2005-11-14  Hrvoje Niksic  <hniksic@xemacs.org>
+2005-11-14  Hrvoje Nikšić  <hniksic@xemacs.org>
 
 	* savehist.el (savehist-mode): Don't bother with
 	`custom-set-minor-mode'.
@@ -18983,7 +18983,7 @@
 	(savehist-mode) <defun>: Run the minor mode hook, set the custom state
 	and emit a message if applicable.
 
-2005-11-01  Hrvoje Niksic  <hniksic@xemacs.org>
+2005-11-01  Hrvoje Nikšić  <hniksic@xemacs.org>
 
 	* savehist.el: Sync up to version 19.
 	(savehist-mode): New minor mode.
@@ -19496,7 +19496,7 @@
 	* simple.el (completion-common-substring):
 	Use `completion-common-substring' prior to `completion-base-size'.
 
-2005-10-24  Hrvoje Niksic  <hniksic@xemacs.org>
+2005-10-24  Hrvoje Nikšić  <hniksic@xemacs.org>
 
 	* savehist.el: Require CL while compiling.
 	(savehist-history-variables): Remove.
@@ -20221,7 +20221,7 @@
 	(savehist-process-for-saving): Replace use of CL funs `subseq' and
 	`delete-if-not'.
 
-2005-10-16  Hrvoje Niksic  <hniksic@xemacs.org>
+2005-10-16  Hrvoje Nikšić  <hniksic@xemacs.org>
 
 	* savehist.el: Newer version.
 	(savehist-autosave-interval, savehist-coding-system, savehist-timer)
@@ -21480,7 +21480,7 @@
 2005-09-18  Michael Albinus  <michael.albinus@gmx.de>
 
 	* net/tramp.el (tramp-login-prompt-regexp): Expand regexp in order
-	to cover prompts like "login as:".  Reported by Slawomir Nowaczyk
+	to cover prompts like "login as:".  Reported by Sławomir Nowaczyk
 	<slawomir.nowaczyk.847@student.lu.se>.
 
 2005-09-18  Chong Yidong  <cyd@stupidchicken.com>
diff --git a/lisp/ChangeLog.15 b/lisp/ChangeLog.15
index b22661fe81..d8519a2720 100644
--- a/lisp/ChangeLog.15
+++ b/lisp/ChangeLog.15
@@ -4156,7 +4156,7 @@
 	coreutils.  Reported by Klaus Reichl
 	<Klaus.Reichl@thalesgroup.com>.
 
-2010-11-13  Hrvoje Niksic  <hniksic@xemacs.org>
+2010-11-13  Hrvoje Nikšić  <hniksic@xemacs.org>
 
 	* simple.el (count-words-region): New function.
 
diff --git a/lisp/ChangeLog.7 b/lisp/ChangeLog.7
index b8e0f10199..2fe98e8f00 100644
--- a/lisp/ChangeLog.7
+++ b/lisp/ChangeLog.7
@@ -8142,7 +8142,7 @@
 	implementation) so that `locate-library' can find compressed files.
 	(finder-commentary): Use it.
 
-1997-11-15  Hrvoje Niksic  <hniksic@srce.hr>
+1997-11-15  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* cus-edit.el (custom-face-save): Save the face.
 
@@ -9078,11 +9078,11 @@
 
 	* gnus.el: Gnus v5.4.60 is released.
 
-1997-10-21  Hrvoje Niksic  <hniksic@srce.hr>
+1997-10-21  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-salt.el: Customized.
 
-1997-10-21  Hrvoje Niksic  <hniksic@srce.hr>
+1997-10-21  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-salt.el (gnus-tree-show-summary): New function.
 	(gnus-tree-mode-map): Use it.
@@ -9098,7 +9098,7 @@
 
 	* gnus-sum.el (gnus-adjust-marked-articles): Improper lists.
 
-1997-10-21  Hrvoje Niksic  <hniksic@srce.hr>
+1997-10-21  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-sum.el (gnus-summary-search-article): Inhibit updating tree
 	buffer.
@@ -9213,7 +9213,7 @@
 	* gnus-score.el (gnus-score-find-trace): Would bug out for
 	file-less rules.
 
-1997-10-21  Hrvoje Niksic  <hniksic@srce.hr>
+1997-10-21  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-xmas.el (gnus-xmas-group-startup-message): Cleanup.
 
@@ -9264,7 +9264,7 @@
 	* gnus-art.el (gnus-header-button-alist): Check for URLs in the
 	Subject.
 
-1997-10-21  Hrvoje Niksic  <hniksic@srce.hr>
+1997-10-21  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-xmas.el: Cleanup.
 
@@ -9715,7 +9715,7 @@
 	* gnus-art.el (gnus-read-save-file-name): Expand file name i save
 	dir.
 
-1997-10-21  Hrvoje Niksic  <hniksic@srce.hr>
+1997-10-21  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-art.el (gnus-signature-face): New face; use it.
 
@@ -9724,12 +9724,12 @@
 	* gnus-picon.el (gnus-picons-insert-face-if-exists): Add picons to
 	list.
 
-1997-10-21  Hrvoje Niksic  <hniksic@srce.hr>
+1997-10-21  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* message.el (message-font-lock-keywords): Be a little bit more
 	case-insensitive.
 
-1997-10-21  Hrvoje Niksic  <hniksic@srce.hr>
+1997-10-21  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* message.el (message-insert-to): New argument FORCE.
 
@@ -9748,7 +9748,7 @@
 
 	* gnus-ems.el: appt, not appt.el.
 
-1997-10-21  Hrvoje Niksic  <hniksic@srce.hr>
+1997-10-21  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-xmas.el (gnus-xmas-summary-set-display-table): Don't nix
 	out in Latin1.
@@ -10150,7 +10150,7 @@
 	* vc-hooks.el (vc-find-cvs-master): Add missing `throw' for
 	the case when TIMESTAMP is arbitrary text.
 
-1997-09-30  Hrvoje Niksic  <hniksic@srce.hr>
+1997-09-30  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* wid-edit.el (widget-plist-member): Move from here to src/fns.c;
 	translated into C for efficiency.
@@ -10386,7 +10386,7 @@
 
 	* international/mule-util.el (truncate-string-to-width): Doc typo fix.
 
-1997-09-14  Hrvoje Niksic  <hniksic@srce.hr>
+1997-09-14  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* arc-mode.el: Customized.
 
@@ -17073,7 +17073,7 @@
 	* server.el (server-kill-buffer): Prevent infinite recursion.
 	(server-kill-buffer-running): New variable.
 
-1997-05-28  Hrvoje Niksic  <hniksic@srce.hr>
+1997-05-28  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* dired-aux.el: Customize.
 
@@ -17337,7 +17337,7 @@
 
 	* libc.el: New file.
 
-1997-05-22  Hrvoje Niksic  <hniksic@srce.hr>
+1997-05-22  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* terminal.el: Use defgroup and defcustom.
 	* dired.el, dired-x.el: Likewise.
@@ -18220,7 +18220,7 @@
 
 	* vc.el: Doc fixes.
 
-1997-05-05  Hrvoje Niksic  <hniksic@srce.hr>
+1997-05-05  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* time.el, gud.el, metamail.el, simple.el: Customize.
 	* window.el, frame.el, menu-bar.el, lisp.el, fill.el: Customize.
@@ -18316,7 +18316,7 @@
 
 	* ispell.el (ispell-dictionary-alist-2): Specify syntax of ' in Danish.
 
-1997-05-02  Hrvoje Niksic  <hniksic@srce.hr>
+1997-05-02  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* calendar.el: Customize.
 	* appt.el, cal-china.el, cal-tex.el, diary-lib.el, solar.el: Likewise.
@@ -18926,7 +18926,7 @@
 
 	* sh-script.el (sh-while-getopts): Don't add menu-enable property.
 
-1997-04-15  Hrvoje Niksic  <hniksic@srce.hr>
+1997-04-15  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* saveplace.el: Add defgroup; use defcustom for user vars.
 	* pascal.el, supercite.el: Likewise.
@@ -19021,7 +19021,7 @@
 	* dired.el (dired-noselect): Avoid calling file-directory-p
 	when the initial argument was syntactically a directory name.
 
-1997-04-13  Hrvoje Niksic  <hniksic@srce.hr>
+1997-04-13  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* time-stamp.el: Add defgroup; use defcustom for user vars.
 	* eldoc.el: Likewise.
@@ -19214,7 +19214,7 @@
 	* Makefile (finder-inf.el, autoloads): New targets.
 	(cus-load.el): Minor simplification.
 
-1997-04-11  Hrvoje Niksic  <hniksic@srce.hr>
+1997-04-11  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* add-log.el, avoid.el, bookmark.el, cl-indent.el, cmacexp.el:
 	* comint.el, completion.el, dabbrev.el, desktop.el, edebug.el:
@@ -19291,7 +19291,7 @@
 
 	* cal-islam.el (diary-islamic-date): Use `date'.
 
-1997-04-10  Hrvoje Niksic  <hniksic@srce.hr>
+1997-04-10  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* ispell.el: Use defcustom for user variables.
 
diff --git a/lisp/allout-widgets.el b/lisp/allout-widgets.el
index 67fce325ff..e7da08d44e 100644
--- a/lisp/allout-widgets.el
+++ b/lisp/allout-widgets.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2005-2019 Free Software Foundation, Inc.
 
 ;; Author: Ken Manheimer <ken dot manheimer at gmail...>
-;; Maintainer: Ken Manheimer <ken dot manheimer at gmail...>
 ;; Version: 1.0
 ;; Created: Dec 2005
 ;; Keywords: outlines
@@ -70,12 +69,7 @@
 (require 'allout)
 (require 'widget)
 (require 'wid-edit)
-
-(eval-when-compile
-  (progn
-    (require 'overlay)
-    (require 'cl)
-    ))
+(eval-when-compile (require 'cl-lib))
 
 ;;;_ : internal variables needed before user-customization variables
 ;;; In order to enable activation of allout-widgets-mode via customization,
@@ -960,7 +954,7 @@ posting threshold criteria."
         (when changes-pending
           (while changes-record
             (setq entry (pop changes-record))
-            (case (car entry)
+            (pcase (car entry)
               (:exposed (push entry exposures))
               (:added (push entry additions))
               (:deleted (push entry deletions))
@@ -1378,34 +1372,34 @@ FROM and TO must be in increasing order, as must be the pairs in RANGES."
 
     ;; fresh:
     (setq ranges nil)
-    (assert (equal (funcall try 3 5) '(nil ((3 5)))))
+    (cl-assert (equal (funcall try 3 5) '(nil ((3 5)))))
     ;; add range at end:
-    (assert (equal (funcall try 10 12) '(nil ((3 5) (10 12)))))
+    (cl-assert (equal (funcall try 10 12) '(nil ((3 5) (10 12)))))
     ;; add range at beginning:
-    (assert (equal (funcall try 1 2) '(nil ((1 2) (3 5) (10 12)))))
+    (cl-assert (equal (funcall try 1 2) '(nil ((1 2) (3 5) (10 12)))))
     ;; insert range somewhere in the middle:
-    (assert (equal (funcall try 7 9) '(nil ((1 2) (3 5) (7 9) (10 12)))))
+    (cl-assert (equal (funcall try 7 9) '(nil ((1 2) (3 5) (7 9) (10 12)))))
     ;; consolidate some:
-    (assert (equal (funcall try 5 8) '(t ((1 2) (3 9) (10 12)))))
+    (cl-assert (equal (funcall try 5 8) '(t ((1 2) (3 9) (10 12)))))
     ;; add more:
-    (assert (equal (funcall try 15 17) '(nil ((1 2) (3 9) (10 12) (15 17)))))
+    (cl-assert (equal (funcall try 15 17) '(nil ((1 2) (3 9) (10 12) (15 17)))))
     ;; add more:
-    (assert (equal (funcall try 20 22)
+    (cl-assert (equal (funcall try 20 22)
                    '(nil ((1 2) (3 9) (10 12) (15 17) (20 22)))))
     ;; encompass more:
-    (assert (equal (funcall try 4 11) '(t ((1 2) (3 12) (15 17) (20 22)))))
+    (cl-assert (equal (funcall try 4 11) '(t ((1 2) (3 12) (15 17) (20 22)))))
     ;; encompass all:
-    (assert (equal (funcall try 2 25) '(t ((1 25)))))
+    (cl-assert (equal (funcall try 2 25) '(t ((1 25)))))
 
     ;; fresh slate:
     (setq ranges nil)
-    (assert (equal (funcall try 20 25) '(nil ((20 25)))))
-    (assert (equal (funcall try 30 35) '(nil ((20 25) (30 35)))))
-    (assert (equal (funcall try 26 28) '(nil ((20 25) (26 28) (30 35)))))
-    (assert (equal (funcall try 15 20) '(t ((15 25) (26 28) (30 35)))))
-    (assert (equal (funcall try 10 30) '(t ((10 35)))))
-    (assert (equal (funcall try 5 6) '(nil ((5 6) (10 35)))))
-    (assert (equal (funcall try 2 100) '(t ((2 100)))))
+    (cl-assert (equal (funcall try 20 25) '(nil ((20 25)))))
+    (cl-assert (equal (funcall try 30 35) '(nil ((20 25) (30 35)))))
+    (cl-assert (equal (funcall try 26 28) '(nil ((20 25) (26 28) (30 35)))))
+    (cl-assert (equal (funcall try 15 20) '(t ((15 25) (26 28) (30 35)))))
+    (cl-assert (equal (funcall try 10 30) '(t ((10 35)))))
+    (cl-assert (equal (funcall try 5 6) '(nil ((5 6) (10 35)))))
+    (cl-assert (equal (funcall try 2 100) '(t ((2 100)))))
 
     (setq ranges nil)
     ))
diff --git a/lisp/allout.el b/lisp/allout.el
index b3b87e533b..251f2f5900 100644
--- a/lisp/allout.el
+++ b/lisp/allout.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1992-1994, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Ken Manheimer <ken dot manheimer at gmail...>
-;; Maintainer: Ken Manheimer <ken dot manheimer at gmail...>
 ;; Created: Dec 1991 -- first release to usenet
 ;; Version: 2.3
 ;; Keywords: outlines, wp, languages, PGP, GnuPG
@@ -79,12 +78,7 @@
 
 ;;;_* Dependency loads
 (require 'overlay)
-(eval-when-compile
-  ;; `cl' is required for `assert'.  `assert' is not covered by a standard
-  ;; autoload, but it is a macro, so that eval-when-compile is sufficient
-  ;; to byte-compile it in, or to do the require when the buffer evalled.
-  (require 'cl)
-  )
+(eval-when-compile (require 'cl-lib))
 
 ;;;_* USER CUSTOMIZATION VARIABLES:
 
@@ -6122,13 +6116,13 @@ signal."
                                                           (point-max))))
     ;; determine key mode and, if keypair, recipients:
     (setq recipients
-          (case keypair-mode
+          (pcase keypair-mode
 
-            (decrypting nil)
+            ('decrypting nil)
 
-            (default (if encrypt-to (epg-list-keys epg-context encrypt-to)))
+            ('default (if encrypt-to (epg-list-keys epg-context encrypt-to)))
 
-            ((prompt prompt-save)
+            ((or 'prompt 'prompt-save)
              (save-window-excursion
                (epa-select-keys epg-context keypair-message)))))
 
@@ -6786,6 +6780,7 @@ To ignore intangibility, bind `inhibit-point-motion-hooks' to t."
 (defvar allout-tests-locally-true nil
   "Fodder for allout resumptions tests -- defvar just for byte compiler.")
 (defun allout-test-resumptions ()
+  ;; FIXME: Use ERT.
   "Exercise allout resumptions."
   ;; for each resumption case, we also test that the right local/global
   ;; scopes are affected during resumption effects:
@@ -6794,48 +6789,48 @@ To ignore intangibility, bind `inhibit-point-motion-hooks' to t."
   (with-temp-buffer
     (allout-tests-obliterate-variable 'allout-tests-globally-unbound)
     (allout-add-resumptions '(allout-tests-globally-unbound t))
-    (assert (not (default-boundp 'allout-tests-globally-unbound)))
-    (assert (local-variable-p 'allout-tests-globally-unbound (current-buffer)))
-    (assert (boundp 'allout-tests-globally-unbound))
-    (assert (equal allout-tests-globally-unbound t))
+    (cl-assert (not (default-boundp 'allout-tests-globally-unbound)))
+    (cl-assert (local-variable-p 'allout-tests-globally-unbound (current-buffer)))
+    (cl-assert (boundp 'allout-tests-globally-unbound))
+    (cl-assert (equal allout-tests-globally-unbound t))
     (allout-do-resumptions)
-    (assert (not (local-variable-p 'allout-tests-globally-unbound
+    (cl-assert (not (local-variable-p 'allout-tests-globally-unbound
                                    (current-buffer))))
-    (assert (not (boundp 'allout-tests-globally-unbound))))
+    (cl-assert (not (boundp 'allout-tests-globally-unbound))))
 
   ;; ensure that variable with prior global value is resumed
   (with-temp-buffer
     (allout-tests-obliterate-variable 'allout-tests-globally-true)
     (setq allout-tests-globally-true t)
     (allout-add-resumptions '(allout-tests-globally-true nil))
-    (assert (equal (default-value 'allout-tests-globally-true) t))
-    (assert (local-variable-p 'allout-tests-globally-true (current-buffer)))
-    (assert (equal allout-tests-globally-true nil))
+    (cl-assert (equal (default-value 'allout-tests-globally-true) t))
+    (cl-assert (local-variable-p 'allout-tests-globally-true (current-buffer)))
+    (cl-assert (equal allout-tests-globally-true nil))
     (allout-do-resumptions)
-    (assert (not (local-variable-p 'allout-tests-globally-true
+    (cl-assert (not (local-variable-p 'allout-tests-globally-true
                                    (current-buffer))))
-    (assert (boundp 'allout-tests-globally-true))
-    (assert (equal allout-tests-globally-true t)))
+    (cl-assert (boundp 'allout-tests-globally-true))
+    (cl-assert (equal allout-tests-globally-true t)))
 
   ;; ensure that prior local value is resumed
   (with-temp-buffer
     (allout-tests-obliterate-variable 'allout-tests-locally-true)
     (set (make-local-variable 'allout-tests-locally-true) t)
-    (assert (not (default-boundp 'allout-tests-locally-true))
+    (cl-assert (not (default-boundp 'allout-tests-locally-true))
             nil (concat "Test setup mistake -- variable supposed to"
                         " not have global binding, but it does."))
-    (assert (local-variable-p 'allout-tests-locally-true (current-buffer))
+    (cl-assert (local-variable-p 'allout-tests-locally-true (current-buffer))
             nil (concat "Test setup mistake -- variable supposed to have"
                         " local binding, but it lacks one."))
     (allout-add-resumptions '(allout-tests-locally-true nil))
-    (assert (not (default-boundp 'allout-tests-locally-true)))
-    (assert (local-variable-p 'allout-tests-locally-true (current-buffer)))
-    (assert (equal allout-tests-locally-true nil))
+    (cl-assert (not (default-boundp 'allout-tests-locally-true)))
+    (cl-assert (local-variable-p 'allout-tests-locally-true (current-buffer)))
+    (cl-assert (equal allout-tests-locally-true nil))
     (allout-do-resumptions)
-    (assert (boundp 'allout-tests-locally-true))
-    (assert (local-variable-p 'allout-tests-locally-true (current-buffer)))
-    (assert (equal allout-tests-locally-true t))
-    (assert (not (default-boundp 'allout-tests-locally-true))))
+    (cl-assert (boundp 'allout-tests-locally-true))
+    (cl-assert (local-variable-p 'allout-tests-locally-true (current-buffer)))
+    (cl-assert (equal allout-tests-locally-true t))
+    (cl-assert (not (default-boundp 'allout-tests-locally-true))))
 
   ;; ensure that last of multiple resumptions holds, for various scopes.
   (with-temp-buffer
@@ -6851,27 +6846,27 @@ To ignore intangibility, bind `inhibit-point-motion-hooks' to t."
                             '(allout-tests-globally-true 3)
                             '(allout-tests-locally-true 4))
     ;; reestablish many of the basic conditions are maintained after re-add:
-    (assert (not (default-boundp 'allout-tests-globally-unbound)))
-    (assert (local-variable-p 'allout-tests-globally-unbound (current-buffer)))
-    (assert (equal allout-tests-globally-unbound 2))
-    (assert (default-boundp 'allout-tests-globally-true))
-    (assert (local-variable-p 'allout-tests-globally-true (current-buffer)))
-    (assert (equal allout-tests-globally-true 3))
-    (assert (not (default-boundp 'allout-tests-locally-true)))
-    (assert (local-variable-p 'allout-tests-locally-true (current-buffer)))
-    (assert (equal allout-tests-locally-true 4))
+    (cl-assert (not (default-boundp 'allout-tests-globally-unbound)))
+    (cl-assert (local-variable-p 'allout-tests-globally-unbound (current-buffer)))
+    (cl-assert (equal allout-tests-globally-unbound 2))
+    (cl-assert (default-boundp 'allout-tests-globally-true))
+    (cl-assert (local-variable-p 'allout-tests-globally-true (current-buffer)))
+    (cl-assert (equal allout-tests-globally-true 3))
+    (cl-assert (not (default-boundp 'allout-tests-locally-true)))
+    (cl-assert (local-variable-p 'allout-tests-locally-true (current-buffer)))
+    (cl-assert (equal allout-tests-locally-true 4))
     (allout-do-resumptions)
-    (assert (not (local-variable-p 'allout-tests-globally-unbound
+    (cl-assert (not (local-variable-p 'allout-tests-globally-unbound
                                    (current-buffer))))
-    (assert (not (boundp 'allout-tests-globally-unbound)))
-    (assert (not (local-variable-p 'allout-tests-globally-true
+    (cl-assert (not (boundp 'allout-tests-globally-unbound)))
+    (cl-assert (not (local-variable-p 'allout-tests-globally-true
                                    (current-buffer))))
-    (assert (boundp 'allout-tests-globally-true))
-    (assert (equal allout-tests-globally-true t))
-    (assert (boundp 'allout-tests-locally-true))
-    (assert (local-variable-p 'allout-tests-locally-true (current-buffer)))
-    (assert (equal allout-tests-locally-true t))
-    (assert (not (default-boundp 'allout-tests-locally-true))))
+    (cl-assert (boundp 'allout-tests-globally-true))
+    (cl-assert (equal allout-tests-globally-true t))
+    (cl-assert (boundp 'allout-tests-locally-true))
+    (cl-assert (local-variable-p 'allout-tests-locally-true (current-buffer)))
+    (cl-assert (equal allout-tests-locally-true t))
+    (cl-assert (not (default-boundp 'allout-tests-locally-true))))
 
   ;; ensure that deliberately unbinding registered variables doesn't foul things
   (with-temp-buffer
diff --git a/lisp/ansi-color.el b/lisp/ansi-color.el
index d3b8d06604..fe8cadacda 100644
--- a/lisp/ansi-color.el
+++ b/lisp/ansi-color.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Alex Schroeder <alex@gnu.org>
-;; Maintainer: Alex Schroeder <alex@gnu.org>
 ;; Version: 3.4.2
 ;; Keywords: comm processes terminals services
 
@@ -415,7 +414,11 @@ this."
 	;; if the rest of the region should have a face, put it there
 	(funcall ansi-color-apply-face-function
 		 start-marker end-marker (ansi-color--find-face codes))
-	(setq ansi-color-context-region (if codes (list codes)))))))
+	(setq ansi-color-context-region (if codes (list codes)))))
+    ;; Clean up our temporary markers.
+    (unless (eq start-marker (cadr ansi-color-context-region))
+      (set-marker start-marker nil))
+    (set-marker end-marker nil)))
 
 (defun ansi-color-apply-overlay-face (beg end face)
   "Make an overlay from BEG to END, and apply face FACE.
@@ -425,6 +428,12 @@ If FACE is nil, do nothing."
      (ansi-color-make-extent beg end)
      face)))
 
+(defun ansi-color-apply-text-property-face (beg end face)
+  "Set the `font-lock-face' property to FACE in region BEG..END.
+If FACE is nil, do nothing."
+  (when face
+    (put-text-property beg end 'font-lock-face face)))
+
 ;; This function helps you look for overlapping overlays.  This is
 ;; useful in comint-buffers.  Overlapping overlays should not happen!
 ;; A possible cause for bugs are the markers.  If you create an overlay
diff --git a/lisp/arc-mode.el b/lisp/arc-mode.el
index 6a58d61a54..7f435f17a1 100644
--- a/lisp/arc-mode.el
+++ b/lisp/arc-mode.el
@@ -417,70 +417,66 @@ file.  Archive and member name will be added."
       (substitute-key-definition 'advertised-undo 'archive-undo map global-map)
       (substitute-key-definition 'undo 'archive-undo map global-map))
 
-    (define-key map
-      (if (featurep 'xemacs) 'button2 [mouse-2]) 'archive-extract)
-
-    (if (featurep 'xemacs)
-        ()				; out of luck
-
-      (define-key map [menu-bar immediate]
-        (cons "Immediate" (make-sparse-keymap "Immediate")))
-      (define-key map [menu-bar immediate alternate]
-        '(menu-item "Alternate Display" archive-alternate-display
-          :enable (boundp (archive-name "alternate-display"))
-          :help "Toggle alternate file info display"))
-      (define-key map [menu-bar immediate view]
-        '(menu-item "View This File" archive-view
-          :help "Display file at cursor in View Mode"))
-      (define-key map [menu-bar immediate display]
-        '(menu-item "Display in Other Window" archive-display-other-window
-          :help "Display file at cursor in another window"))
-      (define-key map [menu-bar immediate find-file-other-window]
-        '(menu-item "Find in Other Window" archive-extract-other-window
-          :help "Edit file at cursor in another window"))
-      (define-key map [menu-bar immediate find-file]
-        '(menu-item "Find This File" archive-extract
-          :help "Extract file at cursor and edit it"))
-
-      (define-key map [menu-bar mark]
-        (cons "Mark" (make-sparse-keymap "Mark")))
-      (define-key map [menu-bar mark unmark-all]
-        '(menu-item "Unmark All" archive-unmark-all-files
-          :help "Unmark all marked files"))
-      (define-key map [menu-bar mark deletion]
-        '(menu-item "Flag" archive-flag-deleted
-          :help "Flag file at cursor for deletion"))
-      (define-key map [menu-bar mark unmark]
-        '(menu-item "Unflag" archive-unflag
-          :help "Unmark file at cursor"))
-      (define-key map [menu-bar mark mark]
-        '(menu-item "Mark" archive-mark
-          :help "Mark file at cursor"))
-
-      (define-key map [menu-bar operate]
-        (cons "Operate" (make-sparse-keymap "Operate")))
-      (define-key map [menu-bar operate chown]
-        '(menu-item "Change Owner..." archive-chown-entry
-          :enable (fboundp (archive-name "chown-entry"))
-          :help "Change owner of marked files"))
-      (define-key map [menu-bar operate chgrp]
-        '(menu-item "Change Group..." archive-chgrp-entry
-          :enable (fboundp (archive-name "chgrp-entry"))
-          :help "Change group ownership of marked files"))
-      (define-key map [menu-bar operate chmod]
-        '(menu-item "Change Mode..." archive-chmod-entry
-          :enable (fboundp (archive-name "chmod-entry"))
-          :help "Change mode (permissions) of marked files"))
-      (define-key map [menu-bar operate rename]
-        '(menu-item "Rename to..." archive-rename-entry
-          :enable (fboundp (archive-name "rename-entry"))
-          :help "Rename marked files"))
-      ;;(define-key map [menu-bar operate copy]
-      ;;  '(menu-item "Copy to..." archive-copy))
-      (define-key map [menu-bar operate expunge]
-        '(menu-item "Expunge Marked Files" archive-expunge
-          :help "Delete all flagged files from archive"))
-      map))
+    (define-key map [mouse-2] 'archive-extract)
+
+    (define-key map [menu-bar immediate]
+      (cons "Immediate" (make-sparse-keymap "Immediate")))
+    (define-key map [menu-bar immediate alternate]
+      '(menu-item "Alternate Display" archive-alternate-display
+                  :enable (boundp (archive-name "alternate-display"))
+                  :help "Toggle alternate file info display"))
+    (define-key map [menu-bar immediate view]
+      '(menu-item "View This File" archive-view
+                  :help "Display file at cursor in View Mode"))
+    (define-key map [menu-bar immediate display]
+      '(menu-item "Display in Other Window" archive-display-other-window
+                  :help "Display file at cursor in another window"))
+    (define-key map [menu-bar immediate find-file-other-window]
+      '(menu-item "Find in Other Window" archive-extract-other-window
+                  :help "Edit file at cursor in another window"))
+    (define-key map [menu-bar immediate find-file]
+      '(menu-item "Find This File" archive-extract
+                  :help "Extract file at cursor and edit it"))
+
+    (define-key map [menu-bar mark]
+      (cons "Mark" (make-sparse-keymap "Mark")))
+    (define-key map [menu-bar mark unmark-all]
+      '(menu-item "Unmark All" archive-unmark-all-files
+                  :help "Unmark all marked files"))
+    (define-key map [menu-bar mark deletion]
+      '(menu-item "Flag" archive-flag-deleted
+                  :help "Flag file at cursor for deletion"))
+    (define-key map [menu-bar mark unmark]
+      '(menu-item "Unflag" archive-unflag
+                  :help "Unmark file at cursor"))
+    (define-key map [menu-bar mark mark]
+      '(menu-item "Mark" archive-mark
+                  :help "Mark file at cursor"))
+
+    (define-key map [menu-bar operate]
+      (cons "Operate" (make-sparse-keymap "Operate")))
+    (define-key map [menu-bar operate chown]
+      '(menu-item "Change Owner..." archive-chown-entry
+                  :enable (fboundp (archive-name "chown-entry"))
+                  :help "Change owner of marked files"))
+    (define-key map [menu-bar operate chgrp]
+      '(menu-item "Change Group..." archive-chgrp-entry
+                  :enable (fboundp (archive-name "chgrp-entry"))
+                  :help "Change group ownership of marked files"))
+    (define-key map [menu-bar operate chmod]
+      '(menu-item "Change Mode..." archive-chmod-entry
+                  :enable (fboundp (archive-name "chmod-entry"))
+                  :help "Change mode (permissions) of marked files"))
+    (define-key map [menu-bar operate rename]
+      '(menu-item "Rename to..." archive-rename-entry
+                  :enable (fboundp (archive-name "rename-entry"))
+                  :help "Rename marked files"))
+    ;;(define-key map [menu-bar operate copy]
+    ;;  '(menu-item "Copy to..." archive-copy))
+    (define-key map [menu-bar operate expunge]
+      '(menu-item "Expunge Marked Files" archive-expunge
+                  :help "Delete all flagged files from archive"))
+    map)
   "Local keymap for archive mode listings.")
 (defvar archive-file-name-indent nil "Column where file names start.")
 
@@ -516,17 +512,12 @@ Each descriptor is a vector of the form
 ;; -------------------------------------------------------------------------
 ;;; Section: Support functions.
 
-(eval-when-compile
-  (defsubst byte-after (pos)
-    "Like char-after but an eight-bit char is converted to unibyte."
-    (multibyte-char-to-unibyte (char-after pos)))
-  (defsubst insert-unibyte (&rest args)
-    "Like insert but don't make unibyte string and eight-bit char multibyte."
-    (dolist (elt args)
-      (if (integerp elt)
-	  (insert (if (< elt 128) elt (decode-char 'eight-bit elt)))
-	(insert (string-to-multibyte elt)))))
-  )
+(defun arc-insert-unibyte (&rest args)
+  "Like insert but don't make unibyte string and eight-bit char multibyte."
+  (dolist (elt args)
+    (if (integerp elt)
+	(insert (if (< elt 128) elt (decode-char 'eight-bit elt)))
+      (insert elt))))
 
 (defsubst archive-name (suffix)
   (intern (concat "archive-" (symbol-name archive-subtype) "-" suffix)))
@@ -538,7 +529,8 @@ in which case a second argument, length LEN, should be supplied."
   (if (stringp str)
       (setq len (length str))
     (setq str (buffer-substring str (+ str len))))
-  (setq str (string-as-unibyte str))
+  (if (multibyte-string-p str)
+      (setq str (encode-coding-string str 'utf-8-emacs-unix)))
   (let ((result 0)
         (i 0))
     (while (< i len)
@@ -842,13 +834,11 @@ when parsing the archive."
        ;; Using `concat' here copies the text also, so we can add
        ;; properties without problems.
        (let ((text (concat (aref fil 0) "\n")))
-         (if (featurep 'xemacs)
-             ()                         ; out of luck
-           (add-text-properties
-            (aref fil 1) (aref fil 2)
-            '(mouse-face highlight
-              help-echo "mouse-2: extract this file into a buffer")
-            text))
+         (add-text-properties
+          (aref fil 1) (aref fil 2)
+          '(mouse-face highlight
+                       help-echo "mouse-2: extract this file into a buffer")
+          text)
          text))
      files)))
   (setq archive-file-list-end (point-marker)))
@@ -1492,8 +1482,8 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
         files
 	visual)
     (while (and (< (+ p 29) (point-max))
-		(= (byte-after p) ?\C-z)
-		(> (byte-after (1+ p)) 0))
+		(= (get-byte p) ?\C-z)
+		(> (get-byte (1+ p)) 0))
       (let* ((namefld (buffer-substring (+ p 2) (+ p 2 13)))
 	     (fnlen   (or (string-match "\0" namefld) 13))
 	     (efnname (decode-coding-string (substring namefld 0 fnlen)
@@ -1546,7 +1536,7 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
 	(widen)
 	(goto-char (+ archive-proper-file-start (aref descr 4) 2))
 	(delete-char 13)
-	(insert-unibyte name)))))
+	(arc-insert-unibyte name)))))
 ;; -------------------------------------------------------------------------
 ;;; Section: Lzh Archives
 
@@ -1558,13 +1548,13 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
 	visual)
     (while (progn (goto-char p)		;beginning of a base header.
 		  (looking-at "\\(.\\|\n\\)\\(.\\|\n\\)-l[hz][0-9ds]-"))
-      (let* ((hsize   (byte-after p))	;size of the base header (level 0 and 1)
+      (let* ((hsize   (get-byte p))	;size of the base header (level 0 and 1)
 	     (csize   (archive-l-e (+ p 7) 4)) ;size of a compressed file to follow (level 0 and 2),
 					;size of extended headers + the compressed file to follow (level 1).
              (ucsize  (archive-l-e (+ p 11) 4))	;size of an uncompressed file.
 	     (time1   (archive-l-e (+ p 15) 2))	;date/time (MSDOS format in level 0, 1 headers
 	     (time2   (archive-l-e (+ p 17) 2))	;and UNIX format in level 2 header.)
-	     (hdrlvl  (byte-after (+ p 20))) ;header level
+	     (hdrlvl  (get-byte (+ p 20))) ;header level
 	     thsize		;total header size (base + extensions)
 	     fnlen efnname osid fiddle ifnname width p2
 	     neh	;beginning of next extension header (level 1 and 2)
@@ -1572,7 +1562,7 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
 	     gname uname modtime moddate)
 	(if (= hdrlvl 3) (error "can't handle lzh level 3 header type"))
 	(when (or (= hdrlvl 0) (= hdrlvl 1))
-	  (setq fnlen   (byte-after (+ p 21))) ;filename length
+	  (setq fnlen   (get-byte (+ p 21))) ;filename length
 	  (setq efnname (let ((str (buffer-substring (+ p 22) (+ p 22 fnlen))))	;filename from offset 22
 			(decode-coding-string
 			 str archive-file-name-coding-system)))
@@ -1583,19 +1573,19 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
               (setq neh (+ p 24))))     ;specific to level 2 header
 	(if neh		;if level 1 or 2 we expect extension headers to follow
 	    (let* ((ehsize (archive-l-e neh 2))	;size of the extension header
-		   (etype (byte-after (+ neh 2)))) ;extension type
+		   (etype (get-byte (+ neh 2)))) ;extension type
 	      (while (not (= ehsize 0))
 		  (cond
 		 ((= etype 1)	;file name
 		  (let ((i (+ neh 3)))
 		    (while (< i (+ neh ehsize))
-		      (setq efnname (concat efnname (char-to-string (byte-after i))))
+		      (setq efnname (concat efnname (char-to-string (get-byte i))))
 		      (setq i (1+ i)))))
 		 ((= etype 2)	;directory name
 		  (let ((i (+ neh 3)))
 		    (while (< i (+ neh ehsize))
 				    (setq dir (concat dir
-						       (if (= (byte-after i)
+						       (if (= (get-byte i)
 							      255)
 							   "/"
 							 (char-to-string
@@ -1619,7 +1609,7 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
 		   )
 		(setq neh (+ neh ehsize))
 		(setq ehsize (archive-l-e neh 2))
-		(setq etype (byte-after (+ neh 2))))
+		(setq etype (get-byte (+ neh 2))))
 	      ;;get total header size for level 1 and 2 headers
 	      (setq thsize (- neh p))))
 	(if (= hdrlvl 0)  ;total header size
@@ -1706,7 +1696,7 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
   (let ((sum 0))
     (while (> count 0)
       (setq count (1- count)
-	    sum (+ sum (byte-after p))
+	    sum (+ sum (get-byte p))
 	    p (1+ p)))
     (logand sum 255)))
 
@@ -1715,8 +1705,8 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
     (save-excursion
       (widen)
       (let* ((p        (+ archive-proper-file-start (aref descr 4)))
-	     (oldhsize (byte-after p))
-	     (oldfnlen (byte-after (+ p 21)))
+	     (oldhsize (get-byte p))
+	     (oldfnlen (get-byte (+ p 21)))
 	     (newfnlen (length newname))
 	     (newhsize (+ oldhsize newfnlen (- oldfnlen)))
 	     (inhibit-read-only t))
@@ -1724,10 +1714,10 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
 	    (error "The file name is too long"))
 	(goto-char (+ p 21))
 	(delete-char (1+ oldfnlen))
-	(insert-unibyte newfnlen newname)
+	(arc-insert-unibyte newfnlen newname)
 	(goto-char p)
 	(delete-char 2)
-	(insert-unibyte newhsize (archive-lzh-resum p newhsize))))))
+	(arc-insert-unibyte newhsize (archive-lzh-resum p newhsize))))))
 
 (defun archive-lzh-ogm (newval files errtxt ofs)
   (save-excursion
@@ -1735,10 +1725,10 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
       (widen)
       (dolist (fil files)
 	(let* ((p (+ archive-proper-file-start (aref fil 4)))
-	       (hsize   (byte-after p))
-	       (fnlen   (byte-after (+ p 21)))
+	       (hsize   (get-byte p))
+	       (fnlen   (get-byte (+ p 21)))
 	       (p2      (+ p 22 fnlen))
-	       (creator (if (>= (- hsize fnlen) 24) (byte-after (+ p2 2)) 0))
+	       (creator (if (>= (- hsize fnlen) 24) (get-byte (+ p2 2)) 0))
 	       (inhibit-read-only t))
 	  (if (= creator ?U)
 	      (progn
@@ -1746,10 +1736,10 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
 		    (setq newval (funcall newval (archive-l-e (+ p2 ofs) 2))))
 		(goto-char (+ p2 ofs))
 		(delete-char 2)
-		(insert-unibyte (logand newval 255) (ash newval -8))
+		(arc-insert-unibyte (logand newval 255) (ash newval -8))
 		(goto-char (1+ p))
 		(delete-char 1)
-		(insert-unibyte (archive-lzh-resum (1+ p) hsize)))
+		(arc-insert-unibyte (archive-lzh-resum (1+ p) hsize)))
 	    (message "Member %s does not have %s field"
 		     (aref fil 1) errtxt)))))))
 
@@ -1821,7 +1811,7 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
       (setq p (archive-l-e (+ p 48) 8)))
     (setq p (+ p (point-min)))
     (while (string= "PK\001\002" (buffer-substring p (+ p 4)))
-      (let* ((creator (byte-after (+ p 5)))
+      (let* ((creator (get-byte (+ p 5)))
 	     ;; (method  (archive-l-e (+ p 10) 2))
              (modtime (archive-l-e (+ p 12) 2))
              (moddate (archive-l-e (+ p 14) 2))
@@ -1841,7 +1831,7 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
 			     (logior ?\444
 				     (if isdir (logior 16384 ?\111) 0)
 				     (if (zerop
-					  (logand 1 (byte-after (+ p 38))))
+					  (logand 1 (get-byte (+ p 38))))
 					 ?\222 0)))
 			    (t nil)))
 	     (modestr (if mode (archive-int-to-mode mode) "??????????"))
@@ -1918,18 +1908,19 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
       (widen)
       (dolist (fil files)
 	(let* ((p (+ archive-proper-file-start (car (aref fil 4))))
-	       (creator (byte-after (+ p 5)))
+	       (creator (get-byte (+ p 5)))
 	       (oldmode (aref fil 3))
 	       (newval  (archive-calc-mode oldmode newmode t))
 	       (inhibit-read-only t))
 	  (cond ((memq creator '(2 3)) ; Unix
 		 (goto-char (+ p 40))
 		 (delete-char 2)
-		 (insert-unibyte (logand newval 255) (ash newval -8)))
+		 (arc-insert-unibyte (logand newval 255) (ash newval -8)))
 		((memq creator '(0 5 6 7 10 11 15)) ; Dos etc.
 		 (goto-char (+ p 38))
-		 (insert-unibyte (logior (logand (byte-after (point)) 254)
-					 (logand (logxor 1 (ash newval -7)) 1)))
+		 (arc-insert-unibyte
+                  (logior (logand (get-byte (point)) 254)
+			  (logand (logxor 1 (ash newval -7)) 1)))
 		 (delete-char 1))
 		(t (message "Don't know how to change mode for this member"))))
         ))))
@@ -1949,9 +1940,9 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
              (modtime (archive-l-e (+ p 16) 2))
              (ucsize  (archive-l-e (+ p 20) 4))
 	     (namefld (buffer-substring (+ p 38) (+ p 38 13)))
-	     (dirtype (byte-after (+ p 4)))
-	     (lfnlen  (if (= dirtype 2) (byte-after (+ p 56)) 0))
-	     (ldirlen (if (= dirtype 2) (byte-after (+ p 57)) 0))
+	     (dirtype (get-byte (+ p 4)))
+	     (lfnlen  (if (= dirtype 2) (get-byte (+ p 56)) 0))
+	     (ldirlen (if (= dirtype 2) (get-byte (+ p 57)) 0))
 	     (fnlen   (or (string-match "\0" namefld) 13))
 	     (efnname (let ((str
 			     (concat
@@ -2019,7 +2010,7 @@ This doesn't recover lost files, it just undoes changes in the buffer itself."
       (re-search-forward "^\\(\s+=+\s*\\)+\n")
       (while (looking-at (concat "^\s+[0-9.]+\s+D?-+\s+"   ; Flags
                                  "\\([0-9-]+\\)\s+"        ; Size
-                                 "\\([-0-9.%]+\\|-+\\)\s+" ; Ratio
+                                 "\\([-0-9.%]+\\)\s+"      ; Ratio
                                  "\\([0-9a-zA-Z]+\\)\s+"   ; Mode
                                  "\\([0-9-]+\\)\s+"        ; Date
                                  "\\([0-9:]+\\)\s+"        ; Time
diff --git a/lisp/autoinsert.el b/lisp/autoinsert.el
index f7ecfe27bb..a77ca091d2 100644
--- a/lisp/autoinsert.el
+++ b/lisp/autoinsert.el
@@ -1,4 +1,4 @@
-;;; autoinsert.el --- automatic mode-dependent insertion of text into new files
+;;; autoinsert.el --- automatic mode-dependent insertion of text into new files  -*- lexical-binding: t -*-
 
 ;; Copyright (C) 1985-1987, 1994-1995, 1998, 2000-2019 Free Software
 ;; Foundation, Inc.
@@ -49,6 +49,8 @@
 
 ;;; Code:
 
+(require 'seq)
+
 (defgroup auto-insert nil
   "Automatic mode-dependent insertion of text into new files."
   :prefix "auto-insert-"
@@ -72,22 +74,19 @@ With \\[auto-insert], this is always treated as if it were t."
   :type '(choice (const :tag "Insert if possible" t)
                  (const :tag "Do nothing" nil)
                  (other :tag "insert if possible, mark as unmodified."
-                        not-modified))
-  :group 'auto-insert)
+                        not-modified)))
 
 (defcustom auto-insert-query 'function
   "Non-nil means ask user before auto-inserting.
 When this is `function', only ask when called non-interactively."
   :type '(choice (const :tag "Don't ask" nil)
                  (const :tag "Ask if called non-interactively" function)
-                 (other :tag "Ask" t))
-  :group 'auto-insert)
+                 (other :tag "Ask" t)))
 
 (defcustom auto-insert-prompt "Perform %s auto-insertion? "
   "Prompt to use when querying whether to auto-insert.
 If this contains a %s, that will be replaced by the matching rule."
-  :type 'string
-  :group 'auto-insert)
+  :type 'string)
 
 
 (defcustom auto-insert-alist
@@ -316,8 +315,7 @@ described above, e.g. [\"header.insert\" date-and-author-update]."
                 ;; There's no custom equivalent of "repeat" for vectors.
                 :value-type (choice file function
                                     (sexp :tag "Skeleton or vector")))
-  :version "25.1"
-  :group 'auto-insert)
+  :version "25.1")
 
 
 ;; Establish a default value for auto-insert-directory
@@ -325,8 +323,7 @@ described above, e.g. [\"header.insert\" date-and-author-update]."
   "Directory from which auto-inserted files are taken.
 The value must be an absolute directory name;
 thus, on a GNU or Unix system, it must end in a slash."
-  :type 'directory
-  :group 'auto-insert)
+  :type 'directory)
 
 
 ;;;###autoload
@@ -338,23 +335,23 @@ Matches the visited file name against the elements of `auto-insert-alist'."
        (or (eq this-command 'auto-insert)
 	   (and auto-insert
 		(bobp) (eobp)))
-       (let ((alist auto-insert-alist)
-	     case-fold-search cond desc action)
-	 (goto-char 1)
-	 ;; find first matching alist entry
-	 (while alist
-	   (if (atom (setq cond (car (car alist))))
-	       (setq desc cond)
-	     (setq desc (cdr cond)
-		   cond (car cond)))
-	   (if (if (symbolp cond)
-                   (derived-mode-p cond)
-		 (and buffer-file-name
-		      (string-match cond buffer-file-name)))
-	       (setq action (cdr (car alist))
-		     alist nil)
-	     (setq alist (cdr alist))))
-
+       (let* ((case-fold-search nil)
+              (desc nil)
+              ;; Find first matching alist entry.
+              (action
+               (seq-some
+                (pcase-lambda (`(,cond . ,action))
+                  (if (atom cond)
+                      (setq desc cond)
+                    (setq desc (cdr cond)
+                          cond (car cond)))
+                  (when (if (symbolp cond)
+                            (derived-mode-p cond)
+                          (and buffer-file-name
+                               (string-match cond buffer-file-name)))
+                    action))
+                auto-insert-alist)))
+         (goto-char 1)
 	 ;; Now, if we found something, do it
 	 (and action
 	      (or (not (stringp action))
diff --git a/lisp/autorevert.el b/lisp/autorevert.el
index 4fb865e8ad..2de855b303 100644
--- a/lisp/autorevert.el
+++ b/lisp/autorevert.el
@@ -107,7 +107,7 @@
 
 ;; Dependencies:
 
-(eval-when-compile (require 'cl-lib))
+(require 'cl-lib)
 (require 'timer)
 (require 'filenotify)
 
@@ -126,8 +126,6 @@ Global Auto-Revert Mode does so in all buffers."
 
 ;; Variables:
 
-;;; What's this?: ;; Autoload for the benefit of `make-mode-line-mouse-sensitive'.
-;;; What's this?: ;;;###autoload
 (defvar auto-revert-mode nil
   "Non-nil when Auto-Revert Mode is active.
 Never set this variable directly, use the command `auto-revert-mode' instead.")
@@ -302,6 +300,27 @@ You should set this variable through Custom."
   :type 'regexp
   :version "24.4")
 
+(defcustom auto-revert-avoid-polling nil
+  "Non-nil to avoid polling files when notification is available.
+
+Set this variable to a non-nil value to save power by avoiding
+polling when possible.  Files on file-systems that do not support
+change notifications must match `auto-revert-notify-exclude-dir-regexp'
+for Auto-Revert to work properly in this case.  This typically
+includes files on network file systems on Unix-like machines,
+when those files are modified from another computer.
+
+When nil, buffers in Auto-Revert Mode will always be polled for
+changes to their files on disk every `auto-revert-interval'
+seconds, in addition to using notification for those files."
+  :group 'auto-revert
+  :type 'boolean
+  :set (lambda (variable value)
+         (set-default variable value)
+	 (when (fboundp 'auto-revert-set-timer)
+           (auto-revert-set-timer)))
+  :version "27.1")
+
 ;; Internal variables:
 
 (defvar auto-revert-buffer-list ()
@@ -313,6 +332,9 @@ buffers to this list.
 The timer function `auto-revert-buffers' is responsible for purging
 the list of old buffers.")
 
+(defvar-local auto-revert--global-mode nil
+  "Non-nil if buffer is handled by Global Auto-Revert mode.")
+
 (defvar auto-revert-remaining-buffers ()
   "Buffers not checked when user input stopped execution.")
 
@@ -326,12 +348,12 @@ the list of old buffers.")
 (add-hook 'find-file-hook
 	  #'auto-revert-find-file-function)
 
-(defvar auto-revert-notify-watch-descriptor-hash-list
+(defvar auto-revert--buffers-by-watch-descriptor
   (make-hash-table :test 'equal)
-  "A hash table collecting all file watch descriptors.
-Hash key is a watch descriptor, hash value is a list of buffers
-which are related to files being watched and carrying the same
-default directory.")
+  "A hash table mapping notification descriptors to lists of buffers.
+The buffers use that descriptor for auto-revert notifications.
+The key is equal to `auto-revert-notify-watch-descriptor' in each
+buffer.")
 
 (defvar-local auto-revert-notify-watch-descriptor nil
   "The file watch descriptor active for the current buffer.")
@@ -341,6 +363,9 @@ default directory.")
   "Non-nil when file has been modified on the file system.
 This has been reported by a file notification event.")
 
+(defvar auto-revert-debug nil
+  "Use for debug messages.")
+
 ;; Functions:
 
 (defun auto-revert-remove-current-buffer (&optional buffer)
@@ -476,11 +501,107 @@ specifies in the mode line."
   :global t :group 'auto-revert :lighter global-auto-revert-mode-text
   (auto-revert-set-timer)
   (if global-auto-revert-mode
-      (auto-revert-buffers)
+      ;; Turn global-auto-revert-mode ON.
+      (progn
+        (dolist (buf (buffer-list))
+          (with-current-buffer buf
+            (auto-revert--global-add-current-buffer)))
+        ;; Make sure future buffers are added as well.
+        (add-hook 'find-file-hook #'auto-revert--global-adopt-current-buffer)
+        (add-hook 'after-set-visited-file-name-hook
+                  #'auto-revert--global-set-visited-file-name)
+        ;; To track non-file buffers, we need to listen in to buffer
+        ;; creation in general.  Listening to major-mode changes is
+        ;; suitable, since we then know whether it's a mode that is tracked.
+        (when global-auto-revert-non-file-buffers
+          (add-hook 'after-change-major-mode-hook
+                    #'auto-revert--global-adopt-current-buffer))
+        (auto-revert-buffers))
+    ;; Turn global-auto-revert-mode OFF.
+    (remove-hook 'after-change-major-mode-hook
+                 #'auto-revert--global-adopt-current-buffer)
+    (remove-hook 'after-set-visited-file-name-hook
+                 #'auto-revert--global-set-visited-file-name)
+    (remove-hook 'find-file-hook #'auto-revert--global-adopt-current-buffer)
     (dolist (buf (buffer-list))
       (with-current-buffer buf
-	(when auto-revert-notify-watch-descriptor
-	  (auto-revert-notify-rm-watch))))))
+        (when auto-revert--global-mode
+          (setq auto-revert--global-mode nil)
+          (when (and auto-revert-notify-watch-descriptor
+                     (not (or auto-revert-mode auto-revert-tail-mode)))
+	    (auto-revert-notify-rm-watch)))))))
+
+(defun auto-revert--global-add-current-buffer ()
+  "Set current buffer to be tracked by Global Auto-Revert if appropriate."
+  (when (and (not auto-revert--global-mode)
+             (or buffer-file-name
+                 (and global-auto-revert-non-file-buffers
+                      (not (string-prefix-p " " (buffer-name)))
+                      ;; Any non-file buffer must have a custom
+                      ;; `buffer-stale-function' to be tracked, since
+                      ;; we wouldn't know when to revert it otherwise.
+                      (not (eq buffer-stale-function
+                               #'buffer-stale--default-function))))
+             (not (memq 'major-mode global-auto-revert-ignore-modes))
+             (not global-auto-revert-ignore-buffer))
+    (setq auto-revert--global-mode t)))
+
+(defun auto-revert--global-adopt-current-buffer ()
+  "Consider tracking current buffer in a running Global Auto-Revert mode."
+  (auto-revert--global-add-current-buffer)
+  (auto-revert-set-timer))
+
+(defun auto-revert--global-set-visited-file-name ()
+  "Update Global Auto-Revert management of the current buffer.
+Called after `set-visited-file-name'."
+  ;; Remove any existing notifier first so that we don't track the
+  ;; wrong file in case the file name was changed.
+  (when auto-revert-notify-watch-descriptor
+    (auto-revert-notify-rm-watch))
+  (auto-revert--global-adopt-current-buffer))
+
+(defun auto-revert--polled-buffers ()
+  "List of buffers that need to be polled."
+  (cond (global-auto-revert-mode
+         (mapcan (lambda (buffer)
+                   (and (not (and auto-revert-avoid-polling
+                                  (buffer-local-value
+                                   'auto-revert-notify-watch-descriptor
+                                   buffer)))
+                        (or (buffer-local-value
+                             'auto-revert--global-mode buffer)
+                            (buffer-local-value 'auto-revert-mode buffer)
+                            (buffer-local-value 'auto-revert-tail-mode buffer))
+                        (list buffer)))
+                 (buffer-list)))
+        (auto-revert-avoid-polling
+         (mapcan (lambda (buffer)
+                   (and (not (buffer-local-value
+                              'auto-revert-notify-watch-descriptor buffer))
+                        (list buffer)))
+                 auto-revert-buffer-list))
+        (t auto-revert-buffer-list)))
+
+;; Same as above in a boolean context, but cheaper.
+(defun auto-revert--need-polling-p ()
+  "Whether periodic polling is required."
+  (cond (global-auto-revert-mode
+         (or (not auto-revert-avoid-polling)
+             (cl-some
+              (lambda (buffer)
+                (and (not (buffer-local-value
+                           'auto-revert-notify-watch-descriptor buffer))
+                     (or (buffer-local-value 'auto-revert--global-mode buffer)
+                         (buffer-local-value 'auto-revert-mode buffer)
+                         (buffer-local-value 'auto-revert-tail-mode buffer))))
+              (buffer-list))))
+        (auto-revert-avoid-polling
+         (not (cl-every
+               (lambda (buffer)
+                 (buffer-local-value
+                  'auto-revert-notify-watch-descriptor buffer))
+               auto-revert-buffer-list)))
+        (t auto-revert-buffer-list)))
 
 (defun auto-revert-set-timer ()
   "Restart or cancel the timer used by Auto-Revert Mode.
@@ -492,25 +613,23 @@ will use an up-to-date value of `auto-revert-interval'"
   (if (timerp auto-revert-timer)
       (cancel-timer auto-revert-timer))
   (setq auto-revert-timer
-	(if (or global-auto-revert-mode auto-revert-buffer-list)
-	    (run-with-timer auto-revert-interval
-			    auto-revert-interval
-			    'auto-revert-buffers))))
+	(and (auto-revert--need-polling-p)
+	     (run-with-timer auto-revert-interval
+			     auto-revert-interval
+			     'auto-revert-buffers))))
 
 (defun auto-revert-notify-rm-watch ()
   "Disable file notification for current buffer's associated file."
-  (when auto-revert-notify-watch-descriptor
-    (maphash
-     (lambda (key value)
-       (when (equal key auto-revert-notify-watch-descriptor)
-	 (setq value (delete (current-buffer) value))
-	 (if value
-	     (puthash key value auto-revert-notify-watch-descriptor-hash-list)
-	   (remhash key auto-revert-notify-watch-descriptor-hash-list)
-	   (ignore-errors
-	     (file-notify-rm-watch auto-revert-notify-watch-descriptor)))))
-     auto-revert-notify-watch-descriptor-hash-list)
-    (remove-hook 'kill-buffer-hook #'auto-revert-notify-rm-watch t))
+  (let ((desc auto-revert-notify-watch-descriptor)
+        (table auto-revert--buffers-by-watch-descriptor))
+    (when desc
+      (let ((buffers (delq (current-buffer) (gethash desc table))))
+        (if buffers
+            (puthash desc buffers table)
+          (remhash desc table)))
+      (ignore-errors
+	(file-notify-rm-watch desc))
+      (remove-hook 'kill-buffer-hook #'auto-revert-notify-rm-watch t)))
   (setq auto-revert-notify-watch-descriptor nil
 	auto-revert-notify-modified-p nil))
 
@@ -536,7 +655,7 @@ will use an up-to-date value of `auto-revert-interval'"
                         (gethash key file-notify-descriptors))
                        'auto-revert-notify-handler))
          (setq auto-revert-notify-watch-descriptor key)))
-       auto-revert-notify-watch-descriptor-hash-list)
+       auto-revert--buffers-by-watch-descriptor)
       ;; Create a new watch if needed.
       (unless auto-revert-notify-watch-descriptor
         (setq auto-revert-notify-watch-descriptor
@@ -551,8 +670,8 @@ will use an up-to-date value of `auto-revert-interval'"
          auto-revert-notify-watch-descriptor
          (cons (current-buffer)
 	       (gethash auto-revert-notify-watch-descriptor
-		        auto-revert-notify-watch-descriptor-hash-list))
-         auto-revert-notify-watch-descriptor-hash-list)
+		        auto-revert--buffers-by-watch-descriptor))
+         auto-revert--buffers-by-watch-descriptor)
         (add-hook 'kill-buffer-hook #'auto-revert-notify-rm-watch nil t)))))
 
 ;; If we have file notifications, we want to update the auto-revert buffers
@@ -560,24 +679,20 @@ will use an up-to-date value of `auto-revert-interval'"
 ;; often, we want to skip some revert operations so that we don't spend all our
 ;; time reverting the buffer.
 ;;
-;; We do this by reverting immediately in response to the first in a flurry of
-;; notifications. We suppress subsequent notifications until the next time
-;; `auto-revert-buffers' is called (this happens on a timer with a period set by
-;; `auto-revert-interval').
-(defvar auto-revert-buffers-counter 1
-  "Incremented each time `auto-revert-buffers' is called")
-(defvar-local auto-revert-buffers-counter-lockedout 0
-  "Buffer-local value to indicate whether we should immediately
-update the buffer on a notification event or not. If
-
-  (= auto-revert-buffers-counter-lockedout
-     auto-revert-buffers-counter)
-
-then the updates are locked out, and we wait until the next call
-of `auto-revert-buffers' to revert the buffer. If no lockout is
-present, then we revert immediately and set the lockout, so that
-no more reverts are possible until the next call of
-`auto-revert-buffers'")
+;; We do this by reverting immediately in response to the first in a
+;; flurry of notifications. Any notifications during the following
+;; `auto-revert-lockout-interval' seconds are noted but not acted upon
+;; until the end of that interval.
+
+(defconst auto-revert--lockout-interval 2.5
+  "Duration, in seconds, of the Auto-Revert Mode notification lockout.
+This is the quiescence after each notification of a file being
+changed during which no automatic reverting takes place, to
+prevent many updates in rapid succession from overwhelming the
+system.")
+
+(defvar-local auto-revert--lockout-timer nil
+  "Timer awaiting the end of the notification lockout interval, or nil.")
 
 (defun auto-revert-notify-handler (event)
   "Handle an EVENT returned from file notification."
@@ -587,29 +702,31 @@ no more reverts are possible until the next call of
 	   (file (nth 2 event))
 	   (file1 (nth 3 event)) ;; Target of `renamed'.
 	   (buffers (gethash descriptor
-			     auto-revert-notify-watch-descriptor-hash-list)))
+			     auto-revert--buffers-by-watch-descriptor)))
       ;; Check, that event is meant for us.
       (cl-assert descriptor)
       ;; Since we watch a directory, a file name must be returned.
       (cl-assert (stringp file))
       (when (eq action 'renamed) (cl-assert (stringp file1)))
+      (when auto-revert-debug
+        (message "auto-revert-notify-handler %S" event))
 
       (if (eq action 'stopped)
           ;; File notification has stopped.  Continue with polling.
-          (cl-dolist (buffer
-                      (if global-auto-revert-mode
-                          (buffer-list) auto-revert-buffer-list))
+          (cl-dolist (buffer buffers)
             (with-current-buffer buffer
-              (when (and (equal descriptor auto-revert-notify-watch-descriptor)
-                         (or
-                          ;; A buffer associated with a file.
-                          (and (stringp buffer-file-name)
-                               (string-equal
-                                (file-name-nondirectory file)
-                                (file-name-nondirectory buffer-file-name)))
-                          ;; A buffer w/o a file, like dired.
-                          (null buffer-file-name)))
-                (auto-revert-notify-rm-watch))))
+              (when (or
+                     ;; A buffer associated with a file.
+                     (and (stringp buffer-file-name)
+                          (string-equal
+                           (file-name-nondirectory file)
+                           (file-name-nondirectory buffer-file-name)))
+                     ;; A buffer w/o a file, like dired.
+                     (null buffer-file-name))
+                (auto-revert-notify-rm-watch)
+                ;; Restart the timer if it wasn't running.
+                (unless auto-revert-timer)
+                  (auto-revert-set-timer))))
 
         ;; Loop over all buffers, in order to find the intended one.
         (cl-dolist (buffer buffers)
@@ -635,19 +752,27 @@ no more reverts are possible until the next call of
                 (setq auto-revert-notify-modified-p t)
 
                 ;; Revert the buffer now if we're not locked out.
-                (when (/= auto-revert-buffers-counter-lockedout
-                          auto-revert-buffers-counter)
+                (unless auto-revert--lockout-timer
                   (auto-revert-handler)
-                  (setq auto-revert-buffers-counter-lockedout
-                        auto-revert-buffers-counter))))))))))
+                  (setq auto-revert--lockout-timer
+                        (run-with-timer
+                         auto-revert--lockout-interval nil
+                         #'auto-revert--end-lockout buffer)))))))))))
+
+(defun auto-revert--end-lockout (buffer)
+  "End the lockout period after a notification.
+If the buffer needs to be reverted, do it now."
+  (when (buffer-live-p buffer)
+    (with-current-buffer buffer
+      (setq auto-revert--lockout-timer nil)
+      (when auto-revert-notify-modified-p
+        (auto-revert-handler)))))
 
 (defun auto-revert-active-p ()
-  "Check if auto-revert is active (in current buffer or globally)."
+  "Check if auto-revert is active in current buffer."
   (or auto-revert-mode
       auto-revert-tail-mode
-      (and global-auto-revert-mode
-           (not global-auto-revert-ignore-buffer)
-           (not (memq major-mode global-auto-revert-ignore-modes)))))
+      auto-revert--global-mode))
 
 (defun auto-revert-handler ()
   "Revert current buffer, if appropriate.
@@ -760,13 +885,8 @@ This function is also responsible for removing buffers no longer in
 Auto-Revert Mode from `auto-revert-buffer-list', and for canceling
 the timer when no buffers need to be checked."
 
-  (setq auto-revert-buffers-counter
-        (1+ auto-revert-buffers-counter))
-
   (save-match-data
-    (let ((bufs (if global-auto-revert-mode
-		    (buffer-list)
-		  auto-revert-buffer-list))
+    (let ((bufs (auto-revert--polled-buffers))
 	  remaining new)
       ;; Buffers with remote contents shall be reverted only if the
       ;; connection is established already.
@@ -808,15 +928,18 @@ the timer when no buffers need to be checked."
                   (auto-revert-remove-current-buffer))
               (when (auto-revert-active-p)
                 ;; Enable file notification.
+                ;; Don't bother creating a notifier for non-file buffers
+                ;; unless it explicitly indicates that this works.
                 (when (and auto-revert-use-notify
-                           (not auto-revert-notify-watch-descriptor))
+                           (not auto-revert-notify-watch-descriptor)
+                           (or buffer-file-name
+                               buffer-auto-revert-by-notification))
                   (auto-revert-notify-add-watch))
                 (auto-revert-handler)))))
 	(setq bufs (cdr bufs)))
       (setq auto-revert-remaining-buffers bufs)
       ;; Check if we should cancel the timer.
-      (when (and (not global-auto-revert-mode)
-		 (null auto-revert-buffer-list))
+      (unless (auto-revert--need-polling-p)
         (if (timerp auto-revert-timer)
             (cancel-timer auto-revert-timer))
 	(setq auto-revert-timer nil)))))
diff --git a/lisp/battery.el b/lisp/battery.el
index 49b01d5b54..7037d07dcf 100644
--- a/lisp/battery.el
+++ b/lisp/battery.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1997-1998, 2000-2019 Free Software Foundation, Inc.
 
-;; Author: Ralph Schleicher <rs@nunatak.allgaeu.org>
+;; Author: Ralph Schleicher <rs@ralph-schleicher.de>
 ;; Keywords: hardware
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/bookmark.el b/lisp/bookmark.el
index 3041401e17..ed71dd1ade 100644
--- a/lisp/bookmark.el
+++ b/lisp/bookmark.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1993-1997, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Karl Fogel <kfogel@red-bean.com>
-;; Maintainer: Karl Fogel <kfogel@red-bean.com>
 ;; Created: July, 1993
 ;; Keywords: bookmarks, placeholders, annotations
 
@@ -334,8 +333,9 @@ one element from `bookmark-alist'."
   "Return the bookmark record corresponding to BOOKMARK-NAME-OR-RECORD.
 If BOOKMARK-NAME-OR-RECORD is a string, look for the corresponding
 bookmark record in `bookmark-alist'; return it if found, otherwise
-error.  Else if BOOKMARK-NAME-OR-RECORD is already a bookmark record,
-just return it."
+error.  If optional argument NOERROR is non-nil, return nil
+instead of signaling an error.  Else if BOOKMARK-NAME-OR-RECORD
+is already a bookmark record, just return it."
   (cond
    ((consp bookmark-name-or-record) bookmark-name-or-record)
    ((stringp bookmark-name-or-record)
diff --git a/lisp/bs.el b/lisp/bs.el
index 86a19fddcc..cd9524a440 100644
--- a/lisp/bs.el
+++ b/lisp/bs.el
@@ -181,12 +181,7 @@ return a string representing the column's value."
    (list (bs--make-header-match-string)
 	 '(1 font-lock-type-face append) '(1 'bold append))
    ;; Buffername embedded by *
-   (list "^\\(.*\\*.*\\*.*\\)$"
-	 1
-	 ;; problem in XEmacs with font-lock-constant-face
-	 (if (facep 'font-lock-constant-face)
-	     'font-lock-constant-face
-	   'font-lock-comment-face))
+   (list "^\\(.*\\*.*\\*.*\\)$" 1 'font-lock-constant-face)
    ;; Dired-Buffers
    '("^..\\(.*Dired .*\\)$" 1 font-lock-function-name-face)
    ;; the star for modified buffers
@@ -343,11 +338,6 @@ configuration.
 A value of `never' means to never show the buffer.
 A value of `always' means to show buffer regardless of the configuration.")
 
-;; Make face named region (for XEmacs)
-(unless (facep 'region)
-  (make-face 'region)
-  (set-face-background 'region "gray75"))
-
 (defun bs--sort-by-name (b1 b2)
   "Compare buffers B1 and B2 by buffer name."
   (string< (buffer-name b1)
@@ -448,8 +438,7 @@ Used internally, only.")
     (define-key map "f"       'bs-select)
     (define-key map "v"       'bs-view)
     (define-key map "!"       'bs-select-in-one-window)
-    (define-key map [mouse-2] 'bs-mouse-select)	;; for GNU EMACS
-    (define-key map [button2] 'bs-mouse-select) ;; for XEmacs
+    (define-key map [mouse-2] 'bs-mouse-select)
     (define-key map "F"       'bs-select-other-frame)
     (let ((key ?1))
       (while (<= key ?9)
@@ -459,10 +448,7 @@ Used internally, only.")
     (define-key map "\e-"     'negative-argument)
     (define-key map "o"       'bs-select-other-window)
     (define-key map "\C-o"    'bs-tmp-select-other-window)
-    ;; for GNU EMACS
     (define-key map [mouse-3] 'bs-mouse-select-other-frame)
-    ;; for XEmacs
-    (define-key map [button3] 'bs-mouse-select-other-frame)
     (define-key map [up]      'bs-up)
     (define-key map "n"       'bs-down)
     (define-key map "p"       'bs-up)
diff --git a/lisp/calc/calc.el b/lisp/calc/calc.el
index 35f13f9656..1496a741ab 100644
--- a/lisp/calc/calc.el
+++ b/lisp/calc/calc.el
@@ -37,13 +37,12 @@
 ;; work for the foreseeable future.
 ;;
 ;; Bug reports and suggestions are always welcome!  (Type M-x
-;; report-calc-bug to send them).
+;; report-emacs-bug to send them).
 
 ;; All functions, macros, and Lisp variables defined here begin with one
 ;; of the prefixes "math", "Math", or "calc", with the exceptions of
 ;; "full-calc", "full-calc-keypad", "another-calc", "quick-calc",
-;; "report-calc-bug", and "defmath".  User-accessible variables begin
-;; with "var-".
+;; and "defmath".  User-accessible variables begin with "var-".
 
 ;;; TODO:
 
diff --git a/lisp/calendar/appt.el b/lisp/calendar/appt.el
index 40cb9f7cbd..b7aa2123a4 100644
--- a/lisp/calendar/appt.el
+++ b/lisp/calendar/appt.el
@@ -4,7 +4,7 @@
 ;; Foundation, Inc.
 
 ;; Author: Neil Mager <neilm@juliet.ll.mit.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Package: calendar
 
diff --git a/lisp/calendar/cal-china.el b/lisp/calendar/cal-china.el
index f92947ed28..c006765a09 100644
--- a/lisp/calendar/cal-china.el
+++ b/lisp/calendar/cal-china.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1995, 1997, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: Chinese calendar, calendar, holidays, diary
 ;; Package: calendar
diff --git a/lisp/calendar/cal-coptic.el b/lisp/calendar/cal-coptic.el
index 6fa460625c..c05f6d329a 100644
--- a/lisp/calendar/cal-coptic.el
+++ b/lisp/calendar/cal-coptic.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1995, 1997, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: Coptic calendar, Ethiopic calendar, calendar, diary
 ;; Package: calendar
diff --git a/lisp/calendar/cal-dst.el b/lisp/calendar/cal-dst.el
index 2126cfdadb..e0126a6560 100644
--- a/lisp/calendar/cal-dst.el
+++ b/lisp/calendar/cal-dst.el
@@ -2,9 +2,9 @@
 
 ;; Copyright (C) 1993-1996, 2001-2019 Free Software Foundation, Inc.
 
-;; Author: Paul Eggert <eggert@twinsun.com>
+;; Author: Paul Eggert <eggert@cs.ucla.edu>
 ;;         Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: daylight saving time, calendar, diary, holidays
 ;; Package: calendar
diff --git a/lisp/calendar/cal-french.el b/lisp/calendar/cal-french.el
index b9abab5ffa..2c60602b13 100644
--- a/lisp/calendar/cal-french.el
+++ b/lisp/calendar/cal-french.el
@@ -4,7 +4,7 @@
 ;; Software Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: French Revolutionary calendar, calendar, diary
 ;; Package: calendar
diff --git a/lisp/calendar/cal-hebrew.el b/lisp/calendar/cal-hebrew.el
index b26dbbebda..8268335fc6 100644
--- a/lisp/calendar/cal-hebrew.el
+++ b/lisp/calendar/cal-hebrew.el
@@ -4,7 +4,7 @@
 
 ;; Author: Nachum Dershowitz <nachum@cs.uiuc.edu>
 ;;         Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: Hebrew calendar, calendar, diary
 ;; Package: calendar
diff --git a/lisp/calendar/cal-islam.el b/lisp/calendar/cal-islam.el
index 32e15f538d..008f183e5d 100644
--- a/lisp/calendar/cal-islam.el
+++ b/lisp/calendar/cal-islam.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1995, 1997, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: Islamic calendar, calendar, diary
 ;; Package: calendar
diff --git a/lisp/calendar/cal-iso.el b/lisp/calendar/cal-iso.el
index 8568afeb05..3611091bed 100644
--- a/lisp/calendar/cal-iso.el
+++ b/lisp/calendar/cal-iso.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1995, 1997, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: ISO calendar, calendar, diary
 ;; Package: calendar
diff --git a/lisp/calendar/cal-julian.el b/lisp/calendar/cal-julian.el
index 1297a96bf9..1f2dc09aca 100644
--- a/lisp/calendar/cal-julian.el
+++ b/lisp/calendar/cal-julian.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1995, 1997, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: Julian calendar, Julian day number, calendar, diary
 ;; Package: calendar
diff --git a/lisp/calendar/cal-mayan.el b/lisp/calendar/cal-mayan.el
index 37fe4b9a2e..e1377347bb 100644
--- a/lisp/calendar/cal-mayan.el
+++ b/lisp/calendar/cal-mayan.el
@@ -5,7 +5,7 @@
 
 ;; Author: Stewart M. Clamen <clamen@cs.cmu.edu>
 ;;         Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: Mayan calendar, Maya, calendar, diary
 ;; Package: calendar
diff --git a/lisp/calendar/cal-menu.el b/lisp/calendar/cal-menu.el
index cf7d04fbb4..67181f8645 100644
--- a/lisp/calendar/cal-menu.el
+++ b/lisp/calendar/cal-menu.el
@@ -4,7 +4,7 @@
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
 ;;         Lara Rios <lrios@coewl.cen.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: calendar, popup menus, menu bar
 ;; Package: calendar
diff --git a/lisp/calendar/cal-move.el b/lisp/calendar/cal-move.el
index ecd05e7e49..41407f28e5 100644
--- a/lisp/calendar/cal-move.el
+++ b/lisp/calendar/cal-move.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1995, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: calendar
 ;; Package: calendar
diff --git a/lisp/calendar/cal-persia.el b/lisp/calendar/cal-persia.el
index c0b6cb23cf..2cb6466335 100644
--- a/lisp/calendar/cal-persia.el
+++ b/lisp/calendar/cal-persia.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1996-1997, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: Persian calendar, calendar, diary
 ;; Package: calendar
diff --git a/lisp/calendar/cal-tex.el b/lisp/calendar/cal-tex.el
index 78ab076595..f46c07407d 100644
--- a/lisp/calendar/cal-tex.el
+++ b/lisp/calendar/cal-tex.el
@@ -4,7 +4,7 @@
 
 ;; Author: Steve Fisk <fisk@bowdoin.edu>
 ;;         Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: Calendar, LaTeX
 ;; Package: calendar
diff --git a/lisp/calendar/cal-x.el b/lisp/calendar/cal-x.el
index 58d1eeb60e..adef1fad05 100644
--- a/lisp/calendar/cal-x.el
+++ b/lisp/calendar/cal-x.el
@@ -2,9 +2,9 @@
 
 ;; Copyright (C) 1994-1995, 2001-2019 Free Software Foundation, Inc.
 
-;; Author: Michael Kifer <kifer@cs.sunysb.edu>
+;; Author: Michael Kifer <kifer@cs.stonybrook.edu>
 ;;         Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: calendar, dedicated frames
 ;; Package: calendar
diff --git a/lisp/calendar/calendar.el b/lisp/calendar/calendar.el
index de8f758fae..2baa01f9d5 100644
--- a/lisp/calendar/calendar.el
+++ b/lisp/calendar/calendar.el
@@ -4,7 +4,7 @@
 ;; Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: calendar, Gregorian calendar, diary, holidays
 
diff --git a/lisp/calendar/diary-lib.el b/lisp/calendar/diary-lib.el
index 1be2a05eee..369a93ca17 100644
--- a/lisp/calendar/diary-lib.el
+++ b/lisp/calendar/diary-lib.el
@@ -4,7 +4,7 @@
 ;; Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/calendar/holidays.el b/lisp/calendar/holidays.el
index 2b080c3073..89832ab73e 100644
--- a/lisp/calendar/holidays.el
+++ b/lisp/calendar/holidays.el
@@ -4,7 +4,7 @@
 ;; Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: holidays, calendar
 ;; Package: calendar
 
diff --git a/lisp/calendar/lunar.el b/lisp/calendar/lunar.el
index 5424551e24..7ddb93967f 100644
--- a/lisp/calendar/lunar.el
+++ b/lisp/calendar/lunar.el
@@ -4,7 +4,7 @@
 ;; Foundation, Inc.
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: moon, lunar phases, calendar, diary
 ;; Package: calendar
diff --git a/lisp/calendar/parse-time.el b/lisp/calendar/parse-time.el
index 93e7e53b6a..68d6ce05d6 100644
--- a/lisp/calendar/parse-time.el
+++ b/lisp/calendar/parse-time.el
@@ -168,8 +168,7 @@ unknown DST value is returned as -1."
 	    (when (and (not (nth (car slots) time)) ;not already set
 		       (setq parse-time-val
 			     (cond ((and (consp predicate)
-					 (not (eq (car predicate)
-						  'lambda)))
+					 (not (functionp predicate)))
 				    (and (numberp parse-time-elt)
 					 (<= (car predicate) parse-time-elt)
 					 (or (not (cdr predicate))
@@ -191,7 +190,7 @@ unknown DST value is returned as -1."
 					  :end (aref this 1))
 				       (funcall this)))
 				 parse-time-val)))
-		  (rplaca (nthcdr (pop slots) time) new-val))))))))
+		  (setf (nth (pop slots) time) new-val))))))))
     time))
 
 (defconst parse-time-iso8601-regexp
@@ -244,16 +243,17 @@ If DATE-STRING cannot be parsed, it falls back to
 	      re-start (match-end 0))
 	(when (string-match tz-re date-string re-start)
           (setq dst nil)
-          (if (string= "Z" (match-string 1 date-string))
-              (setq tz 0)  ;; UTC timezone indicated by Z
-            (setq tz (+
-                      (* 3600
-                         (string-to-number (match-string 3 date-string)))
-                      (* 60
-                         (string-to-number
-                          (or (match-string 4 date-string) "0")))))
-            (when (string= "-" (match-string 2 date-string))
-              (setq tz (- tz)))))
+          (setq tz (if (string= "Z" (match-string 1 date-string))
+                       0  ;; UTC timezone indicated by Z
+                     (let ((tz (+
+                                (* 3600
+                                   (string-to-number
+                                    (match-string 3 date-string)))
+                                (* 60
+                                   (string-to-number
+                                    (or (match-string 4 date-string) "0"))))))
+                       (if (string= "-" (match-string 2 date-string))
+                            (- tz) tz)))))
 	(setq time (list seconds minute hour day month year day-of-week dst tz))))
 
     ;; Fall back to having `parse-time-string' do fancy things for us.
diff --git a/lisp/calendar/solar.el b/lisp/calendar/solar.el
index 23bc7611e5..bf8a7f0b21 100644
--- a/lisp/calendar/solar.el
+++ b/lisp/calendar/solar.el
@@ -5,7 +5,7 @@
 
 ;; Author: Edward M. Reingold <reingold@cs.uiuc.edu>
 ;;         Denis B. Roegel <Denis.Roegel@loria.fr>
-;; Maintainer: Glenn Morris <rgm@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: calendar
 ;; Human-Keywords: sunrise, sunset, equinox, solstice, calendar, diary, holidays
 ;; Package: calendar
diff --git a/lisp/calendar/time-date.el b/lisp/calendar/time-date.el
index cc30bd1fda..2c0280ccf3 100644
--- a/lisp/calendar/time-date.el
+++ b/lisp/calendar/time-date.el
@@ -155,13 +155,13 @@ If DATE lacks timezone information, GMT is assumed."
     (error
      (let ((overflow-error '(error "Specified time is not representable")))
        (if (equal err overflow-error)
-	   (apply 'signal err)
+	   (signal (car err) (cdr err))
 	 (condition-case err
 	     (encode-time (parse-time-string
 			   (timezone-make-date-arpa-standard date)))
 	   (error
 	    (if (equal err overflow-error)
-		(apply 'signal err)
+		(signal (car err) (cdr err))
 	      (error "Invalid date: %s" date)))))))))
 
 ;;;###autoload
diff --git a/lisp/cedet/cedet-files.el b/lisp/cedet/cedet-files.el
index b378bcfc25..d3becd5c84 100644
--- a/lisp/cedet/cedet-files.el
+++ b/lisp/cedet/cedet-files.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 ;; Package: cedet
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/cedet/cedet-global.el b/lisp/cedet/cedet-global.el
index 0a6604b8e9..e3cd7a852a 100644
--- a/lisp/cedet/cedet-global.el
+++ b/lisp/cedet/cedet-global.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 ;; Package: cedet
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/cedet/cedet-idutils.el b/lisp/cedet/cedet-idutils.el
index 7b8be0767f..f2fbe19362 100644
--- a/lisp/cedet/cedet-idutils.el
+++ b/lisp/cedet/cedet-idutils.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 ;; Old-Version: 0.2
 ;; Keywords: OO, lisp
 ;; Package: cedet
diff --git a/lisp/cedet/cedet.el b/lisp/cedet/cedet.el
index b3d4a5def2..9260cfb47d 100644
--- a/lisp/cedet/cedet.el
+++ b/lisp/cedet/cedet.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 2002-2019 Free Software Foundation, Inc.
 
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: Eric M. Ludlam  <zappo@gnu.org>
+;; Maintainer: Eric M. Ludlam <zappo@gnu.org>
 ;; Version: 2.0
 ;; Keywords: OO, lisp
 
diff --git a/lisp/cedet/data-debug.el b/lisp/cedet/data-debug.el
index eeec6b5834..ffdd9e8cdb 100644
--- a/lisp/cedet/data-debug.el
+++ b/lisp/cedet/data-debug.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam  <zappo@gnu.org>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 ;; Old-Version: 0.2
 ;; Keywords: OO, lisp
 ;; Package: cedet
diff --git a/lisp/cedet/ede/config.el b/lisp/cedet/ede/config.el
index 285951cacc..f708f844f3 100644
--- a/lisp/cedet/ede/config.el
+++ b/lisp/cedet/ede/config.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2014-2019 Free Software Foundation, Inc.
 
-;; Author: Eric Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/cpp-root.el b/lisp/cedet/ede/cpp-root.el
index f715187f4b..ec12bbec6b 100644
--- a/lisp/cedet/ede/cpp-root.el
+++ b/lisp/cedet/ede/cpp-root.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/detect.el b/lisp/cedet/ede/detect.el
index e33f7a9a0f..3dfb84803b 100644
--- a/lisp/cedet/ede/detect.el
+++ b/lisp/cedet/ede/detect.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2014-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/emacs.el b/lisp/cedet/ede/emacs.el
index 19400c77bf..dea00106b2 100644
--- a/lisp/cedet/ede/emacs.el
+++ b/lisp/cedet/ede/emacs.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/files.el b/lisp/cedet/ede/files.el
index dbe07fbbdb..fc74c0a07e 100644
--- a/lisp/cedet/ede/files.el
+++ b/lisp/cedet/ede/files.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/generic.el b/lisp/cedet/ede/generic.el
index 075c4ce0a1..3706daf082 100644
--- a/lisp/cedet/ede/generic.el
+++ b/lisp/cedet/ede/generic.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2010-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/linux.el b/lisp/cedet/ede/linux.el
index 8ec6d8b0b1..e06b57e39e 100644
--- a/lisp/cedet/ede/linux.el
+++ b/lisp/cedet/ede/linux.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/locate.el b/lisp/cedet/ede/locate.el
index 866dce6ede..d0904c0c15 100644
--- a/lisp/cedet/ede/locate.el
+++ b/lisp/cedet/ede/locate.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/make.el b/lisp/cedet/ede/make.el
index 3eb11d52bf..d3777ca7d6 100644
--- a/lisp/cedet/ede/make.el
+++ b/lisp/cedet/ede/make.el
@@ -2,7 +2,7 @@
 
 ;;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/makefile-edit.el b/lisp/cedet/ede/makefile-edit.el
index 1472108ad5..ac3f1e9f51 100644
--- a/lisp/cedet/ede/makefile-edit.el
+++ b/lisp/cedet/ede/makefile-edit.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/shell.el b/lisp/cedet/ede/shell.el
index a20046c817..11a5eacaef 100644
--- a/lisp/cedet/ede/shell.el
+++ b/lisp/cedet/ede/shell.el
@@ -2,7 +2,7 @@
 ;;
 ;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 ;;
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/simple.el b/lisp/cedet/ede/simple.el
index fb4df48958..80b19027fc 100644
--- a/lisp/cedet/ede/simple.el
+++ b/lisp/cedet/ede/simple.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/ede/srecode.el b/lisp/cedet/ede/srecode.el
index 5217e2d675..2d3636006f 100644
--- a/lisp/cedet/ede/srecode.el
+++ b/lisp/cedet/ede/srecode.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/mode-local.el b/lisp/cedet/mode-local.el
index f83decbc01..fe87d1ae4b 100644
--- a/lisp/cedet/mode-local.el
+++ b/lisp/cedet/mode-local.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2004-2005, 2007-2019 Free Software Foundation, Inc.
 ;;
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 27 Apr 2004
 ;; Keywords: syntax
 
diff --git a/lisp/cedet/pulse.el b/lisp/cedet/pulse.el
index fd658fa19b..bd3687ab55 100644
--- a/lisp/cedet/pulse.el
+++ b/lisp/cedet/pulse.el
@@ -2,7 +2,7 @@
 
 ;;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 ;; Version: 1.0
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/cedet/semantic/bovine.el b/lisp/cedet/semantic/bovine.el
index 5d174c812e..7a9556f784 100644
--- a/lisp/cedet/semantic/bovine.el
+++ b/lisp/cedet/semantic/bovine.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1999-2004, 2006-2007, 2009-2019 Free Software
 ;; Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/bovine/gcc.el b/lisp/cedet/semantic/bovine/gcc.el
index e04efb30b7..e5f85599fe 100644
--- a/lisp/cedet/semantic/bovine/gcc.el
+++ b/lisp/cedet/semantic/bovine/gcc.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/bovine/grammar.el b/lisp/cedet/semantic/bovine/grammar.el
index f77bc9db55..7c25b79db8 100644
--- a/lisp/cedet/semantic/bovine/grammar.el
+++ b/lisp/cedet/semantic/bovine/grammar.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2002-2019 Free Software Foundation, Inc.
 ;;
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 26 Aug 2002
 ;; Keywords: syntax
 
diff --git a/lisp/cedet/semantic/complete.el b/lisp/cedet/semantic/complete.el
index 88ddd58059..ea2e2dbd1a 100644
--- a/lisp/cedet/semantic/complete.el
+++ b/lisp/cedet/semantic/complete.el
@@ -1551,7 +1551,7 @@ one in the source buffer."
 
 ;;; Tooltip completion lister
 ;;
-;; Written and contributed by Masatake YAMATO <jet@gyve.org>
+;; Written and contributed by Masatake YAMATO <yamato@redhat.com>
 ;;
 ;; Modified by Eric Ludlam for
 ;; * Safe compatibility for tooltip free systems.
@@ -1749,7 +1749,7 @@ Return a cons cell (X . Y)"
   (semantic-displayor-show-request obj)
   )
 
-;; End code contributed by Masatake YAMATO <jet@gyve.org>
+;; End code contributed by Masatake YAMATO <yamato@redhat.com>
 
 
 ;;; Ghost Text displayor
diff --git a/lisp/cedet/semantic/db-debug.el b/lisp/cedet/semantic/db-debug.el
index bfc2c98044..bbff296331 100644
--- a/lisp/cedet/semantic/db-debug.el
+++ b/lisp/cedet/semantic/db-debug.el
@@ -2,7 +2,7 @@
 
 ;;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/db-mode.el b/lisp/cedet/semantic/db-mode.el
index e1d8f63285..949413d968 100644
--- a/lisp/cedet/semantic/db-mode.el
+++ b/lisp/cedet/semantic/db-mode.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/db-ref.el b/lisp/cedet/semantic/db-ref.el
index ddac96c704..cfe5c366b5 100644
--- a/lisp/cedet/semantic/db-ref.el
+++ b/lisp/cedet/semantic/db-ref.el
@@ -2,7 +2,7 @@
 
 ;;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/db-typecache.el b/lisp/cedet/semantic/db-typecache.el
index 8de3cc49a9..2c99b2cef3 100644
--- a/lisp/cedet/semantic/db-typecache.el
+++ b/lisp/cedet/semantic/db-typecache.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/doc.el b/lisp/cedet/semantic/doc.el
index 5611629c14..4f98cf4102 100644
--- a/lisp/cedet/semantic/doc.el
+++ b/lisp/cedet/semantic/doc.el
@@ -103,7 +103,8 @@ If NOSNARF is `lex', then return the lex token."
 	    nil
 	  ;; ok, try to clean the text up.
 	  ;; Comment start thingy
-	  (while (string-match (concat "^\\s-*" comment-start-skip) ct)
+	  (while (string-match (concat "^\\s-*\\(?:" comment-start-skip "\\)")
+                               ct)
 	    (setq ct (concat (substring ct 0 (match-beginning 0))
 			     (substring ct (match-end 0)))))
 	  ;; Arbitrary punctuation at the beginning of each line.
diff --git a/lisp/cedet/semantic/grammar.el b/lisp/cedet/semantic/grammar.el
index f6d67cf48e..7fb54cbb89 100644
--- a/lisp/cedet/semantic/grammar.el
+++ b/lisp/cedet/semantic/grammar.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2002-2005, 2007-2019 Free Software Foundation, Inc.
 
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/imenu.el b/lisp/cedet/semantic/imenu.el
index 0fb9eca753..027c9891cd 100644
--- a/lisp/cedet/semantic/imenu.el
+++ b/lisp/cedet/semantic/imenu.el
@@ -4,7 +4,6 @@
 ;; Foundation, Inc.
 
 ;; Author: Eric M. Ludlam <zappo@gnu.org>
-;; Maintainer: Eric Ludlam
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/mru-bookmark.el b/lisp/cedet/semantic/mru-bookmark.el
index 2f38d35780..a15ea9b316 100644
--- a/lisp/cedet/semantic/mru-bookmark.el
+++ b/lisp/cedet/semantic/mru-bookmark.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/scope.el b/lisp/cedet/semantic/scope.el
index e0851d309b..3b38e8a61c 100644
--- a/lisp/cedet/semantic/scope.el
+++ b/lisp/cedet/semantic/scope.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/symref.el b/lisp/cedet/semantic/symref.el
index b005199da0..00403d4d52 100644
--- a/lisp/cedet/semantic/symref.el
+++ b/lisp/cedet/semantic/symref.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/symref/cscope.el b/lisp/cedet/semantic/symref/cscope.el
index 53e62a4170..89545965bf 100644
--- a/lisp/cedet/semantic/symref/cscope.el
+++ b/lisp/cedet/semantic/symref/cscope.el
@@ -2,7 +2,7 @@
 
 ;;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/symref/filter.el b/lisp/cedet/semantic/symref/filter.el
index 5d16669953..f23d751955 100644
--- a/lisp/cedet/semantic/symref/filter.el
+++ b/lisp/cedet/semantic/symref/filter.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/symref/global.el b/lisp/cedet/semantic/symref/global.el
index 9bc24fbbd4..2eb0ab091c 100644
--- a/lisp/cedet/semantic/symref/global.el
+++ b/lisp/cedet/semantic/symref/global.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/symref/grep.el b/lisp/cedet/semantic/symref/grep.el
index caac757d51..d8dbfca05d 100644
--- a/lisp/cedet/semantic/symref/grep.el
+++ b/lisp/cedet/semantic/symref/grep.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/symref/idutils.el b/lisp/cedet/semantic/symref/idutils.el
index 58cf12af2e..9f28e16c34 100644
--- a/lisp/cedet/semantic/symref/idutils.el
+++ b/lisp/cedet/semantic/symref/idutils.el
@@ -2,7 +2,7 @@
 
 ;;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/symref/list.el b/lisp/cedet/semantic/symref/list.el
index 50aa5c5740..c11eb310a0 100644
--- a/lisp/cedet/semantic/symref/list.el
+++ b/lisp/cedet/semantic/symref/list.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/tag-write.el b/lisp/cedet/semantic/tag-write.el
index bb79775411..679a15b603 100644
--- a/lisp/cedet/semantic/tag-write.el
+++ b/lisp/cedet/semantic/tag-write.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/semantic/wisent.el b/lisp/cedet/semantic/wisent.el
index 6bb771054d..122b5d399c 100644
--- a/lisp/cedet/semantic/wisent.el
+++ b/lisp/cedet/semantic/wisent.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2001-2007, 2009-2019 Free Software Foundation, Inc.
 
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 30 Aug 2001
 ;; Keywords: syntax
 
diff --git a/lisp/cedet/semantic/wisent/comp.el b/lisp/cedet/semantic/wisent/comp.el
index db910b1424..051b898ed7 100644
--- a/lisp/cedet/semantic/wisent/comp.el
+++ b/lisp/cedet/semantic/wisent/comp.el
@@ -4,7 +4,6 @@
 ;; Software Foundation, Inc.
 
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 30 January 2002
 ;; Keywords: syntax
 
diff --git a/lisp/cedet/semantic/wisent/grammar.el b/lisp/cedet/semantic/wisent/grammar.el
index 7d776712eb..d23e293552 100644
--- a/lisp/cedet/semantic/wisent/grammar.el
+++ b/lisp/cedet/semantic/wisent/grammar.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2002-2019 Free Software Foundation, Inc.
 ;;
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 26 Aug 2002
 ;; Keywords: syntax
 ;; This file is part of GNU Emacs.
diff --git a/lisp/cedet/semantic/wisent/java-tags.el b/lisp/cedet/semantic/wisent/java-tags.el
index 4bf7a8e2af..87c3090bdb 100644
--- a/lisp/cedet/semantic/wisent/java-tags.el
+++ b/lisp/cedet/semantic/wisent/java-tags.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2001-2006, 2009-2019 Free Software Foundation, Inc.
 
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 15 Dec 2001
 ;; Keywords: syntax
 
diff --git a/lisp/cedet/semantic/wisent/javascript.el b/lisp/cedet/semantic/wisent/javascript.el
index 05040b3a95..7722c95360 100644
--- a/lisp/cedet/semantic/wisent/javascript.el
+++ b/lisp/cedet/semantic/wisent/javascript.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2005, 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric Ludlam <zappo@gnu.org>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 ;; Keywords: syntax
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/cedet/semantic/wisent/python.el b/lisp/cedet/semantic/wisent/python.el
index c530329bae..f0e294efa6 100644
--- a/lisp/cedet/semantic/wisent/python.el
+++ b/lisp/cedet/semantic/wisent/python.el
@@ -2,8 +2,7 @@
 
 ;; Copyright (C) 2002, 2004, 2006-2019 Free Software Foundation, Inc.
 
-;; Author: Richard Kim  <emacs18@gmail.com>
-;; Maintainer: Richard Kim  <emacs18@gmail.com>
+;; Author: Richard Kim <emacs18@gmail.com>
 ;; Created: June 2002
 ;; Keywords: syntax
 
diff --git a/lisp/cedet/semantic/wisent/wisent.el b/lisp/cedet/semantic/wisent/wisent.el
index 21082429a2..401b404fee 100644
--- a/lisp/cedet/semantic/wisent/wisent.el
+++ b/lisp/cedet/semantic/wisent/wisent.el
@@ -3,7 +3,6 @@
 ;;; Copyright (C) 2002-2007, 2009-2019 Free Software Foundation, Inc.
 
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 30 January 2002
 ;; Keywords: syntax
 
diff --git a/lisp/cedet/srecode/args.el b/lisp/cedet/srecode/args.el
index e8a1a2c215..7f5600083e 100644
--- a/lisp/cedet/srecode/args.el
+++ b/lisp/cedet/srecode/args.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/cpp.el b/lisp/cedet/srecode/cpp.el
index e6a5599233..cedc195433 100644
--- a/lisp/cedet/srecode/cpp.el
+++ b/lisp/cedet/srecode/cpp.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007, 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 ;;         Jan Moringen <scymtym@users.sourceforge.net>
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/cedet/srecode/ctxt.el b/lisp/cedet/srecode/ctxt.el
index 66f67790a9..071fbe4625 100644
--- a/lisp/cedet/srecode/ctxt.el
+++ b/lisp/cedet/srecode/ctxt.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/dictionary.el b/lisp/cedet/srecode/dictionary.el
index a13c42df33..4b1f28babd 100644
--- a/lisp/cedet/srecode/dictionary.el
+++ b/lisp/cedet/srecode/dictionary.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/document.el b/lisp/cedet/srecode/document.el
index 06fc262f87..ad15b3ef6f 100644
--- a/lisp/cedet/srecode/document.el
+++ b/lisp/cedet/srecode/document.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/el.el b/lisp/cedet/srecode/el.el
index 348c8126c8..0bc8e1f450 100644
--- a/lisp/cedet/srecode/el.el
+++ b/lisp/cedet/srecode/el.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/expandproto.el b/lisp/cedet/srecode/expandproto.el
index 7b5de0df6d..10e304aa15 100644
--- a/lisp/cedet/srecode/expandproto.el
+++ b/lisp/cedet/srecode/expandproto.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007, 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/extract.el b/lisp/cedet/srecode/extract.el
index f4932513bc..acb200a46e 100644
--- a/lisp/cedet/srecode/extract.el
+++ b/lisp/cedet/srecode/extract.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/fields.el b/lisp/cedet/srecode/fields.el
index 95caeb3118..f4999827f7 100644
--- a/lisp/cedet/srecode/fields.el
+++ b/lisp/cedet/srecode/fields.el
@@ -2,7 +2,7 @@
 ;;
 ;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 ;;
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/filters.el b/lisp/cedet/srecode/filters.el
index b9b037fb50..2ff7594c4b 100644
--- a/lisp/cedet/srecode/filters.el
+++ b/lisp/cedet/srecode/filters.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/find.el b/lisp/cedet/srecode/find.el
index 68592265e1..f5ddc619b8 100644
--- a/lisp/cedet/srecode/find.el
+++ b/lisp/cedet/srecode/find.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/getset.el b/lisp/cedet/srecode/getset.el
index cef4b9435b..e5740964a4 100644
--- a/lisp/cedet/srecode/getset.el
+++ b/lisp/cedet/srecode/getset.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/insert.el b/lisp/cedet/srecode/insert.el
index 26af2ffe2e..a7445ea401 100644
--- a/lisp/cedet/srecode/insert.el
+++ b/lisp/cedet/srecode/insert.el
@@ -1,4 +1,4 @@
-;;; srecode/insert.el --- Insert srecode templates to an output stream.
+;;; srecode/insert.el --- Insert srecode templates to an output stream  -*- lexical-binding:t -*-
 
 ;; Copyright (C) 2005, 2007-2019 Free Software Foundation, Inc.
 
@@ -26,9 +26,6 @@
 ;; Manage the insertion process for a template.
 ;;
 
-(eval-when-compile
-  (require 'cl)) ;; for `lexical-let'
-
 (require 'srecode/compile)
 (require 'srecode/find)
 (require 'srecode/dictionary)
@@ -1049,21 +1046,20 @@ template where a ^ inserter occurs."
   ;; which implements the wrap insertion behavior in FUNCTION. The
   ;; maximum valid nesting depth is just the current depth + 1.
   (let ((srecode-template-inserter-point-override
-	 (lexical-let ((inserter1 sti))
-	   (cons
-	    ;; DEPTH
-	    (+ (length (oref-default 'srecode-template active)) 1)
-	    ;; FUNCTION
-	    (lambda (dict)
-	      (let ((srecode-template-inserter-point-override nil))
-		(if (srecode-dictionary-lookup-name
-		     dict (oref inserter1 :object-name))
-		    ;; Insert our sectional part with looping.
-		    (srecode-insert-method-helper
-		     inserter1 dict 'template)
-		  ;; Insert our sectional part just once.
-		  (srecode-insert-subtemplate
-		   inserter1 dict 'template))))))))
+	 (cons
+	  ;; DEPTH
+	  (+ (length (oref-default 'srecode-template active)) 1)
+	  ;; FUNCTION
+	  (lambda (dict)
+	    (let ((srecode-template-inserter-point-override nil))
+	      (if (srecode-dictionary-lookup-name
+		   dict (oref sti :object-name))
+		  ;; Insert our sectional part with looping.
+		  (srecode-insert-method-helper
+		   sti dict 'template)
+		;; Insert our sectional part just once.
+		(srecode-insert-subtemplate
+		 sti dict 'template)))))))
     ;; Do a regular insertion for an include, but with our override in
     ;; place.
     (cl-call-next-method)))
diff --git a/lisp/cedet/srecode/java.el b/lisp/cedet/srecode/java.el
index 85df930fed..43c207e988 100644
--- a/lisp/cedet/srecode/java.el
+++ b/lisp/cedet/srecode/java.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/map.el b/lisp/cedet/srecode/map.el
index fa5d27b8d2..08ff0e6305 100644
--- a/lisp/cedet/srecode/map.el
+++ b/lisp/cedet/srecode/map.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/mode.el b/lisp/cedet/srecode/mode.el
index bf1f64e125..a47520e013 100644
--- a/lisp/cedet/srecode/mode.el
+++ b/lisp/cedet/srecode/mode.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/semantic.el b/lisp/cedet/srecode/semantic.el
index 93dcaff943..ea11b0e483 100644
--- a/lisp/cedet/srecode/semantic.el
+++ b/lisp/cedet/srecode/semantic.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/srt.el b/lisp/cedet/srecode/srt.el
index e6d2bb7c9e..dc6300ea79 100644
--- a/lisp/cedet/srecode/srt.el
+++ b/lisp/cedet/srecode/srt.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/table.el b/lisp/cedet/srecode/table.el
index 3b271f06f7..95d8bfa1bc 100644
--- a/lisp/cedet/srecode/table.el
+++ b/lisp/cedet/srecode/table.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/cedet/srecode/texi.el b/lisp/cedet/srecode/texi.el
index 223cf28e12..212b56c6ca 100644
--- a/lisp/cedet/srecode/texi.el
+++ b/lisp/cedet/srecode/texi.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/char-fold.el b/lisp/char-fold.el
index e61bc3edc6..d2fa7108bb 100644
--- a/lisp/char-fold.el
+++ b/lisp/char-fold.el
@@ -24,11 +24,12 @@
 
 (eval-and-compile (put 'char-fold-table 'char-table-extra-slots 1))
 
-(defconst char-fold-table
-  (eval-when-compile
-    (let ((equiv (make-char-table 'char-fold-table))
-          (equiv-multi (make-char-table 'char-fold-table))
-          (table (unicode-property-table-internal 'decomposition)))
+(eval-and-compile
+  (defun char-fold-make-table ()
+    (let* ((equiv (make-char-table 'char-fold-table))
+           (equiv-multi (make-char-table 'char-fold-table))
+           (search-spaces-regexp nil)   ; workaround for bug#35802
+           (table (unicode-property-table-internal 'decomposition)))
       (set-char-table-extra-slot equiv 0 equiv-multi)
 
       ;; Ensure the table is populated.
@@ -107,13 +108,17 @@
 
       ;; Convert the lists of characters we compiled into regexps.
       (map-char-table
-       (lambda (char dec-list)
-         (let ((re (regexp-opt (cons (char-to-string char) dec-list))))
-           (if (consp char)
+       (lambda (char decomp-list)
+         (let ((re (regexp-opt (cons (char-to-string char) decomp-list))))
+           (if (consp char) ; FIXME: char never is consp?
                (set-char-table-range equiv char re)
              (aset equiv char re))))
        equiv)
-      equiv))
+      equiv)))
+
+(defconst char-fold-table
+  (eval-when-compile
+    (char-fold-make-table))
   "Used for folding characters of the same group during search.
 This is a char-table with the `char-fold-table' subtype.
 
diff --git a/lisp/comint.el b/lisp/comint.el
index d21cc1378f..fbb67360df 100644
--- a/lisp/comint.el
+++ b/lisp/comint.el
@@ -350,13 +350,14 @@ This variable is buffer-local."
 ;; Ubuntu's sudo prompts like `[sudo] password for user:'
 ;; Some implementations of passwd use "Password (again)" as the 2nd prompt.
 ;; Something called "perforce" uses "Enter password:".
-;; See M-x comint-testsuite--test-comint-password-prompt-regexp.
+;; OpenVPN prints a prompt like: "Enter Auth Password:".
+;; See ert test `comint-test-password-regexp'.
 (defcustom comint-password-prompt-regexp
   (concat
    "\\(^ *\\|"
    (regexp-opt
     '("Enter" "enter" "Enter same" "enter same" "Enter the" "enter the"
-      "Old" "old" "New" "new" "'s" "login"
+      "Enter Auth" "enter auth" "Old" "old" "New" "new" "'s" "login"
       "Kerberos" "CVS" "UNIX" " SMB" "LDAP" "PEM" "SUDO"
       "[sudo]" "Repeat" "Bad" "Retype")
     t)
@@ -3470,7 +3471,7 @@ the process mark is at the beginning of the accumulated input."
     (message "Process mark set")))
 
 
-;; Author:  Peter Breton <pbreton@cs.umb.edu>
+;; Author: Peter Breton <pbreton@cs.umb.edu>
 
 ;; This little add-on for comint is intended to make it easy to get
 ;; output from currently active comint buffers into another buffer,
diff --git a/lisp/composite.el b/lisp/composite.el
index d2df3d1e92..87f563030b 100644
--- a/lisp/composite.el
+++ b/lisp/composite.el
@@ -7,7 +7,7 @@
 ;;   National Institute of Advanced Industrial Science and Technology (AIST)
 ;;   Registration Number H14PRO021
 
-;; Author: Kenichi HANDA <handa@etl.go.jp>
+;; Author: Kenichi Handa <handa@gnu.org>
 ;; (according to ack.texi)
 ;; Keywords: mule, multilingual, character composition
 ;; Package: emacs
diff --git a/lisp/cus-edit.el b/lisp/cus-edit.el
index f87b6b621c..6d47e607ae 100644
--- a/lisp/cus-edit.el
+++ b/lisp/cus-edit.el
@@ -1827,20 +1827,9 @@ item in another window.\n\n"))
 			      (" `-" "bottom")))
 
 (defun custom-browse-insert-prefix (prefix)
-  "Insert PREFIX.  On XEmacs convert it to line graphics."
-  ;; Fixme: do graphics.
-  (if nil ; (featurep 'xemacs)
-      (progn
-	(insert "*")
-	(while (not (string-equal prefix ""))
-	  (let ((entry (substring prefix 0 3)))
-	    (setq prefix (substring prefix 3))
-	    (let ((overlay (make-overlay (1- (point)) (point) nil t nil))
-		  (name (nth 1 (assoc entry custom-browse-alist))))
-	      (overlay-put overlay 'end-glyph (widget-glyph-find name entry))
-	      (overlay-put overlay 'start-open t)
-	      (overlay-put overlay 'end-open t)))))
-    (insert prefix)))
+  "Insert PREFIX."
+  (declare (obsolete insert "27.1"))
+  (insert prefix))
 
 ;;; Modification of Basic Widgets.
 ;;
@@ -4043,7 +4032,7 @@ If GROUPS-ONLY is non-nil, return only those members that are groups."
     (cond ((and (eq custom-buffer-style 'tree)
 		(eq state 'hidden)
 		(or members (custom-unloaded-widget-p widget)))
-	   (custom-browse-insert-prefix prefix)
+	   (insert prefix)
 	   (push (widget-create-child-and-convert
 		  widget 'custom-browse-visibility
 		  :tag "+")
@@ -4056,19 +4045,17 @@ If GROUPS-ONLY is non-nil, return only those members that are groups."
 	   (widget-put widget :buttons buttons))
 	  ((and (eq custom-buffer-style 'tree)
 		(zerop (length members)))
-	   (custom-browse-insert-prefix prefix)
-	   (insert "[ ]-- ")
+	   (insert prefix "[ ]-- ")
 	   (push (widget-create-child-and-convert
 		  widget 'custom-browse-group-tag)
 		 buttons)
 	   (insert " " tag "\n")
 	   (widget-put widget :buttons buttons))
 	  ((eq custom-buffer-style 'tree)
-	   (custom-browse-insert-prefix prefix)
+	   (insert prefix)
 	   (if (zerop (length members))
 	       (progn
-		 (custom-browse-insert-prefix prefix)
-		 (insert "[ ]-- ")
+		 (insert prefix "[ ]-- ")
 		 ;; (widget-glyph-insert nil "[ ]" "empty")
 		 ;; (widget-glyph-insert nil "-- " "horizontal")
 		 (push (widget-create-child-and-convert
diff --git a/lisp/cus-start.el b/lisp/cus-start.el
index baa05d0a89..4c4d5ebb16 100644
--- a/lisp/cus-start.el
+++ b/lisp/cus-start.el
@@ -648,6 +648,19 @@ since it could result in memory overflow and make Emacs crash."
                                   (const :tag "Count lines from beginning of narrowed region"
                                          :value nil))
                                  "26.1")
+
+             (display-fill-column-indicator display-fill-column-indicator
+                                 boolean "27.1")
+             (display-fill-column-indicator-column display-fill-column-indicator
+                                 (choice
+                                  (const :tag "Use fill-column variable"
+                                         :value t)
+                                  (const :tag "Fixed column number"
+                                         :value 70
+                                         :format "%v"))
+                                 integer "27.1")
+             (display-fill-column-indicator-character display-fill-column-indicator
+                                 character "27.1")
 	     ;; xfaces.c
 	     (scalable-fonts-allowed display boolean "22.1")
 	     ;; xfns.c
diff --git a/lisp/custom.el b/lisp/custom.el
index 53b8045f05..29bf9e570a 100644
--- a/lisp/custom.el
+++ b/lisp/custom.el
@@ -56,8 +56,14 @@ Otherwise, if symbol has a `saved-value' property, it will evaluate
 the car of that and use it as the default binding for symbol.
 Otherwise, EXP will be evaluated and used as the default binding for
 symbol."
-  (eval `(defvar ,symbol ,(let ((sv (get symbol 'saved-value)))
-                            (if sv (car sv) exp)))))
+  (condition-case nil
+      (default-toplevel-value symbol)   ;Test presence of default value.
+    (void-variable
+     ;; The var is not initialized yet.
+     (set-default-toplevel-value
+      symbol (eval (let ((sv (get symbol 'saved-value)))
+                     (if sv (car sv) exp))
+                   t)))))
 
 (defun custom-initialize-set (symbol exp)
   "Initialize SYMBOL based on EXP.
@@ -188,18 +194,13 @@ set to nil, as the value is no longer rogue."
 		(t
 		 (custom-handle-keyword symbol keyword value
 					'custom-variable))))))
+    ;; Set the docstring, record the var on load-history, as well
+    ;; as set the special-variable-p flag.
+    (internal--define-uninitialized-variable symbol doc)
     (put symbol 'custom-requests requests)
     ;; Do the actual initialization.
     (unless custom-dont-initialize
       (funcall initialize symbol default)))
-  ;; Use defvar to set the docstring as well as the special-variable-p flag.
-  ;; FIXME: We should reproduce more of `defvar's behavior, such as the warning
-  ;; when the var is currently let-bound.
-  (if (not (default-boundp symbol))
-      ;; Don't use defvar to avoid setting a default-value when undesired.
-      (when doc (put symbol 'variable-documentation doc))
-    (eval `(defvar ,symbol nil ,@(when doc (list doc)))))
-  (push symbol current-load-list)
   (run-hooks 'custom-define-hook)
   symbol)
 
diff --git a/lisp/dabbrev.el b/lisp/dabbrev.el
index 2159f96028..23abe7ae16 100644
--- a/lisp/dabbrev.el
+++ b/lisp/dabbrev.el
@@ -82,7 +82,7 @@
 ;;  [hymie]	Hyman Rosen <marks!hymie@jyacc.jyacc.com>
 ;;  [burgett]	Steve Burgett <burgett@bizet.eecs.berkeley.edu>
 ;;  [jules]	Julian Gosnell <jules@x.co.uk>
-;;  [kifer]	Michael Kifer <kifer@sbcs.sunysb.edu>
+;;  [kifer]	Michael Kifer <kifer@cs.stonybrook.edu>
 ;;  [ake]	Ake Stenhoff <extaksf@aom.ericsson.se>
 ;;  [alon]	Alon Albert <al%imercury@uunet.uu.net>
 ;;  [tromey]	Tom Tromey <tromey@busco.lanl.gov>
@@ -238,8 +238,7 @@ See also `dabbrev-ignored-buffer-names'."
   :version "21.1")
 
 (defcustom dabbrev-check-other-buffers t
-  "Should \\[dabbrev-expand] look in other buffers?\
-
+  "Should \\[dabbrev-expand] look in other buffers?
 nil: Don't look in other buffers.
 t: Also look for expansions in the buffers pointed out by
    `dabbrev-select-buffers-function'.
diff --git a/lisp/delim-col.el b/lisp/delim-col.el
index a968b32052..3e309e917d 100644
--- a/lisp/delim-col.el
+++ b/lisp/delim-col.el
@@ -1,12 +1,11 @@
-;;; delim-col.el --- prettify all columns in a region or rectangle
+;;; delim-col.el --- prettify all columns in a region or rectangle  -*- lexical-binding: t; -*-
 
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Version: 2.1
-;; Keywords: internal
-;; X-URL: http://www.emacswiki.org/cgi-bin/wiki/ViniciusJoseLatorre
+;; Keywords: convenience text
+;; X-URL: https://www.emacswiki.org/emacs/ViniciusJoseLatorre
 
 ;; This file is part of GNU Emacs.
 
@@ -27,11 +26,6 @@
 
 ;; delim-col helps to prettify columns in a text region or rectangle.
 ;;
-;; To use it, make sure that this file is in load-path and insert in your
-;; .emacs:
-;;
-;;    (require 'delim-col)
-;;
 ;; If you have, for example, the following columns:
 ;;
 ;;	a	b	c	d
@@ -91,9 +85,9 @@
 ;;	aaa	[ <bbb>, <cccc>    ]	dddd
 ;;	aa	[ <bb> , <ccccccc> ]	ddd
 ;;
-;; Note that `delimit-columns-region' operates over all text region
-;; selected, extending the region start to the beginning of line and the
-;; region end to the end of line.  While `delimit-columns-rectangle'
+;; Note that `delimit-columns-region' operates over the entire selected
+;; text region, extending the region start to the beginning of line and
+;; the region end to the end of line.  While `delimit-columns-rectangle'
 ;; operates over the text rectangle selected which rectangle diagonal is
 ;; given by the region start and end.
 ;;
@@ -117,6 +111,7 @@
 
 ;;; Code:
 
+(require 'rect)
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; User Options:
@@ -125,6 +120,7 @@
   "Prettify columns."
   :link '(emacs-library-link :tag "Source Lisp File" "delim-col.el")
   :prefix "delimit-columns-"
+  :group 'convenience
   :group 'text)
 
 (defcustom delimit-columns-str-before ""
@@ -213,10 +209,11 @@ See also `delimit-columns-end' for documentation.
 The following relation must hold:
    0 <= delimit-columns-start <= delimit-columns-end
 
-The column number start from 0 and it's relative to the beginning of selected
-region.  So if you selected a text region, the first column (column 0) is
-located at beginning of line.  If you selected a text rectangle, the first
-column (column 0) is located at left corner."
+The column number starts at 0 and is relative to the beginning of
+the selected region.  So if you select a text region, the first
+column (column 0) is located at the beginning of line.  If you
+select a text rectangle, the first column (column 0) is located
+at the left corner."
   :type '(integer :tag "Column Start")
   :group 'columns)
 
@@ -228,10 +225,11 @@ See also `delimit-columns-start' for documentation.
 The following relation must hold:
    0 <= delimit-columns-start <= delimit-columns-end
 
-The column number start from 0 and it's relative to the beginning of selected
-region.  So if you selected a text region, the first column (column 0) is
-located at beginning of line.  If you selected a text rectangle, the first
-column (column 0) is located at left corner."
+The column number starts at 0 and is relative to the beginning of
+the selected region.  So if you select a text region, the first
+column (column 0) is located at the beginning of line.  If you
+select a text rectangle, the first column (column 0) is located
+at the left corner."
   :type '(integer :tag "Column End")
   :group 'columns)
 
@@ -247,20 +245,20 @@ column (column 0) is located at left corner."
 
 ;;;###autoload
 (defun delimit-columns-customize ()
-  "Customization of `columns' group."
+  "Customize the `columns' group."
   (interactive)
   (customize-group 'columns))
 
 
-(defmacro delimit-columns-str (str)
-  `(if (stringp ,str) ,str ""))
+(defun delimit-columns-str (str)
+  (if (stringp str) str ""))
 
 
 ;;;###autoload
 (defun delimit-columns-region (start end)
   "Prettify all columns in a text region.
 
-START and END delimits the text region."
+START and END delimit the text region."
   (interactive "*r")
   (let ((delimit-columns-str-before
 	 (delimit-columns-str delimit-columns-str-before))
@@ -273,8 +271,7 @@ START and END delimits the text region."
 	(delimit-columns-after
 	 (delimit-columns-str delimit-columns-after))
 	(delimit-columns-start
-	 (if (and (integerp delimit-columns-start)
-		  (>= delimit-columns-start 0))
+         (if (natnump delimit-columns-start)
 	     delimit-columns-start
 	   0))
 	(delimit-columns-end
@@ -309,14 +306,11 @@ START and END delimits the text region."
 	(set-marker the-end nil)))))
 
 
-(require 'rect)
-
-
 ;;;###autoload
 (defun delimit-columns-rectangle (start end)
   "Prettify all columns in a text rectangle.
 
-START and END delimits the corners of text rectangle."
+START and END delimit the corners of the text rectangle."
   (interactive "*r")
   (let ((delimit-columns-str-before
 	 (delimit-columns-str delimit-columns-str-before))
@@ -329,8 +323,7 @@ START and END delimits the corners of text rectangle."
 	(delimit-columns-after
 	 (delimit-columns-str delimit-columns-after))
 	(delimit-columns-start
-	 (if (and (integerp delimit-columns-start)
-		  (>= delimit-columns-start 0))
+         (if (natnump delimit-columns-start)
 	     delimit-columns-start
 	   0))
 	(delimit-columns-end
@@ -344,11 +337,11 @@ START and END delimits the corners of text rectangle."
       ;; get maximum length for each column
       (and delimit-columns-format
 	   (save-excursion
-	     (operate-on-rectangle 'delimit-columns-rectangle-max
+             (operate-on-rectangle #'delimit-columns-rectangle-max
 				   start the-end nil)))
       ;; prettify columns
       (save-excursion
-	(operate-on-rectangle 'delimit-columns-rectangle-line
+        (operate-on-rectangle #'delimit-columns-rectangle-line
 			      start the-end nil))
       ;; nullify markers
       (set-marker delimit-columns-limit nil)
@@ -359,7 +352,7 @@ START and END delimits the corners of text rectangle."
 ;; Internal Variables and Functions:
 
 
-(defun delimit-columns-rectangle-max (startpos &optional _ignore1 _ignore2)
+(defun delimit-columns-rectangle-max (startpos &optional _begextra _endextra)
   (set-marker delimit-columns-limit (point))
   (goto-char startpos)
   (let ((ncol 1)
@@ -392,7 +385,7 @@ START and END delimits the corners of text rectangle."
       (setq values (cdr values)))))
 
 
-(defun delimit-columns-rectangle-line (startpos &optional _ignore1 _ignore2)
+(defun delimit-columns-rectangle-line (startpos &optional _begextra _endextra)
   (let ((len  (length delimit-columns-max))
 	(ncol 0)
 	origin)
@@ -442,8 +435,7 @@ START and END delimits the corners of text rectangle."
 	    ((eq delimit-columns-format 'padding)
 	     (insert spaces delimit-columns-after delimit-columns-str-after))
 	    (t
-	     (insert delimit-columns-after spaces delimit-columns-str-after))
-	    ))
+             (insert delimit-columns-after spaces delimit-columns-str-after))))
     (goto-char (max (point) delimit-columns-limit))))
 
 
@@ -466,8 +458,7 @@ START and END delimits the corners of text rectangle."
 	 (insert delimit-columns-after
 		 delimit-columns-str-separator
 		 spaces
-		 delimit-columns-before))
-	))
+                 delimit-columns-before))))
 
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
diff --git a/lisp/desktop.el b/lisp/desktop.el
index 97c057e201..33d7643d1b 100644
--- a/lisp/desktop.el
+++ b/lisp/desktop.el
@@ -124,7 +124,7 @@
 ;;            avk@rtsg.mot.com (Andrew V. Klein)     for a dired tip.
 ;;            chris@tecc.co.uk (Chris Boucher)       for a mark tip.
 ;;            f89-kam@nada.kth.se (Klas Mellbourn)   for a mh-e tip.
-;;            kifer@sbkifer.cs.sunysb.edu (M. Kifer) for a bug hunt.
+;;            kifer@cs.stonybrook.edu (M. Kifer)     for a bug hunt.
 ;;            treese@lcs.mit.edu (Win Treese)        for ange-ftp tips.
 ;;            pot@cnuce.cnr.it (Francesco Potortì)  for misc. tips.
 ;; ---------------------------------------------------------------------------
diff --git a/lisp/dframe.el b/lisp/dframe.el
index eebc0bf7bd..473f826ad2 100644
--- a/lisp/dframe.el
+++ b/lisp/dframe.el
@@ -781,7 +781,7 @@ Evaluates all cached timer functions in sequence."
 ;; In XEmacs, we make popup menus work on the item over mouse (as
 ;; opposed to where the point happens to be.)  We attain this by
 ;; temporarily moving the point to that place.
-;;    Hrvoje Niksic <hniksic@srce.hr>
+;;    Hrvoje Nikšić <hrvoje.niksic@avl.com>
 (defalias 'dframe-popup-kludge
   (if (featurep 'xemacs)
       (lambda (event)                        ; XEmacs.
diff --git a/lisp/dired-aux.el b/lisp/dired-aux.el
index b81c0d1a4f..41fcd062fb 100644
--- a/lisp/dired-aux.el
+++ b/lisp/dired-aux.el
@@ -246,9 +246,11 @@ Examples of PREDICATE:
      (lambda ()
        (dired-mark-if
         (member (dired-get-filename nil t) file-list2) nil)))
-    (message "Marked in dir1: %s files, in dir2: %s files"
-             (length file-list1)
-             (length file-list2))))
+    (message "Marked in dir1: %s, in dir2: %s"
+             (format-message (ngettext "%d file" "%d files" (length file-list1))
+                             (length file-list1))
+             (format-message (ngettext "%d file" "%d files" (length file-list2))
+                             (length file-list2)))))
 
 (defun dired-file-set-difference (list1 list2 predicate)
   "Combine LIST1 and LIST2 using a set-difference operation.
@@ -1065,7 +1067,9 @@ and `dired-compress-files-alist'."
                                              (shell-quote-argument (file-name-nondirectory
                                                                     file-desc)))
                                            in-files " "))))))
-             (message "Compressed %d file(s) to %s"
+             (message (ngettext "Compressed %d file to %s"
+			        "Compressed %d files to %s"
+			        (length in-files))
                       (length in-files)
                       (file-name-nondirectory out-file)))))))
 
@@ -1193,12 +1197,14 @@ Return nil if no change in files."
 	     (string (if (eq op-symbol 'compress) "Compress or uncompress"
 		       (capitalize (symbol-name op-symbol)))))
 	(if (not failures)
-	    (message "%s: %d file%s."
-		     string total (dired-plural-s total))
+	    (message (ngettext "%s: %d file." "%s: %d files." total)
+		     string total)
 	  ;; end this bunch of errors:
 	  (dired-log-summary
-	   (format "Failed to %s %d of %d file%s"
-		   (downcase string) count total (dired-plural-s total))
+	   (format (ngettext "Failed to %s %d of %d file"
+                             "Failed to %s %d of %d files"
+                             total)
+		   (downcase string) count total)
 	   failures)))))
 
 ;;;###autoload
@@ -1798,32 +1804,36 @@ ESC or `q' to not overwrite any of the remaining files,
                (progn
                  (push (dired-make-relative from)
                        failures)
-                 (dired-log "%s `%s' to `%s' failed:\n%s\n"
+                 (dired-log "%s: `%s' to `%s' failed:\n%s\n"
                             operation from to err))))))))
     (cond
      (dired-create-files-failures
       (setq failures (nconc failures dired-create-files-failures))
       (dired-log-summary
-       (format "%s failed for %d file%s in %d requests"
-		operation (length failures)
-		(dired-plural-s (length failures))
-		total)
+       (format (ngettext "%s failed for %d file in %d requests"
+			 "%s failed for %d files in %d requests"
+			 (length failures))
+	       operation (length failures) total)
        failures))
      (failures
       (dired-log-summary
-       (format "%s failed for %d of %d file%s"
-		operation (length failures)
-		total (dired-plural-s total))
+       (format (ngettext "%s: %d of %d file failed"
+			 "%s: %d of %d files failed"
+			 total)
+	       operation (length failures) total)
        failures))
      (skipped
       (dired-log-summary
-       (format "%s: %d of %d file%s skipped"
-		operation (length skipped) total
-		(dired-plural-s total))
+       (format (ngettext "%s: %d of %d file skipped"
+			 "%s: %d of %d files skipped"
+			 total)
+	       operation (length skipped) total)
        skipped))
      (t
-      (message "%s: %s file%s"
-	       operation success-count (dired-plural-s success-count)))))
+      (message (ngettext "%s: %d file done"
+			 "%s: %d files done"
+			 success-count)
+	       operation success-count))))
   (dired-move-to-filename))
 
 (defun dired-do-create-files (op-symbol file-creator operation arg
@@ -2839,6 +2849,8 @@ is part of a file name (i.e., has the text property `dired-filename')."
   (multi-isearch-files-regexp
    (dired-get-marked-files nil nil 'dired-nondirectory-p nil t)))
 
+(declare-function fileloop-continue "fileloop" ())
+
 ;;;###autoload
 (defun dired-do-search (regexp)
   "Search through all marked files for a match for REGEXP.
@@ -2887,6 +2899,7 @@ directories.
 REGEXP should use constructs supported by your local `grep' command."
   (interactive "sSearch marked files (regexp): ")
   (require 'grep)
+  (require 'xref)
   (defvar grep-find-ignored-files)
   (declare-function rgrep-find-ignored-directories "grep" (dir))
   (let* ((files (dired-get-marked-files nil nil nil nil t))
@@ -2894,15 +2907,18 @@ REGEXP should use constructs supported by your local `grep' command."
                           #'file-name-as-directory
                           (rgrep-find-ignored-directories default-directory))
                          grep-find-ignored-files))
-         (xrefs (mapcan
-                 (lambda (file)
-                   (xref-collect-matches regexp "*" file
-                                         (and (file-directory-p file)
-                                              ignores)))
-                 files)))
-    (unless xrefs
-      (user-error "No matches for: %s" regexp))
-    (xref--show-xrefs xrefs nil t)))
+         (fetcher
+          (lambda ()
+            (let ((xrefs (mapcan
+                          (lambda (file)
+                            (xref-collect-matches regexp "*" file
+                                                  (and (file-directory-p file)
+                                                       ignores)))
+                          files)))
+              (unless xrefs
+                (user-error "No matches for: %s" regexp))
+              xrefs))))
+    (xref--show-xrefs fetcher nil)))
 
 ;;;###autoload
 (defun dired-do-find-regexp-and-replace (from to)
diff --git a/lisp/dired-x.el b/lisp/dired-x.el
index defc541ddc..3b78ec47d9 100644
--- a/lisp/dired-x.el
+++ b/lisp/dired-x.el
@@ -159,7 +159,7 @@ See Info node `(dired-x) Omitting Variables' for more information."
 
 (put 'dired-omit-mode 'safe-local-variable 'booleanp)
 
-(defcustom dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$"
+(defcustom dired-omit-files "\\`[.]?#\\|\\`[.][.]?\\'"
   "Filenames matching this regexp will not be displayed.
 This only has effect when `dired-omit-mode' is t.  See interactive function
 `dired-omit-mode' (\\[dired-omit-mode]) and variable
diff --git a/lisp/dired.el b/lisp/dired.el
index 63082fe392..ea1943de1d 100644
--- a/lisp/dired.el
+++ b/lisp/dired.el
@@ -2148,6 +2148,7 @@ Keybindings:
     (setq buffer-invisibility-spec (list t)))
   (setq-local revert-buffer-function #'dired-revert)
   (setq-local buffer-stale-function #'dired-buffer-stale-p)
+  (setq-local buffer-auto-revert-by-notification t)
   (setq-local page-delimiter "\n\n")
   (setq-local dired-directory (or dirname default-directory))
   ;; list-buffers uses this to display the dir being edited in this buffer.
@@ -3212,9 +3213,10 @@ non-empty directories is allowed."
 	    (if (not failures)
 		(progress-reporter-done progress-reporter)
 	      (dired-log-summary
-	       (format "%d of %d deletion%s failed"
-		       (length failures) count
-		       (dired-plural-s count))
+	       (format (ngettext "%d of %d deletion failed"
+			         "%d of %d deletions failed"
+			         count)
+		       (length failures) count)
 	       failures)))))
       (message "(No deletions performed)")))
   (dired-move-to-filename))
@@ -3267,8 +3269,9 @@ confirmation.  To disable the confirmation, see
     (let ((buf-list (dired-buffers-for-dir (expand-file-name fn))))
       (and buf-list
            (and dired-clean-confirm-killing-deleted-buffers
-                (y-or-n-p (format "Kill Dired buffer%s of %s, too? "
-                                  (dired-plural-s (length buf-list))
+                (y-or-n-p (format (ngettext "Kill Dired buffer of %s, too? "
+			                    "Kill Dired buffers of %s, too? "
+			                    (length buf-list))
                                   (file-name-nondirectory fn))))
            (dolist (buf buf-list)
              (kill-buffer buf))))))
diff --git a/lisp/dirtrack.el b/lisp/dirtrack.el
index 0925a4de12..259d3fdf2e 100644
--- a/lisp/dirtrack.el
+++ b/lisp/dirtrack.el
@@ -179,8 +179,6 @@ and ends with a forward slash."
     dir))
 
 
-(define-obsolete-function-alias 'dirtrack-toggle 'dirtrack-mode "23.1")
-(define-obsolete-variable-alias 'dirtrackp 'dirtrack-mode "23.1")
 ;;;###autoload
 (define-minor-mode dirtrack-mode
   "Toggle directory tracking in shell buffers (Dirtrack mode).
diff --git a/lisp/display-fill-column-indicator.el b/lisp/display-fill-column-indicator.el
new file mode 100644
index 0000000000..6d5f5a9f89
--- /dev/null
+++ b/lisp/display-fill-column-indicator.el
@@ -0,0 +1,78 @@
+;;; display-fill-column-indicator.el --- interface for display-fill-column-indicator -*- lexical-binding: t -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Maintainer: emacs-devel@gnu.org
+;; Keywords: convenience
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;; Provides a minor mode interface for `display-fill-column-indicator'.
+;;
+;; Toggle display of the column indicator with M-x
+;; display-fill-column-indicator-mode.  To enable the indicator in
+;; all buffers, use M-x global-display-fill-column-indicator-mode.
+
+
+;; NOTE: Customization variables for
+;; `display-fill-column-indicator-column' and
+;; `display-fill-column-indicator-char' itself are defined in
+;; cus-start.el.
+
+;;; Code:
+
+(defgroup display-fill-column-indicator nil
+  "Display a fill column indicator in the buffer."
+  :group 'convenience
+  :group 'display)
+
+
+;;;###autoload
+(define-minor-mode display-fill-column-indicator-mode
+  "Toggle display of fill-column indicator.
+This uses `display-fill-column-indicator' internally.
+
+To change the position of the column displayed by default
+customize `display-fill-column-indicator-column'.  You can change the
+character for the indicator setting `display-fill-column-indicator-character'."
+  :lighter nil
+  (if display-fill-column-indicator-mode
+      (progn
+        (setq display-fill-column-indicator t)
+        (unless display-fill-column-indicator-character
+          (if (and (char-displayable-p ?\u2502)
+                   (or (not (display-graphic-p))
+                       (eq (aref (query-font (car (internal-char-font nil ?\u2502))) 0)
+                           (face-font 'default))))
+              (setq display-fill-column-indicator-character ?\u2502)
+            (setq display-fill-column-indicator-character ?|))))
+    (setq display-fill-column-indicator nil)))
+
+(defun display-fill-column-indicator--turn-on ()
+  "Turn on `display-fill-column-indicator-mode'."
+  (unless (or (minibufferp)
+              (and (daemonp) (null (frame-parameter nil 'client))))
+    (display-fill-column-indicator-mode)))
+
+;;;###autoload
+(define-globalized-minor-mode global-display-fill-column-indicator-mode
+  display-fill-column-indicator-mode display-fill-column-indicator--turn-on)
+
+(provide 'display-fill-column-indicator)
+
+;;; display-fill-column-indicator.el ends here
diff --git a/lisp/doc-view.el b/lisp/doc-view.el
index a706907260..7ab8539052 100644
--- a/lisp/doc-view.el
+++ b/lisp/doc-view.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 ;;
 ;; Author: Tassilo Horn <tsdh@gnu.org>
-;; Maintainer: Tassilo Horn <tsdh@gnu.org>
 ;; Keywords: files, pdf, ps, dvi
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/edmacro.el b/lisp/edmacro.el
index b480b2330a..da3e782bd9 100644
--- a/lisp/edmacro.el
+++ b/lisp/edmacro.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1993-1994, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Dave Gillespie <daveg@synaptics.com>
-;; Maintainer: Dave Gillespie <daveg@synaptics.com>
 ;; Version: 2.01
 ;; Keywords: abbrev
 
diff --git a/lisp/elec-pair.el b/lisp/elec-pair.el
index 3be09d87b4..5fb9d751e2 100644
--- a/lisp/elec-pair.el
+++ b/lisp/elec-pair.el
@@ -246,7 +246,7 @@ functions when `parse-sexp-lookup-properties' is non-nil.  The
 cache is flushed from position START, defaulting to point."
   (declare (debug ((form &optional form) body)) (indent 1))
   (let ((start-var (make-symbol "start")))
-    `(let ((syntax-propertize-function nil)
+    `(let ((syntax-propertize-function #'ignore)
            (,start-var ,(or start '(point))))
        (unwind-protect
            (with-syntax-table ,table
@@ -564,13 +564,6 @@ happened."
                       (matching-paren (char-after))))
          (save-excursion (newline 1 t)))))))
 
-;; Prioritize this to kick in after
-;; `electric-layout-post-self-insert-function': that considerably
-;; simplifies interoperation when `electric-pair-mode',
-;; `electric-layout-mode' and `electric-indent-mode' are used
-;; together.  Use `vc-region-history' on these lines for more info.
-(put 'electric-pair-post-self-insert-function   'priority  50)
-
 (defun electric-pair-will-use-region ()
   (and (use-region-p)
        (memq (car (electric-pair-syntax-info last-command-event))
@@ -622,8 +615,14 @@ To toggle the mode in a single buffer, use `electric-pair-local-mode'."
   (if electric-pair-mode
       (progn
 	(add-hook 'post-self-insert-hook
-		  #'electric-pair-post-self-insert-function)
-        (electric--sort-post-self-insertion-hook)
+		  #'electric-pair-post-self-insert-function
+                  ;; Prioritize this to kick in after
+                  ;; `electric-layout-post-self-insert-function': that
+                  ;; considerably simplifies interoperation when
+                  ;; `electric-pair-mode', `electric-layout-mode' and
+                  ;; `electric-indent-mode' are used together.
+                  ;; Use `vc-region-history' on these lines for more info.
+                  50)
 	(add-hook 'self-insert-uses-region-functions
 		  #'electric-pair-will-use-region))
     (remove-hook 'post-self-insert-hook
diff --git a/lisp/electric.el b/lisp/electric.el
index 07da2f1d9e..53e53bd975 100644
--- a/lisp/electric.el
+++ b/lisp/electric.el
@@ -190,17 +190,6 @@ Returns nil when we can't find this char."
                            (eq (char-before) last-command-event)))))
       pos)))
 
-(defun electric--sort-post-self-insertion-hook ()
-  "Ensure order of electric functions in `post-self-insertion-hook'.
-
-Hooks in this variable interact in non-trivial ways, so a
-relative order must be maintained within it."
-  (setq-default post-self-insert-hook
-                (sort (default-value 'post-self-insert-hook)
-                      #'(lambda (fn1 fn2)
-                          (< (or (if (symbolp fn1) (get fn1 'priority)) 0)
-                             (or (if (symbolp fn2) (get fn2 'priority)) 0))))))
-
 ;;; Electric indentation.
 
 ;; Autoloading variables is generally undesirable, but major modes
@@ -297,8 +286,6 @@ or comment."
                 (indent-according-to-mode)
               (error (throw 'indent-error nil)))))))))
 
-(put 'electric-indent-post-self-insert-function 'priority  60)
-
 (defun electric-indent-just-newline (arg)
   "Insert just a newline, without any auto-indentation."
   (interactive "*P")
@@ -341,8 +328,8 @@ use `electric-indent-local-mode'."
         (remove-hook 'post-self-insert-hook
                      #'electric-indent-post-self-insert-function))
     (add-hook 'post-self-insert-hook
-              #'electric-indent-post-self-insert-function)
-    (electric--sort-post-self-insertion-hook)))
+              #'electric-indent-post-self-insert-function
+              60)))
 
 ;;;###autoload
 (define-minor-mode electric-indent-local-mode
@@ -472,8 +459,6 @@ If multiple rules match, only first one is executed.")
               ('after-stay (save-excursion (funcall nl-after)))
               ('around (funcall nl-before) (funcall nl-after))))))))
 
-(put 'electric-layout-post-self-insert-function 'priority  40)
-
 ;;;###autoload
 (define-minor-mode electric-layout-mode
   "Automatically insert newlines around some chars.
@@ -482,8 +467,8 @@ The variable `electric-layout-rules' says when and how to insert newlines."
   :global t :group 'electricity
   (cond (electric-layout-mode
          (add-hook 'post-self-insert-hook
-                   #'electric-layout-post-self-insert-function)
-         (electric--sort-post-self-insertion-hook))
+                   #'electric-layout-post-self-insert-function
+                   40))
         (t
          (remove-hook 'post-self-insert-hook
                       #'electric-layout-post-self-insert-function))))
@@ -623,8 +608,6 @@ This requotes when a quoting key is typed."
                     (replace-match (string q>>))
                     (setq last-command-event q>>))))))))))
 
-(put 'electric-quote-post-self-insert-function 'priority 10)
-
 ;;;###autoload
 (define-minor-mode electric-quote-mode
   "Toggle on-the-fly requoting (Electric Quote mode).
@@ -651,8 +634,8 @@ use `electric-quote-local-mode'."
         (remove-hook 'post-self-insert-hook
                      #'electric-quote-post-self-insert-function))
     (add-hook 'post-self-insert-hook
-              #'electric-quote-post-self-insert-function)
-    (electric--sort-post-self-insertion-hook)))
+              #'electric-quote-post-self-insert-function
+              10)))
 
 ;;;###autoload
 (define-minor-mode electric-quote-local-mode
diff --git a/lisp/emacs-lisp/benchmark.el b/lisp/emacs-lisp/benchmark.el
index 5b5cda3615..8f12858b03 100644
--- a/lisp/emacs-lisp/benchmark.el
+++ b/lisp/emacs-lisp/benchmark.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2003-2019 Free Software Foundation, Inc.
 
-;; Author: Dave Love  <fx@gnu.org>
+;; Author: Dave Love <fx@gnu.org>
 ;; Keywords: lisp, extensions
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/emacs-lisp/byte-run.el b/lisp/emacs-lisp/byte-run.el
index b638b56be1..842d1d48b4 100644
--- a/lisp/emacs-lisp/byte-run.el
+++ b/lisp/emacs-lisp/byte-run.el
@@ -423,7 +423,7 @@ variable (this is due to the way `defvaralias' works).
 If provided, WHEN should be a string indicating when the variable
 was first made obsolete, for example a date or a release number.
 
-For the benefit of `custom-set-variables', if OBSOLETE-NAME has
+For the benefit of Customize, if OBSOLETE-NAME has
 any of the following properties, they are copied to
 CURRENT-NAME, if it does not already have them:
 `saved-value', `saved-variable-comment'."
@@ -495,6 +495,21 @@ is enabled."
   (car (last body)))
 
 
+(defun byte-run--unescaped-character-literals-warning ()
+  "Return a warning about unescaped character literals.
+If there were any unescaped character literals in the last form
+read, return an appropriate warning message as a string.
+Otherwise, return nil.  For internal use only."
+  ;; This is called from lread.c and therefore needs to be preloaded.
+  (if lread--unescaped-character-literals
+      (let ((sorted (sort lread--unescaped-character-literals #'<)))
+        (format-message "unescaped character literals %s detected, %s expected!"
+                        (mapconcat (lambda (char) (format "`?%c'" char))
+                                   sorted ", ")
+                        (mapconcat (lambda (char) (format "`?\\%c'" char))
+                                   sorted ", ")))))
+
+
 ;; I nuked this because it's not a good idea for users to think of using it.
 ;; These options are a matter of installation preference, and have nothing to
 ;; with particular source files; it's a mistake to suggest to users
diff --git a/lisp/emacs-lisp/bytecomp.el b/lisp/emacs-lisp/bytecomp.el
index 8bbe6292d9..dfbda8d43e 100644
--- a/lisp/emacs-lisp/bytecomp.el
+++ b/lisp/emacs-lisp/bytecomp.el
@@ -1022,6 +1022,15 @@ If STR is something like \"Buffer foo.el\", return #<buffer foo.el>
   "The value for `compilation-parse-errors-filename-function' for when
 we go into emacs-lisp-compilation-mode.")
 
+(defcustom emacs-lisp-compilation-search-path '(nil)
+  "Search path for byte-compile error messages.
+Elements should be directory names, not file names of directories.
+The value nil as an element means to try the default directory."
+  :group 'bytecomp
+  :version "27.1"
+  :type '(repeat (choice (const :tag "Default" nil)
+			 (string :tag "Directory"))))
+
 (define-compilation-mode emacs-lisp-compilation-mode "elisp-compile"
   "The variant of `compilation-mode' used for emacs-lisp error buffers")
 
@@ -1392,7 +1401,7 @@ when printing the error message."
 (defun byte-compile-callargs-warn (form)
   (let* ((def (or (byte-compile-fdefinition (car form) nil)
 		  (byte-compile-fdefinition (car form) t)))
-	 (sig (byte-compile--function-signature def))
+         (sig (byte-compile--function-signature (or def (car form))))
 	 (ncall (length (cdr form))))
     ;; Check many or unevalled from subr-arity.
     (if (and (cdr-safe sig)
@@ -2082,14 +2091,9 @@ With argument ARG, insert value in current buffer after the form."
 		 (not (eobp)))
 	  (setq byte-compile-read-position (point)
 		byte-compile-last-position byte-compile-read-position)
-	  (let* ((lread--unescaped-character-literals nil)
-                 (form (read inbuffer)))
-            (when lread--unescaped-character-literals
-              (byte-compile-warn
-               "unescaped character literals %s detected!"
-               (mapconcat (lambda (char) (format "`?%c'" char))
-                          (sort lread--unescaped-character-literals #'<)
-                          ", ")))
+	  (let ((form (read inbuffer))
+                (warning (byte-run--unescaped-character-literals-warning)))
+            (when warning (byte-compile-warn "%s" warning))
 	    (byte-compile-toplevel-file-form form)))
 	;; Compile pending forms at end of file.
 	(byte-compile-flush-pending)
@@ -4087,8 +4091,8 @@ that suppresses all warnings during execution of BODY."
   ;; and the other is a constant expression whose value can be
   ;; compared with `eq' (with `macroexp-const-p').
   (or
-   (and (symbolp obj1) (macroexp-const-p obj2) (cons obj1 obj2))
-   (and (symbolp obj2) (macroexp-const-p obj1) (cons obj2 obj1))))
+   (and (symbolp obj1) (macroexp-const-p obj2) (cons obj1 (eval obj2)))
+   (and (symbolp obj2) (macroexp-const-p obj1) (cons obj2 (eval obj1)))))
 
 (defconst byte-compile--default-val (cons nil nil) "A unique object.")
 
@@ -4117,12 +4121,11 @@ Return a list of the form ((TEST . VAR)  ((VALUE BODY) ...))"
                (unless prev-test
                  (setq prev-test test))
                (if (and obj1 (memq test '(eq eql equal))
-                        (consp condition)
                         (eq test prev-test)
-                        (eq obj1 prev-var)
-                        ;; discard duplicate clauses
-                        (not (assq obj2 cases)))
-                   (push (list (if (consp obj2) (eval obj2) obj2) body) cases)
+                        (eq obj1 prev-var))
+                   ;; discard duplicate clauses
+                   (unless (assoc obj2 cases test)
+                     (push (list obj2 body) cases))
                  (if (and (macroexp-const-p condition) condition)
 		     (progn (push (list byte-compile--default-val
 					(or body `(,condition)))
diff --git a/lisp/emacs-lisp/chart.el b/lisp/emacs-lisp/chart.el
index 9c29297da0..354830d911 100644
--- a/lisp/emacs-lisp/chart.el
+++ b/lisp/emacs-lisp/chart.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1996, 1998-1999, 2001, 2004-2005, 2007-2019 Free
 ;; Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam  <zappo@gnu.org>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 ;; Version: 0.2
 ;; Keywords: OO, chart, graph
 
diff --git a/lisp/emacs-lisp/cl-macs.el b/lisp/emacs-lisp/cl-macs.el
index 16e9bd6a75..24e79acfa5 100644
--- a/lisp/emacs-lisp/cl-macs.el
+++ b/lisp/emacs-lisp/cl-macs.el
@@ -2145,16 +2145,26 @@ of `cl-symbol-macrolet' to additionally expand symbol macros."
              (let ((symval (assq exp venv)))
                (when symval
                  (setq exp (cadr symval)))))
-            (`(setq . ,_)
+            (`(setq . ,args)
              ;; Convert setq to setf if required by symbol-macro expansion.
-             (let* ((args (mapcar (lambda (f) (macroexpand f env))
-                                  (cdr exp)))
-                    (p args))
-               (while (and p (symbolp (car p))) (setq p (cddr p)))
-               (if p (setq exp (cons 'setf args))
-                 (setq exp (cons 'setq args))
-                 ;; Don't loop further.
-                 nil)))
+             (let ((convert nil)
+                   (rargs nil))
+               (while args
+                 (let ((place (pop args)))
+                   ;; Here, we know `place' should be a symbol.
+                   (while
+                       (let ((symval (assq place venv)))
+                         (when symval
+                           (setq place (cadr symval))
+                           (if (symbolp place)
+                               t        ;Repeat.
+                             (setq convert t)
+                             nil))))
+                   (push place rargs)
+                   (push (pop args) rargs)))
+               (setq exp (cons (if convert 'setf 'setq)
+                               (nreverse rargs)))
+               convert))
             ;; CL's symbol-macrolet used to treat re-bindings as candidates for
             ;; expansion (turning the let into a letf if needed), contrary to
             ;; Common-Lisp where such re-bindings hide the symbol-macro.
@@ -2587,8 +2597,9 @@ rather than all at the end (i.e. like `let*' rather than like `let')."
 ;;;###autoload
 (defmacro cl-callf (func place &rest args)
   "Set PLACE to (FUNC PLACE ARGS...).
-FUNC should be an unquoted function name.  PLACE may be a symbol,
-or any generalized variable allowed by `setf'."
+FUNC should be an unquoted function name or a lambda expression.
+PLACE may be a symbol, or any generalized variable allowed by
+`setf'."
   (declare (indent 2) (debug (cl-function place &rest form)))
   (gv-letplace (getter setter) place
     (let* ((rargs (cons getter args)))
@@ -2893,7 +2904,7 @@ non-nil value, that slot cannot be set via `setf'.
 	      ;; and pred-check, so changing it is not straightforward.
 	      (push `(,defsym ,accessor (cl-x)
                        ,(format "Access slot \"%s\" of `%s' struct CL-X."
-                                slot struct)
+                                slot name)
                        (declare (side-effect-free t))
                        ,@(and pred-check
 			      (list `(or ,pred-check
diff --git a/lisp/emacs-lisp/cl-seq.el b/lisp/emacs-lisp/cl-seq.el
index 3eb6ea16da..87c02a6b54 100644
--- a/lisp/emacs-lisp/cl-seq.el
+++ b/lisp/emacs-lisp/cl-seq.el
@@ -703,9 +703,7 @@ Return the sublist of LIST whose car is ITEM.
 	(while (and cl-list (not (cl--check-test cl-item (car cl-list))))
 	  (setq cl-list (cdr cl-list)))
 	cl-list)
-    (if (and (numberp cl-item) (not (integerp cl-item)))
-	(member cl-item cl-list)
-      (memq cl-item cl-list))))
+    (memql cl-item cl-list)))
 (autoload 'cl--compiler-macro-member "cl-macs")
 
 ;;;###autoload
@@ -744,7 +742,7 @@ Return the sublist of LIST whose car matches.
 			(not (cl--check-test cl-item (car (car cl-alist))))))
 	  (setq cl-alist (cdr cl-alist)))
 	(and cl-alist (car cl-alist)))
-    (if (and (numberp cl-item) (not (integerp cl-item)))
+    (if (and (numberp cl-item) (not (fixnump cl-item)))
 	(assoc cl-item cl-alist)
       (assq cl-item cl-alist))))
 (autoload 'cl--compiler-macro-assoc "cl-macs")
diff --git a/lisp/emacs-lisp/edebug.el b/lisp/emacs-lisp/edebug.el
index 6dfcc24493..ab5553b4e8 100644
--- a/lisp/emacs-lisp/edebug.el
+++ b/lisp/emacs-lisp/edebug.el
@@ -70,8 +70,7 @@ Each time it is set to a new value, Edebug will call those functions
 once and then reset `edebug-setup-hook' to nil.  You could use this
 to load up Edebug specifications associated with a package you are
 using, but only when you also use Edebug."
-  :type 'hook
-  :group 'edebug)
+  :type 'hook)
 
 ;; edebug-all-defs and edebug-all-forms need to be autoloaded
 ;; because the byte compiler binds them; as a result, if edebug
@@ -88,8 +87,7 @@ You can use the command `edebug-all-defs' to toggle the value of this
 variable.  You may wish to make it local to each buffer with
 \(make-local-variable \\='edebug-all-defs) in your
 `emacs-lisp-mode-hook'."
-  :type 'boolean
-  :group 'edebug)
+  :type 'boolean)
 
 ;; edebug-all-defs and edebug-all-forms need to be autoloaded
 ;; because the byte compiler binds them; as a result, if edebug
@@ -100,8 +98,7 @@ variable.  You may wish to make it local to each buffer with
   "Non-nil means evaluation of all forms will instrument for Edebug.
 This doesn't apply to loading or evaluations in the minibuffer.
 Use the command `edebug-all-forms' to toggle the value of this option."
-  :type 'boolean
-  :group 'edebug)
+  :type 'boolean)
 
 (defcustom edebug-eval-macro-args nil
   "Non-nil means all macro call arguments may be evaluated.
@@ -110,8 +107,7 @@ macro call arguments as if they will be evaluated.
 For each macro, an `edebug-form-spec' overrides this option.
 So to specify exceptions for macros that have some arguments evaluated
 and some not, use `def-edebug-spec' to specify an `edebug-form-spec'."
-  :type 'boolean
-  :group 'edebug)
+  :type 'boolean)
 
 (defcustom edebug-max-depth 150
   "Maximum recursion depth when instrumenting code.
@@ -122,7 +118,6 @@ the error message \"Too deep - perhaps infinite loop in spec?\".
 Make this limit larger to countermand that, but you may also need to
 increase `max-lisp-eval-depth' and `max-specpdl-size'."
   :type 'integer
-  :group 'edebug
   :version "26.1")
 
 (defcustom edebug-save-windows t
@@ -134,8 +129,7 @@ If the value is a list, only the listed windows are saved and
 restored.
 
 `edebug-toggle-save-windows' may be used to change this variable."
-  :type '(choice boolean (repeat string))
-  :group 'edebug)
+  :type '(choice boolean (repeat string)))
 
 (defcustom edebug-save-displayed-buffer-points nil
   "If non-nil, save and restore point in all displayed buffers.
@@ -148,8 +142,7 @@ window, the buffer's point will be changed to the window's point.
 Saving and restoring point in all buffers is expensive, since it
 requires selecting each window twice, so enable this only if you
 need it."
-  :type 'boolean
-  :group 'edebug)
+  :type 'boolean)
 
 (defcustom edebug-initial-mode 'step
   "Initial execution mode for Edebug, if non-nil.
@@ -159,8 +152,7 @@ go, Go-nonstop, trace, Trace-fast, continue, and Continue-fast."
   :type '(choice (const step) (const next) (const go)
 		 (const Go-nonstop) (const trace)
 		 (const Trace-fast) (const continue)
-		 (const Continue-fast))
-  :group 'edebug)
+		 (const Continue-fast)))
 
 (defcustom edebug-trace nil
   "Non-nil means display a trace of function entry and exit.
@@ -169,8 +161,7 @@ function entry or exit per line, indented by the recursion level.
 
 You can customize by replacing functions `edebug-print-trace-before'
 and `edebug-print-trace-after'."
-  :type 'boolean
-  :group 'edebug)
+  :type 'boolean)
 
 (defcustom edebug-test-coverage nil
   "If non-nil, Edebug tests coverage of all expressions debugged.
@@ -180,36 +171,30 @@ results are found.
 
 Use `edebug-display-freq-count' to display the frequency count and
 coverage information for a definition."
-  :type 'boolean
-  :group 'edebug)
+  :type 'boolean)
 
 (defcustom edebug-continue-kbd-macro nil
   "If non-nil, continue defining or executing any keyboard macro.
 Use this with caution since it is not debugged."
-  :type 'boolean
-  :group 'edebug)
+  :type 'boolean)
 
 
 (defcustom edebug-print-length 50
   "If non-nil, default value of `print-length' for printing results in Edebug."
-  :type '(choice integer (const nil))
-  :group 'edebug)
+  :type '(choice integer (const nil)))
 (defcustom edebug-print-level 50
   "If non-nil, default value of `print-level' for printing results in Edebug."
-  :type '(choice integer (const nil))
-  :group 'edebug)
+  :type '(choice integer (const nil)))
 (defcustom edebug-print-circle t
   "If non-nil, default value of `print-circle' for printing results in Edebug."
-  :type 'boolean
-  :group 'edebug)
+  :type 'boolean)
 
 (defcustom edebug-unwrap-results nil
   "Non-nil if Edebug should unwrap results of expressions.
 That is, Edebug will try to remove its own instrumentation from the result.
 This is useful when debugging macros where the results of expressions
 are instrumented expressions."
-  :type 'boolean
-  :group 'edebug)
+  :type 'boolean)
 
 (defcustom edebug-on-error t
   "Value bound to `debug-on-error' while Edebug is active.
@@ -225,30 +210,25 @@ After execution is resumed, the error is signaled again."
 		 (repeat :menu-tag "When"
 			 :value (nil)
 			 (symbol :format "%v"))
-		 (const :tag "always" t))
-  :group 'edebug)
+		 (const :tag "always" t)))
 
 (defcustom edebug-on-quit t
   "Value bound to `debug-on-quit' while Edebug is active."
-  :type 'boolean
-  :group 'edebug)
+  :type 'boolean)
 
 (defcustom edebug-global-break-condition nil
   "If non-nil, an expression to test for at every stop point.
 If the result is non-nil, then break.  Errors are ignored."
   :type 'sexp
-  :risky t
-  :group 'edebug)
+  :risky t)
 
 (defcustom edebug-sit-for-seconds 1
   "Number of seconds to pause when execution mode is `trace' or `continue'."
-  :type 'number
-  :group 'edebug)
+  :type 'number)
 
 (defcustom edebug-sit-on-break t
   "Whether or not to pause for `edebug-sit-for-seconds' on reaching a break."
   :type 'boolean
-  :group 'edebug
   :version "26.1")
 
 ;;; Form spec utilities.
@@ -547,8 +527,13 @@ already is one.)"
       (edebug-read-top-level-form)))))
 
 
+(defvar edebug-active nil)  ;; Non-nil when edebug is active
+
 (defun edebug-read-top-level-form ()
-  (let ((starting-point (point)))
+  (let ((starting-point (point))
+        ;; Don't enter Edebug while doing that, in case we're trying to
+        ;; instrument things like end-of-defun.
+        (edebug-active t))
     (end-of-defun)
     (beginning-of-defun)
     (prog1
@@ -586,7 +571,7 @@ already is one.)"
 (defun edebug-uninstall-read-eval-functions ()
   (interactive)
   (remove-function load-read-function #'edebug--read)
-  (advice-remove 'eval-defun 'edebug-eval-defun))
+  (advice-remove 'eval-defun #'edebug-eval-defun))
 
 ;;; Edebug internal data
 
@@ -2225,8 +2210,6 @@ into `edebug--cl-macrolet-defs' which is checked in `edebug-list-form-args'."
 
 ;;; The debugger itself
 
-(defvar edebug-active nil)  ;; Non-nil when edebug is active
-
 (defvar edebug-stack nil)
 ;; Stack of active functions evaluated via edebug.
 ;; Should be nil at the top level.
@@ -2304,8 +2287,8 @@ and run its entry function, and set up `edebug-before' and
 `edebug-after'."
   (cl-letf* ((behavior (get func 'edebug-behavior))
              (functions (cdr (assoc behavior edebug-behavior-alist)))
-             ((symbol-function #'edebug-before) (nth 1 functions))
-             ((symbol-function #'edebug-after) (nth 2 functions)))
+             ((symbol-function 'edebug-before) (nth 1 functions))
+             ((symbol-function 'edebug-after) (nth 2 functions)))
     (funcall (nth 0 functions) func args body)))
 
 (defun edebug-default-enter (function args body)
@@ -2335,7 +2318,7 @@ and run its entry function, and set up `edebug-before' and
               (debug-on-error (or debug-on-error edebug-on-error))
               (debug-on-quit edebug-on-quit))
           (unwind-protect
-              (let ((signal-hook-function 'edebug-signal))
+              (let ((signal-hook-function #'edebug-signal))
                 (setq edebug-execution-mode (or edebug-next-execution-mode
                                                 edebug-initial-mode
                                                 edebug-execution-mode)
@@ -2905,7 +2888,7 @@ See `edebug-behavior-alist' for implementations.")
 	      (recursive-edit)		;  <<<<<<<<<< Recursive edit
 
 	    ;; Do the following, even if quit occurs.
-	    (setq signal-hook-function 'edebug-signal)
+	    (setq signal-hook-function #'edebug-signal)
 	    (if edebug-backtrace-buffer
 		(kill-buffer edebug-backtrace-buffer))
 
@@ -3810,7 +3793,7 @@ Options:
             (if (consp setting)
                 (set (car setting) (cdr setting))
               (kill-local-variable setting))))
-        (remove-hook 'kill-buffer-hook 'edebug-kill-buffer t))
+        (remove-hook 'kill-buffer-hook #'edebug-kill-buffer t))
     (pcase-dolist (`(,var . ,val) '((buffer-read-only . t)))
       (push
        (if (local-variable-p var) (cons var (symbol-value var)) var)
@@ -3818,7 +3801,7 @@ Options:
       (set (make-local-variable var) val))
     ;; Append `edebug-kill-buffer' to the hook to avoid interfering with
     ;; other entries that are unguarded against deleted buffer.
-    (add-hook 'kill-buffer-hook 'edebug-kill-buffer t t)))
+    (add-hook 'kill-buffer-hook #'edebug-kill-buffer t t)))
 
 (defun edebug-kill-buffer ()
   "Used on `kill-buffer-hook' when Edebug is operating in a buffer of Lisp code."
@@ -4016,7 +3999,7 @@ This should be a list of `edebug---frame' objects.")
   (pop-to-buffer edebug-backtrace-buffer)
   (unless (derived-mode-p 'backtrace-mode)
     (backtrace-mode)
-    (add-hook 'backtrace-goto-source-functions 'edebug--backtrace-goto-source))
+    (add-hook 'backtrace-goto-source-functions #'edebug--backtrace-goto-source))
   (setq edebug-instrumented-backtrace-frames
         (backtrace-get-frames 'edebug-debugger
                               :constructor #'edebug--make-frame)
@@ -4396,8 +4379,8 @@ With prefix argument, make it a temporary breakpoint."
       ;; We still want to run unload-feature to completion
       (run-with-idle-timer 0 nil #'(lambda () (unload-feature 'edebug)))))
   (remove-hook 'called-interactively-p-functions
-               'edebug--called-interactively-skip)
-  (remove-hook 'cl-read-load-hooks 'edebug--require-cl-read)
+               #'edebug--called-interactively-skip)
+  (remove-hook 'cl-read-load-hooks #'edebug--require-cl-read)
   (edebug-uninstall-read-eval-functions)
   ;; Continue standard unloading.
   nil)
diff --git a/lisp/emacs-lisp/eieio-base.el b/lisp/emacs-lisp/eieio-base.el
index 3a0109877e..203541fdfc 100644
--- a/lisp/emacs-lisp/eieio-base.el
+++ b/lisp/emacs-lisp/eieio-base.el
@@ -3,7 +3,7 @@
 ;;; Copyright (C) 2000-2002, 2004-2005, 2007-2019 Free Software
 ;;; Foundation, Inc.
 
-;; Author: Eric M. Ludlam  <zappo@gnu.org>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 ;; Keywords: OO, lisp
 ;; Package: eieio
 
@@ -64,10 +64,18 @@ SLOT-NAME is the offending slot.  FN is the function signaling the error."
     ;; Throw the regular signal.
     (cl-call-next-method)))
 
-(cl-defmethod clone ((obj eieio-instance-inheritor) &rest _params)
+(cl-defmethod clone ((obj eieio-instance-inheritor) &rest params)
   "Clone OBJ, initializing `:parent' to OBJ.
 All slots are unbound, except those initialized with PARAMS."
-  (let ((nobj (cl-call-next-method)))
+  ;; call next method without params as we makeunbound slots anyhow
+  (let ((nobj  (if (stringp (car params))
+                   (cl-call-next-method obj (pop params))
+                 (cl-call-next-method obj))))
+    (dolist (descriptor (eieio-class-slots (class-of nobj)))
+      (let ((slot (eieio-slot-descriptor-name descriptor)))
+        (slot-makeunbound nobj slot)))
+    (when params
+      (shared-initialize nobj params))
     (oset nobj parent-instance obj)
     nobj))
 
@@ -510,16 +518,18 @@ instance."
 All slots are unbound, except those initialized with PARAMS."
   (let* ((newname (and (stringp (car params)) (pop params)))
          (nobj (apply #'cl-call-next-method obj params))
-         (nm (slot-value obj 'object-name)))
-    (eieio-oset obj 'object-name
+         (nm (slot-value nobj 'object-name)))
+    (eieio-oset nobj 'object-name
                 (or newname
-                    (save-match-data
-                      (if (and nm (string-match "-\\([0-9]+\\)" nm))
-                          (let ((num (1+ (string-to-number
-                                          (match-string 1 nm)))))
-                            (concat (substring nm 0 (match-beginning 0))
-                                    "-" (int-to-string num)))
-                        (concat nm "-1")))))
+                    (if (equal nm (slot-value obj 'object-name))
+                        (save-match-data
+                          (if (and nm (string-match "-\\([0-9]+\\)" nm))
+                              (let ((num (1+ (string-to-number
+                                              (match-string 1 nm)))))
+                                (concat (substring nm 0 (match-beginning 0))
+                                        "-" (int-to-string num)))
+                            (concat nm "-1")))
+                      nm)))
     nobj))
 
 (cl-defmethod make-instance ((class (subclass eieio-named)) &rest args)
diff --git a/lisp/emacs-lisp/eieio-core.el b/lisp/emacs-lisp/eieio-core.el
index 31ee6c5bfd..30445f9e64 100644
--- a/lisp/emacs-lisp/eieio-core.el
+++ b/lisp/emacs-lisp/eieio-core.el
@@ -117,9 +117,6 @@ Currently under control of this var:
 (defsubst eieio--object-class-tag (obj)
   (aref obj 0))
 
-(defsubst eieio--object-class (obj)
-  (eieio--object-class-tag obj))
-
 
 ;;; Important macros used internally in eieio.
 
@@ -132,6 +129,12 @@ Currently under control of this var:
       (or (cl--find-class class) class)
     class))
 
+(defsubst eieio--object-class (obj)
+  (let ((tag (eieio--object-class-tag obj)))
+    (if eieio-backward-compatibility
+        (eieio--class-object tag)
+      tag)))
+
 (defun class-p (x)
   "Return non-nil if X is a valid class vector.
 X can also be is a symbol."
@@ -163,7 +166,7 @@ Return nil if that option doesn't exist."
 (defun eieio-object-p (obj)
   "Return non-nil if OBJ is an EIEIO object."
   (and (recordp obj)
-       (eieio--class-p (eieio--object-class-tag obj))))
+       (eieio--class-p (eieio--object-class obj))))
 
 (define-obsolete-function-alias 'object-p 'eieio-object-p "25.1")
 
diff --git a/lisp/emacs-lisp/eieio.el b/lisp/emacs-lisp/eieio.el
index b6ec191e2b..7ad44b6d26 100644
--- a/lisp/emacs-lisp/eieio.el
+++ b/lisp/emacs-lisp/eieio.el
@@ -710,6 +710,9 @@ calls `initialize-instance' on that object."
     ;; Call the initialize method on the new object with the slots
     ;; that were passed down to us.
     (initialize-instance new-object slots)
+    (when eieio-backward-compatibility
+      ;; Use symbol as type descriptor, for backwards compatibility.
+      (aset new-object 0 class))
     ;; Return the created object.
     new-object))
 
diff --git a/lisp/emacs-lisp/eldoc.el b/lisp/emacs-lisp/eldoc.el
index 188d99e14c..16b5863209 100644
--- a/lisp/emacs-lisp/eldoc.el
+++ b/lisp/emacs-lisp/eldoc.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1996-2019 Free Software Foundation, Inc.
 
 ;; Author: Noah Friedman <friedman@splode.com>
-;; Maintainer: friedman@splode.com
 ;; Keywords: extensions
 ;; Created: 1995-10-06
 
diff --git a/lisp/emacs-lisp/elint.el b/lisp/emacs-lisp/elint.el
index 3f49b51acd..4a53972016 100644
--- a/lisp/emacs-lisp/elint.el
+++ b/lisp/emacs-lisp/elint.el
@@ -937,7 +937,7 @@ Does basic handling of `featurep' tests."
 	  ((and (memq func '(unless or))
 		(equal test '(featurep (quote emacs)))))
 	  ((and (eq func 'if)
-		(or (null test)	      ; eg custom-browse-insert-prefix
+		(or (null test)
 		    (member test '((featurep (quote xemacs))
 				   (not (featurep (quote emacs)))))
 		    (and (eq (car-safe test) 'and)
diff --git a/lisp/emacs-lisp/ert.el b/lisp/emacs-lisp/ert.el
index 20d013b079..ab24efe5a7 100644
--- a/lisp/emacs-lisp/ert.el
+++ b/lisp/emacs-lisp/ert.el
@@ -792,13 +792,13 @@ This mainly sets up debugger-related bindings."
 This can be useful after reducing the value of `message-log-max'."
   (with-current-buffer (messages-buffer)
     ;; This is a reimplementation of this part of message_dolog() in xdisp.c:
-    ;; if (NATNUMP (Vmessage_log_max))
+    ;; if (FIXNATP (Vmessage_log_max))
     ;;   {
     ;;     scan_newline (Z, Z_BYTE, BEG, BEG_BYTE,
-    ;;                   -XFASTINT (Vmessage_log_max) - 1, 0);
-    ;;     del_range_both (BEG, BEG_BYTE, PT, PT_BYTE, 0);
+    ;;                   -XFIXNAT (Vmessage_log_max) - 1, false);
+    ;;     del_range_both (BEG, BEG_BYTE, PT, PT_BYTE, false);
     ;;   }
-    (when (and (integerp message-log-max) (>= message-log-max 0))
+    (when (natnump message-log-max)
       (let ((begin (point-min))
             (end (save-excursion
                    (goto-char (point-max))
diff --git a/lisp/emacs-lisp/ewoc.el b/lisp/emacs-lisp/ewoc.el
index c33b46501f..597afdd66f 100644
--- a/lisp/emacs-lisp/ewoc.el
+++ b/lisp/emacs-lisp/ewoc.el
@@ -4,7 +4,7 @@
 
 ;; Author: Per Cederqvist <ceder@lysator.liu.se>
 ;;	Inge Wallin <inge@lysator.liu.se>
-;; Maintainer: monnier@gnu.org
+;; Maintainer: Stefan Monnier <monnier@gnu.org>
 ;; Created: 3 Aug 1992
 ;; Keywords: extensions, lisp
 
diff --git a/lisp/emacs-lisp/find-func.el b/lisp/emacs-lisp/find-func.el
index b63d4d4e0a..9fc7e4a797 100644
--- a/lisp/emacs-lisp/find-func.el
+++ b/lisp/emacs-lisp/find-func.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1997, 1999, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Jens Petersen <petersen@kurims.kyoto-u.ac.jp>
-;; Maintainer: petersen@kurims.kyoto-u.ac.jp
 ;; Keywords: emacs-lisp, functions, variables
 ;; Created: 97/07/25
 
diff --git a/lisp/emacs-lisp/generic.el b/lisp/emacs-lisp/generic.el
index 678d384da4..e4ed745b25 100644
--- a/lisp/emacs-lisp/generic.el
+++ b/lisp/emacs-lisp/generic.el
@@ -2,7 +2,7 @@
 ;;
 ;; Copyright (C) 1997, 1999, 2001-2019 Free Software Foundation, Inc.
 ;;
-;; Author:  Peter Breton <pbreton@cs.umb.edu>
+;; Author: Peter Breton <pbreton@cs.umb.edu>
 ;; Created: Fri Sep 27 1996
 ;; Keywords: generic, comment, font-lock
 ;; Package: emacs
diff --git a/lisp/emacs-lisp/gv.el b/lisp/emacs-lisp/gv.el
index 4ea3ce84fc..bdd1574820 100644
--- a/lisp/emacs-lisp/gv.el
+++ b/lisp/emacs-lisp/gv.el
@@ -392,18 +392,20 @@ The return value is the last VAL in the list.
                                  ,(funcall setter
                                            `(cons (setq ,p (cons ,k ,v))
                                                   ,getter)))))
-                         (cond
-                          ((null remove) set-exp)
-                          ((or (eql v default)
-                               (and (eq (car-safe v) 'quote)
-                                    (eq (car-safe default) 'quote)
-                                    (eql (cadr v) (cadr default))))
-                           `(if ,p ,(funcall setter `(delq ,p ,getter))))
-                          (t
-                           `(cond
-                             ((not (eql ,default ,v)) ,set-exp)
-                             (,p ,(funcall setter
-                                           `(delq ,p ,getter)))))))))))))))
+                         `(progn
+                            ,(cond
+                             ((null remove) set-exp)
+                             ((or (eql v default)
+                                  (and (eq (car-safe v) 'quote)
+                                       (eq (car-safe default) 'quote)
+                                       (eql (cadr v) (cadr default))))
+                              `(if ,p ,(funcall setter `(delq ,p ,getter))))
+                             (t
+                              `(cond
+                                ((not (eql ,default ,v)) ,set-exp)
+                                (,p ,(funcall setter
+                                              `(delq ,p ,getter))))))
+                            ,v))))))))))
 
 
 ;;; Some occasionally handy extensions.
diff --git a/lisp/emacs-lisp/lisp-mode.el b/lisp/emacs-lisp/lisp-mode.el
index 4c7a8bea3f..fa6dc98d04 100644
--- a/lisp/emacs-lisp/lisp-mode.el
+++ b/lisp/emacs-lisp/lisp-mode.el
@@ -1210,19 +1210,25 @@ ENDPOS is encountered."
                     ;; Get error now if we don't have a complete sexp
                     ;; after point.
                     (save-excursion
+                      (forward-sexp 1)
                       (let ((eol (line-end-position)))
-                        (forward-sexp 1)
                         ;; We actually look for a sexp which ends
                         ;; after the current line so that we properly
                         ;; indent things like #s(...).  This might not
                         ;; be needed if Bug#15998 is fixed.
-                        (condition-case ()
-                            (while (and (< (point) eol) (not (eobp)))
-                              (forward-sexp 1))
-                          ;; But don't signal an error for incomplete
-                          ;; sexps following the first complete sexp
-                          ;; after point.
-                          (scan-error nil)))
+                        (when (and (< (point) eol)
+                                   ;; Check if eol is within a sexp.
+                                   (> (nth 0 (save-excursion
+                                               (parse-partial-sexp
+                                                (point) eol)))
+                                      0))
+                          (condition-case ()
+                              (while (< (point) eol)
+                                (forward-sexp 1))
+                            ;; But don't signal an error for incomplete
+                            ;; sexps following the first complete sexp
+                            ;; after point.
+                            (scan-error nil))))
                       (point)))))
     (save-excursion
       (while (let ((indent (lisp-indent-calc-next parse-state))
diff --git a/lisp/emacs-lisp/lisp.el b/lisp/emacs-lisp/lisp.el
index d10d5f0d10..38df920f17 100644
--- a/lisp/emacs-lisp/lisp.el
+++ b/lisp/emacs-lisp/lisp.el
@@ -645,7 +645,7 @@ Interactively, the behavior depends on `narrow-to-defun-include-comments'."
       (re-search-backward "^\n" (- (point) 1) t)
       (narrow-to-region beg end))))
 
-(defvar insert-pair-alist
+(defcustom insert-pair-alist
   '((?\( ?\)) (?\[ ?\]) (?\{ ?\}) (?\< ?\>) (?\" ?\") (?\' ?\') (?\` ?\'))
   "Alist of paired characters inserted by `insert-pair'.
 Each element looks like (OPEN-CHAR CLOSE-CHAR) or (COMMAND-CHAR
@@ -655,7 +655,16 @@ or without modifiers, are inserted by `insert-pair'.
 
 If COMMAND-CHAR is specified, it is a character that triggers the
 insertion of the open/close pair, and COMMAND-CHAR itself isn't
-inserted.")
+inserted."
+  :type '(repeat (choice (list :tag "Pair"
+                               (character :tag "Open")
+                               (character :tag "Close"))
+                         (list :tag "Triple"
+                               (character :tag "Command")
+                               (character :tag "Open")
+                               (character :tag "Close"))))
+  :group 'lisp
+  :version "27.1")
 
 (defun insert-pair (&optional arg open close)
   "Enclose following ARG sexps in a pair of OPEN and CLOSE characters.
diff --git a/lisp/emacs-lisp/package.el b/lisp/emacs-lisp/package.el
index 61cf690697..670831d963 100644
--- a/lisp/emacs-lisp/package.el
+++ b/lisp/emacs-lisp/package.el
@@ -334,16 +334,22 @@ default directory."
            (epg-find-configuration 'OpenPGP))
       'allow-unsigned)
   "Non-nil means to check package signatures when installing.
-The value `allow-unsigned' means to still install a package even if
-it is unsigned.
+More specifically the value can be:
+- nil: package signatures are ignored.
+- `allow-unsigned': install a package even if it is unsigned,
+  but if it is signed and we have the key for it, verify the signature.
+- t: accept a package only if it comes with at least one verified signature.
+- `all': same as t, except when the package has several signatures,
+  in which case we verify all the signatures.
 
 This also applies to the \"archive-contents\" file that lists the
 contents of the archive."
   :type '(choice (const nil :tag "Never")
                  (const allow-unsigned :tag "Allow unsigned")
-                 (const t :tag "Check always"))
+                 (const t :tag "Check always")
+                 (const all :tag "Check all signatures"))
   :risky t
-  :version "24.4")
+  :version "27.1")
 
 (defcustom package-unsigned-archives nil
   "List of archives where we do not check for package signatures."
@@ -1191,45 +1197,66 @@ errors signaled by ERROR-FORM or by BODY).
   (declare (indent defun) (debug t))
   (while (keywordp (car body))
     (setq body (cdr (cdr body))))
-  (macroexp-let2* nil ((url-1 url)
-                       (noerror-1 noerror))
-    (let ((url-sym (make-symbol "url"))
-          (b-sym (make-symbol "b-sym")))
-      `(cl-macrolet ((unless-error (body-2 &rest before-body)
-                                   (let ((err (make-symbol "err")))
-                                     `(with-temp-buffer
-                                        (when (condition-case ,err
-                                                  (progn ,@before-body t)
-                                                ,(list 'error ',error-form
-                                                       (list 'unless ',noerror-1
-                                                             `(signal (car ,err) (cdr ,err)))))
-                                          ,@body-2)))))
-         (if (string-match-p "\\`https?:" ,url-1)
-             (let ((,url-sym (concat ,url-1 ,file)))
-               (if ,async
-                   (unless-error nil
-                                 (url-retrieve ,url-sym
-                                               (lambda (status)
-                                                 (let ((,b-sym (current-buffer)))
-                                                   (require 'url-handlers)
-                                                   (unless-error ,body
-                                                                 (when-let* ((er (plist-get status :error)))
-                                                                   (error "Error retrieving: %s %S" ,url-sym er))
-                                                                 (with-current-buffer ,b-sym
-                                                                   (goto-char (point-min))
-                                                                   (unless (search-forward-regexp "^\r?\n\r?" nil 'noerror)
-                                                                     (error "Error retrieving: %s %S" ,url-sym "incomprehensible buffer")))
-                                                                 (url-insert-buffer-contents ,b-sym ,url-sym)
-                                                                 (kill-buffer ,b-sym)
-                                                                 (goto-char (point-min)))))
-                                               nil
-                                               'silent))
-                 (unless-error ,body (url-insert-file-contents ,url-sym))))
-           (unless-error ,body
-                         (let ((url (expand-file-name ,file ,url-1)))
-                           (unless (file-name-absolute-p url)
-                             (error "Location %s is not a url nor an absolute file name" url))
-                           (insert-file-contents url))))))))
+  `(package--with-response-buffer-1 ,url (lambda () ,@body)
+                                    :file ,file
+                                    :async ,async
+                                    :error-function (lambda () ,error-form)
+                                    :noerror ,noerror))
+
+(defmacro package--unless-error (body &rest before-body)
+  (declare (debug t) (indent 1))
+  (let ((err (make-symbol "err")))
+    `(with-temp-buffer
+       (set-buffer-multibyte nil)
+       (when (condition-case ,err
+                 (progn ,@before-body t)
+               (error (funcall error-function)
+                      (unless noerror
+                        (signal (car ,err) (cdr ,err)))))
+         (funcall ,body)))))
+
+(cl-defun package--with-response-buffer-1 (url body &key async file error-function noerror &allow-other-keys)
+  (if (string-match-p "\\`https?:" url)
+        (let ((url (concat url file)))
+          (if async
+              (package--unless-error #'ignore
+                (url-retrieve
+                 url
+                 (lambda (status)
+                   (let ((b (current-buffer)))
+                     (require 'url-handlers)
+                     (package--unless-error body
+                       (when-let* ((er (plist-get status :error)))
+                         (error "Error retrieving: %s %S" url er))
+                       (with-current-buffer b
+                         (goto-char (point-min))
+                         (unless (search-forward-regexp "^\r?\n\r?" nil t)
+                           (error "Error retrieving: %s %S"
+                                  url "incomprehensible buffer")))
+                       (url-insert b)
+                       (kill-buffer b)
+                       (goto-char (point-min)))))
+                 nil
+                 'silent))
+            (package--unless-error body
+              ;; Copy&pasted from url-insert-file-contents,
+              ;; except it calls `url-insert' because we want the contents
+              ;; literally (but there's no url-insert-file-contents-literally).
+              (let ((buffer (url-retrieve-synchronously url)))
+                (unless buffer (signal 'file-error (list url "No Data")))
+                (when (fboundp 'url-http--insert-file-helper)
+                  ;; XXX: This is HTTP/S specific and should be moved
+                  ;; to url-http instead.  See bug#17549.
+                  (url-http--insert-file-helper buffer url))
+                (url-insert buffer)
+                (kill-buffer buffer)
+                (goto-char (point-min))))))
+      (package--unless-error body
+        (let ((url (expand-file-name file url)))
+          (unless (file-name-absolute-p url)
+            (error "Location %s is not a url nor an absolute file name"
+                   url))
+          (insert-file-contents-literally url)))))
 
 (define-error 'bad-signature "Failed to verify signature")
 
@@ -1257,7 +1284,9 @@ errors."
           (unless (and (eq package-check-signature 'allow-unsigned)
                        (eq (epg-signature-status sig) 'no-pubkey))
             (setq had-fatal-error t))))
-      (when (or (null good-signatures) had-fatal-error)
+      (when (or (null good-signatures)
+                (and (eq package-check-signature 'all)
+                     had-fatal-error))
         (package--display-verify-error context sig-file)
         (signal 'bad-signature (list sig-file)))
       good-signatures)))
@@ -1286,7 +1315,8 @@ else, even if an error is signaled."
     (package--with-response-buffer location :file sig-file
       :async async :noerror t
       ;; Connection error is assumed to mean "no sig-file".
-      :error-form (let ((allow-unsigned (eq package-check-signature 'allow-unsigned)))
+      :error-form (let ((allow-unsigned
+                         (eq package-check-signature 'allow-unsigned)))
                     (when (and callback allow-unsigned)
                       (funcall callback nil))
                     (when unwind (funcall unwind))
@@ -1295,8 +1325,9 @@ else, even if an error is signaled."
       ;; OTOH, an error here means "bad signature", which we never
       ;; suppress.  (Bug#22089)
       (unwind-protect
-          (let ((sig (package--check-signature-content (buffer-substring (point) (point-max))
-                                                       string sig-file)))
+          (let ((sig (package--check-signature-content
+                      (buffer-substring (point) (point-max))
+                      string sig-file)))
             (when callback (funcall callback sig))
             sig)
         (when unwind (funcall unwind))))))
@@ -1573,15 +1604,18 @@ similar to an entry in `package-alist'.  Save the cached copy to
                 (member name package-unsigned-archives))
             ;; If we don't care about the signature, save the file and
             ;; we're done.
-            (progn (let ((coding-system-for-write 'utf-8))
-                     (write-region content nil local-file nil 'silent))
-                   (package--update-downloads-in-progress archive))
+            (progn
+             (cl-assert (not enable-multibyte-characters))
+             (let ((coding-system-for-write 'binary))
+               (write-region content nil local-file nil 'silent))
+             (package--update-downloads-in-progress archive))
           ;; If we care, check it (perhaps async) and *then* write the file.
           (package--check-signature
            location file content async
            ;; This function will be called after signature checking.
            (lambda (&optional good-sigs)
-             (let ((coding-system-for-write 'utf-8))
+             (cl-assert (not enable-multibyte-characters))
+             (let ((coding-system-for-write 'binary))
                (write-region content nil local-file nil 'silent))
              ;; Write out good signatures into archive-contents.signed file.
              (when good-sigs
@@ -1617,7 +1651,7 @@ downloads in the background."
     (make-directory package-user-dir t))
   (let ((default-keyring (expand-file-name "package-keyring.gpg"
                                            data-directory))
-        (inhibit-message async))
+        (inhibit-message (or inhibit-message async)))
     (when (and package-check-signature (file-exists-p default-keyring))
       (condition-case-unless-debug error
           (package-import-keyring default-keyring)
@@ -1879,9 +1913,12 @@ if all the in-between dependencies are also in PACKAGE-LIST."
            ;; This function will be called after signature checking.
            (lambda (&optional good-sigs)
              ;; Signature checked, unpack now.
-             (with-temp-buffer (insert content)
-                               (let ((save-silently t))
-                                 (package-unpack pkg-desc)))
+             (with-temp-buffer ;FIXME: Just use the previous current-buffer.
+               (set-buffer-multibyte nil)
+               (cl-assert (not (multibyte-string-p content)))
+               (insert content)
+               (let ((save-silently t))
+                 (package-unpack pkg-desc)))
              ;; Here the package has been installed successfully, mark it as
              ;; signed if appropriate.
              (when good-sigs
@@ -1895,7 +1932,8 @@ if all the in-between dependencies are also in PACKAGE-LIST."
                ;; Update the old pkg-desc which will be shown on the description buffer.
                (setf (package-desc-signed pkg-desc) t)
                ;; Update the new (activated) pkg-desc as well.
-               (when-let* ((pkg-descs (cdr (assq (package-desc-name pkg-desc) package-alist))))
+               (when-let* ((pkg-descs (cdr (assq (package-desc-name pkg-desc)
+                                                 package-alist))))
                  (setf (package-desc-signed (car pkg-descs)) t))))))))))
 
 (defun package-installed-p (package &optional min-version)
@@ -2469,10 +2507,12 @@ The description is read from the installed package files."
               (replace-match ""))))
 
       (if (package-installed-p desc)
-          ;; For installed packages, get the description from the installed files.
+          ;; For installed packages, get the description from the
+          ;; installed files.
           (insert (package--get-description desc))
 
-        ;; For non-built-in, non-installed packages, get description from the archive.
+        ;; For non-built-in, non-installed packages, get description from
+        ;; the archive.
         (let* ((basename (format "%s-readme.txt" name))
                readme-string)
 
@@ -2482,7 +2522,10 @@ The description is read from the installed package files."
               (goto-char (point-max))
               (unless (bolp)
                 (insert ?\n)))
-            (setq readme-string (buffer-string))
+            (cl-assert (not enable-multibyte-characters))
+            (setq readme-string
+                  ;; The readme.txt files are defined to contain utf-8 text.
+                  (decode-coding-region (point-min) (point-max) 'utf-8 t))
             t)
           (insert (or readme-string
                       "This package does not provide a description.")))
@@ -3253,7 +3296,7 @@ objects removed."
     (redisplay 'force)
     (dolist (elt (package--sort-by-dependence delete-list))
       (condition-case-unless-debug err
-          (let ((inhibit-message package-menu-async))
+          (let ((inhibit-message (or inhibit-message package-menu-async)))
             (package-delete elt nil 'nosave))
         (error (message "Error trying to delete `%s': %S"
                  (package-desc-full-name elt)
diff --git a/lisp/emacs-lisp/radix-tree.el b/lisp/emacs-lisp/radix-tree.el
index 75d9874b43..dd65e1a0b4 100644
--- a/lisp/emacs-lisp/radix-tree.el
+++ b/lisp/emacs-lisp/radix-tree.el
@@ -196,8 +196,8 @@ If not found, return nil."
 
 (eval-and-compile
   (pcase-defmacro radix-tree-leaf (vpat)
-    "Build a `pcase' pattern that matches radix-tree leaf EXPVAL.
-VPAT is a `pcase' pattern to extract the value."
+    "Pattern which matches a radix-tree leaf.
+The pattern VPAT is matched against the leaf's carried value."
     ;; FIXME: We'd like to use a negative pattern (not consp), but pcase
     ;; doesn't support it.  Using `atom' works but generates sub-optimal code.
     `(or `(t . ,,vpat) (and (pred atom) ,vpat))))
diff --git a/lisp/emacs-lisp/regexp-opt.el b/lisp/emacs-lisp/regexp-opt.el
index d883752d71..00f72e284a 100644
--- a/lisp/emacs-lisp/regexp-opt.el
+++ b/lisp/emacs-lisp/regexp-opt.el
@@ -144,9 +144,9 @@ usually more efficient than that of a simplified version:
 			    (sort (copy-sequence strings) 'string-lessp)))
 	   (re
             (cond
-             ;; No strings: return a\` which cannot match anything.
+             ;; No strings: return an unmatchable regexp.
              ((null strings)
-              (concat (or open "\\(?:") "a\\`\\)"))
+              (concat (or open "\\(?:") regexp-unmatchable "\\)"))
              ;; If we cannot reorder, give up all attempts at
              ;; optimisation.  There is room for improvement (Bug#34641).
              ((and keep-order (regexp-opt--contains-prefix sorted-strings))
diff --git a/lisp/emacs-lisp/regi.el b/lisp/emacs-lisp/regi.el
index f8268ed27b..c2e1c44dcf 100644
--- a/lisp/emacs-lisp/regi.el
+++ b/lisp/emacs-lisp/regi.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1993, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: 1993 Barry A. Warsaw, Century Computing, Inc. <bwarsaw@cen.com>
-;; Maintainer:    bwarsaw@cen.com
 ;; Created:       24-Feb-1993
 ;; Version:       1.8
 ;; Last Modified: 1993/06/01 21:33:00
diff --git a/lisp/emacs-lisp/rmc.el b/lisp/emacs-lisp/rmc.el
index 6d1adae974..47f3b8dc9c 100644
--- a/lisp/emacs-lisp/rmc.el
+++ b/lisp/emacs-lisp/rmc.el
@@ -118,7 +118,7 @@ Usage example:
                             choices)))
                   (condition-case nil
                       (let ((cursor-in-echo-area t))
-                        (read-char))
+                        (read-event))
                     (error nil))))
           (setq answer (lookup-key query-replace-map (vector tchar) t))
           (setq tchar
diff --git a/lisp/emacs-lisp/rx.el b/lisp/emacs-lisp/rx.el
index fdd24317c6..8ef78fd69e 100644
--- a/lisp/emacs-lisp/rx.el
+++ b/lisp/emacs-lisp/rx.el
@@ -107,15 +107,16 @@
 ;;; Code:
 
 (require 'cl-lib)
+(require 'cl-extra)
 
 ;; FIXME: support macros.
 
 (defvar rx-constituents              ;Not `const' because some modes extend it.
-  '((and		. (rx-and 1 nil))
+  '((and		. (rx-and 0 nil))
     (seq		. and)		; SRE
     (:			. and)		; SRE
     (sequence		. and)		; sregex
-    (or			. (rx-or 1 nil))
+    (or			. (rx-or 0 nil))
     (|			. or)		; SRE
     (not-newline	. ".")
     (nonl		. not-newline)	; SRE
@@ -391,9 +392,11 @@ FORM is of the form `(and FORM1 ...)'."
   "Parse and produce code from FORM, which is `(or FORM1 ...)'."
   (rx-check form)
   (rx-group-if
-   (if (memq nil (mapcar 'stringp (cdr form)))
-       (mapconcat (lambda (x) (rx-form x '|)) (cdr form) "\\|")
+   (cond
+    ((null (cdr form)) regexp-unmatchable)
+    ((cl-every #'stringp (cdr form))
      (regexp-opt (cdr form) nil t))
+    (t (mapconcat (lambda (x) (rx-form x '|)) (cdr form) "\\|")))
    (and (memq rx-parent '(: * t)) rx-parent)))
 
 
@@ -1122,6 +1125,7 @@ CHAR
 `(seq SEXP1 SEXP2 ...)'
 `(sequence SEXP1 SEXP2 ...)'
      matches what SEXP1 matches, followed by what SEXP2 matches, etc.
+     Without arguments, matches the empty string.
 
 `(submatch SEXP1 SEXP2 ...)'
 `(group SEXP1 SEXP2 ...)'
@@ -1137,7 +1141,7 @@ CHAR
 `(| SEXP1 SEXP2 ...)'
      matches anything that matches SEXP1 or SEXP2, etc.  If all
      args are strings, use `regexp-opt' to optimize the resulting
-     regular expression.
+     regular expression.  Without arguments, never matches anything.
 
 `(minimal-match SEXP)'
      produce a non-greedy regexp for SEXP.  Normally, regexps matching
diff --git a/lisp/emacs-lisp/smie.el b/lisp/emacs-lisp/smie.el
index 92b639d71e..f2163b243e 100644
--- a/lisp/emacs-lisp/smie.el
+++ b/lisp/emacs-lisp/smie.el
@@ -1446,9 +1446,9 @@ in order to figure out the indentation of some other (further down) point."
   (and (smie-indent--bolp)
        (save-excursion
          (comment-normalize-vars)
-         (re-search-forward (concat comment-start-skip
+         (re-search-forward (concat "\\(?:" comment-start-skip "\\)"
                                     "fixindent"
-                                    comment-end-skip)
+                                    "\\(?:" comment-end-skip "\\)")
                             ;; 1+ to account for the \n comment termination.
                             (1+ (line-end-position)) t))
        (current-column)))
@@ -1648,11 +1648,33 @@ should not be computed on the basis of the following token."
          (let ((ppss (syntax-ppss)))
            (save-excursion
              (forward-line -1)
-             (if (<= (point) (nth 8 ppss))
-                 (progn (goto-char (1+ (nth 8 ppss))) (current-column))
-               (skip-chars-forward " \t")
-               (if (looking-at (regexp-quote continue))
-                   (current-column))))))))
+             (let ((start (nth 8 ppss)))
+               (if (<= (point) start)
+                   (progn
+                     (goto-char start)
+                     (if (not (and comment-start-skip
+                                   (looking-at comment-start-skip)))
+                         (forward-char 1)
+                       (goto-char (match-end 0))
+                       (skip-chars-backward " \t")
+                       ;; Try to align the first char of the comment-continue
+                       ;; with the second char of the comment-start or the
+                       ;; first char if the comment-start is made of
+                       ;; a single char.  E.g.
+                       ;;
+                       ;;     /* foo
+                       ;;      * bar */
+                       ;;
+                       ;; but
+                       ;;
+                       ;;     { foo
+                       ;;     | bar }
+                       (goto-char (if (eq (point) (1+ start))
+                                      start (1+ start))))
+                     (current-column))
+                 (skip-chars-forward " \t")
+                 (if (looking-at (regexp-quote continue))
+                     (current-column)))))))))
 
 (defun smie-indent-comment-close ()
   (and (boundp 'comment-end-skip)
diff --git a/lisp/emacs-lisp/syntax.el b/lisp/emacs-lisp/syntax.el
index d09d6c1225..60ed531e63 100644
--- a/lisp/emacs-lisp/syntax.el
+++ b/lisp/emacs-lisp/syntax.el
@@ -283,10 +283,13 @@ END) suitable for `syntax-propertize-function'."
         ;; In case it was eval'd/compiled.
         (setq keywords font-lock-syntactic-keywords)))))
 
+(defvar-local syntax-ppss-table nil
+  "Syntax-table to use during `syntax-ppss', if any.")
+
 (defun syntax-propertize (pos)
   "Ensure that syntax-table properties are set until POS (a buffer point)."
   (when (< syntax-propertize--done pos)
-    (if (null syntax-propertize-function)
+    (if (memq syntax-propertize-function '(nil ignore))
         (setq syntax-propertize--done (max (point-max) pos))
       ;; (message "Needs to syntax-propertize from %s to %s"
       ;;          syntax-propertize--done pos)
@@ -298,50 +301,51 @@ END) suitable for `syntax-propertize-function'."
         ;; between syntax-ppss and syntax-propertize, we also have to make
         ;; sure the flush function is installed here (bug#29767).
         (add-hook 'before-change-functions
-	          #'syntax-ppss-flush-cache t t))
+	          #'syntax-ppss-flush-cache 99 t))
       (save-excursion
         (with-silent-modifications
-          (make-local-variable 'syntax-propertize--done) ;Just in case!
-          (let* ((start (max (min syntax-propertize--done (point-max))
-                             (point-min)))
-                 (end (max pos
-                           (min (point-max)
-                                (+ start syntax-propertize-chunk-size))))
-                 (funs syntax-propertize-extend-region-functions))
-            (while funs
-              (let ((new (funcall (pop funs) start end))
-                    ;; Avoid recursion!
-                    (syntax-propertize--done most-positive-fixnum))
-                (if (or (null new)
-                        (and (>= (car new) start) (<= (cdr new) end)))
-                    nil
-                  (setq start (car new))
-                  (setq end (cdr new))
-                  ;; If there's been a change, we should go through the
-                  ;; list again since this new position may
-                  ;; warrant a different answer from one of the funs we've
-                  ;; already seen.
-                  (unless (eq funs
-                              (cdr syntax-propertize-extend-region-functions))
-                    (setq funs syntax-propertize-extend-region-functions)))))
-            ;; Flush ppss cache between the original value of `start' and that
-            ;; set above by syntax-propertize-extend-region-functions.
-            (syntax-ppss-flush-cache start)
-            ;; Move the limit before calling the function, so the function
-            ;; can use syntax-ppss.
-            (setq syntax-propertize--done end)
-            ;; (message "syntax-propertizing from %s to %s" start end)
-            (remove-text-properties start end
-                                    '(syntax-table nil syntax-multiline nil))
-            ;; Avoid recursion!
-            (let ((syntax-propertize--done most-positive-fixnum))
-              (funcall syntax-propertize-function start end))))))))
+          (with-syntax-table (or syntax-ppss-table (syntax-table))
+            (make-local-variable 'syntax-propertize--done) ;Just in case!
+            (let* ((start (max (min syntax-propertize--done (point-max))
+                               (point-min)))
+                   (end (max pos
+                             (min (point-max)
+                                  (+ start syntax-propertize-chunk-size))))
+                   (funs syntax-propertize-extend-region-functions))
+              (while funs
+                (let ((new (funcall (pop funs) start end))
+                      ;; Avoid recursion!
+                      (syntax-propertize--done most-positive-fixnum))
+                  (if (or (null new)
+                          (and (>= (car new) start) (<= (cdr new) end)))
+                      nil
+                    (setq start (car new))
+                    (setq end (cdr new))
+                    ;; If there's been a change, we should go through the
+                    ;; list again since this new position may
+                    ;; warrant a different answer from one of the funs we've
+                    ;; already seen.
+                    (unless (eq funs
+                                (cdr syntax-propertize-extend-region-functions))
+                      (setq funs syntax-propertize-extend-region-functions)))))
+              ;; Flush ppss cache between the original value of `start' and that
+              ;; set above by syntax-propertize-extend-region-functions.
+              (syntax-ppss-flush-cache start)
+              ;; Move the limit before calling the function, so the function
+              ;; can use syntax-ppss.
+              (setq syntax-propertize--done end)
+              ;; (message "syntax-propertizing from %s to %s" start end)
+              (remove-text-properties start end
+                                      '(syntax-table nil syntax-multiline nil))
+              ;; Avoid recursion!
+              (let ((syntax-propertize--done most-positive-fixnum))
+                (funcall syntax-propertize-function start end)))))))))
 
 ;;; Link syntax-propertize with syntax.c.
 
 (defvar syntax-propertize-chunks
   ;; We're not sure how far we'll go.  In my tests, using chunks of 2000
-  ;; brings to overhead to something negligible.  Passing ‘charpos’ directly
+  ;; brings the overhead to something negligible.  Passing ‘charpos’ directly
   ;; also works (basically works line-by-line) but results in an overhead which
   ;; I thought was a bit too high (like around 50%).
   2000)
@@ -404,7 +408,8 @@ These are valid when the buffer has no restriction.")
 (defvar-local syntax-ppss-narrow-start nil
   "Start position of the narrowing for `syntax-ppss-narrow'.")
 
-(defalias 'syntax-ppss-after-change-function 'syntax-ppss-flush-cache)
+(define-obsolete-function-alias 'syntax-ppss-after-change-function
+  #'syntax-ppss-flush-cache "27.1")
 (defun syntax-ppss-flush-cache (beg &rest ignored)
   "Flush the cache of `syntax-ppss' starting at position BEG."
   ;; Set syntax-propertize to refontify anything past beg.
@@ -429,7 +434,7 @@ These are valid when the buffer has no restriction.")
        ;; Unregister if there's no cache left.  Sadly this doesn't work
        ;; because `before-change-functions' is temporarily bound to nil here.
        ;; (unless cache
-       ;;   (remove-hook 'before-change-functions 'syntax-ppss-flush-cache t))
+       ;;   (remove-hook 'before-change-functions #'syntax-ppss-flush-cache t))
        (setcar cell last)
        (setcdr cell cache)))
     ))
@@ -449,9 +454,6 @@ These are valid when the buffer has no restriction.")
     (cl-incf (car pair))
     (cl-incf (cdr pair) (- new old))))
 
-(defvar-local syntax-ppss-table nil
-  "Syntax-table to use during `syntax-ppss', if any.")
-
 (defun syntax-ppss--data ()
   (if (eq (point-min) 1)
       (progn
@@ -533,13 +535,14 @@ running the hook."
 
 	      ;; Setup the before-change function if necessary.
 	      (unless (or ppss-cache ppss-last)
-                ;; We should be either the very last function on
-                ;; before-change-functions or the very first on
-                ;; after-change-functions.
                 ;; Note: combine-change-calls-1 needs to be kept in sync
                 ;; with this!
 		(add-hook 'before-change-functions
-			  'syntax-ppss-flush-cache t t))
+			  #'syntax-ppss-flush-cache
+                          ;; We should be either the very last function on
+                          ;; before-change-functions or the very first on
+                          ;; after-change-functions.
+                          99 t))
 
 	      ;; Use the best of OLD-POS and CACHE.
 	      (if (or (not old-pos) (< old-pos pt-min))
diff --git a/lisp/emacs-lisp/tcover-ses.el b/lisp/emacs-lisp/tcover-ses.el
index 29b481849e..d34d30ff0f 100644
--- a/lisp/emacs-lisp/tcover-ses.el
+++ b/lisp/emacs-lisp/tcover-ses.el
@@ -2,8 +2,7 @@
 
 ;; Copyright (C) 2002-2019 Free Software Foundation, Inc.
 
-;; Author: Jonathan Yavner <jyavner@engineer.com>
-;; Maintainer: Jonathan Yavner <jyavner@engineer.com>
+;; Author: Jonathan Yavner <jyavner@member.fsf.org>
 ;; Keywords: spreadsheet lisp utility
 ;; Package: testcover
 
diff --git a/lisp/emacs-lisp/tcover-unsafep.el b/lisp/emacs-lisp/tcover-unsafep.el
index 571f53c795..fc6b6cb74d 100644
--- a/lisp/emacs-lisp/tcover-unsafep.el
+++ b/lisp/emacs-lisp/tcover-unsafep.el
@@ -2,8 +2,7 @@
 
 ;; Copyright (C) 2002-2019 Free Software Foundation, Inc.
 
-;; Author: Jonathan Yavner <jyavner@engineer.com>
-;; Maintainer: Jonathan Yavner <jyavner@engineer.com>
+;; Author: Jonathan Yavner <jyavner@member.fsf.org>
 ;; Keywords: safety lisp utility
 ;; Package: testcover
 
diff --git a/lisp/emacs-lisp/testcover.el b/lisp/emacs-lisp/testcover.el
index 1ea12859c2..1b94aa80e5 100644
--- a/lisp/emacs-lisp/testcover.el
+++ b/lisp/emacs-lisp/testcover.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2002-2019 Free Software Foundation, Inc.
 
 ;; Author: Jonathan Yavner <jyavner@member.fsf.org>
-;; Maintainer: Jonathan Yavner <jyavner@member.fsf.org>
 ;; Keywords: lisp utility
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/emacs-lisp/thunk.el b/lisp/emacs-lisp/thunk.el
index e1370c4591..8d28570dc2 100644
--- a/lisp/emacs-lisp/thunk.el
+++ b/lisp/emacs-lisp/thunk.el
@@ -54,16 +54,15 @@
   "Delay the evaluation of BODY."
   (declare (debug t))
   (cl-assert lexical-binding)
-  (let ((forced (make-symbol "forced"))
-        (val (make-symbol "val")))
-    `(let (,forced ,val)
-       (lambda (&optional check)
-         (if check
-             ,forced
-           (unless ,forced
-             (setf ,val (progn ,@body))
-             (setf ,forced t))
-           ,val)))))
+  `(let (forced
+         (val (lambda () ,@body)))
+     (lambda (&optional check)
+       (if check
+           forced
+         (unless forced
+           (setf val (funcall val))
+           (setf forced t))
+         val))))
 
 (defun thunk-force (delayed)
   "Force the evaluation of DELAYED.
diff --git a/lisp/emacs-lisp/timer-list.el b/lisp/emacs-lisp/timer-list.el
index 81e2f91c0e..55aa56b72e 100644
--- a/lisp/emacs-lisp/timer-list.el
+++ b/lisp/emacs-lisp/timer-list.el
@@ -1,4 +1,4 @@
-;;; timer-list.el --- list active timers in a buffer
+;;; timer-list.el --- list active timers in a buffer  -*- lexical-binding:t -*-
 
 ;; Copyright (C) 2016-2019 Free Software Foundation, Inc.
 
@@ -24,6 +24,9 @@
 
 ;;; Code:
 
+(defvar cl-print-compiled)
+(defvar cl-print-compiled-button)
+
 ;;;###autoload
 (defun list-timers (&optional _ignore-auto _nonconfirm)
   "List all timers in a buffer."
@@ -85,8 +88,9 @@
   (setq-local revert-buffer-function #'list-timers)
   (setq buffer-read-only t)
   (setq header-line-format
-        (format "%4s %10s %8s %s"
-                "Idle" "Next" "Repeat" "Function")))
+        (concat (propertize " " 'display '(space :align-to 0))
+                (format "%4s %10s %8s %s"
+                "Idle" "Next" "Repeat" "Function"))))
 
 (defun timer-list-cancel ()
   "Cancel the timer on the line under point."
diff --git a/lisp/emacs-lisp/timer.el b/lisp/emacs-lisp/timer.el
index f706d9bc62..22ccc35103 100644
--- a/lisp/emacs-lisp/timer.el
+++ b/lisp/emacs-lisp/timer.el
@@ -281,7 +281,7 @@ This function is called, by name, directly by the C code."
               ;; perhaps because Emacs was suspended for a long time,
               ;; limit how many times things get repeated.
               (if (and (numberp timer-max-repeats)
-		       (time-less-p nil (timer--time timer)))
+		       (time-less-p (timer--time timer) nil))
                   (let ((repeats (/ (timer-until timer nil)
                                     (timer--repeat-delay timer))))
                     (if (> repeats timer-max-repeats)
diff --git a/lisp/emacs-lisp/unsafep.el b/lisp/emacs-lisp/unsafep.el
index d20b751d88..e374cbec55 100644
--- a/lisp/emacs-lisp/unsafep.el
+++ b/lisp/emacs-lisp/unsafep.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2002-2019 Free Software Foundation, Inc.
 
 ;; Author: Jonathan Yavner <jyavner@member.fsf.org>
-;; Maintainer: Jonathan Yavner <jyavner@member.fsf.org>
 ;; Keywords: safety lisp utility
 
 ;; This file is part of GNU Emacs.
@@ -92,11 +91,6 @@
 in the parse.")
 (put 'unsafep-vars 'risky-local-variable t)
 
-;;Side-effect-free functions from subr.el
-(dolist (x '(assoc-default butlast last match-string
-	     match-string-no-properties member-ignore-case remove remq))
-  (put x 'side-effect-free t))
-
 ;;Other safe functions
 (dolist (x '(;;Special forms
 	     and catch if or prog1 prog2 progn while unwind-protect
diff --git a/lisp/emulation/cua-base.el b/lisp/emulation/cua-base.el
index 105e1ab43d..46258cbbd8 100644
--- a/lisp/emulation/cua-base.el
+++ b/lisp/emulation/cua-base.el
@@ -602,6 +602,7 @@ a cons (TYPE . COLOR), then both properties are affected."
 
 (autoload 'cua-set-rectangle-mark "cua-rect"
   "Start rectangle at mouse click position." t nil)
+(autoload 'cua-toggle-rectangle-mark "cua-rect" nil t)
 
 ;; Stub definitions until it is loaded
 (defvar cua--rectangle)
diff --git a/lisp/emulation/edt-lk201.el b/lisp/emulation/edt-lk201.el
index 797de504fd..9ccb40dfe5 100644
--- a/lisp/emulation/edt-lk201.el
+++ b/lisp/emulation/edt-lk201.el
@@ -4,7 +4,6 @@
 ;; Foundation, Inc.
 
 ;; Author: Kevin Gallagher <kevin.gal@verizon.net>
-;; Maintainer: Kevin Gallagher <kevin.gal@verizon.net>
 ;; Keywords: emulations
 ;; Package: edt
 
diff --git a/lisp/emulation/edt-mapper.el b/lisp/emulation/edt-mapper.el
index b8e28f5a75..4aad72caf3 100644
--- a/lisp/emulation/edt-mapper.el
+++ b/lisp/emulation/edt-mapper.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1994-1995, 2000-2019 Free Software Foundation, Inc.
 
 ;; Author: Kevin Gallagher <kevin.gal@verizon.net>
-;; Maintainer: Kevin Gallagher <kevin.gal@verizon.net>
 ;; Keywords: emulations
 ;; Package: edt
 
diff --git a/lisp/emulation/edt-pc.el b/lisp/emulation/edt-pc.el
index 3fe33ca13d..484f84eb15 100644
--- a/lisp/emulation/edt-pc.el
+++ b/lisp/emulation/edt-pc.el
@@ -4,7 +4,6 @@
 ;; Inc.
 
 ;; Author: Kevin Gallagher <kevin.gal@verizon.net>
-;; Maintainer: Kevin Gallagher <kevin.gal@verizon.net>
 ;; Keywords: emulations
 ;; Package: edt
 
diff --git a/lisp/emulation/edt-vt100.el b/lisp/emulation/edt-vt100.el
index f3d2518a49..40c74c9d74 100644
--- a/lisp/emulation/edt-vt100.el
+++ b/lisp/emulation/edt-vt100.el
@@ -4,7 +4,6 @@
 ;; Foundation, Inc.
 
 ;; Author: Kevin Gallagher <kevin.gal@verizon.net>
-;; Maintainer: Kevin Gallagher <kevin.gal@verizon.net>
 ;; Keywords: emulations
 ;; Package: edt
 
diff --git a/lisp/emulation/edt.el b/lisp/emulation/edt.el
index d1fe0b8107..dcc327dbd4 100644
--- a/lisp/emulation/edt.el
+++ b/lisp/emulation/edt.el
@@ -4,7 +4,6 @@
 ;; Inc.
 
 ;; Author: Kevin Gallagher <kevin.gal@verizon.net>
-;; Maintainer: Kevin Gallagher <kevin.gal@verizon.net>
 ;; Keywords: emulations
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/epa-file.el b/lisp/epa-file.el
index 35cd1ecfde..d9886d3d67 100644
--- a/lisp/epa-file.el
+++ b/lisp/epa-file.el
@@ -105,9 +105,7 @@ encryption is used."
   (if (fboundp 'decode-coding-inserted-region)
       (save-restriction
 	(narrow-to-region (point) (point))
-	(insert (if enable-multibyte-characters
-		    (string-to-multibyte string)
-		  string))
+	(insert string)
 	(decode-coding-inserted-region
 	 (point-min) (point-max)
 	 (substring file 0 (string-match epa-file-name-regexp file))
diff --git a/lisp/epa.el b/lisp/epa.el
index c8abff4753..59c11ab541 100644
--- a/lisp/epa.el
+++ b/lisp/epa.el
@@ -1282,29 +1282,6 @@ If no one is selected, default public key is exported.  ")))
        (epa-display-error context)
        (signal (car error) (cdr error))))))
 
-;; (defun epa-sign-keys (keys &optional local)
-;;   "Sign selected KEYS.
-;; If a prefix-arg is specified, the signature is marked as non exportable.
-
-;; Don't use this command in Lisp programs!"
-;;   (declare (interactive-only t))
-;;   (interactive
-;;    (let ((keys (epa--marked-keys)))
-;;      (unless keys
-;;        (error "No keys selected"))
-;;      (list keys current-prefix-arg)))
-;;   (let ((context (epg-make-context epa-protocol)))
-;;     (epg-context-set-passphrase-callback context
-;; 	                                    #'epa-passphrase-callback-function)
-;;     (epg-context-set-progress-callback context
-;; 	                                  (cons
-;; 	                                    #'epa-progress-callback-function
-;; 	                                    "Signing keys..."))
-;;     (message "Signing keys...")
-;;     (epg-sign-keys context keys local)
-;;     (message "Signing keys...done")))
-;; (make-obsolete 'epa-sign-keys "Do not use.")
-
 (provide 'epa)
 
 ;;; epa.el ends here
diff --git a/lisp/epg-config.el b/lisp/epg-config.el
index 4502f90874..bb323e54fa 100644
--- a/lisp/epg-config.el
+++ b/lisp/epg-config.el
@@ -31,8 +31,8 @@
 (defconst epg-version-number "1.0.0"
   "Version number of this package.")
 
-(defconst epg-bug-report-address "ueno@unixuser.org"
-  "Report bugs to this address.")
+(define-obsolete-variable-alias 'epg-bug-report-address
+  'report-emacs-bug-address "27.1")
 
 (defgroup epg ()
   "Interface to the GNU Privacy Guard (GnuPG)."
diff --git a/lisp/epg.el b/lisp/epg.el
index e06cc06a7d..0400716845 100644
--- a/lisp/epg.el
+++ b/lisp/epg.el
@@ -1936,40 +1936,6 @@ If you are unsure, use synchronous version of this function
 			    (epg-errors-to-string errors))))))
     (epg-reset context)))
 
-(defun epg-start-sign-keys (context keys &optional local)
-  "Initiate a sign keys operation.
-
-If you use this function, you will need to wait for the completion of
-`epg-gpg-program' by using `epg-wait-for-completion' and call
-`epg-reset' to clear a temporary output file.
-If you are unsure, use synchronous version of this function
-`epg-sign-keys' instead."
-  (declare (obsolete nil "23.1"))
-  (setf (epg-context-operation context) 'sign-keys)
-  (setf (epg-context-result context) nil)
-  (epg--start context (cons (if local
-			       "--lsign-key"
-			     "--sign-key")
-			   (mapcar
-			    (lambda (key)
-			      (epg-sub-key-id
-			       (car (epg-key-sub-key-list key))))
-			    keys))))
-
-(defun epg-sign-keys (context keys &optional local)
-  "Sign KEYS from the key ring."
-  (declare (obsolete nil "23.1"))
-  (unwind-protect
-      (progn
-	(epg-start-sign-keys context keys local)
-	(epg-wait-for-completion context)
-	(let ((errors (epg-context-result-for context 'error)))
-	  (if errors
-	      (signal 'epg-error
-		      (list "Sign keys failed"
-			    (epg-errors-to-string errors))))))
-    (epg-reset context)))
-
 (defun epg-start-generate-key (context parameters)
   "Initiate a key generation.
 PARAMETERS is a string which specifies parameters of the generated key.
diff --git a/lisp/erc/erc-speedbar.el b/lisp/erc/erc-speedbar.el
index 0a1e38fe24..8d56c85bec 100644
--- a/lisp/erc/erc-speedbar.el
+++ b/lisp/erc/erc-speedbar.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 2001-2004, 2006-2019 Free Software Foundation, Inc.
 
 ;; Author: Mario Lang <mlang@delysid.org>
-;; Contributor: Eric M. Ludlam <eric@siege-engine.com>
+;; Contributor: Eric M. Ludlam <zappo@gnu.org>
 ;; Maintainer: emacs-devel@gnu.org
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/eshell/em-hist.el b/lisp/eshell/em-hist.el
index 614faaa131..adb028002b 100644
--- a/lisp/eshell/em-hist.el
+++ b/lisp/eshell/em-hist.el
@@ -153,7 +153,7 @@ element, regardless of any text on the command line.  In that case,
   :group 'eshell-hist)
 
 (defcustom eshell-hist-word-designator
-  "^:?\\([0-9]+\\|[$^%*]\\)?\\(\\*\\|-[0-9]*\\|[$^%*]\\)?"
+  "^:?\\([0-9]+\\|[$^%*]\\)?\\(-[0-9]*\\|[$^%*]\\)?"
   "The regexp used to identify history word designators."
   :type 'regexp
   :group 'eshell-hist)
diff --git a/lisp/eshell/esh-mode.el b/lisp/eshell/esh-mode.el
index cff29bed1b..a36ac969e5 100644
--- a/lisp/eshell/esh-mode.el
+++ b/lisp/eshell/esh-mode.el
@@ -1014,11 +1014,13 @@ This function could be in the list `eshell-output-filter-functions'."
 		   'eshell-handle-control-codes)
 
 (autoload 'ansi-color-apply-on-region "ansi-color")
+(defvar ansi-color-apply-face-function)
 
 (defun eshell-handle-ansi-color ()
   "Handle ANSI color codes."
-  (ansi-color-apply-on-region eshell-last-output-start
-                              eshell-last-output-end))
+  (let ((ansi-color-apply-face-function #'ansi-color-apply-text-property-face))
+    (ansi-color-apply-on-region eshell-last-output-start
+                                eshell-last-output-end)))
 
 (custom-add-option 'eshell-output-filter-functions
 		   'eshell-handle-ansi-color)
diff --git a/lisp/eshell/esh-proc.el b/lisp/eshell/esh-proc.el
index d538ae32b3..32a3eecb52 100644
--- a/lisp/eshell/esh-proc.el
+++ b/lisp/eshell/esh-proc.el
@@ -251,7 +251,11 @@ The prompt will be set to PROMPT."
   "A marker that tracks the beginning of output of the last subprocess.
 Used only on systems which do not support async subprocesses.")
 
-(defvar eshell-needs-pipe '("bc")
+(defvar eshell-needs-pipe
+  '("bc"
+    ;; xclip.el (in GNU ELPA) calls all of these with
+    ;; `process-connection-type' set to nil.
+    "pbpaste" "putclip" "xclip" "xsel" "wl-copy")
   "List of commands which need `process-connection-type' to be nil.
 Currently only affects commands in pipelines, and not those at
 the front.  If an element contains a directory part it must match
diff --git a/lisp/expand.el b/lisp/expand.el
index 0c4d343090..da76effc26 100644
--- a/lisp/expand.el
+++ b/lisp/expand.el
@@ -66,9 +66,6 @@
 ;;                  Jerome Santini <santini@chambord.univ-orleans.fr>,
 ;;                  Jari Aalto <jaalto@tre.tele.nokia.fi>.
 ;;
-;;   Please send me a word to give me your feeling about this feature or
-;; to explain me how you use it (your expansions table for example) using
-;; the function expand-submit-report.
 ;;; Code:
 
 ;;; Constants:
diff --git a/lisp/faces.el b/lisp/faces.el
index fa526c3506..89b598669c 100644
--- a/lisp/faces.el
+++ b/lisp/faces.el
@@ -2500,6 +2500,18 @@ unwanted effects."
   :group 'basic-faces
   :group 'display-line-numbers)
 
+;; Definition stolen from display-line-numbers.
+(defface fill-column-indicator
+  '((t :inherit shadow :weight normal :slant normal
+       :underline nil :overline nil :strike-through nil
+       :box nil :inverse-video nil :stipple nil))
+  "Face for displaying fill column indicator.
+This face is used when `display-fill-column-indicator-mode' is
+non-nil."
+  :version "27.1"
+  :group 'basic-faces
+  :group 'display-fill-column-indicator)
+
 (defface escape-glyph
   '((((background dark)) :foreground "cyan")
     ;; See the comment in minibuffer-prompt for
diff --git a/lisp/ffap.el b/lisp/ffap.el
index 36e37e95fe..08f7208945 100644
--- a/lisp/ffap.el
+++ b/lisp/ffap.el
@@ -513,7 +513,9 @@ When using jka-compr (a.k.a. `auto-compression-mode'), the returned
 name may have a suffix added from `ffap-compression-suffixes'.
 The optional NOMODIFY argument suppresses the extra search."
   (cond
-   ((not file) nil)			; quietly reject nil
+   ((or (not file)			; quietly reject nil
+	(zerop (length file)))		; and also ""
+    nil)
    ((file-exists-p file) file)		; try unmodified first
    ;; three reasons to suppress search:
    (nomodify nil)
@@ -1326,6 +1328,7 @@ which may actually result in an URL rather than a filename."
 	 ;; If it contains a colon, get rid of it (and return if exists)
 	 ((and (string-match path-separator name)
 	       (setq name (ffap-string-at-point 'nocolon))
+	       (> (length name) 0)
 	       (ffap-file-exists-string name)))
 	 ;; File does not exist, try the alist:
 	 ((let ((alist ffap-alist) tem try case-fold-search)
@@ -2042,19 +2045,19 @@ This hook is intended to be put in `file-name-at-point-functions'."
    '((global-set-key [S-mouse-3] 'ffap-at-mouse)
      (global-set-key [C-S-mouse-3] 'ffap-menu)
 
-     (global-set-key "\C-x\C-f" 'find-file-at-point)
-     (global-set-key "\C-x\C-r" 'ffap-read-only)
-     (global-set-key "\C-x\C-v" 'ffap-alternate-file)
+     (global-set-key [remap find-file] 'find-file-at-point)
+     (global-set-key [remap find-file-read-only] 'ffap-read-only)
+     (global-set-key [remap find-alternate-file] 'ffap-alternate-file)
 
-     (global-set-key "\C-x4f"   'ffap-other-window)
-     (global-set-key "\C-x5f"   'ffap-other-frame)
-     (global-set-key "\C-x4r"   'ffap-read-only-other-window)
-     (global-set-key "\C-x5r"   'ffap-read-only-other-frame)
+     (global-set-key [remap find-file-other-window] 'ffap-other-window)
+     (global-set-key [remap find-file-other-frame] 'ffap-other-frame)
+     (global-set-key [remap find-file-read-only-other-window] 'ffap-read-only-other-window)
+     (global-set-key [remap find-file-read-only-other-frame] 'ffap-read-only-other-frame)
 
-     (global-set-key "\C-xd"    'dired-at-point)
-     (global-set-key "\C-x4d"   'ffap-dired-other-window)
-     (global-set-key "\C-x5d"   'ffap-dired-other-frame)
-     (global-set-key "\C-x\C-d" 'ffap-list-directory)
+     (global-set-key [remap dired] 'dired-at-point)
+     (global-set-key [remap dired-other-window] 'ffap-dired-other-window)
+     (global-set-key [remap dired-other-frame] 'ffap-dired-other-frame)
+     (global-set-key [remap list-directory] 'ffap-list-directory)
 
      (add-hook 'gnus-summary-mode-hook 'ffap-gnus-hook)
      (add-hook 'gnus-article-mode-hook 'ffap-gnus-hook)
diff --git a/lisp/filecache.el b/lisp/filecache.el
index fb099c1802..63268bf2eb 100644
--- a/lisp/filecache.el
+++ b/lisp/filecache.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1996, 2000-2019 Free Software Foundation, Inc.
 
-;; Author:  Peter Breton <pbreton@cs.umb.edu>
+;; Author: Peter Breton <pbreton@cs.umb.edu>
 ;; Created: Sun Nov 10 1996
 ;; Keywords: convenience
 
diff --git a/lisp/filenotify.el b/lisp/filenotify.el
index 3f9bb960a9..d77046d287 100644
--- a/lisp/filenotify.el
+++ b/lisp/filenotify.el
@@ -30,6 +30,9 @@
 (require 'cl-lib)
 (eval-when-compile (require 'subr-x))
 
+(defvar file-notify-debug nil
+  "Use for debug messages.")
+
 (defconst file-notify--library
   (cond
    ((featurep 'inotify) 'inotify)
@@ -49,7 +52,7 @@ could use another implementation.")
   directory
   ;; Watched relative filename, nil if watching the directory.
   filename
-  ;; Function to propagate events to.
+  ;; Function to propagate events to, or nil if watch is being removed.
   callback)
 
 (defun file-notify--watch-absolute-filename (watch)
@@ -72,12 +75,15 @@ struct.")
 DESCRIPTOR should be an object returned by `file-notify-add-watch'.
 If it is registered in `file-notify-descriptors', a stopped event is sent."
   (when-let* ((watch (gethash descriptor file-notify-descriptors)))
-    ;; Send `stopped' event.
-    (unwind-protect
-        (funcall
-         (file-notify--watch-callback watch)
-         `(,descriptor stopped ,(file-notify--watch-absolute-filename watch)))
-      (remhash descriptor file-notify-descriptors))))
+    (let ((callback (file-notify--watch-callback watch)))
+      ;; Make sure this is the last time the callback is invoked.
+      (setf (file-notify--watch-callback watch) nil)
+      ;; Send `stopped' event.
+      (unwind-protect
+          (funcall
+           callback
+           `(,descriptor stopped ,(file-notify--watch-absolute-filename watch)))
+        (remhash descriptor file-notify-descriptors)))))
 
 ;; This function is used by `inotify', `kqueue', `gfilenotify' and
 ;; `w32notify' events.
@@ -90,7 +96,8 @@ If EVENT is a filewatch event, call its callback.  It has the format
 
 Otherwise, signal a `file-notify-error'."
   (interactive "e")
-  ;;(message "file-notify-handle-event %S" event)
+  (when file-notify-debug
+    (message "file-notify-handle-event %S" event))
   (if (and (consp event)
            (eq (car event) 'file-notify)
 	   (>= (length event) 3))
@@ -154,12 +161,14 @@ EVENT is the cadr of the event in `file-notify-handle-event'
       (while actions
         (let ((action (pop actions)))
           ;; Send pending event, if it doesn't match.
+          ;; We only handle {renamed,moved}-{from,to} pairs when these
+          ;; arrive in order without anything else in-between.
           (when (and file-notify--pending-event
-                     ;; The cookie doesn't match.
-                     (not (equal (file-notify--event-cookie
-                                  (car file-notify--pending-event))
-                                 (file-notify--event-cookie event)))
                      (or
+                      ;; The cookie doesn't match.
+                      (not (equal (file-notify--event-cookie
+                                   (car file-notify--pending-event))
+                                  (file-notify--event-cookie event)))
                       ;; inotify.
                       (and (eq (nth 1 (car file-notify--pending-event))
                                'moved-from)
@@ -229,21 +238,28 @@ EVENT is the cadr of the event in `file-notify-handle-event'
                       (string-equal
                        (file-notify--watch-filename watch)
                        (file-name-nondirectory file))
+
                       ;; Directory matches.
-                      (string-equal
-                       (file-name-nondirectory file)
-                       (file-name-nondirectory
-                        (file-notify--watch-directory watch)))
+                      ;;  FIXME: What purpose would this condition serve?
+                      ;;  Doesn't it just slip through events for files
+                      ;;  having the same name as the last component of the
+                      ;;  directory of the file that we are really watching?
+                      ;;(string-equal
+                      ;; (file-name-nondirectory file)
+                      ;; (file-name-nondirectory
+                      ;;  (file-notify--watch-directory watch)))
+
                       ;; File1 matches.
                       (and (stringp file1)
                            (string-equal
                             (file-notify--watch-filename watch)
                             (file-name-nondirectory file1)))))
-            ;;(message
-            ;;"file-notify-callback %S %S %S %S %S %S %S"
-            ;;desc action file file1 watch
-            ;;(file-notify--event-watched-file event)
-            ;;(file-notify--watch-directory watch))
+            (when file-notify-debug
+              (message
+               "file-notify-callback %S %S %S %S %S %S %S"
+               desc action file file1 watch
+               (file-notify--event-watched-file event)
+               (file-notify--watch-directory watch)))
             (funcall (file-notify--watch-callback watch)
                      (if file1
                          `(,desc ,action ,file ,file1)
@@ -259,9 +275,49 @@ EVENT is the cadr of the event in `file-notify-handle-event'
                           file (file-notify--event-watched-file event))))
             (file-notify-rm-watch desc)))))))
 
-;; `kqueue', `gfilenotify' and `w32notify' return a unique descriptor
-;; for every `file-notify-add-watch', while `inotify' returns a unique
-;; descriptor per inode only.
+(declare-function inotify-add-watch "inotify.c" (file flags callback))
+(declare-function kqueue-add-watch "kqueue.c" (file flags callback))
+(declare-function w32notify-add-watch "w32notify.c" (file flags callback))
+(declare-function gfile-add-watch "gfilenotify.c" (file flags callback))
+
+(defun file-notify--add-watch-inotify (_file dir flags)
+  "Add a watch for FILE in DIR with FLAGS, using inotify."
+  (inotify-add-watch dir
+                     (append
+                      (and (memq 'change flags)
+                           '(create delete delete-self modify move-self move))
+                      (and (memq 'attribute-change flags)
+                           '(attrib)))
+                     #'file-notify-callback))
+
+(defun file-notify--add-watch-kqueue (file _dir flags)
+  "Add a watch for FILE in DIR with FLAGS, using kqueue."
+  ;; kqueue does not report changes to file contents when watching
+  ;; directories, so we watch each file directly.
+  (kqueue-add-watch file
+                    (append
+                     (and (memq 'change flags)
+	                  '(create delete write extend rename))
+                     (and (memq 'attribute-change flags)
+                          '(attrib)))
+                    #'file-notify-callback))
+
+(defun file-notify--add-watch-w32notify (_file dir flags)
+  "Add a watch for FILE in DIR with FLAGS, using w32notify."
+  (w32notify-add-watch dir
+                       (append
+                        (and (memq 'change flags)
+                             '(file-name directory-name size last-write-time))
+                        (and (memq 'attribute-change flags)
+                             '(attributes)))
+                       #'file-notify-callback))
+
+(defun file-notify--add-watch-gfilenotify (_file dir flags)
+  "Add a watch for FILE in DIR with FLAGS, using gfilenotify."
+  (gfile-add-watch dir
+                   (append '(watch-mounts send-moved) flags)
+                   #'file-notify-callback))
+
 (defun file-notify-add-watch (file flags callback)
   "Add a watch for filesystem events pertaining to FILE.
 This arranges for filesystem events pertaining to FILE to be reported
@@ -312,94 +368,60 @@ FILE is the name of the file whose event is being reported."
 	(dir (directory-file-name
 	      (if (file-directory-p file)
 		  file
-		(file-name-directory file))))
-        desc func l-flags)
+		(file-name-directory file)))))
 
     (unless (file-directory-p dir)
       (signal 'file-notify-error `("Directory does not exist" ,dir)))
 
-    (if handler
-	;; A file name handler could exist even if there is no local
-	;; file notification support.
-	(setq desc (funcall handler 'file-notify-add-watch dir flags callback))
-
-      ;; Check, whether Emacs has been compiled with file notification
-      ;; support.
-      (unless file-notify--library
-	(signal 'file-notify-error
-		'("No file notification package available")))
-
-      ;; Determine low-level function to be called.
-      (setq func
-	    (cond
-	     ((eq file-notify--library 'inotify) 'inotify-add-watch)
-	     ((eq file-notify--library 'kqueue) 'kqueue-add-watch)
-	     ((eq file-notify--library 'gfilenotify) 'gfile-add-watch)
-	     ((eq file-notify--library 'w32notify) 'w32notify-add-watch)))
-
-      ;; Determine respective flags.
-      (if (eq file-notify--library 'gfilenotify)
-	  (setq l-flags (append '(watch-mounts send-moved) flags))
-	(when (memq 'change flags)
-	  (setq
-	   l-flags
-	   (cond
-	    ((eq file-notify--library 'inotify)
-	     '(create delete delete-self modify move-self move))
-	    ((eq file-notify--library 'kqueue)
-	     '(create delete write extend rename))
-	    ((eq file-notify--library 'w32notify)
-	     '(file-name directory-name size last-write-time)))))
-	(when (memq 'attribute-change flags)
-	  (push (cond
-                 ((eq file-notify--library 'inotify) 'attrib)
-                 ((eq file-notify--library 'kqueue) 'attrib)
-                 ((eq file-notify--library 'w32notify) 'attributes))
-                l-flags)))
-
-      ;; Call low-level function.
-      (setq desc (funcall
-                  ;; kqueue does not report file changes in directory
-                  ;; monitor.  So we must watch the file itself.
-                  func (if (eq file-notify--library 'kqueue) file dir)
-                  l-flags 'file-notify-callback)))
-
-    ;; We do not want to enter quoted file names into the hash.
-    (setq file (file-name-unquote file)
-          dir  (file-name-unquote dir))
-
-    ;; Modify `file-notify-descriptors'.
-    (let ((watch (file-notify--watch-make
-                  dir
-                  (unless (file-directory-p file) (file-name-nondirectory file))
-                  callback)))
-      (puthash desc watch file-notify-descriptors))
-    ;; Return descriptor.
-    desc))
+    (let ((desc
+           (if handler
+               (funcall handler 'file-notify-add-watch dir flags callback)
+             (funcall
+              (pcase file-notify--library
+                ('inotify     #'file-notify--add-watch-inotify)
+                ('kqueue      #'file-notify--add-watch-kqueue)
+                ('w32notify   #'file-notify--add-watch-w32notify)
+                ('gfilenotify #'file-notify--add-watch-gfilenotify)
+                (_ (signal 'file-notify-error
+		           '("No file notification package available"))))
+              file dir flags))))
+
+      ;; Modify `file-notify-descriptors'.
+      (let ((watch (file-notify--watch-make
+                    ;; We do not want to enter quoted file names into the hash.
+                    (file-name-unquote dir)
+                    (unless (file-directory-p file)
+                      (file-name-nondirectory file))
+                    callback)))
+        (puthash desc watch file-notify-descriptors))
+      ;; Return descriptor.
+      desc)))
 
 (defun file-notify-rm-watch (descriptor)
   "Remove an existing watch specified by its DESCRIPTOR.
 DESCRIPTOR should be an object returned by `file-notify-add-watch'."
   (when-let* ((watch (gethash descriptor file-notify-descriptors)))
-    (let ((handler (find-file-name-handler
-                    (file-notify--watch-directory watch)
-                    'file-notify-rm-watch)))
-      (condition-case nil
-          (if handler
-              ;; A file name handler could exist even if there is no
-              ;; local file notification support.
-              (funcall handler 'file-notify-rm-watch descriptor)
-
-            (funcall
-             (cond
-              ((eq file-notify--library 'inotify) 'inotify-rm-watch)
-              ((eq file-notify--library 'kqueue) 'kqueue-rm-watch)
-              ((eq file-notify--library 'gfilenotify) 'gfile-rm-watch)
-              ((eq file-notify--library 'w32notify) 'w32notify-rm-watch))
-             descriptor))
-        (file-notify-error nil)))
-    ;; Modify `file-notify-descriptors'.
-    (file-notify--rm-descriptor descriptor)))
+    ;; If we are called from a `stopped' event, do nothing.
+    (when (file-notify--watch-callback watch)
+      (let ((handler (find-file-name-handler
+                      (file-notify--watch-directory watch)
+                      'file-notify-rm-watch)))
+        (condition-case nil
+            (if handler
+                ;; A file name handler could exist even if there is no
+                ;; local file notification support.
+                (funcall handler 'file-notify-rm-watch descriptor)
+
+              (funcall
+               (cond
+                ((eq file-notify--library 'inotify) 'inotify-rm-watch)
+                ((eq file-notify--library 'kqueue) 'kqueue-rm-watch)
+                ((eq file-notify--library 'gfilenotify) 'gfile-rm-watch)
+                ((eq file-notify--library 'w32notify) 'w32notify-rm-watch))
+               descriptor))
+          (file-notify-error nil)))
+      ;; Modify `file-notify-descriptors' and send a `stopped' event.
+      (file-notify--rm-descriptor descriptor))))
 
 (defun file-notify-valid-p (descriptor)
   "Check a watch specified by its DESCRIPTOR.
diff --git a/lisp/files.el b/lisp/files.el
index b81550e297..5bac49a74e 100644
--- a/lisp/files.el
+++ b/lisp/files.el
@@ -1058,7 +1058,8 @@ REMOTE is non-nil, search on the remote host indicated by
         (when (stringp res) (file-local-name res)))
     ;; Use 1 rather than file-executable-p to better match the
     ;; behavior of call-process.
-    (locate-file command exec-path exec-suffixes 1)))
+    (let ((default-directory (file-name-quote default-directory 'top)))
+      (locate-file command exec-path exec-suffixes 1))))
 
 (defun load-library (library)
   "Load the Emacs Lisp library named LIBRARY.
@@ -3297,6 +3298,7 @@ asking you for confirmation."
 	   (fill-column             . integerp)	;; C source code
 	   (indent-tabs-mode        . booleanp)	;; C source code
 	   (left-margin             . integerp)	;; C source code
+	   (inhibit-compacting-font-caches . booleanp) ;; C source code
 	   (no-update-autoloads     . booleanp)
 	   (lexical-binding	 . booleanp)	  ;; C source code
 	   (tab-width               . integerp)	  ;; C source code
@@ -3589,7 +3591,9 @@ local variables, but directory-local variables may still be applied."
 	result)
     (unless (eq handle-mode t)
       (setq file-local-variables-alist nil)
-      (when (file-remote-p default-directory)
+      (when (and (file-remote-p default-directory)
+                 (fboundp 'hack-connection-local-variables)
+                 (fboundp 'connection-local-criteria-for-default-directory))
         (with-demoted-errors "Connection-local variables error: %s"
 	  ;; Note this is a no-op if enable-local-variables is nil.
 	  (hack-connection-local-variables
@@ -4107,6 +4111,52 @@ This function returns either:
 (declare-function map-merge-with "map" (type function &rest maps))
 (declare-function map-merge "map" (type &rest maps))
 
+(defun dir-locals--get-sort-score (node)
+  "Return a number used for sorting the definitions of dir locals.
+NODE is assumed to be a cons cell where the car is either a
+string or a symbol representing a mode name.
+
+If it is a mode then the the depth of the mode (ie, how many
+parents that mode has) will be returned.
+
+If it is a string then the length of the string plus 1000 will be
+returned.
+
+Otherwise it returns -1.
+
+That way the value can be used to sort the list such that deeper
+modes will be after the other modes.  This will be followed by
+directory entries in order of length.  If the entries are all
+applied in order then that means the more specific modes will
+  override the values specified by the earlier modes and directory
+variables will override modes."
+  (let ((key (car node)))
+    (cond ((null key) -1)
+          ((symbolp key)
+           (let ((mode key)
+                 (depth 0))
+             (while (setq mode (get mode 'derived-mode-parent))
+               (setq depth (1+ depth)))
+             depth))
+          ((stringp key)
+           (+ 1000 (length key)))
+          (t -2))))
+
+(defun dir-locals--sort-variables (variables)
+  "Sorts VARIABLES so that applying them in order has the right effect.
+The variables are compared by dir-locals--get-sort-score.
+Directory entries are then recursively sorted using the same
+criteria."
+  (setq variables (sort variables
+                        (lambda (a b)
+                          (< (dir-locals--get-sort-score a)
+                             (dir-locals--get-sort-score b)))))
+  (dolist (n variables)
+    (when (stringp (car n))
+      (setcdr n (dir-locals--sort-variables (cdr n)))))
+
+  variables)
+
 (defun dir-locals-read-from-dir (dir)
   "Load all variables files in DIR and register a new class and instance.
 DIR is the absolute name of a directory which must contain at
@@ -4144,6 +4194,7 @@ Return the new class name, which is a symbol named DIR."
                                     variables
                                     newvars))))))
       (setq success latest))
+    (setq variables (dir-locals--sort-variables variables))
     (dir-locals-set-class-variables class-name variables)
     (dir-locals-set-directory-class dir class-name success)
     class-name))
@@ -4219,6 +4270,9 @@ However, the mode will not be changed if
   :type 'boolean
   :group 'editing-basics)
 
+(defvar after-set-visited-file-name-hook nil
+  "Normal hook run just after setting visited file name of current buffer.")
+
 (defun set-visited-file-name (filename &optional no-query along-with-file)
   "Change name of file visited in current buffer to FILENAME.
 This also renames the buffer to correspond to the new file.
@@ -4339,7 +4393,8 @@ the old visited file has been renamed to the new name FILENAME."
 	      (set-auto-mode t)
 	      (or (eq old major-mode)
 		  (hack-local-variables))))
-    (error nil))))
+      (error nil))
+    (run-hooks 'after-set-visited-file-name-hook)))
 
 (defun write-file (filename &optional confirm)
   "Write current buffer into file FILENAME.
@@ -5255,7 +5310,7 @@ Before and after saving the buffer, this function runs
 		     (set-file-extended-attributes buffer-file-name
 						   (nth 1 setmodes)))
 		 (set-file-modes buffer-file-name
-				 (logior (car setmodes) 128))))))
+				 (logior (car setmodes) 128)))))
 	(let (success)
 	  (unwind-protect
 	      (progn
@@ -5271,7 +5326,7 @@ Before and after saving the buffer, this function runs
 	    (and setmodes (not success)
 		 (progn
 		   (rename-file (nth 2 setmodes) buffer-file-name t)
-		   (setq buffer-backed-up nil))))))
+		   (setq buffer-backed-up nil)))))))
     setmodes))
 
 (declare-function diff-no-select "diff"
@@ -5840,6 +5895,16 @@ This should not be relied upon.
 For more information on how this variable is used by Auto Revert mode,
 see Info node `(emacs)Supporting additional buffers'.")
 
+(defvar-local buffer-auto-revert-by-notification nil
+  "Whether a buffer can rely on notification in Auto-Revert mode.
+If non-nil, monitoring changes to the directory of the current
+buffer is sufficient for knowing when that buffer needs to be
+updated in Auto Revert Mode.  Such notification does not include
+changes to files in that directory, only to the directory itself.
+
+This variable only applies to buffers where `buffer-file-name' is
+nil; other buffers are tracked by their files.")
+
 (defvar before-revert-hook nil
   "Normal hook for `revert-buffer' to run before reverting.
 The function `revert-buffer--default' runs this.
diff --git a/lisp/font-lock.el b/lisp/font-lock.el
index 1475911195..3991a4ee8e 100644
--- a/lisp/font-lock.el
+++ b/lisp/font-lock.el
@@ -1096,7 +1096,7 @@ accessible portion of the current buffer."
   (lambda (beg end)
     (unless font-lock-fontified
       (save-excursion
-        (font-lock-fontify-region (or beg (point-min)) (or end (point-max))))))
+        (font-lock-fontify-region beg end))))
   "Function to make sure a region has been fontified.
 Called with two arguments BEG and END.")
 
@@ -1387,12 +1387,19 @@ delimit the region to fontify."
 ;; below and given a `font-lock-' prefix.  Those that are not used are defined
 ;; in Lisp below and commented out.  sm.
 
-(defun font-lock-prepend-text-property (start end prop value &optional object)
-  "Prepend to one property of the text from START to END.
-Arguments PROP and VALUE specify the property and value to prepend to the value
-already in place.  The resulting property values are always lists.
-Optional argument OBJECT is the string or buffer containing the text."
-  (let ((val (if (listp value) value (list value))) next prev)
+(defun font-lock--add-text-property (start end prop value object append)
+  "Add an element to a property of the text from START to END.
+Arguments PROP and VALUE specify the property and value to add to
+the value already in place.  The resulting property values are
+always lists.  Argument OBJECT is the string or buffer containing
+the text.  If argument APPEND is non-nil, VALUE will be appended,
+otherwise it will be prepended."
+  (let ((val (if (and (listp value) (not (keywordp (car value))))
+                 ;; Already a list of faces.
+                 value
+               ;; A single face (e.g. a plist of face properties).
+               (list value)))
+        next prev)
     (while (/= start end)
       (setq next (next-single-property-change start prop object end)
 	    prev (get-text-property start prop object))
@@ -1402,30 +1409,26 @@ Optional argument OBJECT is the string or buffer containing the text."
 	   (or (keywordp (car prev))
 	       (memq (car prev) '(foreground-color background-color)))
 	   (setq prev (list prev)))
-      (put-text-property start next prop
-			 (append val (if (listp prev) prev (list prev)))
-			 object)
+      (let* ((list-prev (if (listp prev) prev (list prev)))
+             (new-value (if append
+                           (append list-prev val)
+                         (append val list-prev))))
+        (put-text-property start next prop new-value object))
       (setq start next))))
 
+(defun font-lock-prepend-text-property (start end prop value &optional object)
+  "Prepend to one property of the text from START to END.
+Arguments PROP and VALUE specify the property and value to prepend to the value
+already in place.  The resulting property values are always lists.
+Optional argument OBJECT is the string or buffer containing the text."
+  (font-lock--add-text-property start end prop value object nil))
+
 (defun font-lock-append-text-property (start end prop value &optional object)
   "Append to one property of the text from START to END.
 Arguments PROP and VALUE specify the property and value to append to the value
 already in place.  The resulting property values are always lists.
 Optional argument OBJECT is the string or buffer containing the text."
-  (let ((val (if (listp value) value (list value))) next prev)
-    (while (/= start end)
-      (setq next (next-single-property-change start prop object end)
-	    prev (get-text-property start prop object))
-      ;; Canonicalize old forms of face property.
-      (and (memq prop '(face font-lock-face))
-	   (listp prev)
-	   (or (keywordp (car prev))
-	       (memq (car prev) '(foreground-color background-color)))
-	   (setq prev (list prev)))
-      (put-text-property start next prop
-			 (append (if (listp prev) prev (list prev)) val)
-			 object)
-      (setq start next))))
+  (font-lock--add-text-property start end prop value object t))
 
 (defun font-lock-fillin-text-property (start end prop value &optional object)
   "Fill in one property of the text from START to END.
@@ -1496,7 +1499,7 @@ see `font-lock-syntactic-keywords'."
       ;; Flush the syntax-cache.  I believe this is not necessary for
       ;; font-lock's use of syntax-ppss, but I'm not 100% sure and it can
       ;; still be necessary for other users of syntax-ppss anyway.
-      (syntax-ppss-after-change-function start)
+      (syntax-ppss-flush-cache start)
       (cond
        ((not override)
 	;; Cannot override existing fontification.
diff --git a/lisp/frame.el b/lisp/frame.el
index b5c936a51e..a8c230cb7b 100644
--- a/lisp/frame.el
+++ b/lisp/frame.el
@@ -1610,14 +1610,16 @@ selected frame."
     (with-current-buffer (get-buffer-create "*frame-size-history*")
       (erase-buffer)
       (insert (format "Frame size history of %s\n" frame))
-      (while (listp (setq entry (pop history)))
+      (while (consp (setq entry (pop history)))
 	(when (eq (car entry) frame)
           (pop entry)
           (insert (format "%s" (pop entry)))
           (move-to-column 24 t)
           (while entry
             (insert (format " %s" (pop entry))))
-          (insert "\n"))))))
+          (insert "\n")))
+      (unless frame-size-history
+        (insert "Frame size history is nil.\n")))))
 
 (declare-function x-frame-edges "xfns.c" (&optional frame type))
 (declare-function w32-frame-edges "w32fns.c" (&optional frame type))
@@ -2680,6 +2682,9 @@ See also `toggle-frame-maximized'."
         display-line-numbers-width
         display-line-numbers-current-absolute
         display-line-numbers-widen
+        display-fill-column-indicator
+        display-fill-column-indicator-column
+        display-fill-column-indicator-character
         bidi-paragraph-direction
         bidi-display-reordering))
 
diff --git a/lisp/frameset.el b/lisp/frameset.el
index 3bc73751c0..73b2071a5a 100644
--- a/lisp/frameset.el
+++ b/lisp/frameset.el
@@ -970,8 +970,7 @@ is the parameter alist of the frame being restored.  Internal use only."
 	   ;; that frame has already been loaded (which can happen after
 	   ;; M-x desktop-read).
 	   (setq frame (frameset--find-frame-if
-			(lambda (f id)
-			  (frameset-frame-id-equal-p f id))
+			#'frameset-frame-id-equal-p
 			display (frameset-cfg-id parameters)))
 	   ;; If it has not been loaded, and it is not a minibuffer-only frame,
 	   ;; let's look for an existing non-minibuffer-only frame to reuse.
@@ -1350,15 +1349,17 @@ All keyword parameters default to nil."
 
 ;; Register support
 
-;;;###autoload
-(defun frameset--jump-to-register (data)
-  "Restore frameset from DATA stored in register.
-Called from `jump-to-register'.  Internal use only."
+(cl-defstruct (frameset-register
+               (:constructor nil)
+               (:constructor frameset-make-register (frameset frame-id point)))
+  frameset frame-id point)
+
+(cl-defmethod register-val-jump-to ((data frameset-register) arg)
   (frameset-restore
-   (aref data 0)
+   (frameset-register-frameset data)
    :filters frameset-session-filter-alist
-   :reuse-frames (if current-prefix-arg t 'match)
-   :cleanup-frames (if current-prefix-arg
+   :reuse-frames (if arg t 'match)
+   :cleanup-frames (if arg
 		       ;; delete frames
 		       nil
 		     ;; iconify frames
@@ -1371,20 +1372,21 @@ Called from `jump-to-register'.  Internal use only."
 			 ('ignored (delete-frame frame))))))
 
   ;; Restore selected frame, buffer and point.
-  (let ((frame (frameset-frame-with-id (aref data 1)))
+  (let ((frame (frameset-frame-with-id (frameset-register-frame-id data)))
+        (marker (frameset-register-point data))
 	buffer window)
     (when frame
       (select-frame-set-input-focus frame)
-      (when (and (buffer-live-p (setq buffer (marker-buffer (aref data 2))))
+      (when (and (buffer-live-p
+                  (setq buffer (marker-buffer marker)))
 		 (window-live-p (setq window (get-buffer-window buffer frame))))
 	(set-frame-selected-window frame window)
-	(with-current-buffer buffer (goto-char (aref data 2)))))))
+	(with-current-buffer buffer (goto-char marker))))))
 
-;;;###autoload
-(defun frameset--print-register (data)
+(cl-defmethod register-val-describe ((data frameset-register) _verbose)
   "Print basic info about frameset stored in DATA.
 Called from `list-registers' and `view-register'.  Internal use only."
-  (let* ((fs (aref data 0))
+  (let* ((fs (frameset-register-frameset data))
 	 (ns (length (frameset-states fs))))
     (princ (format "a frameset (%d frame%s, saved on %s)."
 		   ns
@@ -1400,16 +1402,14 @@ Argument is a character, naming the register.
 Interactively, reads the register using `register-read-with-preview'."
   (interactive (list (register-read-with-preview "Frameset to register: ")))
   (set-register register
-		(registerv-make
-		 (vector (frameset-save nil
-					:app 'register
-					:filters frameset-session-filter-alist)
-			 ;; frameset-save does not include the value of point
-			 ;; in the current buffer, so record that separately.
-			 (frameset-frame-id nil)
-			 (point-marker))
-		 :print-func #'frameset--print-register
-		 :jump-func #'frameset--jump-to-register)))
+		(frameset-make-register
+                 (frameset-save nil
+				:app 'register
+				:filters frameset-session-filter-alist)
+		 ;; frameset-save does not include the value of point
+		 ;; in the current buffer, so record that separately.
+		 (frameset-frame-id nil)
+		 (point-marker))))
 
 (provide 'frameset)
 
diff --git a/lisp/generic-x.el b/lisp/generic-x.el
index c430be78ab..4ad7379bbc 100644
--- a/lisp/generic-x.el
+++ b/lisp/generic-x.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1997-1998, 2001-2019 Free Software Foundation, Inc.
 
-;; Author:  Peter Breton <pbreton@cs.umb.edu>
+;; Author: Peter Breton <pbreton@cs.umb.edu>
 ;; Created: Tue Oct 08 1996
 ;; Keywords: generic, comment, font-lock
 ;; Package: emacs
diff --git a/lisp/gnus/ChangeLog.1 b/lisp/gnus/ChangeLog.1
index 333da55bd8..7c59bde491 100644
--- a/lisp/gnus/ChangeLog.1
+++ b/lisp/gnus/ChangeLog.1
@@ -1263,7 +1263,7 @@
 	* gnus-uu.el (gnus-uu-default-view-rules): make sed kill ^M only
 	at the end of line.
 
-1998-06-05  Hrvoje Niksic  <hniksic@srce.hr>
+1998-06-05  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* nnmail.el (nnmail-get-split-group): Don't regexp-quote
 	nnmail-procmail-suffix.
@@ -1334,7 +1334,7 @@
 	* gnus-msg.el (gnus-bug-create-help-buffer): New variable.
 	(gnus-bug): Use it.
 
-1998-05-07  Hrvoje Niksic  <hniksic@srce.hr>
+1998-05-07  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* nnmail.el (nnmail-get-split-group): Use `regexp-quote'
 	when file name is a part of pattern.
@@ -1346,7 +1346,7 @@
 	* gnus-score.el (gnus-score-load-file): Use `regexp-quote'
 	when file name is a part of pattern.
 
-1998-05-06  Hrvoje Niksic  <hniksic@srce.hr>
+1998-05-06  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-cache.el (gnus-cache-generate-active): Use `regexp-quote'
 	when file name is a part of pattern.
@@ -2169,12 +2169,12 @@
 	* nnmail.el (nnmail-purge-split-history): Alist; not a list of
 	alists.
 
-1998-02-16  Hrvoje Niksic  <hniksic@srce.hr>
+1998-02-16  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* message.el (message-kill-to-signature): Do the right thing when
 	there is no signature.
 
-1998-02-16  Hrvoje Niksic  <hniksic@srce.hr>
+1998-02-16  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* message.el (message-elide-elipsis): Add type and group.
 	(message-elide-region): Docfix.
@@ -2690,7 +2690,7 @@
 
 	* nnml.el (nnml-request-create-group): Check for files.
 
-1997-12-19  Hrvoje Niksic  <hniksic@srce.hr>
+1997-12-19  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* message.el (message-mode): Fixed font-lock.
 
@@ -2924,12 +2924,12 @@
 	* gnus-sum.el (gnus-summary-update-info): Would use wrong group
 	name.
 
-1997-11-26  Hrvoje Niksic  <hniksic@srce.hr>
+1997-11-26  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-spec.el (gnus-compile): Avoid multiple `c*addr's.
 	(gnus-compile): Require `bytecomp'.
 
-1997-11-25  Hrvoje Niksic  <hniksic@srce.hr>
+1997-11-25  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-util.el (gnus-prin1): Bind `print-readably' to t.
 
@@ -3047,13 +3047,13 @@
 
 	* nnml.el (nnml-parse-head): Work in empty buffers.
 
-1997-10-14  Hrvoje Niksic  <hniksic@srce.hr>
+1997-10-14  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-xmas.el (gnus-xmas-group-startup-message): Check for image
 	formats correctly.
 	(gnus-xmas-modeline-glyph): Ditto.
 
-1997-11-24  Hrvoje Niksic  <hniksic@srce.hr>
+1997-11-24  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus-spec.el (gnus-compile): Work under XEmacs.
 
@@ -3337,7 +3337,7 @@
 
 	* gnus-picon.el: Doc fixes.
 
-1997-09-23  Hrvoje Niksic  <hniksic@srce.hr>
+1997-09-23  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* gnus.el: Removed definition of `custom-face-lookup'.
 
diff --git a/lisp/gnus/ChangeLog.2 b/lisp/gnus/ChangeLog.2
index bc507d59dc..fcdc7a899d 100644
--- a/lisp/gnus/ChangeLog.2
+++ b/lisp/gnus/ChangeLog.2
@@ -6549,12 +6549,12 @@
 	* nnmail.el (nnmail-split-it): Add tracing to
 	`:' split rule.
 
-2002-08-13  Hrvoje Niksic  <hniksic@xemacs.org>
+2002-08-13  Hrvoje Nikšić  <hniksic@xemacs.org>
 
 	* mm-decode.el (mm-mailcap-command): Remove the quotes around '%s'
 	and "%s" so we don't overquote them.
 
-2002-08-13  Hrvoje Niksic  <hniksic@xemacs.org>
+2002-08-13  Hrvoje Nikšić  <hniksic@xemacs.org>
 
 	* (mm-display-external): Display the actual command that has been
 	executed in the echo area.
@@ -8654,7 +8654,7 @@
 	(gnus-summary-news-other-window, gnus-summary-post-news):
 	Bind gnus-article-copy to nil, thereby inhibiting the `header' posting
 	style match to use data from last viewed article.
-	Suggested by Hrvoje Niksic.
+	Suggested by Hrvoje Nikšić.
 
 2002-06-04  Katsumi Yamaoka  <yamaoka@jpl.org>
 
@@ -9684,7 +9684,7 @@
 
 2002-02-17  ShengHuo ZHU  <zsh@cs.rochester.edu>
 
-	Some ideas is inspired by code from Hrvoje Niksic
+	Some ideas is inspired by code from Hrvoje Nikšić
 	<hniksic@arsdigita.com>
 
 	* gnus-art.el (gnus-article-wash-function): Set the default to
@@ -15154,7 +15154,7 @@
 	* mm-decode.el (mm-handle-set-external-undisplayer):
 	Don't generate compiler warnings.
 
-2001-06-04  Hrvoje Niksic  <hniksic@arsdigita.com>
+2001-06-04  Hrvoje Nikšić  <hniksic@arsdigita.com>
 
 	* mm-decode.el (mm-pipe-part): Bind coding-system-for-write to
 	binary so that we don't transmit ISO 2022 garbage to the process.
@@ -15339,7 +15339,7 @@
 
 	* mm-uu.el (mm-uu-configure-list): Fix customize type.
 
-2001-04-24  Hrvoje Niksic  <hniksic@arsdigita.com>
+2001-04-24  Hrvoje Nikšić  <hniksic@arsdigita.com>
 
 	* mm-view.el (mm-display-inline-fontify): Allow XEmacs to fully
 	fontify HANDLE.
@@ -18253,7 +18253,7 @@
 	(gnus-set-global-variables): Globalize them.
 	(gnus-summary-exit): Kill them.
 
-2000-11-02  Hrvoje Niksic  <hniksic@arsdigita.com>
+2000-11-02  Hrvoje Nikšić  <hniksic@arsdigita.com>
 
 	* rfc2047.el (rfc2047-encoded-word-regexp): Allow empty encoded
 	word.
diff --git a/lisp/gnus/ChangeLog.3 b/lisp/gnus/ChangeLog.3
index 3bd9f89729..b8070668ef 100644
--- a/lisp/gnus/ChangeLog.3
+++ b/lisp/gnus/ChangeLog.3
@@ -20440,7 +20440,7 @@
 	* gnus-msg.el (gnus-inews-insert-gcc): Fix the mistake of using
 	list, not listp.
 
-2005-09-02  Hrvoje Niksic  <hniksic@xemacs.org>
+2005-09-02  Hrvoje Nikšić  <hniksic@xemacs.org>
 
 	* mm-encode.el (mm-encode-content-transfer-encoding):
 	Likewise when encoding.
diff --git a/lisp/gnus/gnus-agent.el b/lisp/gnus/gnus-agent.el
index 9f7d2c9df7..a09b436889 100644
--- a/lisp/gnus/gnus-agent.el
+++ b/lisp/gnus/gnus-agent.el
@@ -1193,7 +1193,7 @@ This can be added to `gnus-select-article-hook' or
 ;;;
 
 (defun gnus-agent-synchronize-group-flags (group actions server)
-"Update a plugged group by performing the indicated actions."
+  "Update a plugged group by performing the indicated actions."
   (let* ((gnus-command-method (gnus-server-to-method server))
 	 (info
 	  ;; This initializer is required as gnus-request-set-mark
@@ -1227,18 +1227,21 @@ This can be added to `gnus-select-article-hook' or
 		  ((memq mark '(tick))
 		   (let ((info-marks (assoc mark (gnus-info-marks info))))
 		     (unless info-marks
-		       (gnus-info-set-marks info (cons (setq info-marks (list mark)) (gnus-info-marks info))))
-		     (setcdr info-marks (funcall (if (eq what 'add)
-				  'gnus-range-add
-				'gnus-remove-from-range)
-			      (cdr info-marks)
-			      range))))))))
-
-      ;;Marks can be synchronized at any time by simply toggling from
-      ;;unplugged to plugged.  If that is what is happening right now, make
-      ;;sure that the group buffer is up to date.
-          (when (gnus-buffer-live-p gnus-group-buffer)
-            (gnus-group-update-group group t)))
+                       (gnus-info-set-marks
+                        info (cons (setq info-marks (list mark))
+                                   (gnus-info-marks info))))
+                     (setcdr info-marks
+                             (funcall (if (eq what 'add)
+                                          'gnus-range-add
+                                        'gnus-remove-from-range)
+                                      (cdr info-marks)
+                                      range))))))))
+
+      ;; Marks can be synchronized at any time by simply toggling from
+      ;; unplugged to plugged.  If that is what is happening right now,
+      ;; make sure that the group buffer is up to date.
+      (when (gnus-buffer-live-p gnus-group-buffer)
+        (gnus-group-update-group group t)))
     nil))
 
 (defun gnus-agent-save-active (method &optional groups-p)
@@ -2439,7 +2442,7 @@ modified) original contents, they are first saved to their own file."
           ;; Parse them and see which articles we want to fetch.
           (setq gnus-newsgroup-dependencies
                 (or gnus-newsgroup-dependencies
-                    (make-vector (length articles) 0)))
+                    (gnus-make-hashtable (length articles))))
           (setq gnus-newsgroup-headers
                 (or gnus-newsgroup-headers
                     (gnus-get-newsgroup-headers-xover articles nil nil
@@ -3929,7 +3932,7 @@ If REREAD is not nil, downloaded articles are marked as unread."
 		     (nnheader-insert-file-contents file)
 		     (nnheader-remove-body)
 		     (setq header (nnheader-parse-naked-head)))
-		   (mail-header-set-number header (car downloaded))
+		   (setf (mail-header-number header) (car downloaded))
 		   (if nov-arts
 		       (let ((key (concat "^" (int-to-string (car nov-arts))
 					  "\t")))
diff --git a/lisp/gnus/gnus-art.el b/lisp/gnus/gnus-art.el
index baa8a244c0..d826faca5b 100644
--- a/lisp/gnus/gnus-art.el
+++ b/lisp/gnus/gnus-art.el
@@ -41,6 +41,7 @@
 (require 'mm-uu)
 (require 'message)
 (require 'mouse)
+(require 'seq)
 
 (autoload 'gnus-msg-mail "gnus-msg" nil t)
 (autoload 'gnus-button-mailto "gnus-msg")
@@ -435,10 +436,10 @@ is the face used for highlighting."
 		     :on " On " :off " Off ")
 	    face)))
   :get (lambda (symbol)
-	 (mapcar 'gnus-emphasis-custom-value-to-internal
+	 (mapcar #'gnus-emphasis-custom-value-to-internal
 		 (default-value symbol)))
   :set (lambda (symbol value)
-	 (set-default symbol (mapcar 'gnus-emphasis-custom-value-to-external
+	 (set-default symbol (mapcar #'gnus-emphasis-custom-value-to-external
 				     value)))
   :group 'gnus-article-emphasis)
 
@@ -1838,14 +1839,14 @@ Initialized from `text-mode-syntax-table'.")
 				(cond ((stringp gnus-ignored-headers)
 				       gnus-ignored-headers)
 				      ((listp gnus-ignored-headers)
-				       (mapconcat 'identity
+				       (mapconcat #'identity
 						  gnus-ignored-headers
 						  "\\|"))))
 		      visible (cond ((stringp gnus-visible-headers)
 				     gnus-visible-headers)
 				    ((and gnus-visible-headers
 					  (listp gnus-visible-headers))
-				     (mapconcat 'identity
+				     (mapconcat #'identity
 						gnus-visible-headers
 						"\\|")))))
 	  (set-buffer cur))
@@ -1976,11 +1977,11 @@ always hide."
 			  (sort (mapcar
 				 (lambda (x) (downcase (cadr x)))
 				 (mail-extract-address-components from t))
-				'string<)
+				#'string<)
 			  (sort (mapcar
 				 (lambda (x) (downcase (cadr x)))
 				 (mail-extract-address-components reply-to t))
-				'string<))))
+				#'string<))))
 		    (gnus-article-hide-header "reply-to")))))
 	     ((eq elem 'date)
 	      (let ((date (with-current-buffer gnus-original-article-buffer
@@ -2404,7 +2405,7 @@ long lines if and only if arg is positive."
 	      (while faces
 		(when (setq png (gnus-convert-face-to-png (pop faces)))
 		  (setq image
-			(apply 'gnus-create-image png 'png t
+			(apply #'gnus-create-image png 'png t
 			       (cdr (assq 'png gnus-face-properties-alist))))
 		  (goto-char from)
 		  (when image
@@ -3733,7 +3734,7 @@ is to run."
   "Stop the Date timer."
   (interactive)
   (when article-lapsed-timer
-    (nnheader-cancel-timer article-lapsed-timer)
+    (cancel-timer article-lapsed-timer)
     (setq article-lapsed-timer nil)))
 
 (defun article-date-user (&optional highlight)
@@ -4102,7 +4103,7 @@ and the raw article including all headers will be piped."
 		  (get 'gnus-summary-save-in-pipe :decode)))
 	save-buffer default)
     (if article
-	(if (vectorp (gnus-summary-article-header article))
+	(if (mail-header-p (gnus-summary-article-header article))
 	    (save-current-buffer
 	      (gnus-summary-select-article decode decode nil article)
 	      (insert-buffer-substring
@@ -4254,7 +4255,7 @@ If variable `gnus-use-long-file-name' is non-nil, it is
 	      (forward-line))
 	    (insert "\n-----BEGIN PGP SIGNATURE-----\n")
 	    (insert "Version: " (car items) "\n\n")
-	    (insert (mapconcat 'identity (cddr items) "\n"))
+	    (insert (mapconcat #'identity (cddr items) "\n"))
 	    (insert "\n-----END PGP SIGNATURE-----\n")
 	    (let ((mm-security-handle (list (format "multipart/signed"))))
 	      (mml2015-clean-buffer)
@@ -4317,7 +4318,7 @@ If variable `gnus-use-long-file-name' is non-nil, it is
 	      (with-current-buffer gnus-article-buffer
 		(if interactive
 		    (call-interactively ',afunc)
-		  (apply ',afunc args))))))))
+		  (apply #',afunc args))))))))
    '(article-hide-headers
      article-verify-x-pgp-sig
      article-verify-cancel-lock
@@ -4656,7 +4657,7 @@ If ALL-HEADERS is non-nil, no headers are hidden."
 		      (gnus-summary-article-header gnus-current-article)
 		      gnus-article-current
 		      (cons gnus-newsgroup-name gnus-current-article))
-		(unless (vectorp gnus-current-headers)
+		(unless (mail-header-p gnus-current-headers)
 		  (setq gnus-current-headers nil))
 		(gnus-summary-goto-subject gnus-current-article)
 		(when (gnus-summary-show-thread)
@@ -4798,11 +4799,10 @@ If a prefix ARG is given, ask for confirmation."
   (interactive "P")
   (dolist (buf (gnus-buffers))
     (with-current-buffer buf
-      (when (derived-mode-p 'gnus-sticky-article-mode)
-	(if (not arg)
-	    (gnus-kill-buffer buf)
-	  (when (yes-or-no-p (concat "Kill buffer " (buffer-name buf) "? "))
-	    (gnus-kill-buffer buf)))))))
+      (and (derived-mode-p 'gnus-sticky-article-mode)
+           (or (not arg)
+               (yes-or-no-p (format "Kill buffer %s? " buf)))
+           (gnus-kill-buffer buf)))))
 
 ;;;
 ;;; Gnus MIME viewing functions
@@ -5482,7 +5482,7 @@ If no internal viewer is available, use an external viewer."
 (defun gnus-mime-action-on-part (&optional action)
   "Do something with the MIME attachment at (point)."
   (interactive
-   (list (gnus-completing-read "Action" (mapcar 'car gnus-mime-action-alist) t)))
+   (list (gnus-completing-read "Action" (mapcar #'car gnus-mime-action-alist) t)))
   (gnus-article-check-buffer)
   (let ((action-pair (assoc action gnus-mime-action-alist)))
     (if action-pair
@@ -5800,7 +5800,7 @@ all parts."
 	      ;; No subpart is displayed, so we find preferred one.
 	      (setq part
 		    (cdr (assq (mm-preferred-alternative
-				(nreverse (mapcar 'car handles)))
+				(nreverse (mapcar #'car handles)))
 			       handles))))
 	    (if part
 		(goto-char (1+ part))
@@ -5994,11 +5994,11 @@ If nil, don't show those extra buttons."
 
 (defun gnus-mime-part-function (handles)
   (if (stringp (car handles))
-      (mapcar 'gnus-mime-part-function (cdr handles))
+      (mapcar #'gnus-mime-part-function (cdr handles))
     (funcall gnus-article-mime-part-function handles)))
 
 (defun gnus-mime-display-mixed (handles)
-  (mapcar 'gnus-mime-display-part handles))
+  (mapcar #'gnus-mime-display-part handles))
 
 (defun gnus-mime-display-single (handle)
   (let ((type (mm-handle-media-type handle))
@@ -6978,9 +6978,7 @@ If given a prefix, show the hidden text instead."
 	  ;; doesn't belong in this newsgroup (possibly), so we find its
 	  ;; message-id and request it by id instead of number.
 	  (when (and (numberp article)
-		     gnus-summary-buffer
-		     (get-buffer gnus-summary-buffer)
-		     (gnus-buffer-exists-p gnus-summary-buffer))
+                     (gnus-buffer-live-p gnus-summary-buffer))
 	    (with-current-buffer gnus-summary-buffer
 	      (let ((header (gnus-summary-article-header article)))
 		(when (< article 0)
@@ -6992,7 +6990,7 @@ If given a prefix, show the hidden text instead."
 			  (delq article gnus-newsgroup-sparse))
 		    (setq article (mail-header-id header))
 		    (setq sparse-header (gnus-read-header article)))
-		   ((vectorp header)
+		   ((mail-header-p header)
 		    ;; It's a real article.
 		    (setq article (mail-header-id header)))
 		   (t
@@ -7003,7 +7001,7 @@ If given a prefix, show the hidden text instead."
 		(let ((method (gnus-find-method-for-group
 			       gnus-newsgroup-name)))
 		  (when (and (eq (car method) 'nneething)
-			     (vectorp header))
+			     (mail-header-p header))
 		    (let ((dir (nneething-get-file-name
 				(mail-header-id header))))
 		      (when (and (stringp dir)
@@ -7014,11 +7012,9 @@ If given a prefix, show the hidden text instead."
 	  (cond
 	   ;; Refuse to select canceled articles.
 	   ((and (numberp article)
-		 gnus-summary-buffer
-		 (get-buffer gnus-summary-buffer)
-		 (gnus-buffer-exists-p gnus-summary-buffer)
-		 (eq (cdr (with-current-buffer gnus-summary-buffer
-			    (assq article gnus-newsgroup-reads)))
+                 (gnus-buffer-live-p gnus-summary-buffer)
+                 (eq (with-current-buffer gnus-summary-buffer
+                       (cdr (assq article gnus-newsgroup-reads)))
 		     gnus-canceled-mark))
 	    nil)
 	   ;; We first check `gnus-original-article-buffer'.
@@ -7027,12 +7023,7 @@ If given a prefix, show the hidden text instead."
 		 (with-current-buffer gnus-original-article-buffer
 		   (and (equal (car gnus-original-article) group)
 			(eq (cdr gnus-original-article) article))))
-            ;; `insert-buffer-substring' would incorrectly use the
-            ;; equivalent of string-make-multibyte which amount to decoding
-            ;; with locale-coding-system, causing failure of
-            ;; subsequent decoding.
-            (insert (with-current-buffer gnus-original-article-buffer
-                      (buffer-substring (point-min) (point-max))))
+            (insert-buffer-substring gnus-original-article-buffer)
 	    'article)
 	   ;; Check the backlog.
 	   ((and gnus-keep-backlog
@@ -8055,7 +8046,7 @@ url is put as the `gnus-button-url' overlay property on the button."
 	  (let ((overlay (make-overlay start end)))
 	    (overlay-put overlay 'evaporate t)
 	    (overlay-put overlay 'gnus-button-url
-			 (list (mapconcat 'identity (nreverse url) "")))
+			 (list (mapconcat #'identity (nreverse url) "")))
 	    (when gnus-article-mouse-face
 	      (overlay-put overlay 'mouse-face gnus-article-mouse-face)))
 	  t)
@@ -8394,7 +8385,7 @@ url is put as the `gnus-button-url' overlay property on the button."
 	(message-position-on-field (caar args)))
       (insert (replace-regexp-in-string
 	       "\r\n" "\n"
-	       (mapconcat 'identity (reverse (cdar args)) ", ") nil t))
+	       (mapconcat #'identity (reverse (cdar args)) ", ") nil t))
       (setq args (cdr args)))
     (if subject
 	(message-goto-body)
@@ -8585,18 +8576,16 @@ For example:
     nil)
    (gnus-treat-condition
     (eq gnus-treat-condition val))
-   ((and (listp val)
-	 (stringp (car val)))
-    (apply 'gnus-or (mapcar `(lambda (s)
-			       (string-match s ,(or gnus-newsgroup-name "")))
-			    val)))
+   ((stringp (car-safe val))
+    (let ((name (or gnus-newsgroup-name "")))
+      (seq-some (lambda (s) (string-match-p s name)) val)))
    ((listp val)
     (let ((pred (pop val)))
       (cond
        ((eq pred 'or)
-	(apply 'gnus-or (mapcar 'gnus-treat-predicate val)))
+	(apply #'gnus-or (mapcar #'gnus-treat-predicate val)))
        ((eq pred 'and)
-	(apply 'gnus-and (mapcar 'gnus-treat-predicate val)))
+	(apply #'gnus-and (mapcar #'gnus-treat-predicate val)))
        ((eq pred 'not)
 	(not (gnus-treat-predicate (car val))))
        ((eq pred 'typep)
@@ -8624,7 +8613,7 @@ For example:
    (list
     (or gnus-article-encrypt-protocol
 	(gnus-completing-read "Encrypt protocol"
-                              (mapcar 'car gnus-article-encrypt-protocol-alist)
+                              (mapcar #'car gnus-article-encrypt-protocol-alist)
                               t))
     current-prefix-arg))
   ;; User might hit `K E' instead of `K e', so prompt once.
@@ -8671,7 +8660,7 @@ For example:
 	    (message-remove-header "MIME-Version")
 	    (goto-char (point-max))
 	    (setq point (point))
-	    (insert (apply 'concat headers))
+	    (insert (apply #'concat headers))
 	    (widen)
 	    (narrow-to-region point (point-max))
 	    (let ((message-options message-options))
diff --git a/lisp/gnus/gnus-async.el b/lisp/gnus/gnus-async.el
index 4e2723e8d2..e6fe2db355 100644
--- a/lisp/gnus/gnus-async.el
+++ b/lisp/gnus/gnus-async.el
@@ -1,4 +1,4 @@
-;;; gnus-async.el --- asynchronous support for Gnus
+;;; gnus-async.el --- asynchronous support for Gnus  -*- lexical-binding:t -*-
 
 ;; Copyright (C) 1996-2019 Free Software Foundation, Inc.
 
@@ -38,7 +38,6 @@
   "If non-nil, prefetch articles in groups that allow this.
 If a number, prefetch only that many articles forward;
 if t, prefetch as many articles as possible."
-  :group 'gnus-asynchronous
   :type '(choice (const :tag "off" nil)
 		 (const :tag "all" t)
 		 (integer :tag "some" 0)))
@@ -46,7 +45,6 @@ if t, prefetch as many articles as possible."
 (defcustom gnus-asynchronous nil
   "If nil, inhibit all Gnus asynchronicity.
 If non-nil, let the other asynch variables be heeded."
-  :group 'gnus-asynchronous
   :type 'boolean)
 
 (defcustom gnus-prefetched-article-deletion-strategy '(read exit)
@@ -55,28 +53,24 @@ Possible values in this list are `read', which means that
 articles are removed as they are read, and `exit', which means
 that all articles belonging to a group are removed on exit
 from that group."
-  :group 'gnus-asynchronous
   :type '(set (const read) (const exit)))
 
 (defcustom gnus-use-header-prefetch nil
   "If non-nil, prefetch the headers to the next group."
-  :group 'gnus-asynchronous
   :type 'boolean)
 
-(defcustom gnus-async-prefetch-article-p 'gnus-async-unread-p
+(defcustom gnus-async-prefetch-article-p #'gnus-async-unread-p
   "Function called to say whether an article should be prefetched or not.
 The function is called with one parameter -- the article data.
 It should return non-nil if the article is to be prefetched."
-  :group 'gnus-asynchronous
   :type 'function)
 
-(defcustom gnus-async-post-fetch-function nil
+(defcustom gnus-async-post-fetch-function #'ignore
   "Function called after an article has been prefetched.
 The function will be called narrowed to the region of the article
 that was fetched."
-  :version "24.1"
-  :group 'gnus-asynchronous
-  :type '(choice (const nil) function))
+  :version "27.1"
+  :type 'function)
 
 ;;; Internal variables.
 
@@ -109,15 +103,13 @@ that was fetched."
   (setcdr (symbol-value semaphore) nil))
 
 (defmacro gnus-async-with-semaphore (&rest forms)
+  (declare (indent 0) (debug t))
   `(unwind-protect
        (progn
 	 (gnus-async-get-semaphore 'gnus-async-article-semaphore)
 	 ,@forms)
      (gnus-async-release-semaphore 'gnus-async-article-semaphore)))
 
-(put 'gnus-async-with-semaphore 'lisp-indent-function 0)
-(put 'gnus-async-with-semaphore 'edebug-form-spec '(body))
-
 ;;;
 ;;; Article prefetch
 ;;;
@@ -142,15 +134,15 @@ that was fetched."
 	     gnus-asynchronous
 	     (gnus-group-asynchronous-p group))
     (with-current-buffer gnus-summary-buffer
-      (let ((next (caadr (gnus-data-find-list article))))
+      (let ((next (cadr (gnus-data-find-list article))))
 	(when next
 	  (when gnus-async-timer
 	    (ignore-errors
-	      (nnheader-cancel-timer 'gnus-async-timer)))
+	      (cancel-timer 'gnus-async-timer)))
 	  (setq gnus-async-timer
 		(run-with-idle-timer
-		 0.1 nil 'gnus-async-prefetch-article
-		 group next summary)))))))
+		 0.1 nil #'gnus-async-prefetch-article
+		 group (gnus-data-number next) summary)))))))
 
 (defun gnus-async-prefetch-article (group article summary &optional next)
   "Possibly prefetch several articles starting with ARTICLE."
@@ -214,8 +206,8 @@ that was fetched."
 
 (defun gnus-make-async-article-function (group article mark summary next)
   "Return a callback function."
-  `(lambda (arg)
-     (gnus-async-article-callback arg ,group ,article ,mark ,summary ,next)))
+  (lambda (arg)
+    (gnus-async-article-callback arg group article mark summary next)))
 
 (defun gnus-async-article-callback (arg group article mark summary next)
   "Function called when an async article is done being fetched."
@@ -356,9 +348,9 @@ that was fetched."
 	(erase-buffer)
 	(let ((nntp-server-buffer (current-buffer))
 	      (nnheader-callback-function
-	       `(lambda (arg)
+	       (lambda (_arg)
 		  (setq gnus-async-header-prefetched
-			,(cons group unread)))))
+			(cons group unread)))))
 	  (gnus-retrieve-headers unread group gnus-fetch-old-headers))))))
 
 (defun gnus-async-retrieve-fetched-headers (articles group)
diff --git a/lisp/gnus/gnus-bcklg.el b/lisp/gnus/gnus-bcklg.el
index c5a0e3ec4f..f478c39f37 100644
--- a/lisp/gnus/gnus-bcklg.el
+++ b/lisp/gnus/gnus-bcklg.el
@@ -46,8 +46,7 @@
 (defun gnus-backlog-shutdown ()
   "Clear all backlog variables and buffers."
   (interactive)
-  (when (get-buffer gnus-backlog-buffer)
-    (gnus-kill-buffer gnus-backlog-buffer))
+  (gnus-kill-buffer gnus-backlog-buffer)
   (setq gnus-backlog-articles nil))
 
 (defun gnus-backlog-enter-article (group number buffer)
diff --git a/lisp/gnus/gnus-cache.el b/lisp/gnus/gnus-cache.el
index 5e6483d105..afe8a8a416 100644
--- a/lisp/gnus/gnus-cache.el
+++ b/lisp/gnus/gnus-cache.el
@@ -187,9 +187,9 @@ it's not cached."
 	      (setq lines-chars (nnheader-get-lines-and-char))
 	      (nnheader-remove-body)
 	      (setq headers (nnheader-parse-naked-head))
-	      (mail-header-set-number headers number)
-	      (mail-header-set-lines headers (car lines-chars))
-	      (mail-header-set-chars headers (cadr lines-chars))
+	      (setf (mail-header-number headers) number)
+	      (setf (mail-header-lines headers) (car lines-chars))
+	      (setf (mail-header-chars headers) (cadr lines-chars))
 	      (gnus-cache-change-buffer group)
 	      (set-buffer (cdr gnus-cache-buffer))
 	      (goto-char (point-max))
diff --git a/lisp/gnus/gnus-cite.el b/lisp/gnus/gnus-cite.el
index 7e431e79fc..3aaf41ccf7 100644
--- a/lisp/gnus/gnus-cite.el
+++ b/lisp/gnus/gnus-cite.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1995-2019 Free Software Foundation, Inc.
 
-;; Author: Per Abhiddenware
+;; Author: Per Abrahamsen <abraham@dina.kvl.dk>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/gnus/gnus-cus.el b/lisp/gnus/gnus-cus.el
index d56066e616..0938d6b6ed 100644
--- a/lisp/gnus/gnus-cus.el
+++ b/lisp/gnus/gnus-cus.el
@@ -369,7 +369,7 @@ category."))
     (unless (or topic (setq info (gnus-get-info group)))
       (error "Killed group; can't be edited"))
     ;; Ready.
-    (gnus-kill-buffer (gnus-get-buffer-create "*Gnus Customize*"))
+    (gnus-kill-buffer "*Gnus Customize*")
     (switch-to-buffer (gnus-get-buffer-create "*Gnus Customize*"))
     (gnus-custom-mode)
     (make-local-variable 'gnus-custom-group)
@@ -1021,9 +1021,7 @@ articles in the thread.
                         (cons 'agent-low-score gnus-agent-low-score)
                         (cons 'agent-high-score gnus-agent-high-score))))
 
-    (let ((old (get-buffer "*Gnus Agent Category Customize*")))
-      (when old
-        (gnus-kill-buffer old)))
+    (gnus-kill-buffer "*Gnus Agent Category Customize*")
     (switch-to-buffer (gnus-get-buffer-create
                        "*Gnus Agent Category Customize*"))
 
@@ -1051,7 +1049,7 @@ articles in the thread.
            (when (get-buffer gnus-category-buffer)
              (switch-to-buffer (get-buffer gnus-category-buffer))
              (gnus-category-list)))
-                       "Done")
+         "Done")
         (widget-insert
          "\n    Note: Empty fields default to the customizable global\
  variables.\n\n")
diff --git a/lisp/gnus/gnus-demon.el b/lisp/gnus/gnus-demon.el
index 6c5e0b7f5d..cb70d9525c 100644
--- a/lisp/gnus/gnus-demon.el
+++ b/lisp/gnus/gnus-demon.el
@@ -111,7 +111,7 @@ marked with SPECIAL."
                                               func idle time))))
             ((and idle (> idle (gnus-demon-idle-since)))
              (when time
-               (nnheader-cancel-timer (plist-get gnus-demon-timers func))
+               (cancel-timer (plist-get gnus-demon-timers func))
                (setq gnus-demon-timers
                      (plist-put gnus-demon-timers func
 				(run-with-idle-timer idle nil
@@ -202,7 +202,7 @@ marked with SPECIAL."
   "Cancel any Gnus daemons."
   (interactive)
   (dotimes (i (/ (length gnus-demon-timers) 2))
-    (nnheader-cancel-timer (nth (1+ (* i 2)) gnus-demon-timers)))
+    (cancel-timer (nth (1+ (* i 2)) gnus-demon-timers)))
   (setq gnus-demon-timers nil))
 
 (defun gnus-demon-add-disconnection ()
diff --git a/lisp/gnus/gnus-diary.el b/lisp/gnus/gnus-diary.el
index ceb0d4a30d..0e78f2b899 100644
--- a/lisp/gnus/gnus-diary.el
+++ b/lisp/gnus/gnus-diary.el
@@ -2,8 +2,7 @@
 
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
-;; Author:        Didier Verna <didier@xemacs.org>
-;; Maintainer:    Didier Verna <didier@xemacs.org>
+;; Author:        Didier Verna <didier@didierverna.net>
 ;; Created:       Tue Jul 20 10:42:55 1999
 ;; Keywords:      calendar mail news
 
diff --git a/lisp/gnus/gnus-draft.el b/lisp/gnus/gnus-draft.el
index ad1aa62a34..0616dc8fd5 100644
--- a/lisp/gnus/gnus-draft.el
+++ b/lisp/gnus/gnus-draft.el
@@ -94,14 +94,13 @@
       (save-restriction
 	(message-narrow-to-headers)
 	(message-remove-header "date")))
-    (let ((message-draft-headers
-	   (delq 'Date (copy-sequence message-draft-headers))))
+    (let ((message-draft-headers (remq 'Date message-draft-headers)))
       (save-buffer))
     (let ((gnus-verbose-backends nil))
       (gnus-request-expire-articles (list article) group t))
     (push
      `((lambda ()
-	 (when (gnus-buffer-exists-p ,gnus-summary-buffer)
+         (when (gnus-buffer-live-p ,gnus-summary-buffer)
 	   (save-excursion
 	     (set-buffer ,gnus-summary-buffer)
 	     (gnus-cache-possibly-remove-article ,article nil nil nil t)))))
diff --git a/lisp/gnus/gnus-group.el b/lisp/gnus/gnus-group.el
index 0956dc46d0..f49ed16443 100644
--- a/lisp/gnus/gnus-group.el
+++ b/lisp/gnus/gnus-group.el
@@ -1743,8 +1743,7 @@ already.  If INFO-UNCHANGED is non-nil, dribble buffer is not updated."
 	     gnus-tmp-header		;Dummy binding for user-defined formats
 	     ;; Get the resulting string.
 	     (modified
-	      (and gnus-dribble-buffer
-		   (buffer-name gnus-dribble-buffer)
+              (and (buffer-live-p gnus-dribble-buffer)
 		   (buffer-modified-p gnus-dribble-buffer)
 		   (with-current-buffer gnus-dribble-buffer
 		     (not (zerop (buffer-size))))))
@@ -2549,37 +2548,33 @@ If PROMPT (the prefix) is a number, use the prompt specified in
     (gnus-group-position-point)))
 
 (defun gnus-group-goto-group (group &optional far test-marked)
-  "Goto to newsgroup GROUP.
+  "Go to newsgroup GROUP.
 If FAR, it is likely that the group is not on the current line.
-If TEST-MARKED, the line must be marked."
+If TEST-MARKED, the line must be marked.
+
+Return nil if GROUP is not found."
   (when group
-    (let ((start (point))
-	  (active (and (or
-                        ;; Some kind of group may be only there.
-                        (gnus-active group)
-                        ;; All groups (but with exception) are there.
-                        (gnus-group-entry group))
-		       group)))
+    (let ((start (point)))
       (beginning-of-line)
       (cond
        ;; It's quite likely that we are on the right line, so
        ;; we check the current line first.
        ((and (not far)
-	     (equal (get-text-property (point) 'gnus-group) active)
+	     (equal (get-text-property (point) 'gnus-group) group)
 	     (or (not test-marked) (gnus-group-mark-line-p)))
 	(point))
        ;; Previous and next line are also likely, so we check them as well.
        ((and (not far)
 	     (save-excursion
 	       (forward-line -1)
-	       (and (equal (get-text-property (point) 'gnus-group) active)
+	       (and (equal (get-text-property (point) 'gnus-group) group)
 		    (or (not test-marked) (gnus-group-mark-line-p)))))
 	(forward-line -1)
 	(point))
        ((and (not far)
 	     (save-excursion
 	       (forward-line 1)
-	       (and (equal (get-text-property (point) 'gnus-group) active)
+	       (and (equal (get-text-property (point) 'gnus-group) group)
 		    (or (not test-marked) (gnus-group-mark-line-p)))))
 	(forward-line 1)
 	(point))
@@ -2588,7 +2583,7 @@ If TEST-MARKED, the line must be marked."
 	(let (found)
 	  (while (and (not found)
 		      (gnus-text-property-search
-		       'gnus-group active 'forward 'goto))
+		       'gnus-group group 'forward 'goto))
 	    (if (gnus-group-mark-line-p)
 		(setq found t)
 	      (forward-line 1)))
@@ -2596,7 +2591,7 @@ If TEST-MARKED, the line must be marked."
        (t
 	;; Search through the entire buffer.
 	(if (gnus-text-property-search
-	     'gnus-group active nil 'goto)
+	     'gnus-group group nil 'goto)
 	    (point)
 	  (goto-char start)
 	  nil))))))
@@ -3304,21 +3299,31 @@ If REVERSE (the prefix), reverse the sorting order."
   (funcall gnus-group-sort-alist-function
 	   (gnus-make-sort-function func) reverse)
   (gnus-group-unmark-all-groups)
+  ;; Redisplay all groups according to the newly-sorted order of
+  ;; `gnus-group-list'.
   (gnus-group-list-groups)
   (gnus-dribble-touch))
 
 (defun gnus-group-sort-flat (func reverse)
-  ;; We peel off the dummy group from the alist.
+  "Sort groups in a flat list using sorting function FUNC.
+If REVERSE is non-nil, reverse the sort order.
+
+This function sets a new value for `gnus-group-list'; its return
+value is disregarded."
   (when func
-    (when (equal (gnus-info-group (car gnus-newsrc-alist)) "dummy.group")
-      (pop gnus-newsrc-alist))
-    ;; Do the sorting.
-    (setq gnus-newsrc-alist
-	  (sort gnus-newsrc-alist func))
-    (when reverse
-      (setq gnus-newsrc-alist (nreverse gnus-newsrc-alist)))
-    ;; Regenerate the hash table.
-    (gnus-make-hashtable-from-newsrc-alist)))
+    (let* ((groups (remove "dummy.group" gnus-group-list))
+	   (sorted-infos
+	    (sort (mapcar (lambda (g)
+			    (gnus-get-info g))
+			  groups)
+		  func)))
+      (setq gnus-group-list
+	    (mapcar (lambda (i)
+		      (gnus-info-group i))
+		    sorted-infos))
+      (when reverse
+	(setq gnus-group-list (nreverse gnus-group-list)))
+      (setq gnus-group-list (cons "dummy.group" gnus-group-list)))))
 
 (defun gnus-group-sort-groups-by-alphabet (&optional reverse)
   "Sort the group buffer alphabetically by group name.
@@ -3381,27 +3386,26 @@ If REVERSE, sort in reverse order."
     (gnus-dribble-touch)))
 
 (defun gnus-group-sort-selected-flat (groups func reverse)
-  (let (entries infos)
-    ;; First find all the group entries for these groups.
-    (while groups
-      (push (nthcdr 2 (gnus-group-entry (pop groups)))
-	    entries))
-    ;; Then sort the infos.
-    (setq infos
-	  (sort
-	   (mapcar
-	    (lambda (entry) (car entry))
-	    (setq entries (nreverse entries)))
-	   func))
+  "Sort only the selected GROUPS, using FUNC.
+If REVERSE is non-nil, reverse the sorting."
+  (let ((infos (sort
+		(mapcar (lambda (g)
+			  (gnus-get-info g))
+			groups)
+		func))
+	sorted-groups)
     (when reverse
       (setq infos (nreverse infos)))
-    ;; Go through all the infos and replace the old entries
-    ;; with the new infos.
-    (while infos
-      (setcar (car entries) (pop infos))
-      (pop entries))
-    ;; Update the hashtable.
-    (gnus-make-hashtable-from-newsrc-alist)))
+    (setq sorted-groups (mapcar (lambda (i) (gnus-info-group i)) infos))
+
+    ;; Find the original locations of GROUPS in `gnus-group-list', and
+    ;; replace each one, in order, with a group from SORTED-GROUPS.
+    (dolist (i (sort (mapcar (lambda (g)
+			       (seq-position gnus-group-list g))
+			     groups)
+		     #'<))
+      (setf (nth i gnus-group-list)
+	    (pop sorted-groups)))))
 
 (defun gnus-group-sort-selected-groups-by-alphabet (&optional n reverse)
   "Sort the group buffer alphabetically by group name.
@@ -4137,20 +4141,19 @@ If DONT-SCAN is non-nil, scan non-activated groups as well."
   (when (not (or gnus-description-hashtb
 		 (gnus-read-all-descriptions-files)))
     (error "Couldn't request descriptions file"))
-  (let ((buffer-read-only nil)
-	(groups (sort (hash-table-keys gnus-description-hashtb)))
-	b)
+  (let ((buffer-read-only nil))
     (erase-buffer)
-    (dolist (group groups)
-      (setq b (point))
-      (let ((charset (gnus-group-name-charset nil group)))
+    (dolist (group (sort (hash-table-keys gnus-description-hashtb) #'string<))
+      (let ((b (point))
+            (desc (gethash group gnus-description-hashtb))
+            (charset (gnus-group-name-charset nil group)))
 	(insert (format "      *: %-20s %s\n"
 			(gnus-group-name-decode group charset)
-			(gnus-group-name-decode group charset))))
-      (add-text-properties
-       b (1+ b) (list 'gnus-group (intern group gnus-description-hashtb)
-		      'gnus-unread t 'gnus-marked nil
-		      'gnus-level (1+ gnus-level-subscribed))))
+                        (gnus-group-name-decode desc charset)))
+        (add-text-properties
+         b (1+ b) (list 'gnus-group group
+                        'gnus-unread t 'gnus-marked nil
+                        'gnus-level (1+ gnus-level-subscribed)))))
     (goto-char (point-min))
     (gnus-group-position-point)))
 
@@ -4358,15 +4361,13 @@ The hook `gnus-exit-gnus-hook' is called before actually exiting."
 
 (defun gnus--abort-on-unsaved-message-buffers ()
   (dolist (buffer (gnus-buffers))
-    (when (gnus-buffer-exists-p buffer)
-      (with-current-buffer buffer
-	(when (and (derived-mode-p 'message-mode)
-		   (buffer-modified-p)
-		   (not (y-or-n-p
-			 (format "Message buffer %s unsaved, continue exit? "
-				 (buffer-name)))))
-	  (error "Gnus exit aborted due to unsaved %s buffer"
-		 (buffer-name)))))))
+    (with-current-buffer buffer
+      (when (and (derived-mode-p 'message-mode)
+                 (buffer-modified-p)
+                 (not (y-or-n-p
+                       (format "Message buffer %s unsaved, continue exit? "
+                               buffer))))
+        (error "Gnus exit aborted due to unsaved buffer %s" buffer)))))
 
 (defun gnus-group-quit ()
   "Quit reading news without updating .newsrc.eld or .newsrc.
@@ -4750,8 +4751,7 @@ Compacting group %s... (this may take a long time)"
       ;; Invalidate the "original article" buffer which might be out of date.
       ;; #### NOTE: Yes, this might be a bit rude, but since compaction
       ;; #### will not happen very often, I think this is acceptable.
-      (let ((original (get-buffer gnus-original-article-buffer)))
-	(and original (gnus-kill-buffer original)))
+      (gnus-kill-buffer gnus-original-article-buffer)
       ;; Update the group line to reflect new information (art number etc).
       (gnus-group-update-group-line))))
 
diff --git a/lisp/gnus/gnus-icalendar.el b/lisp/gnus/gnus-icalendar.el
index 28020a1fd0..53a20b90eb 100644
--- a/lisp/gnus/gnus-icalendar.el
+++ b/lisp/gnus/gnus-icalendar.el
@@ -756,7 +756,7 @@ These will be used to retrieve the RSVP information from ical events."
     `(let ((,charset (cdr (assoc 'charset (mm-handle-type ,handle)))))
        (with-temp-buffer
          (mm-insert-part ,handle)
-         (when (string= ,charset "utf-8")
+         (when (string= (downcase ,charset) "utf-8")
            (decode-coding-region (point-min) (point-max) 'utf-8))
          ,@body))))
 
diff --git a/lisp/gnus/gnus-kill.el b/lisp/gnus/gnus-kill.el
index a7ded39303..442d26cf4f 100644
--- a/lisp/gnus/gnus-kill.el
+++ b/lisp/gnus/gnus-kill.el
@@ -350,8 +350,7 @@ Returns the number of articles marked as read."
 	    (let ((headers gnus-newsgroup-headers))
 	      (if gnus-kill-killed
 		  (setq gnus-newsgroup-kill-headers
-			(mapcar (lambda (header) (mail-header-number header))
-				headers))
+			(mapcar #'mail-header-number headers))
 		(while headers
 		  (unless (gnus-member-of-range
 			   (mail-header-number (car headers))
@@ -600,8 +599,7 @@ marked as read or ticked are ignored."
        ((cond ((fboundp
 		(setq function
 		      (intern-soft
-		       (concat "mail-header-" (downcase field)))))
-	       (setq function `(lambda (h) (,function h))))
+		       (concat "mail-header-" (downcase field))))))
 	      ((when (setq extras
 			   (member (downcase field)
 				   (mapcar (lambda (header)
diff --git a/lisp/gnus/gnus-ml.el b/lisp/gnus/gnus-ml.el
index 6a264e099a..488c01c21c 100644
--- a/lisp/gnus/gnus-ml.el
+++ b/lisp/gnus/gnus-ml.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2000-2019 Free Software Foundation, Inc.
 
-;; Author: Julien Gilles  <jgilles@free.fr>
+;; Author: Julien Gilles <jgilles@free.fr>
 ;; Keywords: news, mail
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/gnus/gnus-msg.el b/lisp/gnus/gnus-msg.el
index b6d649d760..0ae7fe2efc 100644
--- a/lisp/gnus/gnus-msg.el
+++ b/lisp/gnus/gnus-msg.el
@@ -158,9 +158,9 @@ if a regexp and matches the Gcc group name, attach files as external parts;
 if nil, attach files as normal parts."
   :version "22.1"
   :group 'gnus-message
-  :type '(choice (const nil :tag "None")
-		 (const all :tag "Any")
-		 (string :tag "Regexp")))
+  :type '(choice (const :tag "None" nil)
+                 (const :tag "Any"  all)
+                 regexp))
 
 (defcustom gnus-gcc-self-resent-messages 'no-gcc-self
   "Like `gcc-self' group parameter, only for unmodified resent messages.
@@ -232,7 +232,9 @@ List of charsets that are permitted to be unencoded.")
   "Files whose variables will be reported in `gnus-bug'."
   :version "22.1"
   :group 'gnus-message
-  :type '(repeat (string :tag "File")))
+  :type '(repeat file))
+
+(make-obsolete-variable 'gnus-debug-files "it is no longer used." "24.1")
 
 (defcustom gnus-debug-exclude-variables
   '(mm-mime-mule-charset-alist
@@ -240,7 +242,10 @@ List of charsets that are permitted to be unencoded.")
   "Variables that should not be reported in `gnus-bug'."
   :version "22.1"
   :group 'gnus-message
-  :type '(repeat (symbol :tag "Variable")))
+  :type '(repeat variable))
+
+(make-obsolete-variable
+ 'gnus-debug-exclude-variables "it is no longer used." "24.1")
 
 (defcustom gnus-discouraged-post-methods
   '(nndraft nnml nnimap nnmaildir nnmh nnfolder nndir)
@@ -340,7 +345,6 @@ only affect the Gcc copy, but not the original message."
 (defvar gnus-article-yanked-articles nil)
 (defvar gnus-message-buffer "*Mail Gnus*")
 (defvar gnus-article-copy nil)
-(defvar gnus-check-before-posting nil)
 (defvar gnus-last-posting-server nil)
 (defvar gnus-message-group-art nil)
 
@@ -603,7 +607,7 @@ instead."
   (message-add-action
    `(progn
       (setq gnus-current-window-configuration ',winconf-name)
-      (when (gnus-buffer-exists-p ,buffer)
+      (when (gnus-buffer-live-p ,buffer)
 	(set-window-configuration ,winconf)))
    'exit 'postpone 'kill)
   (let ((to-be-marked (cond
@@ -613,7 +617,7 @@ instead."
 		       (article (if (listp article) article (list article)))
 		       (t nil))))
     (message-add-action
-     `(when (gnus-buffer-exists-p ,buffer)
+     `(when (gnus-buffer-live-p ,buffer)
 	(with-current-buffer ,buffer
 	  ,(when to-be-marked
 	     (if (eq config 'forward)
@@ -898,7 +902,7 @@ header line with the old Message-ID."
       (message-supersede)
       (push
        `((lambda ()
-	   (when (gnus-buffer-exists-p ,gnus-summary-buffer)
+           (when (gnus-buffer-live-p ,gnus-summary-buffer)
 	     (with-current-buffer ,gnus-summary-buffer
 	       (gnus-cache-possibly-remove-article ,article nil nil nil t)
 	       (gnus-summary-mark-as-read ,article gnus-canceled-mark)))))
@@ -918,8 +922,7 @@ header line with the old Message-ID."
     (mm-enable-multibyte))
   (let ((article-buffer (or article-buffer gnus-article-buffer))
 	end beg)
-    (if (not (and (get-buffer article-buffer)
-		  (gnus-buffer-exists-p article-buffer)))
+    (if (not (gnus-buffer-live-p article-buffer))
 	(error "Can't find any article buffer")
       (with-current-buffer article-buffer
 	(let ((gnus-newsgroup-charset (or gnus-article-charset
diff --git a/lisp/gnus/gnus-salt.el b/lisp/gnus/gnus-salt.el
index 58c05e0716..529cd8a337 100644
--- a/lisp/gnus/gnus-salt.el
+++ b/lisp/gnus/gnus-salt.el
@@ -573,9 +573,9 @@ Two predefined functions are available:
 	 (header (if (vectorp header) header
 		   (progn
 		     (setq header (make-mail-header "*****"))
-		     (mail-header-set-number header 0)
-		     (mail-header-set-lines header 0)
-		     (mail-header-set-chars header 0)
+		     (setf (mail-header-number header) 0)
+		     (setf (mail-header-lines header) 0)
+		     (setf (mail-header-chars header) 0)
 		     header)))
 	 (gnus-tmp-from (mail-header-from header))
 	 (gnus-tmp-subject (mail-header-subject header))
diff --git a/lisp/gnus/gnus-score.el b/lisp/gnus/gnus-score.el
index 2faf0f951d..72fcc64155 100644
--- a/lisp/gnus/gnus-score.el
+++ b/lisp/gnus/gnus-score.el
@@ -1098,7 +1098,7 @@ EXTRA is the possible non-standard header."
   (if (not gnus-current-score-file)
       (error "No current score file")
     (let ((winconf (current-window-configuration)))
-      (when (buffer-name gnus-summary-buffer)
+      (when (buffer-live-p gnus-summary-buffer)
 	(gnus-score-save))
       (gnus-make-directory (file-name-directory file))
       (setq gnus-score-edit-buffer (find-file-noselect file))
@@ -1126,7 +1126,7 @@ EXTRA is the possible non-standard header."
   (interactive
    (list (read-file-name "Edit score file: " gnus-kill-files-directory)))
   (gnus-make-directory (file-name-directory file))
-  (when (buffer-name gnus-summary-buffer)
+  (when (buffer-live-p gnus-summary-buffer)
     (gnus-score-save))
   (let ((winconf (current-window-configuration)))
     (setq gnus-score-edit-buffer (find-file-noselect file))
@@ -2341,9 +2341,7 @@ score in `gnus-newsgroup-scored' by SCORE."
 				  "references"
 				(symbol-name (caar elem)))
 			      (cdar elem)))
-		(setcar (car elem)
-			`(lambda (h)
-			   (,func h))))
+		(setcar (car elem) func))
 	      (setq elem (cdr elem)))
 	    (setq malist (cdr malist)))
 	  ;; Then we score away.
diff --git a/lisp/gnus/gnus-spec.el b/lisp/gnus/gnus-spec.el
index b236f0a401..47d722c914 100644
--- a/lisp/gnus/gnus-spec.el
+++ b/lisp/gnus/gnus-spec.el
@@ -150,7 +150,7 @@ Return a list of updated types."
 	(let ((buffer (intern (format "gnus-%s-buffer" type))))
 	  (when (and (boundp buffer)
 		     (setq val (symbol-value buffer))
-		     (gnus-buffer-exists-p val))
+                     (gnus-buffer-live-p val))
 	    (set-buffer val))
 	  (setq new-format (symbol-value
 			    (intern (format "gnus-%s-line-format" type)))))
diff --git a/lisp/gnus/gnus-srvr.el b/lisp/gnus/gnus-srvr.el
index 76a0f7d0fd..972ff28e63 100644
--- a/lisp/gnus/gnus-srvr.el
+++ b/lisp/gnus/gnus-srvr.el
@@ -1086,8 +1086,7 @@ Requesting compaction of %s... (this may take a long time)"
       ;; Invalidate the original article buffer which might be out of date.
       ;; #### NOTE: Yes, this might be a bit rude, but since compaction
       ;; #### will not happen very often, I think this is acceptable.
-      (let ((original (get-buffer gnus-original-article-buffer)))
-	(and original (gnus-kill-buffer original))))))
+      (gnus-kill-buffer gnus-original-article-buffer))))
 
 (defun gnus-server-toggle-cloud-server ()
   "Toggle whether the server under point is replicated in the Emacs Cloud."
diff --git a/lisp/gnus/gnus-start.el b/lisp/gnus/gnus-start.el
index 2beb685822..85aefe0f5f 100644
--- a/lisp/gnus/gnus-start.el
+++ b/lisp/gnus/gnus-start.el
@@ -583,12 +583,9 @@ Can be used to turn version control on or off."
 
 (defun gnus-subscribe-alphabetically (newgroup)
   "Subscribe new NEWGROUP and insert it in alphabetical order."
-  (let ((groups (cdr gnus-newsrc-alist))
-	before)
-    (while (and (not before) groups)
-      (if (string< newgroup (caar groups))
-	  (setq before (caar groups))
-	(setq groups (cdr groups))))
+  (let ((before (seq-find (lambda (group)
+			    (string< newgroup group))
+			  (cdr gnus-group-list))))
     (gnus-subscribe-newsgroup newgroup before)))
 
 (defun gnus-subscribe-hierarchically (newgroup)
@@ -618,15 +615,15 @@ It is inserted in hierarchical newsgroup order if subscribed.  If not,
 it is killed."
   (if (gnus-y-or-n-p (format "Subscribe new newsgroup %s? " group))
       (gnus-subscribe-hierarchically group)
-    (push group gnus-killed-list)))
+    (gnus-subscribe-killed group)))
 
 (defun gnus-subscribe-zombies (group)
   "Make the new GROUP into a zombie group."
-  (push group gnus-zombie-list))
+  (cl-pushnew group gnus-zombie-list :test #'equal))
 
 (defun gnus-subscribe-killed (group)
   "Make the new GROUP a killed group."
-  (push group gnus-killed-list))
+  (cl-pushnew group gnus-killed-list :test #'equal))
 
 (defun gnus-subscribe-newsgroup (newsgroup &optional next)
   "Subscribe new NEWSGROUP.
@@ -723,11 +720,10 @@ the first newsgroup."
   ;; Kill Gnus buffers.
   (do-auto-save t)
   (dolist (buffer (gnus-buffers))
-    (when (gnus-buffer-exists-p buffer)
-      (with-current-buffer buffer
-	(set-buffer-modified-p nil)
-	(when (local-variable-p 'kill-buffer-hook)
-	  (setq kill-buffer-hook nil))))
+    (with-current-buffer buffer
+      (set-buffer-modified-p nil)
+      (when (local-variable-p 'kill-buffer-hook)
+        (setq kill-buffer-hook nil)))
     (gnus-kill-buffer buffer))
   ;; Remove Gnus frames.
   (gnus-kill-gnus-frames))
@@ -845,8 +841,7 @@ prompt the user for the name of an NNTP server to use."
   "Enter STRING into the dribble buffer.
 If REGEXP is given, lines that match it will be deleted."
   (when (and (not gnus-dribble-ignore)
-	     gnus-dribble-buffer
-	     (buffer-name gnus-dribble-buffer))
+             (buffer-live-p gnus-dribble-buffer))
     (let ((obuf (current-buffer)))
       (set-buffer gnus-dribble-buffer)
       (when regexp
@@ -938,14 +933,13 @@ If REGEXP is given, lines that match it will be deleted."
 	(set-buffer-modified-p nil)))))
 
 (defun gnus-dribble-save ()
-  (when (and gnus-dribble-buffer
-	     (buffer-name gnus-dribble-buffer))
+  (when (buffer-live-p gnus-dribble-buffer)
     (with-current-buffer gnus-dribble-buffer
       (when (> (buffer-size) 0)
 	(save-buffer)))))
 
 (defun gnus-dribble-clear ()
-  (when (gnus-buffer-exists-p gnus-dribble-buffer)
+  (when (gnus-buffer-live-p gnus-dribble-buffer)
     (with-current-buffer gnus-dribble-buffer
       (erase-buffer)
       (set-buffer-modified-p nil)
@@ -1819,7 +1813,8 @@ The info element is shared with the same element of
   (let ((alist gnus-newsrc-alist)
 	(ohashtb gnus-newsrc-hashtb)
 	info method gname rest methods)
-    (setq gnus-newsrc-hashtb (gnus-make-hashtable (length alist)))
+    (setq gnus-newsrc-hashtb (gnus-make-hashtable (length alist))
+	  gnus-group-list nil)
     (setq alist
 	  (setq gnus-newsrc-alist
 		(if (equal (caar gnus-newsrc-alist)
@@ -2146,14 +2141,14 @@ The info element is shared with the same element of
 	    (if (and (stringp (progn
 				(setq group (read cur)
 				      group
-				      (encode-coding-string
-				       (cond ((numberp group)
-					      (number-to-string group))
-					     ((symbolp group)
-					      (symbol-name group))
-					     ((stringp group)
-					      group))
-				       'latin-1))))
+				      (cond ((numberp group)
+					     (number-to-string group))
+					    ((symbolp group)
+					     (encode-coding-string
+					      (symbol-name group)
+					      'latin-1))
+					    ((stringp group)
+					     group)))))
 		     (numberp (setq max (read cur)))
 		     (numberp (setq min (read cur)))
 		     (null (progn
@@ -2728,8 +2723,7 @@ values from `gnus-newsrc-hashtb', and write a new value of
     (save-excursion
       (if (and (or gnus-use-dribble-file gnus-slave)
 	       (not force)
-	       (or (not gnus-dribble-buffer)
-		   (not (buffer-name gnus-dribble-buffer))
+               (or (not (buffer-live-p gnus-dribble-buffer))
 		   (zerop (with-current-buffer gnus-dribble-buffer
 			    (buffer-size)))))
 	  (gnus-message 4 "(No changes need to be saved)")
diff --git a/lisp/gnus/gnus-sum.el b/lisp/gnus/gnus-sum.el
index b8aa302f11..4c4445275a 100644
--- a/lisp/gnus/gnus-sum.el
+++ b/lisp/gnus/gnus-sum.el
@@ -1,4 +1,4 @@
-;;; gnus-sum.el --- summary mode commands for Gnus
+;;; gnus-sum.el --- summary mode commands for Gnus  -*- lexical-binding:t -*-
 
 ;; Copyright (C) 1996-2019 Free Software Foundation, Inc.
 
@@ -42,6 +42,7 @@
 (defvar gnus-tmp-indentation)
 (defvar gnus-tmp-level)
 (defvar gnus-tmp-lines)
+(defvar gnus-tmp-name)
 (defvar gnus-tmp-number)
 (defvar gnus-tmp-opening-bracket)
 (defvar gnus-tmp-process)
@@ -50,6 +51,7 @@
 (defvar gnus-tmp-score-char)
 (defvar gnus-tmp-subject)
 (defvar gnus-tmp-subject-or-nil)
+(defvar gnus-tmp-thread)
 (defvar gnus-tmp-unread)
 (defvar gnus-tmp-unread-and-unselected)
 (defvar gnus-tmp-unread-and-unticked)
@@ -243,7 +245,7 @@ fill in all gaps that Gnus manages to guess."
 		 (sexp :menu-tag "all" t)))
 
 (defcustom gnus-summary-thread-gathering-function
-  'gnus-gather-threads-by-subject
+  #'gnus-gather-threads-by-subject
   "Function used for gathering loose threads.
 There are two pre-defined functions: `gnus-gather-threads-by-subject',
 which only takes Subjects into consideration; and
@@ -539,7 +541,7 @@ this variable specifies group names."
 			 (cons :value ("" "") regexp (repeat string))
 			 (sexp :value nil))))
 
-(defcustom gnus-move-group-prefix-function 'gnus-group-real-prefix
+(defcustom gnus-move-group-prefix-function #'gnus-group-real-prefix
   "Function used to compute default prefix for article move/copy/etc prompts.
 The function should take one argument, a group name, and return a
 string with the suggested prefix."
@@ -947,7 +949,7 @@ according to the value of `gnus-thread-sort-functions'."
 		    (function :tag "other"))
 	    (boolean :tag "Reverse order")))))
 
-(defcustom gnus-thread-score-function '+
+(defcustom gnus-thread-score-function #'+
   "Function used for calculating the total score of a thread.
 
 The function is called with the scores of the article and each
@@ -1014,10 +1016,9 @@ following hook:
  (add-hook gnus-select-group-hook
 	   (lambda ()
 	     (mapcar (lambda (header)
-		       (mail-header-set-subject
-			header
-			(gnus-simplify-subject
-			 (mail-header-subject header) \\='re-only)))
+		       (setf (mail-header-subject header)
+		             (gnus-simplify-subject
+		              (mail-header-subject header) \\='re-only)))
 		     gnus-newsgroup-headers)))"
   :group 'gnus-group-select
   :type 'hook)
@@ -1171,11 +1172,11 @@ which it may alter in any way."
 		 function)
   :group 'gnus-summary)
 
-(defvar gnus-decode-encoded-word-function 'mail-decode-encoded-word-string
+(defvar gnus-decode-encoded-word-function #'mail-decode-encoded-word-string
   "Function used to decode a string with encoded words.")
 
 (defvar gnus-decode-encoded-address-function
-  'mail-decode-encoded-address-string
+  #'mail-decode-encoded-address-string
   "Function used to decode addresses with encoded words.")
 
 (defcustom gnus-extra-headers '(To Cc Keywords Gcc Newsgroups X-GM-LABELS)
@@ -1373,7 +1374,7 @@ the normal Gnus MIME machinery."
 
 (defvar gnus-thread-indent-array nil)
 (defvar gnus-thread-indent-array-level gnus-thread-indent-level)
-(defvar gnus-sort-gathered-threads-function 'gnus-thread-sort-by-number
+(defvar gnus-sort-gathered-threads-function #'gnus-thread-sort-by-number
   "Function called to sort the articles within a thread after it has been gathered together.")
 
 (defvar gnus-summary-save-parts-type-history nil)
@@ -1444,15 +1445,17 @@ the normal Gnus MIME machinery."
     (?\< (make-string (max 0 (- 20 gnus-tmp-level)) ? ) ?s)
     (?i gnus-tmp-score ?d)
     (?z gnus-tmp-score-char ?c)
-    (?V (gnus-thread-total-score (and (boundp 'thread) (car thread))) ?d)
+    (?V (gnus-thread-total-score
+         (and (boundp 'gnus-tmp-thread) (car gnus-tmp-thread)))
+        ?d)
     (?U gnus-tmp-unread ?c)
     (?f (gnus-summary-from-or-to-or-newsgroups gnus-tmp-header gnus-tmp-from)
 	?s)
     (?t (gnus-summary-number-of-articles-in-thread
-	 (and (boundp 'thread) (car thread)) gnus-tmp-level)
+	 (and (boundp 'gnus-tmp-thread) (car gnus-tmp-thread)) gnus-tmp-level)
 	?d)
     (?e (gnus-summary-number-of-articles-in-thread
-	 (and (boundp 'thread) (car thread)) gnus-tmp-level t)
+	 (and (boundp 'gnus-tmp-thread) (car gnus-tmp-thread)) gnus-tmp-level t)
 	?c)
     (?u gnus-tmp-user-defined ?s)
     (?P (gnus-pick-line-number) ?d)
@@ -1706,6 +1709,7 @@ For example:
   ;; already been loaded (avoids infinite recursion)
   (with-no-warnings (defvar features))  ;Not just a local variable.
   (let ((features (cons 'gnus-sum features)))
+    ;; FIXME: Break this mutual dependency.
     (require 'gnus-art)))
 
 ;; MIME stuff.
@@ -1812,7 +1816,7 @@ matter is removed.  Additional things can be deleted by setting
       (setq modified-tick (buffer-modified-tick))
       (cond
        ((listp regexp)
-	(mapc 'gnus-simplify-buffer-fuzzy-step regexp))
+	(mapc #'gnus-simplify-buffer-fuzzy-step regexp))
        (regexp
 	(gnus-simplify-buffer-fuzzy-step regexp)))
       (gnus-simplify-buffer-fuzzy-step "^ *\\[[-+?*!][-+?*!]\\] *")
@@ -2482,13 +2486,13 @@ increase the score of each group you read."
 		     (let ((command (intern (format "\
 gnus-summary-show-article-from-menu-as-charset-%s" cs))))
 		       (fset command
-			     `(lambda ()
-				(interactive)
-				(let ((gnus-summary-show-article-charset-alist
-				       '((1 . ,cs))))
-				  (gnus-summary-show-article 1))))
+			     (lambda ()
+			       (interactive)
+			       (let ((gnus-summary-show-article-charset-alist
+				      `((1 . ,cs))))
+				 (gnus-summary-show-article 1))))
 		       `[,(symbol-name cs) ,command t]))
-		   (sort (coding-system-list) 'string<)))))
+		   (sort (coding-system-list) #'string<)))))
 	     ("Washing"
 	      ("Remove Blanks"
 	       ["Leading" gnus-article-strip-leading-blank-lines t]
@@ -2676,15 +2680,15 @@ gnus-summary-show-article-from-menu-as-charset-%s" cs))))
 	   (interactive)
 	   (setq message-cite-function
 		 (if (eq message-cite-function
-			 'message-cite-original-without-signature)
-		     'message-cite-original
-		   'message-cite-original-without-signature)))
+			 #'message-cite-original-without-signature)
+		     #'message-cite-original
+		   #'message-cite-original-without-signature)))
 	 :visible (memq message-cite-function
 			'(message-cite-original-without-signature
 			  message-cite-original))
 	 :style toggle
 	 :selected (eq message-cite-function
-		       'message-cite-original-without-signature)
+		       #'message-cite-original-without-signature)
 	 :help "Strip signature from cited article when replying."]))
 
     (cond
@@ -3026,7 +3030,7 @@ When FORCE, rebuild the tool bar."
 	  header)
       (list
        (apply
-	'nconc
+	#'nconc
 	(list
 	 (if (eq type 'lower)
 	     "Lower score"
@@ -3037,7 +3041,7 @@ When FORCE, rebuild the tool bar."
 	    (setq outh
 		  (cons
 		   (apply
-		    'nconc
+		    #'nconc
 		    (list (car header))
 		    (let ((ts (cdr (assoc (nth 2 header) types)))
 			  outt)
@@ -3045,7 +3049,7 @@ When FORCE, rebuild the tool bar."
 			(setq outt
 			      (cons
 			       (apply
-				'nconc
+				#'nconc
 				(list (caar ts))
 				(let ((ps perms)
 				      outp)
@@ -3133,10 +3137,10 @@ The following commands are available:
   (make-local-variable 'gnus-article-buffer)
   (make-local-variable 'gnus-article-current)
   (make-local-variable 'gnus-original-article-buffer)
-  (add-hook 'pre-command-hook 'gnus-set-global-variables nil t)
+  (add-hook 'pre-command-hook #'gnus-set-global-variables nil t)
   (mm-enable-multibyte)
   (set (make-local-variable 'bookmark-make-record-function)
-       'gnus-summary-bookmark-make-record))
+       #'gnus-summary-bookmark-make-record))
 
 (defun gnus-summary-make-local-variables ()
   "Make all the local summary buffer variables."
@@ -3153,53 +3157,33 @@ The following commands are available:
 
 ;; Summary data functions.
 
-(defmacro gnus-data-number (data)
-  `(car ,data))
-
-(defmacro gnus-data-set-number (data number)
-  `(setcar ,data ,number))
-
-(defmacro gnus-data-mark (data)
-  `(nth 1 ,data))
-
-(defmacro gnus-data-set-mark (data mark)
-  `(setcar (nthcdr 1 ,data) ,mark))
-
-(defmacro gnus-data-pos (data)
-  `(nth 2 ,data))
-
-(defmacro gnus-data-set-pos (data pos)
-  `(setcar (nthcdr 2 ,data) ,pos))
-
-(defmacro gnus-data-header (data)
-  `(nth 3 ,data))
-
-(defmacro gnus-data-set-header (data header)
-  `(setf (nth 3 ,data) ,header))
+(cl-defstruct (gnus-data
+               (:constructor nil)
+               (:constructor gnus-data-make (number mark pos header level))
+               ;; In gnus-data-find-in, we rely on (car data) returning the
+               ;; number, because we use `assq' on a list of gnus-data.
+               (:type list))
+  number mark pos header level)
 
-(defmacro gnus-data-level (data)
-  `(nth 4 ,data))
+(define-inline gnus-data-unread-p (data)
+  (inline-quote (= (gnus-data-mark ,data) gnus-unread-mark)))
 
-(defmacro gnus-data-unread-p (data)
-  `(= (nth 1 ,data) gnus-unread-mark))
+(define-inline gnus-data-read-p (data)
+  (inline-quote (/= (gnus-data-mark ,data) gnus-unread-mark)))
 
-(defmacro gnus-data-read-p (data)
-  `(/= (nth 1 ,data) gnus-unread-mark))
+(define-inline gnus-data-pseudo-p (data)
+  (inline-quote (consp (gnus-data-header ,data))))
 
-(defmacro gnus-data-pseudo-p (data)
-  `(consp (nth 3 ,data)))
+(defalias 'gnus-data-find-in #'assq)
 
-(defmacro gnus-data-find (number)
-  `(assq ,number gnus-newsgroup-data))
+(define-inline gnus-data-find (number)
+  (inline-quote (gnus-data-find-in ,number gnus-newsgroup-data)))
 
 (defmacro gnus-data-find-list (number &optional data)
   `(let ((bdata ,(or data 'gnus-newsgroup-data)))
-     (memq (assq ,number bdata)
+     (memq (gnus-data-find-in ,number bdata)
 	   bdata)))
 
-(defmacro gnus-data-make (number mark pos header level)
-  `(list ,number ,mark ,pos ,header ,level))
-
 (defun gnus-data-enter (after-article number mark pos header level offset)
   (let ((data (gnus-data-find-list after-article)))
     (unless data
@@ -3267,7 +3251,7 @@ The following commands are available:
 
 (defun gnus-summary-article-pseudo-p (article)
   "Say whether this article is a pseudo article or not."
-  (not (vectorp (gnus-data-header (gnus-data-find article)))))
+  (not (mail-header-p (gnus-data-header (gnus-data-find article)))))
 
 (defmacro gnus-summary-article-sparse-p (article)
   "Say whether this article is a sparse article or not."
@@ -3289,9 +3273,10 @@ The following commands are available:
       (setq data (cdr data)))
     children))
 
-(defmacro gnus-summary-skip-intangible ()
+(defsubst gnus-summary-skip-intangible ()
+  ;; FIXME: Does this really warrant a `defsubst'?
   "If the current article is intangible, then jump to a different article."
-  '(let ((to (get-text-property (point) 'gnus-intangible)))
+   (let ((to (get-text-property (point) 'gnus-intangible)))
      (and to (gnus-summary-goto-subject to))))
 
 (defmacro gnus-summary-article-intangible-p ()
@@ -3300,19 +3285,20 @@ The following commands are available:
 
 ;; Some summary mode macros.
 
-(defmacro gnus-summary-article-number ()
+(defsubst gnus-summary-article-number ()
   "The article number of the article on the current line.
 If there isn't an article number here, then we return the current
 article number."
-  '(progn
-     (gnus-summary-skip-intangible)
-     (or (get-text-property (point) 'gnus-number)
-	 (gnus-summary-last-subject))))
+  (gnus-summary-skip-intangible)
+  (or (get-text-property (point) 'gnus-number)
+      (gnus-summary-last-subject)))
 
-(defmacro gnus-summary-article-header (&optional number)
+(define-inline gnus-summary-article-header (&optional number)
   "Return the header of article NUMBER."
-  `(gnus-data-header (gnus-data-find
-		      ,(or number '(gnus-summary-article-number)))))
+  (inline-quote
+   (gnus-data-header (gnus-data-find
+		      ,(or number
+                           (inline-quote (gnus-summary-article-number)))))))
 
 (defmacro gnus-summary-thread-level (&optional number)
   "Return the level of thread that starts with article NUMBER."
@@ -3332,17 +3318,17 @@ article number."
   `(gnus-data-pos (gnus-data-find
 		   ,(or number '(gnus-summary-article-number)))))
 
-(defalias 'gnus-summary-subject-string 'gnus-summary-article-subject)
-(defmacro gnus-summary-article-subject (&optional number)
+(defalias 'gnus-summary-subject-string #'gnus-summary-article-subject)
+(defsubst gnus-summary-article-subject (&optional number)
+  ;; FIXME: Does this really warrant a defsubst?
   "Return current subject string or nil if nothing."
-  `(let ((headers
-	  ,(if number
-	       `(gnus-data-header (assq ,number gnus-newsgroup-data))
-	     '(gnus-data-header (assq (gnus-summary-article-number)
-				      gnus-newsgroup-data)))))
-     (and headers
-	  (vectorp headers)
-	  (mail-header-subject headers))))
+  (let ((headers
+	 (gnus-data-header
+          (gnus-data-find (or number
+	                      (gnus-summary-article-number))))))
+    (and headers
+	 (mail-header-p headers)
+	 (mail-header-subject headers))))
 
 (defmacro gnus-summary-article-score (&optional number)
   "Return current article score."
@@ -3409,14 +3395,13 @@ marks of articles."
 
 (defmacro gnus-save-hidden-threads (&rest forms)
   "Save hidden threads, eval FORMS, and restore the hidden threads."
+  (declare (indent 0) (debug t))
   (let ((config (make-symbol "config")))
     `(let ((,config (gnus-hidden-threads-configuration)))
        (unwind-protect
 	   (save-excursion
 	     ,@forms)
 	 (gnus-restore-hidden-threads-configuration ,config)))))
-(put 'gnus-save-hidden-threads 'lisp-indent-function 0)
-(put 'gnus-save-hidden-threads 'edebug-form-spec '(body))
 
 (defun gnus-data-compute-positions ()
   "Compute the positions of all articles."
@@ -3429,7 +3414,7 @@ marks of articles."
 	(while data
 	  (while (get-text-property (point) 'gnus-intangible)
 	    (forward-line 1))
-	  (gnus-data-set-pos (car data) (+ (point) 3))
+	  (setf (gnus-data-pos (car data)) (+ (point) 3))
 	  (setq data (cdr data))
 	  (forward-line 1))))))
 
@@ -3514,8 +3499,7 @@ Returns non-nil if the setup was successful."
 	(dead-name (concat "*Dead Summary "
 			   (gnus-group-decoded-name group) "*")))
     ;; If a dead summary buffer exists, we kill it.
-    (when (gnus-buffer-live-p dead-name)
-      (gnus-kill-buffer dead-name))
+    (gnus-kill-buffer dead-name)
     (if (get-buffer buffer)
 	(progn
 	  (set-buffer buffer)
@@ -3599,6 +3583,12 @@ buffer that was in action when the last article was fetched."
       t
     (not (cdr (gnus-data-find-list article)))))
 
+(defconst gnus--dummy-mail-header
+  (make-full-mail-header 0 "" "" "05 Apr 2001 23:33:09 +0400" "" "" 0 0 "" nil))
+
+(defconst gnus--dummy-data-list
+  (list (gnus-data-make 0 nil nil gnus--dummy-mail-header nil)))
+
 (defun gnus-make-thread-indent-array (&optional n)
   (when (or n
 	    (progn (setq n 200) nil)
@@ -3614,7 +3604,7 @@ buffer that was in action when the last article was fetched."
 (defun gnus-update-summary-mark-positions ()
   "Compute where the summary marks are to go."
   (save-excursion
-    (when (gnus-buffer-exists-p gnus-summary-buffer)
+    (when (gnus-buffer-live-p gnus-summary-buffer)
       (set-buffer gnus-summary-buffer))
     (let ((spec gnus-summary-line-format-spec)
 	  pos)
@@ -3626,11 +3616,13 @@ buffer that was in action when the last article was fetched."
 	      (gnus-score-over-mark ?Z)
 	      (gnus-undownloaded-mark ?Z)
 	      (gnus-summary-line-format-spec spec)
+              ;; Make sure `gnus-data-find' finds a dummy element
+              ;; so we don't call gnus-data-<field> accessors on nil.
+              (gnus-newsgroup-data gnus--dummy-data-list)
 	      (gnus-newsgroup-downloadable '(0))
-	      (header [0 "" "" "05 Apr 2001 23:33:09 +0400" "" "" 0 0 "" nil])
 	      case-fold-search ignores)
 	  ;; Here, all marks are bound to Z.
-	  (gnus-summary-insert-line header
+	  (gnus-summary-insert-line gnus--dummy-mail-header
 				    0 nil t gnus-tmp-unread t nil "" nil 1)
 	  (goto-char (point-min))
 	  ;; Memorize the positions of the same characters as dummy marks.
@@ -3644,7 +3636,7 @@ buffer that was in action when the last article was fetched."
 		gnus-score-below-mark ?C
 		gnus-score-over-mark ?C
 		gnus-undownloaded-mark ?D)
-	  (gnus-summary-insert-line header
+	  (gnus-summary-insert-line gnus--dummy-mail-header
 				    0 nil t gnus-tmp-unread t nil "" nil 1)
 	  ;; Ignore characters which aren't dummy marks.
 	  (dolist (p ignores)
@@ -3783,9 +3775,9 @@ buffer that was in action when the last article was fetched."
       (setq gnus-tmp-name gnus-tmp-from))
     (unless (numberp gnus-tmp-lines)
       (setq gnus-tmp-lines -1))
-    (if (= gnus-tmp-lines -1)
-	(setq gnus-tmp-lines "?")
-      (setq gnus-tmp-lines (number-to-string gnus-tmp-lines)))
+    (setq gnus-tmp-lines (if (= gnus-tmp-lines -1)
+	                     "?"
+                           (number-to-string gnus-tmp-lines)))
     (condition-case ()
 	(put-text-property
 	 (point)
@@ -3843,8 +3835,8 @@ the thread are to be displayed."
 	    1)
 	   ((and (consp thread) (cdr thread))
 	    (apply
-	     '+ 1 (mapcar
-		   'gnus-summary-number-of-articles-in-thread (cdr thread))))
+	     #'+ 1 (mapcar
+		    #'gnus-summary-number-of-articles-in-thread (cdr thread))))
 	   ((null thread)
 	    1)
 	   ((memq (mail-header-number (car thread)) gnus-newsgroup-limit)
@@ -3852,9 +3844,9 @@ the thread are to be displayed."
 	   (t 0))))
     (when (and level (zerop level) gnus-tmp-new-adopts)
       (cl-incf number
-	    (apply '+ (mapcar
-		       'gnus-summary-number-of-articles-in-thread
-		       gnus-tmp-new-adopts))))
+	    (apply #'+ (mapcar
+		        #'gnus-summary-number-of-articles-in-thread
+		        gnus-tmp-new-adopts))))
     (if char
 	(if (> number 1) gnus-not-empty-thread-mark
 	  gnus-empty-thread-mark)
@@ -4074,9 +4066,10 @@ If SELECT-ARTICLES, only select those articles from GROUP."
       (unless no-display
 	(gnus-summary-prepare))
       (when gnus-use-trees
-	(gnus-tree-open)
+	(gnus-tree-open)                ;Autoloaded from gnus-salt.
+        (declare-function gnus-tree-highlight-article "gnus-salt" (article face))
 	(setq gnus-summary-highlight-line-function
-	      'gnus-tree-highlight-article))
+	      #'gnus-tree-highlight-article))
       ;; If the summary buffer is empty, but there are some low-scored
       ;; articles or some excluded dormants, we include these in the
       ;; buffer.
@@ -4338,7 +4331,7 @@ If SELECT-ARTICLES, only select those articles from GROUP."
 		(when (and (car refs)
 			   (not (zerop
 				 (apply
-				  '+
+				  #'+
 				  (mapcar
 				   (lambda (thread)
 				     (gnus-thread-loop-p
@@ -4398,7 +4391,7 @@ Returns HEADER if it was entered in the DEPENDENCIES.  Returns nil otherwise."
       (setq id-dep (puthash (setq id (nnmail-message-id))
 			    (list header)
 			    dependencies))
-      (mail-header-set-id header id))
+      (setf (mail-header-id header) id))
 
      ;; The last case ignores an existing entry, except it adds any
      ;; additional Xrefs (in case the two articles came from different
@@ -4406,11 +4399,10 @@ Returns HEADER if it was entered in the DEPENDENCIES.  Returns nil otherwise."
      ;; Also sets `header' to nil meaning that the `dependencies'
      ;; table was *not* modified.
      (t
-      (mail-header-set-xref
-       (car id-dep)
-       (concat (or (mail-header-xref (car id-dep))
-		   "")
-	       (or (mail-header-xref header) "")))
+      (setf (mail-header-xref (car id-dep))
+            (concat (or (mail-header-xref (car id-dep))
+		        "")
+	            (or (mail-header-xref header) "")))
       (setq header nil)))
 
     (when (and header (not replaced))
@@ -4424,7 +4416,7 @@ Returns HEADER if it was entered in the DEPENDENCIES.  Returns nil otherwise."
 	    ;; Yuk!  This is a reference loop.  Make the article be a
 	    ;; root article.
 	    (progn
-	      (mail-header-set-references (car id-dep) "none")
+	      (setf (mail-header-references (car id-dep)) "none")
 	      (setq ref nil)
 	      (setq parent-id nil))
 	  (setq ref (gnus-parent-id (mail-header-references ref-header)))))
@@ -4479,7 +4471,7 @@ Returns HEADER if it was entered in the DEPENDENCIES.  Returns nil otherwise."
 	  (erase-buffer)))
       (kill-buffer (current-buffer)))
     ;; Sort over trustworthiness.
-    (dolist (relation (sort relations 'car-less-than-car))
+    (dolist (relation (sort relations #'car-less-than-car))
       (when (gnus-dependencies-add-header
 	     (make-full-mail-header
 	      gnus-reffed-article-number
@@ -4562,8 +4554,8 @@ Returns HEADER if it was entered in the DEPENDENCIES.  Returns nil otherwise."
     (when (and (string= references "")
 	       (setq in-reply-to (mail-header-extra header))
 	       (setq in-reply-to (cdr (assq 'In-Reply-To in-reply-to))))
-      (mail-header-set-references
-       header (gnus-extract-message-id-from-in-reply-to in-reply-to)))
+      (setf (mail-header-references header)
+            (gnus-extract-message-id-from-in-reply-to in-reply-to)))
 
     (when gnus-alter-header-function
       (funcall gnus-alter-header-function header))
@@ -4703,7 +4695,7 @@ the id of the parent article (if any)."
 	  (delq thread parent)))
       (if (gnus-summary-insert-subject id header)
 	  ;; Set the (possibly) new article number in the data structure.
-	  (gnus-data-set-number data (gnus-id-to-article id))
+	  (setf (gnus-data-number data) (gnus-id-to-article id))
 	(setcar thread old)
 	nil))))
 
@@ -4828,7 +4820,7 @@ If LINE, insert the rebuilt thread starting on line LINE."
 (defun gnus-articles-in-thread (thread)
   "Return the list of articles in THREAD."
   (cons (mail-header-number (car thread))
-	(mapcan 'gnus-articles-in-thread (cdr thread))))
+	(mapcan #'gnus-articles-in-thread (cdr thread))))
 
 (defun gnus-remove-thread (id &optional dont-remove)
   "Remove the thread that has ID in it."
@@ -4916,7 +4908,8 @@ If LINE, insert the rebuilt thread starting on line LINE."
 			  (and (cdr thread)
 			       (gnus-sort-subthreads-recursive
 				(cdr thread) subthread-sort-func))))
-		  threads) func)))
+		  threads)
+          func)))
 
 (defun gnus-sort-subthreads-recursive (threads func)
   ;; Responsible for sorting subthreads.
@@ -4924,7 +4917,8 @@ If LINE, insert the rebuilt thread starting on line LINE."
 		  (cons (car thread)
 			(and (cdr thread)
 			     (gnus-sort-subthreads-recursive (cdr thread) func))))
-		threads) func))
+		threads)
+        func))
 
 (defun gnus-sort-threads-loop (threads func)
   (let* ((superthread (cons nil threads))
@@ -4999,14 +4993,12 @@ using some other form will lead to serious barfage."
   (gnus-article-sort-by-number
    (gnus-thread-header h1) (gnus-thread-header h2)))
 
-(defsubst gnus-article-sort-by-random (h1 h2)
+(defsubst gnus-article-sort-by-random (_h1 _h2)
   "Sort articles randomly."
   (zerop (random 2)))
 
-(defun gnus-thread-sort-by-random (h1 h2)
-  "Sort threads randomly."
-  (gnus-article-sort-by-random
-   (gnus-thread-header h1) (gnus-thread-header h2)))
+(defalias 'gnus-thread-sort-by-random #'gnus-article-sort-by-random
+  "Sort threads randomly.")
 
 (defsubst gnus-article-sort-by-lines (h1 h2)
   "Sort articles by article Lines header."
@@ -5122,7 +5114,7 @@ Unscored articles will be counted as having a score of zero."
    ((consp thread)
     (if (stringp (car thread))
 	(apply gnus-thread-score-function 0
-	       (mapcar 'gnus-thread-total-score-1 (cdr thread)))
+	       (mapcar #'gnus-thread-total-score-1 (cdr thread)))
       (gnus-thread-total-score-1 thread)))
    (t
     (gnus-thread-total-score-1 (list thread)))))
@@ -5137,7 +5129,7 @@ Unscored articles will be counted as having a score of zero."
 
 (defun gnus-thread-highest-number (thread)
   "Return the highest article number in THREAD."
-  (apply 'max (mapcar (lambda (header)
+  (apply #'max (mapcar (lambda (header)
 			(mail-header-number header))
 		      (flatten-tree thread))))
 
@@ -5155,7 +5147,7 @@ Unscored articles will be counted as having a score of zero."
 ; quite a bit to use gnus-date-get-time, which caches the time value.
 (defun gnus-thread-latest-date (thread)
   "Return the highest article date in THREAD."
-  (apply 'max
+  (apply #'max
 	 (mapcar (lambda (header) (float-time
 				   (gnus-date-get-time
 				    (mail-header-date header))))
@@ -5166,7 +5158,7 @@ Unscored articles will be counted as having a score of zero."
   (setq root (car root))
   (apply gnus-thread-score-function
 	 (or (append
-	      (mapcar 'gnus-thread-total-score
+	      (mapcar #'gnus-thread-total-score
 		      (cdr (gnus-id-to-thread (mail-header-id root))))
 	      (when (> (mail-header-number root) 0)
 		(list (or (cdr (assq (mail-header-number root)
@@ -5262,7 +5254,7 @@ or a straight list of headers."
 	gnus-tmp-header gnus-tmp-unread gnus-tmp-downloaded
 	gnus-tmp-replied gnus-tmp-subject-or-nil
 	gnus-tmp-dummy gnus-tmp-indentation gnus-tmp-lines gnus-tmp-score
-	gnus-tmp-score-char gnus-tmp-from gnus-tmp-name
+	gnus-tmp-score-char gnus-tmp-from gnus-tmp-name gnus-tmp-thread
 	gnus-tmp-number gnus-tmp-opening-bracket gnus-tmp-closing-bracket
 	tree-stack)
 
@@ -5500,7 +5492,7 @@ or a straight list of headers."
 		     (t
 		      (or gnus-sum-thread-tree-single-indent subject))))
 	      (t
-	       (concat (apply 'concat
+	       (concat (apply #'concat
 			      (mapcar (lambda (item)
 					(if (= item 1)
 					    gnus-sum-thread-tree-vertical
@@ -5513,9 +5505,10 @@ or a straight list of headers."
 	      (setq gnus-tmp-name gnus-tmp-from))
 	    (unless (numberp gnus-tmp-lines)
 	      (setq gnus-tmp-lines -1))
-	    (if (= gnus-tmp-lines -1)
-		(setq gnus-tmp-lines "?")
-	      (setq gnus-tmp-lines (number-to-string gnus-tmp-lines)))
+	    (setq gnus-tmp-lines (if (= gnus-tmp-lines -1)
+		                     "?"
+                                   (number-to-string gnus-tmp-lines)))
+            (setq gnus-tmp-thread thread)
 	    (put-text-property
 	     (point)
 	     (progn (eval gnus-summary-line-format-spec) (point))
@@ -5594,7 +5587,7 @@ or a straight list of headers."
   "Get list identifier regexp for GROUP."
   (or (gnus-parameter-list-identifier group)
       (if (consp gnus-list-identifiers)
-          (mapconcat 'identity gnus-list-identifiers " *\\|")
+          (mapconcat #'identity gnus-list-identifiers " *\\|")
         gnus-list-identifiers)))
 
 (defun gnus-summary-remove-list-identifiers ()
@@ -5616,7 +5609,7 @@ or a straight list of headers."
 	    (setq subject
 		  (concat (substring subject 0 (match-beginning 1))
 			  (substring subject (match-end 1)))))
-	  (mail-header-set-subject header subject))))))
+	  (setf (mail-header-subject header) subject))))))
 
 (defun gnus-fetch-headers (articles &optional limit force-new dependencies)
   "Fetch headers of ARTICLES."
@@ -5695,11 +5688,11 @@ If SELECT-ARTICLES, only select those articles from GROUP."
 	     ((not (zerop (or (car-safe read-all) 0)))
 	      ;; The user entered the group with C-u SPC/RET, let's show
 	      ;; all articles.
-	      'gnus-not-ignore)
+	      #'gnus-not-ignore)
 	     ((eq display 'all)
-	      'gnus-not-ignore)
+	      #'gnus-not-ignore)
 	     ((arrayp display)
-	      (gnus-summary-display-make-predicate (mapcar 'identity display)))
+	      (gnus-summary-display-make-predicate (mapcar #'identity display)))
 	     ((numberp display)
 	      ;; The following is probably the "correct" solution, but
 	      ;; it makes Gnus fetch all headers and then limit the
@@ -5707,9 +5700,8 @@ If SELECT-ARTICLES, only select those articles from GROUP."
 	      ;; select-articles parameter instead. -- Simon Josefsson
 	      ;; <jas@kth.se>
 	      ;;
-	      ;; (gnus-byte-compile
-	      ;;  `(lambda () (> number ,(- (cdr (gnus-active group))
-	      ;; 			 display)))))
+	      ;;  (let ((n (cdr (gnus-active group))))
+	      ;;    (lambda () (> number (- n display))))
 	      (setq select-articles
 		    (gnus-uncompress-range
 		     (cons (let ((tmp (- (cdr (gnus-active group)) display)))
@@ -5773,8 +5765,7 @@ If SELECT-ARTICLES, only select those articles from GROUP."
       (setq gnus-newsgroup-limit (copy-sequence articles))
       ;; Remove canceled articles from the list of unread articles.
       (setq fetched-articles
-	    (mapcar (lambda (headers) (mail-header-number headers))
-		    gnus-newsgroup-headers))
+	    (mapcar #'mail-header-number gnus-newsgroup-headers))
       (setq gnus-newsgroup-articles fetched-articles)
       (setq gnus-newsgroup-unreads
 	    (gnus-sorted-nintersection
@@ -5833,8 +5824,8 @@ If SELECT-ARTICLES, only select those articles from GROUP."
 			    (unseen . unseen))
 			  gnus-article-mark-lists))
       (push (cons (cdr elem)
-		  (gnus-byte-compile    ;Why bother?
-		   `(lambda () (gnus-article-marked-p ',(cdr elem)))))
+                  (let ((x (cdr elem)))
+		    (lambda () (gnus-article-marked-p x))))
 	    gnus-summary-display-cache)))
   (let ((gnus-category-predicate-alist gnus-summary-display-cache)
 	(gnus-category-predicate-cache gnus-summary-display-cache))
@@ -5974,7 +5965,7 @@ If SELECT-ARTICLES, only select those articles from GROUP."
 	select
       (if (and (not (zerop scored)) (<= (abs select) scored))
 	  (progn
-	    (setq articles (sort scored-list '<))
+	    (setq articles (sort scored-list #'<))
 	    (setq number (length articles)))
 	(setq articles (copy-sequence articles)))
 
@@ -5991,7 +5982,7 @@ If SELECT-ARTICLES, only select those articles from GROUP."
 	      (sort
 	       (funcall gnus-alter-articles-to-read-function
 			gnus-newsgroup-name articles)
-	       '<)))
+	       #'<)))
       articles)))
 
 (defun gnus-killed-articles (killed articles)
@@ -6137,7 +6128,7 @@ If SELECT-ARTICLES, only select those articles from GROUP."
 	  (setq list (gnus-range-add list gnus-newsgroup-unseen)))
 
 	(when (eq (gnus-article-mark-to-type (cdr type)) 'list)
-	  (setq list (gnus-compress-sequence (set symbol (sort list '<)) t)))
+	  (setq list (gnus-compress-sequence (set symbol (sort list #'<)) t)))
 
 	(when (and (gnus-check-backend-function
 		    'request-set-mark gnus-newsgroup-name)
@@ -6220,7 +6211,7 @@ If WHERE is `summary', the summary mode line format will be used."
 				 gnus-tmp-unselected))))
 	       (gnus-tmp-subject
 		(if (and gnus-current-headers
-			 (vectorp gnus-current-headers))
+			 (mail-header-p gnus-current-headers))
 		    (gnus-mode-string-quote
 		     (mail-header-subject gnus-current-headers))
 		  ""))
@@ -6343,7 +6334,7 @@ The resulting hash table is returned, or nil if no Xrefs were found."
 	(setq ninfo (gnus-info-read info)))
       ;; Then we add the read articles to the range.
       (gnus-add-to-range
-       ninfo (setq articles (sort articles '<))))))
+       ninfo (setq articles (sort articles #'<))))))
 
 (defun gnus-group-make-articles-read (group articles)
   "Update the info of GROUP to say that ARTICLES are read."
@@ -6437,7 +6428,7 @@ The resulting hash table is returned, or nil if no Xrefs were found."
 	  ;; doesn't always go hand in hand.
 	  (setq
 	   header
-	   (vector
+	   (make-full-mail-header
 	    ;; Number.
 	    (prog1
 		(setq number (read cur))
@@ -6567,7 +6558,7 @@ Return a list of headers that match SEQUENCE (see
 `nntp-retrieve-headers')."
   ;; Get the Xref when the users reads the articles since most/some
   ;; NNTP servers do not include Xrefs when using XOVER.
-  (setq gnus-article-internal-prepare-hook '(gnus-article-get-xrefs))
+  (setq gnus-article-internal-prepare-hook (list #'gnus-article-get-xrefs))
   (let ((mail-parse-charset gnus-newsgroup-charset)
 	(mail-parse-ignored-charsets gnus-newsgroup-ignored-charsets)
 	(cur nntp-server-buffer)
@@ -6640,7 +6631,7 @@ This is meant to be called in `gnus-article-internal-prepare-hook'."
 		      (search-forward "\nXref:" nil t))
 	      (goto-char (1+ (match-end 0)))
 	      (setq xref (buffer-substring (point) (point-at-eol)))
-	      (mail-header-set-xref headers xref)))))))
+	      (setf (mail-header-xref headers) xref)))))))
 
 (defun gnus-summary-insert-subject (id &optional old-header use-old-header)
   "Find article ID and insert the summary line for that article.
@@ -6650,7 +6641,7 @@ If USE-OLD-HEADER is non-nil, then OLD-HEADER should be a header,
 and OLD-HEADER will be used when the summary line is inserted,
 too, instead of trying to fetch new headers."
   (let* ((line (and (numberp old-header) old-header))
-	 (old-header (and (vectorp old-header) old-header))
+	 (old-header (and (mail-header-p old-header) old-header))
 	 (header (cond ((and old-header use-old-header)
 			old-header)
 		       ((and (numberp id)
@@ -6678,7 +6669,7 @@ too, instead of trying to fetch new headers."
       (let ((gnus-newsgroup-headers (list header)))
         (gnus-summary-remove-list-identifiers))
       (when old-header
-	(mail-header-set-number header (mail-header-number old-header)))
+	(setf (mail-header-number header) (mail-header-number old-header)))
       (setq gnus-newsgroup-sparse
 	    (delq (setq number (mail-header-number header))
 		  gnus-newsgroup-sparse))
@@ -6752,6 +6743,7 @@ current article will be taken into consideration."
   "Iterate over the process/prefixed articles and do FORMS.
 ARG is the interactive prefix given to the command.  FORMS will be
 executed with point over the summary line of the articles."
+  (declare (indent 1) (debug t))
   (let ((articles (make-symbol "gnus-summary-iterate-articles")))
     `(let ((,articles (gnus-summary-work-articles ,arg)))
        (while ,articles
@@ -6759,9 +6751,6 @@ executed with point over the summary line of the articles."
 	 ,@forms
 	 (pop ,articles)))))
 
-(put 'gnus-summary-iterate 'lisp-indent-function 1)
-(put 'gnus-summary-iterate 'edebug-form-spec '(form body))
-
 (defun gnus-summary-save-process-mark ()
   "Push the current set of process marked articles on the stack."
   (interactive)
@@ -6784,7 +6773,7 @@ executed with point over the summary line of the articles."
 (defun gnus-summary-process-mark-set (set)
   "Make SET into the current process marked articles."
   (gnus-summary-unmark-all-processable)
-  (mapc 'gnus-summary-set-process-mark set))
+  (mapc #'gnus-summary-set-process-mark set))
 
 ;;; Searching and stuff
 
@@ -6890,7 +6879,7 @@ If EXCLUDE-GROUP, do not go to this group."
     (while arts
       (and (or (not unread)
 	       (gnus-data-unread-p (car arts)))
-	   (vectorp (gnus-data-header (car arts)))
+	   (mail-header-p (gnus-data-header (car arts)))
 	   (gnus-subject-equal
 	    simp-subject (mail-header-subject (gnus-data-header (car arts))) t)
 	   (setq result (car arts)
@@ -7166,7 +7155,7 @@ buffer."
   (gnus-summary-position-point))
 
 (define-obsolete-function-alias
-    'gnus-summary-toggle-truncation 'toggle-truncate-lines "26.1")
+    'gnus-summary-toggle-truncation #'toggle-truncate-lines "26.1")
 
 (defun gnus-summary-find-for-reselect ()
   "Return the number of an article to stay on across a reselect.
@@ -7322,7 +7311,7 @@ If FORCE (the prefix), also save the .newsrc file(s)."
       (gnus-summary-update-info))
     (gnus-close-group group)
     ;; Make sure where we were, and go to next newsgroup.
-    (when (buffer-live-p (get-buffer gnus-group-buffer))
+    (when (gnus-buffer-live-p gnus-group-buffer)
       (set-buffer gnus-group-buffer))
     (unless quit-config
       (gnus-group-jump-to-group group))
@@ -7497,8 +7486,7 @@ The state which existed when entering the ephemeral is reset."
 (defun gnus-deaden-summary ()
   "Make the current summary buffer into a dead summary buffer."
   ;; Kill any previous dead summary buffer.
-  (when (and gnus-dead-summary
-	     (buffer-name gnus-dead-summary))
+  (when (buffer-live-p gnus-dead-summary)
     (with-current-buffer gnus-dead-summary
       (when gnus-dead-summary-mode
 	(kill-buffer (current-buffer)))))
@@ -7516,7 +7504,7 @@ The state which existed when entering the ephemeral is reset."
 (defun gnus-kill-or-deaden-summary (buffer)
   "Kill or deaden the summary BUFFER."
   (save-excursion
-    (when (and (buffer-name buffer)
+    (when (and (buffer-live-p buffer)
 	       (not gnus-single-article-buffer))
       (with-current-buffer buffer
 	(gnus-kill-buffer gnus-article-buffer)
@@ -7525,12 +7513,12 @@ The state which existed when entering the ephemeral is reset."
      ;; Kill the buffer.
      (gnus-kill-summary-on-exit
       (when (and gnus-use-trees
-		 (gnus-buffer-exists-p buffer))
+                 (gnus-buffer-live-p buffer))
 	(with-current-buffer buffer
 	  (gnus-tree-close)))
       (gnus-kill-buffer buffer))
      ;; Deaden the buffer.
-     ((gnus-buffer-exists-p buffer)
+     ((gnus-buffer-live-p buffer)
       (with-current-buffer buffer
 	(gnus-deaden-summary))))))
 
@@ -7601,7 +7589,7 @@ previous group instead."
 		       (and unreads (not (zerop unreads))))
  		   (gnus-summary-read-group
  		    target-group nil no-article
- 		    (and (buffer-name current-buffer) current-buffer)
+                    (and (buffer-live-p current-buffer) current-buffer)
  		    nil backward))
 	      (setq entered t)
 	    (setq current-group target-group
@@ -7727,7 +7715,7 @@ If FORCE, also allow jumping to articles not currently shown."
 	 force
 	 (gnus-summary-insert-subject
 	  article
-	  (if (or (numberp force) (vectorp force)) force)
+	  (if (or (numberp force) (mail-header-p force)) force)
 	  t)
 	 (setq data (gnus-data-find article)))
     (goto-char b)
@@ -7772,9 +7760,9 @@ Given a prefix, will force an `article' buffer configuration."
   (if (null article)
       nil
     (prog1
-	(if gnus-summary-display-article-function
-	    (funcall gnus-summary-display-article-function article all-header)
-	  (gnus-article-prepare article all-header))
+	(funcall (or gnus-summary-display-article-function
+                     #'gnus-article-prepare)
+                 article all-header)
       (gnus-run-hooks 'gnus-select-article-hook)
       (when (and gnus-current-article
 		 (not (zerop gnus-current-article)))
@@ -8229,7 +8217,7 @@ is a number, it is the line the article is to be displayed on."
    (list
     (gnus-completing-read
      "Article number or Message-ID"
-     (mapcar 'int-to-string gnus-newsgroup-limit))
+     (mapcar #'int-to-string gnus-newsgroup-limit))
     current-prefix-arg
     t))
   (prog1
@@ -8281,8 +8269,7 @@ If given a prefix, remove all limits."
   (interactive "P")
   (when total
     (setq gnus-newsgroup-limits
-	  (list (mapcar (lambda (h) (mail-header-number h))
-			gnus-newsgroup-headers))))
+	  (list (mapcar #'mail-header-number gnus-newsgroup-headers))))
   (unless gnus-newsgroup-limits
     (error "No limit to pop"))
   (prog1
@@ -8410,9 +8397,9 @@ in `nnmail-extra-headers'."
 			   (if (eq to t)
 			       from
 			     (mapcar (lambda (a) (car (memq a from))) to))
-			 (if (eq to t)
-			     (mapcar (lambda (a) (car (memq a from))) cc)
-			   (mapcar (lambda (a) (car (memq a from)))
+			 (mapcar (lambda (a) (car (memq a from)))
+                                 (if (eq to t)
+			             cc
 				   (mapcar (lambda (a) (car (memq a to)))
 					   cc))))
 		     (nconc (if (eq to t) nil to)
@@ -8473,7 +8460,7 @@ articles that are younger than AGE days."
 	    (cutoff (days-to-time age))
 	    articles d date is-younger)
 	(while (setq d (pop data))
-	  (when (and (vectorp (gnus-data-header d))
+	  (when (and (mail-header-p (gnus-data-header d))
 		     (setq date (mail-header-date (gnus-data-header d))))
 	    (setq is-younger (time-less-p
 			      (time-since (gnus-date-get-time date))
@@ -8494,7 +8481,7 @@ articles that are younger than AGE days."
 	    (if current-prefix-arg
 		"Exclude extra header"
 	      "Limit extra header")
-	    (mapcar 'symbol-name gnus-extra-headers)
+	    (mapcar #'symbol-name gnus-extra-headers)
 	    t nil nil
             (symbol-name (car gnus-extra-headers))))))
      (list header
@@ -8787,12 +8774,11 @@ fetched for this group."
   "Mark all unread excluded articles as read.
 If ALL, mark even excluded ticked and dormants as read."
   (interactive "P")
-  (setq gnus-newsgroup-limit (sort gnus-newsgroup-limit '<))
+  (setq gnus-newsgroup-limit (sort gnus-newsgroup-limit #'<))
   (let ((articles (gnus-sorted-ndifference
 		   (sort
-		    (mapcar (lambda (h) (mail-header-number h))
-			    gnus-newsgroup-headers)
-		    '<)
+		    (mapcar #'mail-header-number gnus-newsgroup-headers)
+		    #'<)
 		   gnus-newsgroup-limit))
 	article)
     (setq gnus-newsgroup-unreads
@@ -8907,7 +8893,7 @@ fetch-old-headers verbiage, and so on."
   ;; Most groups have nothing to remove.
   (unless (or gnus-inhibit-limiting
 	      (and (null gnus-newsgroup-dormant)
-		   (eq gnus-newsgroup-display 'gnus-not-ignore)
+		   (eq gnus-newsgroup-display #'gnus-not-ignore)
 		   (not (eq gnus-fetch-old-headers 'some))
 		   (not (numberp gnus-fetch-old-headers))
 		   (not (eq gnus-fetch-old-headers 'invisible))
@@ -8948,7 +8934,7 @@ fetch-old-headers verbiage, and so on."
     (let* ((max-lisp-eval-depth (max 5000 max-lisp-eval-depth))
 	   (children
 	   (if (cdr thread)
-	       (apply '+ (mapcar 'gnus-summary-limit-children
+	       (apply #'+ (mapcar #'gnus-summary-limit-children
 				 (cdr thread)))
 	     0))
 	   (number (mail-header-number (car thread)))
@@ -9018,7 +9004,7 @@ fetch-old-headers verbiage, and so on."
       (push (cons number gnus-low-score-mark)
 	    gnus-newsgroup-reads)))
   ;; Go recursively through all subthreads.
-  (mapcar 'gnus-expunge-thread (cdr thread)))
+  (mapcar #'gnus-expunge-thread (cdr thread)))
 
 ;; Summary article oriented commands
 
@@ -9137,11 +9123,13 @@ non-numeric or nil fetch the number specified by the
 		   (refs (split-string (or (mail-header-references header)
 					   "")))
 		   (gnus-parse-headers-hook
-		    `(lambda () (goto-char (point-min))
-		      (keep-lines
-		       (regexp-opt ',(append refs (list id subject)))))))
+                    (let ((refs (append refs (list id subject))))
+		      (lambda ()
+                        (goto-char (point-min))
+		        (keep-lines (regexp-opt refs))))))
 	      (gnus-fetch-headers (list last) (if (numberp limit)
-						  (* 2 limit) limit) t))))
+						  (* 2 limit) limit)
+                                  t))))
 	 article-ids new-unreads)
     (when (listp new-headers)
       (dolist (header new-headers)
@@ -9423,8 +9411,11 @@ With optional ARG, move across that many fields."
   (interactive "p")
   (gnus-summary-select-article)
   (gnus-configure-windows 'article)
-  (select-window (gnus-get-buffer-window gnus-article-buffer))
-  (widget-forward arg))
+  (let ((win (or (gnus-get-buffer-window gnus-article-buffer t)
+                 (error "No article window found"))))
+    (select-window win)
+    (select-frame-set-input-focus (window-frame win))
+    (widget-forward arg)))
 
 (defun gnus-summary-widget-backward (arg)
   "Move point to the previous field or button in the article.
@@ -9432,10 +9423,13 @@ With optional ARG, move across that many fields."
   (interactive "p")
   (gnus-summary-select-article)
   (gnus-configure-windows 'article)
-  (select-window (gnus-get-buffer-window gnus-article-buffer))
-  (unless (widget-at (point))
-    (goto-char (point-max)))
-  (widget-backward arg))
+  (let ((win (or (gnus-get-buffer-window gnus-article-buffer t)
+                 (error "No article window found"))))
+    (select-window win)
+    (select-frame-set-input-focus (window-frame win))
+    (unless (widget-at (point))
+      (goto-char (point-max)))
+    (widget-backward arg)))
 
 (defun gnus-summary-isearch-article (&optional regexp-p)
   "Do incremental search forward on the current article.
@@ -9572,8 +9566,7 @@ Optional argument BACKWARD means do search for backward.
 This search includes all articles in the current group that Gnus has
 fetched headers for, whether they are displayed or not."
   (let ((articles nil)
-	;; Can't eta-reduce because it's a macro.
-	(func `(lambda (h) (,(intern (concat "mail-header-" header)) h)))
+	(func (intern (concat "mail-header-" header)))
 	(case-fold-search t))
     (dolist (header gnus-newsgroup-headers)
       ;; FIXME: when called from gnus-summary-limit-include-thread via
@@ -9597,13 +9590,14 @@ not match REGEXP on HEADER."
     (if (consp header)
 	(if (eq (car header) 'extra)
 	    (setq func
-		  `(lambda (h)
-		     (or (cdr (assq ',(cdr header) (mail-header-extra h)))
-			 "")))
+                  (let ((x (cdr header)))
+		    (lambda (h)
+		      (or (cdr (assq x (mail-header-extra h)))
+			  ""))))
 	  (error "%s is an invalid header" header))
       (unless (fboundp (intern (concat "mail-header-" header)))
 	(error "%s is not a valid header" header))
-      (setq func `(lambda (h) (,(intern (concat "mail-header-" header)) h))))
+      (setq func (intern (concat "mail-header-" header))))
     (dolist (d (if (eq backward 'all)
 		   gnus-newsgroup-data
 		 (gnus-data-find-list
@@ -9611,7 +9605,7 @@ not match REGEXP on HEADER."
 		  (gnus-data-list backward))))
       (when (and (or (not unread)	; We want all articles...
 		     (gnus-data-unread-p d)) ; Or just unreads.
-		 (vectorp (gnus-data-header d)) ; It's not a pseudo.
+		 (mail-header-p (gnus-data-header d)) ; It's not a pseudo.
 		 (if not-matching
 		     (not (string-match
 			   regexp
@@ -9629,7 +9623,7 @@ article.  If BACKWARD (the prefix) is non-nil, search backward instead."
    (list (let ((completion-ignore-case t))
 	   (gnus-completing-read
 	    "Header name"
-	    (mapcar 'symbol-name
+	    (mapcar #'symbol-name
 		    (append
 		     '(Number Subject From Lines Date
 		       Message-ID Xref References Body)
@@ -9803,9 +9797,9 @@ C-u g', show the raw article."
 	    (insert ".\n")
 	    (let ((nntp-server-buffer (current-buffer)))
 	      (setq header (car (gnus-get-newsgroup-headers deps t))))))
-	(gnus-data-set-header
-	 (gnus-data-find (cdr gnus-article-current))
-	 header)
+	(setf (gnus-data-header
+	       (gnus-data-find (cdr gnus-article-current)))
+	      header)
 	(gnus-summary-update-article-line
 	 (cdr gnus-article-current) header)
 	(when (gnus-summary-goto-subject (cdr gnus-article-current) nil t)
@@ -10143,7 +10137,7 @@ ACTION can be either `move' (the default), `crosspost' or `copy'."
 	     (setq xref (list (system-name))))
 	   (setq new-xref
 		 (concat
-		  (mapconcat 'identity
+		  (mapconcat #'identity
 			     (delete "Xref:" (delete new-xref xref))
 			     " ")
 		  " " new-xref))
@@ -10302,7 +10296,7 @@ ACTION can be either `move' (the default), `crosspost' or `copy'."
       (push article articles-to-update-marks))
 
     (save-excursion
-      (apply 'gnus-summary-remove-process-mark articles-to-update-marks))
+      (apply #'gnus-summary-remove-process-mark articles-to-update-marks))
     ;; Re-activate all groups that have been moved to.
     (with-current-buffer gnus-group-buffer
       (let ((gnus-group-marked to-groups))
@@ -10494,7 +10488,7 @@ This will be the case if the article has both been mailed and posted."
 		   (gnus-summary-update-info)
 		   (gnus-list-of-read-articles gnus-newsgroup-name))
 	       (setq gnus-newsgroup-expirable
-		     (sort gnus-newsgroup-expirable '<)))
+		     (sort gnus-newsgroup-expirable #'<)))
 	     gnus-newsgroup-unexist))
 	   (expiry-wait (if now 'immediate
 			  (gnus-group-find-parameter
@@ -10573,7 +10567,7 @@ confirmation before the articles are deleted."
   (unless (gnus-check-server (gnus-find-method-for-group gnus-newsgroup-name))
     (error "Couldn't open server"))
   ;; Compute the list of articles to delete.
-  (let ((articles (sort (copy-sequence (gnus-summary-work-articles n)) '<))
+  (let ((articles (sort (copy-sequence (gnus-summary-work-articles n)) #'<))
 	(nnmail-expiry-target 'delete)
 	not-deleted)
     (if (and gnus-novice-user
@@ -10654,15 +10648,15 @@ groups."
 	    (setq raw t))
 	(gnus-article-edit-article
 	 (if raw 'ignore
-	   `(lambda ()
-	      (let ((mbl mml-buffer-list))
-		(setq mml-buffer-list nil)
-		(let ((rfc2047-quote-decoded-words-containing-tspecials t))
-		  (mime-to-mml ',current-handles))
-		(let ((mbl1 mml-buffer-list))
-		  (setq mml-buffer-list mbl)
-		  (set (make-local-variable 'mml-buffer-list) mbl1))
-		(add-hook 'kill-buffer-hook 'mml-destroy-buffers t t))))
+	   (lambda ()
+	     (let ((mbl mml-buffer-list))
+	       (setq mml-buffer-list nil)
+	       (let ((rfc2047-quote-decoded-words-containing-tspecials t))
+		 (mime-to-mml current-handles))
+	       (let ((mbl1 mml-buffer-list))
+		 (setq mml-buffer-list mbl)
+		 (set (make-local-variable 'mml-buffer-list) mbl1))
+	       (add-hook 'kill-buffer-hook #'mml-destroy-buffers t t))))
 	 `(lambda (no-highlight)
 	    (let ((mail-parse-charset ',gnus-newsgroup-charset)
 		  (message-options message-options)
@@ -10682,7 +10676,7 @@ groups."
 				(mml-to-mime)
 				(mml-destroy-buffers)
 				(remove-hook 'kill-buffer-hook
-					     'mml-destroy-buffers t)
+					     #'mml-destroy-buffers t)
 				(kill-local-variable 'mml-buffer-list)))
 	      (gnus-summary-edit-article-done
 	       ,(or (mail-header-references gnus-current-headers) "")
@@ -10754,7 +10748,7 @@ groups."
 		    (let ((nntp-server-buffer (current-buffer)))
 		      (setq header (car (gnus-get-newsgroup-headers nil t))))
 		    (with-current-buffer gnus-summary-buffer
-		      (gnus-data-set-header (gnus-data-find article) header)
+		      (setf (gnus-data-header (gnus-data-find article)) header)
 		      (gnus-summary-update-article-line article header)
 		      (if (gnus-summary-goto-subject article nil t)
 			  (gnus-summary-update-secondary-mark article)))))))
@@ -10817,7 +10811,7 @@ groups."
 	(unless silent
 	  (if groups
 	      (message "This message would go to %s"
-		       (mapconcat 'car groups ", "))
+		       (mapconcat #'car groups ", "))
 	    (message "This message would go to no groups"))
 	  groups)))))
 
@@ -11148,7 +11142,7 @@ If NO-EXPIRE, auto-expiry will be inhibited."
 
 	;; See whether the article is to be put in the cache.
 	(and gnus-use-cache
-	     (vectorp (gnus-summary-article-header article))
+	     (mail-header-p (gnus-summary-article-header article))
 	     (save-excursion
 	       (gnus-cache-possibly-enter-article
 		gnus-newsgroup-name article
@@ -11195,7 +11189,7 @@ If NO-EXPIRE, auto-expiry will be inhibited."
 	;; See whether the article is to be put in the cache.
 	(and gnus-use-cache
 	     (not (= mark gnus-canceled-mark))
-	     (vectorp (gnus-summary-article-header article))
+	     (mail-header-p (gnus-summary-article-header article))
 	     (save-excursion
 	       (gnus-cache-possibly-enter-article
 		gnus-newsgroup-name article
@@ -11263,8 +11257,9 @@ If NO-EXPIRE, auto-expiry will be inhibited."
           (insert to-insert))
 	;; Optionally update the marks by some user rule.
 	(when (eq type 'unread)
-	  (gnus-data-set-mark
-	   (gnus-data-find (gnus-summary-article-number)) mark)
+	  (setf (gnus-data-mark
+	         (gnus-data-find (gnus-summary-article-number)))
+                mark)
 	  (gnus-summary-update-line (eq mark gnus-unread-mark)))))))
 
 (defun gnus-mark-article-as-read (article &optional mark)
@@ -11625,6 +11620,7 @@ read."
 (defmacro gnus-with-article (article &rest forms)
   "Select ARTICLE and perform FORMS in the original article buffer.
 Then replace the article with the result."
+  (declare (indent 1) (debug t))
   `(progn
      ;; We don't want the article to be marked as read.
      (let (gnus-mark-article-hook)
@@ -11646,9 +11642,6 @@ Then replace the article with the result."
        (gnus-cache-update-article
 	(car gnus-article-current) (cdr gnus-article-current)))))
 
-(put 'gnus-with-article 'lisp-indent-function 1)
-(put 'gnus-with-article 'edebug-form-spec '(form body))
-
 ;; Thread-based commands.
 
 (defun gnus-summary-articles-in-thread (&optional article)
@@ -11815,9 +11808,8 @@ Returns nil if no thread was there to be shown."
 
 (defun gnus-map-articles (predicate articles)
   "Map PREDICATE over ARTICLES and return non-nil if any predicate is non-nil."
-  (apply 'gnus-or (mapcar predicate
-			  (mapcar (lambda (number)
-				    (gnus-summary-article-header number))
+  (apply #'gnus-or (mapcar predicate
+			  (mapcar #'gnus-summary-article-header
 				  articles))))
 
 (defun gnus-summary-hide-all-threads (&optional predicate)
@@ -12095,15 +12087,15 @@ Argument REVERSE means reverse order."
 	 (gnus-thread-sort-functions
 	  (if (not reverse)
 	      thread
-	    `(lambda (t1 t2)
-	       (,thread t2 t1))))
+	    (lambda (t1 t2)
+	       (funcall thread t2 t1))))
 	 (gnus-sort-gathered-threads-function
 	  gnus-thread-sort-functions)
 	 (gnus-article-sort-functions
 	  (if (not reverse)
 	      article
-	    `(lambda (t1 t2)
-	       (,article t2 t1))))
+	    (lambda (t1 t2)
+	      (funcall article t2 t1))))
 	 (inhibit-read-only t)
 	 (gnus-summary-prepare-hook nil))
     ;; We do the sorting by regenerating the threads.
@@ -12147,7 +12139,7 @@ performed."
 	 header file)
     (dolist (article articles)
       (setq header (gnus-summary-article-header article))
-      (if (not (vectorp header))
+      (if (not (mail-header-p header))
 	  ;; This is a pseudo-article.
 	  (if (assq 'name header)
 	      (gnus-copy-file (cdr (assq 'name header)))
@@ -12488,7 +12480,7 @@ If REVERSE, save parts that do not match TYPE."
     ;; If all commands are to be bunched up on one line, we collect
     ;; them here.
     (unless gnus-view-pseudos-separately
-      (let ((ps (setq pslist (sort pslist 'gnus-pseudos<)))
+      (let ((ps (setq pslist (sort pslist #'gnus-pseudos<)))
 	    files action)
 	(while ps
 	  (setq action (cdr (assq 'action (car ps))))
@@ -12505,7 +12497,7 @@ If REVERSE, save parts that do not match TYPE."
 	    (when (assq 'execute (car ps))
 	      (setcdr (assq 'execute (car ps))
 		      (funcall (if (string-match "%s" action)
-				   'format 'concat)
+				   #'format #'concat)
 			       action
 			       (mapconcat
 				(lambda (f)
@@ -12643,7 +12635,7 @@ If REVERSE, save parts that do not match TYPE."
 	      ;; If we fetched by Message-ID and the article came from
 	      ;; a different group (or server), we fudge some bogus
 	      ;; article numbers for this article.
-	      (mail-header-set-number header gnus-reffed-article-number))
+	      (setf (mail-header-number header) gnus-reffed-article-number))
 	    (with-current-buffer gnus-summary-buffer
 	      (cl-decf gnus-reffed-article-number)
 	      (gnus-remove-header (mail-header-number header))
@@ -12932,7 +12924,7 @@ treated as multipart/mixed."
 (defun gnus-summary-make-all-marking-commands ()
   (define-key gnus-summary-mark-map "M" gnus-summary-generic-mark-map)
   (dolist (elem gnus-summary-marking-alist)
-    (apply 'gnus-summary-make-marking-command elem)))
+    (apply #'gnus-summary-make-marking-command elem)))
 
 (defun gnus-summary-make-marking-command (name mark keystroke)
   (let ((map (make-sparse-keymap)))
@@ -13046,7 +13038,7 @@ If ALL is non-nil, already read articles become readable.
 If ALL is a number, fetch this number of articles."
   (interactive "P")
   (prog1
-      (let ((old (sort (mapcar 'car gnus-newsgroup-data) '<))
+      (let ((old (sort (mapcar #'car gnus-newsgroup-data) #'<))
 	    older len)
 	(setq older
 	      ;; Some nntp servers lie about their active range.  When
@@ -13116,7 +13108,7 @@ If ALL is a number, fetch this number of articles."
 (defun gnus-summary-insert-new-articles ()
   "Insert all new articles in this group."
   (interactive)
-  (let ((old (sort (mapcar 'car gnus-newsgroup-data) '<))
+  (let ((old (sort (mapcar #'car gnus-newsgroup-data) #'<))
 	(old-high gnus-newsgroup-highest)
 	(nnmail-fetched-sources (list t))
 	(new-active (gnus-activate-group gnus-newsgroup-name 'scan))
diff --git a/lisp/gnus/gnus-util.el b/lisp/gnus/gnus-util.el
index 6b0f29b0af..31421cc755 100644
--- a/lisp/gnus/gnus-util.el
+++ b/lisp/gnus/gnus-util.el
@@ -34,6 +34,7 @@
 
 (eval-when-compile (require 'cl-lib))
 
+(require 'seq)
 (require 'time-date)
 (require 'text-property-search)
 
@@ -108,12 +109,6 @@ This is a compatibility function for different Emacsen."
 (defsubst gnus-goto-char (point)
   (and point (goto-char point)))
 
-(defmacro gnus-buffer-exists-p (buffer)
-  `(let ((buffer ,buffer))
-     (when buffer
-       (funcall (if (stringp buffer) 'get-buffer 'buffer-name)
-		buffer))))
-
 (defun gnus-delete-first (elt list)
   "Delete by side effect the first occurrence of ELT as a member of LIST."
   (if (equal (car list) elt)
@@ -561,8 +556,12 @@ If N, return the Nth ancestor instead."
 	  (match-string 1 references))))))
 
 (defsubst gnus-buffer-live-p (buffer)
-  "Say whether BUFFER is alive or not."
-  (and buffer (buffer-live-p (get-buffer buffer))))
+  "If BUFFER names a live buffer, return its object; else nil."
+  (and buffer (buffer-live-p (setq buffer (get-buffer buffer)))
+       buffer))
+
+(define-obsolete-function-alias 'gnus-buffer-exists-p
+  'gnus-buffer-live-p "27.1")
 
 (defun gnus-horizontal-recenter ()
   "Recenter the current buffer horizontally."
@@ -1160,20 +1159,13 @@ ARG is passed to the first function."
       (eq (cadr (memq 'gnus-undeletable (text-properties-at b))) t)
     (text-property-any b e 'gnus-undeletable t)))
 
-(defun gnus-or (&rest elems)
-  "Return non-nil if any of the elements are non-nil."
-  (catch 'found
-    (while elems
-      (when (pop elems)
-	(throw 'found t)))))
-
-(defun gnus-and (&rest elems)
-  "Return non-nil if all of the elements are non-nil."
-  (catch 'found
-    (while elems
-      (unless (pop elems)
-	(throw 'found nil)))
-    t))
+(defun gnus-or (&rest elements)
+  "Return non-nil if any one of ELEMENTS is non-nil."
+  (seq-drop-while #'null elements))
+
+(defun gnus-and (&rest elements)
+  "Return non-nil if all ELEMENTS are non-nil."
+  (not (memq nil elements)))
 
 ;; gnus.el requires mm-util.
 (declare-function mm-disable-multibyte "mm-util")
diff --git a/lisp/gnus/gnus-win.el b/lisp/gnus/gnus-win.el
index 5f7154c545..e6906e99bb 100644
--- a/lisp/gnus/gnus-win.el
+++ b/lisp/gnus/gnus-win.el
@@ -28,6 +28,7 @@
 
 (require 'gnus)
 (require 'gnus-util)
+(require 'seq)
 
 (defgroup gnus-windows nil
   "Window configuration."
@@ -269,7 +270,7 @@ See the Gnus manual for an explanation of the syntax used.")
 	    (error "Invalid buffer type: %s" type))
 	  (let ((buf (gnus-get-buffer-create
 		      (gnus-window-to-buffer-helper buffer))))
-	    (when (buffer-name buf)
+            (when (buffer-live-p buf)
 	      (cond
                ((eq buf (window-buffer (selected-window)))
                 (set-buffer buf))
@@ -284,7 +285,7 @@ See the Gnus manual for an explanation of the syntax used.")
                 ;; from a hard-dedicated frame, it creates (and
                 ;; configures) a new frame, leaving the dedicated frame alone.
                 (pop-to-buffer buf))
-               (t (switch-to-buffer buf)))))
+               (t (pop-to-buffer-same-window buf)))))
 	  (when (memq 'frame-focus split)
 	    (setq gnus-window-frame-focus window))
 	  ;; We return the window if it has the `point' spec.
@@ -429,20 +430,13 @@ See the Gnus manual for an explanation of the syntax used.")
 (defun gnus-delete-windows-in-gnusey-frames ()
   "Do a `delete-other-windows' in all frames that have Gnus windows."
   (let ((buffers (gnus-buffers)))
-    (mapcar
-     (lambda (frame)
-       (unless (eq (cdr (assq 'minibuffer
-			      (frame-parameters frame)))
-		   'only)
-	 (select-frame frame)
-	 (let (do-delete)
-	   (walk-windows
-	    (lambda (window)
-	      (when (memq (window-buffer window) buffers)
-		(setq do-delete t))))
-	   (when do-delete
-	     (delete-other-windows)))))
-     (frame-list))))
+    (dolist (frame (frame-list))
+      (unless (eq (frame-parameter frame 'minibuffer) 'only)
+        (select-frame frame)
+        (when (get-window-with-predicate
+               (lambda (window)
+                 (memq (window-buffer window) buffers)))
+          (delete-other-windows))))))
 
 (defun gnus-all-windows-visible-p (split)
   "Say whether all buffers in SPLIT are currently visible.
@@ -490,11 +484,10 @@ should have point."
   (nth 1 (window-edges window)))
 
 (defun gnus-remove-some-windows ()
-  (let ((buffers (gnus-buffers))
-	buf bufs lowest-buf lowest)
+  (let (bufs lowest-buf lowest)
     (save-excursion
       ;; Remove windows on all known Gnus buffers.
-      (while (setq buf (pop buffers))
+      (dolist (buf (gnus-buffers))
 	(when (get-buffer-window buf)
 	  (push buf bufs)
 	  (pop-to-buffer buf)
@@ -505,19 +498,19 @@ should have point."
       (when lowest-buf
 	(pop-to-buffer lowest-buf)
 	(set-buffer nntp-server-buffer))
-      (mapcar (lambda (b) (delete-windows-on b t))
-	      (delq lowest-buf bufs)))))
+      (dolist (b (delq lowest-buf bufs))
+        (delete-windows-on b t)))))
 
 (defun gnus-get-buffer-window (buffer &optional frame)
-  (cond ((and (null gnus-use-frames-on-any-display)
-	      (memq frame '(t 0 visible)))
-	 (car
-	  (let ((frames (frames-on-display-list)))
-	    (seq-remove (lambda (win) (not (memq (window-frame win)
-						     frames)))
-			    (get-buffer-window-list buffer nil frame)))))
-	(t
-	 (get-buffer-window buffer frame))))
+  "Return a window currently displaying BUFFER, or nil if none.
+Like `get-buffer-window', but respecting
+`gnus-use-frames-on-any-display'."
+  (if (and (not gnus-use-frames-on-any-display)
+           (memq frame '(t 0 visible)))
+      (let ((frames (frames-on-display-list)))
+        (seq-find (lambda (win) (memq (window-frame win) frames))
+                  (get-buffer-window-list buffer nil frame)))
+    (get-buffer-window buffer frame)))
 
 (provide 'gnus-win)
 
diff --git a/lisp/gnus/gnus.el b/lisp/gnus/gnus.el
index 989347c9fd..9ee7db9e20 100644
--- a/lisp/gnus/gnus.el
+++ b/lisp/gnus/gnus.el
@@ -665,26 +665,15 @@ be used directly.")
 (defmacro gnus-kill-buffer (buffer)
   "Kill BUFFER and remove from the list of Gnus buffers."
   `(let ((buf ,buffer))
-     (when (gnus-buffer-exists-p buf)
+     (when (gnus-buffer-live-p buf)
        (kill-buffer buf)
        (gnus-prune-buffers))))
 
-(defun gnus-prune-buffers ()
-  (dolist (buf gnus-buffers)
-    (unless (buffer-live-p buf)
-      (setq gnus-buffers (delete buf gnus-buffers)))))
-
 (defun gnus-buffers ()
   "Return a list of live Gnus buffers."
-  (while (and gnus-buffers
-	      (not (buffer-name (car gnus-buffers))))
-    (pop gnus-buffers))
-  (let ((buffers gnus-buffers))
-    (while (cdr buffers)
-      (if (buffer-name (cadr buffers))
-	  (pop buffers)
-	(setcdr buffers (cddr buffers)))))
-  gnus-buffers)
+  (setq gnus-buffers (seq-filter #'buffer-live-p gnus-buffers)))
+
+(defalias 'gnus-prune-buffers #'gnus-buffers)
 
 ;;; Splash screen.
 
@@ -2511,12 +2500,12 @@ are always t.")
      (let ((interactive (nth 1 (memq ':interactive package))))
        (mapcar
 	(lambda (function)
-	  (let (keymap)
+	  (let (type)
 	    (when (consp function)
-	      (setq keymap (car (memq 'keymap function)))
+	      (setq type (cadr function))
 	      (setq function (car function)))
 	    (unless (fboundp function)
-	      (autoload function (car package) nil interactive keymap))))
+	      (autoload function (car package) nil interactive type))))
 	(if (eq (nth 1 package) ':interactive)
 	    (nthcdr 3 package)
 	  (cdr package)))))
@@ -2892,7 +2881,7 @@ See Info node `(gnus)Formatting Variables'."
 
 (defun gnus-set-info (group info)
   (setcdr (gethash group gnus-newsrc-hashtb)
-	  info))
+	  (list info)))
 
 
 ;;;
@@ -3143,7 +3132,7 @@ that that variable is buffer-local to the summary buffers."
 	 t)				    ;is news of course.
 	((not (gnus-member-of-valid 'post-mail group)) ;Non-combined.
 	 nil)				;must be mail then.
-	((vectorp article)		;Has header info.
+	((mail-header-p article)		;Has header info.
 	 (eq (gnus-request-type group (mail-header-id article)) 'news))
 	((null article)			       ;Hasn't header info
 	 (eq (gnus-request-type group) 'news)) ;(unknown ==> mail)
@@ -3638,9 +3627,8 @@ If SYMBOL, return the value of that symbol in the group parameters.
 
 If you call this function inside a loop, consider using the faster
 `gnus-group-fast-parameter' instead."
-  (with-current-buffer (if (buffer-live-p (get-buffer gnus-group-buffer))
-			   gnus-group-buffer
-			 (current-buffer))
+  (with-current-buffer (or (gnus-buffer-live-p gnus-group-buffer)
+                           (current-buffer))
     (if symbol
 	(gnus-group-fast-parameter group symbol allow-list)
       (nconc
diff --git a/lisp/gnus/mail-source.el b/lisp/gnus/mail-source.el
index 7514e64e7c..69ecde3027 100644
--- a/lisp/gnus/mail-source.el
+++ b/lisp/gnus/mail-source.el
@@ -31,7 +31,6 @@
 (autoload 'auth-source-search "auth-source")
 (autoload 'pop3-movemail "pop3")
 (autoload 'pop3-get-message-count "pop3")
-(autoload 'nnheader-cancel-timer "nnheader")
 (require 'mm-util)
 (require 'message) ;; for `message-directory'
 
@@ -723,8 +722,7 @@ Deleting old (> %s day(s)) incoming mail file `%s'." diff bfile)
 				   (buffer-string) result))
 		    (error "%s" (buffer-string)))
 		  (setq to nil)))))))
-      (when (and errors
-		 (buffer-name errors))
+      (when (buffer-live-p errors)
 	(kill-buffer errors))
       ;; Return whether we moved successfully or not.
       to)))
@@ -989,9 +987,9 @@ This only works when `display-time' is enabled."
 	      (> (prefix-numeric-value arg) 0))))
     (setq mail-source-report-new-mail on)
     (and mail-source-report-new-mail-timer
-	 (nnheader-cancel-timer mail-source-report-new-mail-timer))
+	 (cancel-timer mail-source-report-new-mail-timer))
     (and mail-source-report-new-mail-idle-timer
-	 (nnheader-cancel-timer mail-source-report-new-mail-idle-timer))
+	 (cancel-timer mail-source-report-new-mail-idle-timer))
     (setq mail-source-report-new-mail-timer nil)
     (setq mail-source-report-new-mail-idle-timer nil)
     (if on
diff --git a/lisp/gnus/message.el b/lisp/gnus/message.el
index c8b6f0ee68..d3f6ec3c34 100644
--- a/lisp/gnus/message.el
+++ b/lisp/gnus/message.el
@@ -1078,13 +1078,15 @@ point and mark around the citation text as modified."
 
 (defcustom message-signature mail-signature
   "String to be inserted at the end of the message buffer.
-If t, the `message-signature-file' file will be inserted instead.
-If a function, the result from the function will be used instead.
-If a form, the result from the form will be used instead."
+If nil, don't insert a signature.
+If t, insert `message-signature-file'.
+If a function or form, insert its result.
+See `mail-signature' for the recommended format of a signature."
   :version "23.2"
-  :type '(choice string (const :tag "Contents of signature file" t)
-		 function
-		 sexp)
+  :type '(choice string
+                 (const :tag "None" nil)
+                 (const :tag "Contents of signature file" t)
+                 function sexp)
   :risky t
   :link '(custom-manual "(message)Insertion Variables")
   :group 'message-insertion)
@@ -1599,19 +1601,21 @@ starting with `not' and followed by regexps."
 	(progn (goto-char (match-beginning 0)) (match-end 0)) nil
         (1 'message-header-name)
         (2 'message-header-other nil t)))
-      ,@(if (and mail-header-separator
-		 (not (equal mail-header-separator "")))
-	    `((,(concat "^\\(" (regexp-quote mail-header-separator) "\\)$")
-	       1 'message-separator))
-	  nil)
-      ((lambda (limit)
-	 (re-search-forward (concat "^\\("
-				    message-cite-prefix-regexp
-				    "\\).*")
-			    limit t))
-       (0 'message-cited-text))
-      ("<#/?\\(multipart\\|part\\|external\\|mml\\|secure\\)[^>]*>"
-       (0 'message-mml))))
+      (,(lambda (limit)
+          (and mail-header-separator
+               (not (equal mail-header-separator ""))
+               (re-search-forward
+                (concat "^" (regexp-quote mail-header-separator) "$")
+                limit t)))
+       0 'message-separator)
+      (,(lambda (limit)
+          (re-search-forward (concat "^\\(?:"
+                                     message-cite-prefix-regexp
+                                     "\\).*")
+                             limit t))
+       0 'message-cited-text)
+      ("<#/?\\(?:multipart\\|part\\|external\\|mml\\|secure\\)[^>]*>"
+       0 'message-mml)))
   "Additional expressions to highlight in Message mode.")
 
 (defvar message-face-alist
@@ -2030,8 +2034,7 @@ see `message-narrow-to-headers-or-head'."
 
 (defmacro message-with-reply-buffer (&rest forms)
   "Evaluate FORMS in the reply buffer, if it exists."
-  `(when (and (bufferp message-reply-buffer)
-	      (buffer-name message-reply-buffer))
+  `(when (buffer-live-p message-reply-buffer)
      (with-current-buffer message-reply-buffer
        ,@forms)))
 
@@ -2051,8 +2054,9 @@ see `message-narrow-to-headers-or-head'."
   (let ((regexp (if (stringp gnus-list-identifiers)
 		    gnus-list-identifiers
 		  (mapconcat 'identity gnus-list-identifiers " *\\|"))))
-    (if (string-match (concat "\\(\\(\\(Re: +\\)?\\(" regexp
-			      " *\\)\\)+\\(Re: +\\)?\\)") subject)
+    (if (and (not (equal regexp ""))
+             (string-match (concat "\\(\\(\\(Re: +\\)?\\(" regexp
+                                   " *\\)\\)+\\(Re: +\\)?\\)") subject))
 	(concat (substring subject 0 (match-beginning 1))
 		(or (match-string 3 subject)
 		    (match-string 5 subject))
@@ -2894,42 +2898,9 @@ See also `message-forbidden-properties'."
 ;;;###autoload
 (define-derived-mode message-mode text-mode "Message"
   "Major mode for editing mail and news to be sent.
-Like Text Mode but with these additional commands:\\<message-mode-map>
-C-c C-s  `message-send' (send the message)  C-c C-c  `message-send-and-exit'
-C-c C-d  Postpone sending the message       C-c C-k  Kill the message
-C-c C-f  move to a header field (and create it if there isn't):
-	 C-c C-f C-t  move to To	C-c C-f C-s  move to Subject
-	 C-c C-f C-c  move to Cc	C-c C-f C-b  move to Bcc
-	 C-c C-f C-w  move to Fcc	C-c C-f C-r  move to Reply-To
-	 C-c C-f C-u  move to Summary	C-c C-f C-n  move to Newsgroups
-	 C-c C-f C-k  move to Keywords	C-c C-f C-d  move to Distribution
-	 C-c C-f C-o  move to From (\"Originator\")
-	 C-c C-f C-f  move to Followup-To
-	 C-c C-f C-m  move to Mail-Followup-To
-	 C-c C-f C-e  move to Expires
-	 C-c C-f C-i  cycle through Importance values
-	 C-c C-f s    change subject and append \"(was: <Old Subject>)\"
-	 C-c C-f x    crossposting with FollowUp-To header and note in body
-	 C-c C-f t    replace To: header with contents of Cc: or Bcc:
-	 C-c C-f a    Insert X-No-Archive: header and a note in the body
-C-c C-t  `message-insert-to' (add a To header to a news followup)
-C-c C-l  `message-to-list-only' (removes all but list address in to/cc)
-C-c C-n  `message-insert-newsgroups' (add a Newsgroup header to a news reply)
-C-c C-b  `message-goto-body' (move to beginning of message text).
-C-c C-i  `message-goto-signature' (move to the beginning of the signature).
-C-c C-w  `message-insert-signature' (insert `message-signature-file' file).
-C-c C-y  `message-yank-original' (insert current message, if any).
-C-c C-q  `message-fill-yanked-message' (fill what was yanked).
-C-c C-e  `message-elide-region' (elide the text between point and mark).
-C-c C-v  `message-delete-not-region' (remove the text outside the region).
-C-c C-z  `message-kill-to-signature' (kill the text up to the signature).
-C-c C-r  `message-caesar-buffer-body' (rot13 the message body).
-C-c C-a  `mml-attach-file' (attach a file as MIME).
-C-c C-u  `message-insert-or-toggle-importance'  (insert or cycle importance).
-C-c M-n  `message-insert-disposition-notification-to'  (request receipt).
-C-c M-m  `message-mark-inserted-region' (mark region with enclosing tags).
-C-c M-f  `message-mark-insert-file' (insert file marked with enclosing tags).
-M-RET    `message-newline-and-reformat' (break the line and reformat)."
+Like `text-mode', but with these additional commands:
+
+\\{message-mode-map}"
   (set (make-local-variable 'message-reply-buffer) nil)
   (set (make-local-variable 'message-inserted-headers) nil)
   (set (make-local-variable 'message-send-actions) nil)
@@ -3257,8 +3228,7 @@ or in the synonym headers, defined by `message-header-synonyms'."
   "Widen the reply to include maximum recipients."
   (interactive)
   (let ((follow-to
-	 (and (bufferp message-reply-buffer)
-	      (buffer-name message-reply-buffer)
+         (and (buffer-live-p message-reply-buffer)
 	      (with-current-buffer message-reply-buffer
 		(message-get-reply-headers t)))))
     (save-excursion
@@ -3847,13 +3817,14 @@ This function uses `mail-citation-hook' if that is non-nil."
 	      (narrow-to-region start end)
 	      (message-narrow-to-head-1)
 	      (setq x-no-archive (message-fetch-field "x-no-archive"))
-	      (vector 0
-		      (or (message-fetch-field "subject") "none")
-		      (or (message-fetch-field "from") "nobody")
-		      (message-fetch-field "date")
-		      (message-fetch-field "message-id" t)
-		      (message-fetch-field "references")
-		      0 0 ""))))
+	      (make-full-mail-header
+               0
+	       (or (message-fetch-field "subject") "none")
+	       (or (message-fetch-field "from") "nobody")
+	       (message-fetch-field "date")
+	       (message-fetch-field "message-id" t)
+	       (message-fetch-field "references")
+	       0 0 ""))))
       (mml-quote-region start end)
       (when strip-signature
 	;; Allow undoing.
@@ -4054,7 +4025,7 @@ It should typically alter the sending method in some way or other."
   (let ((buf (current-buffer))
 	(actions message-exit-actions))
     (when (and (message-send arg)
-	       (buffer-name buf))
+               (buffer-live-p buf))
       (message-bury buf)
       (if message-kill-buffer-on-exit
 	  (kill-buffer buf))
@@ -4588,8 +4559,7 @@ This function could be useful in `message-setup-hook'."
 	      (message-generate-headers '(Lines)))
 	    ;; Remove some headers.
 	    (message-remove-header message-ignored-mail-headers t)
-	    (let ((mail-parse-charset message-default-charset))
-	      (mail-encode-encoded-word-buffer)))
+            (mail-encode-encoded-word-buffer))
 	  (goto-char (point-max))
 	  ;; require one newline at the end.
 	  (or (= (preceding-char) ?\n)
@@ -4623,10 +4593,12 @@ This function could be useful in `message-setup-hook'."
 	    (message-insert-courtesy-copy
 	     (with-current-buffer mailbuf
 	       message-courtesy-message)))
-          ;; Let's make sure we encoded all the body.
-          (cl-assert (save-excursion
-                       (goto-char (point-min))
-                       (not (re-search-forward "[^\000-\377]" nil t))))
+          ;; If this was set, `sendmail-program' takes care of encoding.
+          (unless message-inhibit-body-encoding
+            ;; Let's make sure we encoded all the body.
+            (cl-assert (save-excursion
+                         (goto-char (point-min))
+                         (not (re-search-forward "[^\000-\377]" nil t)))))
           (mm-disable-multibyte)
 	  (if (or (not message-send-mail-partially-limit)
 		  (< (buffer-size) message-send-mail-partially-limit)
@@ -4768,7 +4740,7 @@ that instead."
 	      (if (not (zerop (buffer-size)))
 		  (error "Sending...failed to %s"
 			 (buffer-string))))))
-      (when (bufferp errbuf)
+      (when (buffer-live-p errbuf)
 	(kill-buffer errbuf)))))
 
 (defun message-send-mail-with-qmail ()
@@ -4962,8 +4934,7 @@ Otherwise, generate and save a value for `canlock-password' first."
 		  (message-generate-headers '(Lines)))
 		;; Remove some headers.
 		(message-remove-header message-ignored-news-headers t)
-		(let ((mail-parse-charset message-default-charset))
-		  (mail-encode-encoded-word-buffer)))
+                (mail-encode-encoded-word-buffer))
 	      (goto-char (point-max))
 	      ;; require one newline at the end.
 	      (or (= (preceding-char) ?\n)
@@ -5441,8 +5412,7 @@ The result is a fixnum."
 	  (while (setq file (message-fetch-field "fcc" t))
 	    (push file list)
 	    (message-remove-header "fcc" nil t))
-	  (let ((mail-parse-charset message-default-charset)
-		(rfc2047-header-encoding-alist
+          (let ((rfc2047-header-encoding-alist
 		 (cons '("Newsgroups" . default)
 		       rfc2047-header-encoding-alist)))
 	    (mail-encode-encoded-word-buffer)))
@@ -6407,8 +6377,7 @@ moved to the beginning "
 (defun message-pop-to-buffer (name &optional switch-function)
   "Pop to buffer NAME, and warn if it already exists and is modified."
   (let ((buffer (get-buffer name)))
-    (if (and buffer
-	     (buffer-name buffer))
+    (if (buffer-live-p buffer)
 	(let ((window (get-buffer-window buffer 0)))
 	  (if window
 	      ;; Raise the frame already displaying the message buffer.
@@ -6439,7 +6408,7 @@ moved to the beginning "
 	      (>= (length message-buffer-list) message-max-buffers))
     ;; Kill the oldest buffer -- unless it has been changed.
     (let ((buffer (pop message-buffer-list)))
-      (when (and (buffer-name buffer)
+      (when (and (buffer-live-p buffer)
 		 (not (buffer-modified-p buffer)))
 	(kill-buffer buffer))))
   ;; Rename the buffer.
@@ -6951,21 +6920,12 @@ Useful functions to put in this list include:
   :type '(repeat function))
 
 (defun message-simplify-subject (subject &optional functions)
-  "Return simplified SUBJECT."
-  (unless functions
-    ;; Simplify fully:
-    (setq functions message-simplify-subject-functions))
-  (when (and (memq 'message-strip-list-identifiers functions)
-	     gnus-list-identifiers)
-    (setq subject (message-strip-list-identifiers subject)))
-  (when (memq 'message-strip-subject-re functions)
-    (setq subject (concat "Re: " (message-strip-subject-re subject))))
-  (when (and (memq 'message-strip-subject-trailing-was functions)
-	     message-subject-trailing-was-query)
-    (setq subject (message-strip-subject-trailing-was subject)))
-  (when (memq 'message-strip-subject-encoded-words functions)
-    (setq subject (message-strip-subject-encoded-words subject)))
-  subject)
+  "Return simplified SUBJECT.
+Do so by calling each one-argument function in the list of functions
+specified by FUNCTIONS, if non-nil, or by the variable
+`message-simplify-subject-functions' otherwise."
+  (dolist (fun (or functions message-simplify-subject-functions) subject)
+    (setq subject (funcall fun subject))))
 
 ;;;###autoload
 (defun message-reply (&optional to-address wide switch-function)
@@ -6998,7 +6958,7 @@ Useful functions to put in this list include:
 	    subject (or (message-fetch-field "subject") "none"))
 
       ;; Strip list identifiers, "Re: ", and "was:"
-      (setq subject (message-simplify-subject subject))
+      (setq subject (concat "Re: " (message-simplify-subject subject)))
 
       (when (and (setq gnus-warning (message-fetch-field "gnus-warning"))
 		 (string-match "<[^>]+>" gnus-warning))
@@ -7017,8 +6977,8 @@ Useful functions to put in this list include:
 	  (if wide to-address nil))
 	 switch-function))
       (setq message-reply-headers
-	    (vector 0 (cdr (assq 'Subject headers))
-		    from date message-id references 0 0 ""))
+	    (make-full-mail-header 0 (cdr (assq 'Subject headers))
+		                   from date message-id references 0 0 ""))
       (message-setup headers cur))))
 
 ;;;###autoload
@@ -7069,13 +7029,14 @@ If TO-NEWSGROUPS, use that as the new Newsgroups line."
 		   (string-match "world" distribution)))
 	(setq distribution nil))
       ;; Strip list identifiers, "Re: ", and "was:"
-      (setq subject (message-simplify-subject subject))
+      (setq subject (concat "Re: " (message-simplify-subject subject)))
       (widen))
 
     (message-pop-to-buffer (message-buffer-name "followup" from newsgroups))
 
     (setq message-reply-headers
-	  (vector 0 subject from date message-id references 0 0 ""))
+	  (make-full-mail-header
+           0 subject from date message-id references 0 0 ""))
 
     (message-setup
      `((Subject . ,subject)
@@ -7414,9 +7375,7 @@ Optional DIGEST will use digest to forward."
     (unless (multibyte-string-p contents)
       (error "Attempt to insert unibyte string from the buffer \"%s\"\
  to the multibyte buffer \"%s\""
-	     (if (bufferp forward-buffer)
-		 (buffer-name forward-buffer)
-	       forward-buffer)
+             forward-buffer
 	     (buffer-name)))
     (insert (mm-with-multibyte-buffer
 	      (insert contents)
@@ -7478,9 +7437,7 @@ Optional DIGEST will use digest to forward."
 	  (unless (multibyte-string-p contents)
 	    (error "Attempt to insert unibyte string from the buffer \"%s\"\
  to the multibyte buffer \"%s\""
-		   (if (bufferp forward-buffer)
-		       (buffer-name forward-buffer)
-		     forward-buffer)
+                   forward-buffer
 		   (buffer-name)))
 	  (insert (mm-with-multibyte-buffer
 		    (insert contents)
@@ -8101,9 +8058,7 @@ regexp VARSTR."
 
 (defun message-encode-message-body ()
   (unless message-inhibit-body-encoding
-    (let ((mail-parse-charset (or mail-parse-charset
-				  message-default-charset))
-	  (case-fold-search t)
+    (let ((case-fold-search t)
 	  lines content-type-p)
       (message-goto-body)
       (save-restriction
diff --git a/lisp/gnus/mm-decode.el b/lisp/gnus/mm-decode.el
index 3f255419e7..85aa6944dd 100644
--- a/lisp/gnus/mm-decode.el
+++ b/lisp/gnus/mm-decode.el
@@ -236,6 +236,7 @@ before the external MIME handler is invoked."
     ("text/x-patch" mm-display-patch-inline identity)
     ;; In case mime.types uses x-diff (as does Debian's mime-support-3.40).
     ("text/x-diff" mm-display-patch-inline identity)
+    ("application/x-patch" mm-display-patch-inline identity)
     ("application/emacs-lisp" mm-display-elisp-inline identity)
     ("application/x-emacs-lisp" mm-display-elisp-inline identity)
     ("application/x-shellscript" mm-display-shell-script-inline identity)
@@ -261,15 +262,6 @@ before the external MIME handler is invoked."
     ("text/.*" mm-inline-text identity)
     ("application/x-.?tar\\(-.*\\)?" mm-archive-dissect-and-inline identity)
     ("application/zip" mm-archive-dissect-and-inline identity)
-    ("audio/wav" mm-inline-audio
-     ,(lambda (_handle)
-       (and (fboundp 'device-sound-enabled-p)
-	    (device-sound-enabled-p))))
-    ("audio/au"
-     mm-inline-audio
-     ,(lambda (_handle)
-       (and (fboundp 'device-sound-enabled-p)
-	    (device-sound-enabled-p))))
     ("application/pgp-signature" ignore identity)
     ("application/x-pkcs7-signature" ignore identity)
     ("application/pkcs7-signature" ignore identity)
@@ -303,8 +295,9 @@ before the external MIME handler is invoked."
 
 (defcustom mm-inlined-types
   '("image/.*" "text/.*" "message/delivery-status" "message/rfc822"
-    "message/partial" "message/external-body" "application/emacs-lisp"
-    "application/x-emacs-lisp"
+    "message/partial" "message/external-body"
+    "application/x-patch"
+    "application/emacs-lisp" "application/x-emacs-lisp"
     "application/pgp-signature" "application/x-pkcs7-signature"
     "application/pkcs7-signature" "application/x-pkcs7-mime"
     "application/pkcs7-mime"
@@ -900,8 +893,7 @@ external if displayed external."
 		  (if method
 		      (progn
 			(when (and (boundp 'gnus-summary-buffer)
-				   (bufferp gnus-summary-buffer)
-				   (buffer-name gnus-summary-buffer))
+                                   (buffer-live-p gnus-summary-buffer))
 			  (when attachment-filename
 			    (with-current-buffer mm
 			      (rename-buffer (format "*mm* %s" attachment-filename) t)))
@@ -1118,7 +1110,7 @@ external if displayed external."
 	  (mm-remove-part handle)))))))
 
 (defun mm-destroy-parts (handles)
-  "Remove the displayed MIME parts represented by HANDLES."
+  "Destroy the displayed MIME parts represented by HANDLES."
   (if (and (listp handles)
 	   (bufferp (car handles)))
       (mm-destroy-part handles)
@@ -1159,9 +1151,8 @@ external if displayed external."
 	  (ignore-errors (delete-file (car object)))
 	  (ignore-errors (delete-directory (file-name-directory
 					    (car object)))))
-	 ((bufferp object)
-	  (when (buffer-live-p object)
-	    (kill-buffer object)))))
+         ((buffer-live-p object)
+          (kill-buffer object))))
       (mm-handle-set-undisplayer handle nil))))
 
 (defun mm-display-inline (handle)
diff --git a/lisp/gnus/mm-view.el b/lisp/gnus/mm-view.el
index 1e1d264b99..849488293a 100644
--- a/lisp/gnus/mm-view.el
+++ b/lisp/gnus/mm-view.el
@@ -472,10 +472,8 @@ If MODE is not set, try to find mode automatically."
 		       (buffer-string)))
 		    (coding-system
 		     (decode-coding-string text coding-system))
-		    (charset
-		     (mm-decode-string text charset))
-		    (t
-		     text)))
+                    (t
+                     (mm-decode-string text (or charset 'undecided)))))
       (let ((font-lock-verbose nil)     ; font-lock is a bit too verbose.
 	    (enable-local-variables nil))
         ;; We used to set font-lock-mode-hook to nil to avoid enabling
diff --git a/lisp/gnus/mml.el b/lisp/gnus/mml.el
index f6d358dfc0..1df4e28f13 100644
--- a/lisp/gnus/mml.el
+++ b/lisp/gnus/mml.el
@@ -48,7 +48,6 @@
 
 (defvar gnus-article-mime-handles)
 (defvar gnus-newsrc-hashtb)
-(defvar message-default-charset)
 (defvar message-deletable-headers)
 (defvar message-options)
 (defvar message-posting-charset)
@@ -703,9 +702,7 @@ be \"related\" or \"alternate\"."
 				  filename)))))
 	       (t
 		(let ((contents (cdr (assq 'contents cont))))
-		  (if (if (featurep 'xemacs)
-			  (string-match "[^\000-\377]" contents)
-			(multibyte-string-p contents))
+		  (if (multibyte-string-p contents)
 		      (progn
 			(set-buffer-multibyte t)
 			(insert contents)
@@ -907,8 +904,14 @@ be \"related\" or \"alternate\"."
 	      (or disposition
 		  (mml-content-disposition type (cdr (assq 'filename cont)))))
       (when parameters
-	(mml-insert-parameter-string
-	 cont mml-content-disposition-parameters))
+	(let ((cont (copy-sequence cont)))
+	  ;; Set the file name to what's specified by the user.
+	  (when-let ((recipient-filename (cdr (assq 'recipient-filename cont))))
+	    (setcdr cont
+		    (cons (cons 'filename recipient-filename)
+			  (cdr cont))))
+	  (mml-insert-parameter-string
+	   cont mml-content-disposition-parameters)))
       (insert "\n"))
     (unless (eq encoding '7bit)
       (insert (format "Content-Transfer-Encoding: %s\n" encoding)))
@@ -1015,8 +1018,7 @@ If HANDLES is non-nil, use it instead reparsing the buffer."
     ;; Skip past any From_ headers.
     (while (looking-at "From ")
       (forward-line 1))
-    (let ((mail-parse-charset message-default-charset))
-      (mail-encode-encoded-word-buffer)))
+    (mail-encode-encoded-word-buffer))
   (message-encode-message-body))
 
 (defun mml-insert-mime (handle &optional no-markup)
diff --git a/lisp/gnus/nnbabyl.el b/lisp/gnus/nnbabyl.el
index 3b31645410..0f4f4303cd 100644
--- a/lisp/gnus/nnbabyl.el
+++ b/lisp/gnus/nnbabyl.el
@@ -145,10 +145,8 @@
 
 (deffoo nnbabyl-server-opened (&optional server)
   (and (nnoo-current-server-p 'nnbabyl server)
-       nnbabyl-mbox-buffer
-       (buffer-name nnbabyl-mbox-buffer)
-       nntp-server-buffer
-       (buffer-name nntp-server-buffer)))
+       (buffer-live-p nnbabyl-mbox-buffer)
+       (buffer-live-p nntp-server-buffer)))
 
 (deffoo nnbabyl-request-article (article &optional newsgroup server buffer)
   (nnbabyl-possibly-change-newsgroup newsgroup server)
@@ -452,8 +450,7 @@
   (when (and server
 	     (not (nnbabyl-server-opened server)))
     (nnbabyl-open-server server))
-  (when (or (not nnbabyl-mbox-buffer)
-	    (not (buffer-name nnbabyl-mbox-buffer)))
+  (unless (buffer-live-p nnbabyl-mbox-buffer)
     (save-excursion (nnbabyl-read-mbox)))
   (unless nnbabyl-group-alist
     (nnmail-activate 'nnbabyl))
@@ -556,8 +553,7 @@
   (nnmail-activate 'nnbabyl)
   (nnbabyl-create-mbox)
 
-  (unless (and nnbabyl-mbox-buffer
-	       (buffer-name nnbabyl-mbox-buffer)
+  (unless (and (buffer-live-p nnbabyl-mbox-buffer)
 	       (with-current-buffer nnbabyl-mbox-buffer
 		 (= (buffer-size) (nnheader-file-size nnbabyl-mbox-file))))
     ;; This buffer has changed since we read it last.  Possibly.
@@ -627,8 +623,7 @@
   (let ((idents (gnus-make-hashtable 1000))
 	id)
     (save-excursion
-      (when (or (not nnbabyl-mbox-buffer)
-		(not (buffer-name nnbabyl-mbox-buffer)))
+      (unless (buffer-live-p nnbabyl-mbox-buffer)
 	(nnbabyl-read-mbox))
       (set-buffer nnbabyl-mbox-buffer)
       (goto-char (point-min))
diff --git a/lisp/gnus/nndiary.el b/lisp/gnus/nndiary.el
index c8b7eed987..f8ec222616 100644
--- a/lisp/gnus/nndiary.el
+++ b/lisp/gnus/nndiary.el
@@ -2,8 +2,7 @@
 
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
-;; Author:        Didier Verna <didier@xemacs.org>
-;; Maintainer:    Didier Verna <didier@xemacs.org>
+;; Author:        Didier Verna <didier@didierverna.net>
 ;; Created:       Fri Jul 16 18:55:42 1999
 ;; Keywords:      calendar mail news
 
@@ -979,7 +978,7 @@ all.  This may very well take some time.")
   "Add a nov line for the GROUP base."
   (with-current-buffer (nndiary-open-nov group)
     (goto-char (point-max))
-    (mail-header-set-number headers article)
+    (setf (mail-header-number headers) article)
     (nnheader-insert-nov headers)))
 
 (defsubst nndiary-header-value ()
@@ -994,8 +993,8 @@ all.  This may very well take some time.")
 	 (goto-char (point-min))
 	 (if (search-forward "\n\n" nil t) (1- (point)) (point-max))))
       (let ((headers (nnheader-parse-naked-head)))
-	(mail-header-set-chars headers chars)
-	(mail-header-set-number headers number)
+	(setf (mail-header-chars  headers) chars)
+	(setf (mail-header-number headers) number)
 	headers))))
 
 (defun nndiary-open-nov (group)
@@ -1016,7 +1015,7 @@ all.  This may very well take some time.")
 (defun nndiary-save-nov ()
   (save-excursion
     (while nndiary-nov-buffer-alist
-      (when (buffer-name (cdar nndiary-nov-buffer-alist))
+      (when (buffer-live-p (cdar nndiary-nov-buffer-alist))
 	(set-buffer (cdar nndiary-nov-buffer-alist))
 	(when (buffer-modified-p)
 	  (nnmail-write-region 1 (point-max) nndiary-nov-buffer-file-name
diff --git a/lisp/gnus/nndoc.el b/lisp/gnus/nndoc.el
index 532ba11fa0..9c8cab597a 100644
--- a/lisp/gnus/nndoc.el
+++ b/lisp/gnus/nndoc.el
@@ -309,8 +309,7 @@ from the document.")
 
 (deffoo nndoc-close-group (group &optional server)
   (nndoc-possibly-change-buffer group server)
-  (and nndoc-current-buffer
-       (buffer-name nndoc-current-buffer)
+  (and (buffer-live-p nndoc-current-buffer)
        (kill-buffer nndoc-current-buffer))
   (setq nndoc-group-alist (delq (assoc group nndoc-group-alist)
 				nndoc-group-alist))
@@ -335,8 +334,7 @@ from the document.")
   (let (buf)
     (cond
      ;; The current buffer is this group's buffer.
-     ((and nndoc-current-buffer
-	   (buffer-name nndoc-current-buffer)
+     ((and (buffer-live-p nndoc-current-buffer)
 	   (eq nndoc-current-buffer
 	       (setq buf (cdr (assoc group nndoc-group-alist))))))
      ;; We change buffers by taking an old from the group alist.
@@ -344,8 +342,7 @@ from the document.")
      (buf
       (setq nndoc-current-buffer buf))
      ;; It's a totally new group.
-     ((or (and (bufferp nndoc-address)
-	       (buffer-name nndoc-address))
+     ((or (buffer-live-p nndoc-address)
 	  (and (stringp nndoc-address)
 	       (file-exists-p nndoc-address)
 	       (not (file-directory-p nndoc-address))))
diff --git a/lisp/gnus/nnfolder.el b/lisp/gnus/nnfolder.el
index 1c83045e45..6334b1c998 100644
--- a/lisp/gnus/nnfolder.el
+++ b/lisp/gnus/nnfolder.el
@@ -328,8 +328,7 @@ all.  This may very well take some time.")
 	      (delq inf nnfolder-buffer-alist))
 	(setq nnfolder-current-buffer (cadr inf)
 	      nnfolder-current-group (car inf))))
-    (when (and nnfolder-current-buffer
-	       (buffer-name nnfolder-current-buffer))
+    (when (buffer-live-p nnfolder-current-buffer)
       (with-current-buffer nnfolder-current-buffer
 	;; If the buffer was modified, write the file out now.
 	(nnfolder-save-buffer)
@@ -1110,7 +1109,7 @@ This command does not work if you use short group names."
 (defun nnfolder-save-nov ()
   (save-excursion
     (while nnfolder-nov-buffer-alist
-      (when (buffer-name (cdar nnfolder-nov-buffer-alist))
+      (when (buffer-live-p (cdar nnfolder-nov-buffer-alist))
 	(set-buffer (cdar nnfolder-nov-buffer-alist))
 	(when (buffer-modified-p)
 	  (gnus-make-directory (file-name-directory
@@ -1162,15 +1161,15 @@ This command does not work if you use short group names."
       (with-temp-buffer
 	(insert-buffer-substring buf b e)
 	(let ((headers (nnheader-parse-naked-head)))
-	  (mail-header-set-chars headers chars)
-	  (mail-header-set-number headers number)
+	  (setf (mail-header-chars  headers) chars)
+	  (setf (mail-header-number headers) number)
 	  headers)))))
 
 (defun nnfolder-add-nov (group article headers)
   "Add a nov line for the GROUP base."
   (with-current-buffer (nnfolder-open-nov group)
     (goto-char (point-max))
-    (mail-header-set-number headers article)
+    (setf (mail-header-number headers) article)
     (nnheader-insert-nov headers)))
 
 (provide 'nnfolder)
diff --git a/lisp/gnus/nnheader.el b/lisp/gnus/nnheader.el
index 090b842084..6ef324ae91 100644
--- a/lisp/gnus/nnheader.el
+++ b/lisp/gnus/nnheader.el
@@ -121,7 +121,6 @@ on your system, you could say something like:
 
 (autoload 'nnmail-message-id "nnmail")
 (autoload 'mail-position-on-field "sendmail")
-(autoload 'gnus-buffer-live-p "gnus-util")
 
 ;;; Header access macros.
 
@@ -136,97 +135,31 @@ on your system, you could say something like:
 ;; (That next-to-last entry is defined as "misc" in the NOV format,
 ;; but Gnus uses it for xrefs.)
 
-(defmacro mail-header-number (header)
-  "Return article number in HEADER."
-  `(aref ,header 0))
-
-(defmacro mail-header-set-number (header number)
-  "Set article number of HEADER to NUMBER."
-  `(aset ,header 0 ,number))
-
-(defmacro mail-header-subject (header)
-  "Return subject string in HEADER."
-  `(aref ,header 1))
-
-(defmacro mail-header-set-subject (header subject)
-  "Set article subject of HEADER to SUBJECT."
-  `(aset ,header 1 ,subject))
-
-(defmacro mail-header-from (header)
-  "Return author string in HEADER."
-  `(aref ,header 2))
-
-(defmacro mail-header-set-from (header from)
-  "Set article author of HEADER to FROM."
-  `(aset ,header 2 ,from))
-
-(defmacro mail-header-date (header)
-  "Return date in HEADER."
-  `(aref ,header 3))
-
-(defmacro mail-header-set-date (header date)
-  "Set article date of HEADER to DATE."
-  `(aset ,header 3 ,date))
-
-(defalias 'mail-header-message-id 'mail-header-id)
-(defmacro mail-header-id (header)
-  "Return Id in HEADER."
-  `(aref ,header 4))
-
-(defalias 'mail-header-set-message-id 'mail-header-set-id)
-(defmacro mail-header-set-id (header id)
-  "Set article Id of HEADER to ID."
-  `(aset ,header 4 ,id))
-
-(defmacro mail-header-references (header)
-  "Return references in HEADER."
-  `(aref ,header 5))
-
-(defmacro mail-header-set-references (header ref)
-  "Set article references of HEADER to REF."
-  `(aset ,header 5 ,ref))
-
-(defmacro mail-header-chars (header)
-  "Return number of chars of article in HEADER."
-  `(aref ,header 6))
-
-(defmacro mail-header-set-chars (header chars)
-  "Set number of chars in article of HEADER to CHARS."
-  `(aset ,header 6 ,chars))
-
-(defmacro mail-header-lines (header)
-  "Return lines in HEADER."
-  `(aref ,header 7))
-
-(defmacro mail-header-set-lines (header lines)
-  "Set article lines of HEADER to LINES."
-  `(aset ,header 7 ,lines))
-
-(defmacro mail-header-xref (header)
-  "Return xref string in HEADER."
-  `(aref ,header 8))
-
-(defmacro mail-header-set-xref (header xref)
-  "Set article XREF of HEADER to xref."
-  `(aset ,header 8 ,xref))
-
-(defmacro mail-header-extra (header)
-  "Return the extra headers in HEADER."
-  `(aref ,header 9))
-
-(defun mail-header-set-extra (header extra)
-  "Set the extra headers in HEADER to EXTRA."
-  (aset header 9 extra))
+(defalias 'mail-header-p #'vectorp)     ;For lack of tag, it's all we have.
+(cl-defstruct (mail-header
+               (:type vector)
+               (:constructor nil)
+               (:constructor make-full-mail-header
+                (&optional number subject from date id
+			   references chars lines xref
+			   extra)))
+  number
+  subject
+  from
+  date
+  id
+  references
+  chars
+  lines
+  xref
+  extra)
+
+(defalias 'mail-header-message-id #'mail-header-id)
 
 (defsubst make-mail-header (&optional init)
   "Create a new mail header structure initialized with INIT."
-  (make-vector 10 init))
-
-(defsubst make-full-mail-header (&optional number subject from date id
-					   references chars lines xref
-					   extra)
-  "Create a new mail header structure initialized with the parameters given."
-  (vector number subject from date id references chars lines xref extra))
+  (make-full-mail-header init init init init init
+                         init init init init init))
 
 ;; fake message-ids: generation and detection
 
@@ -1036,8 +969,9 @@ See `find-file-noselect' for the arguments."
   "Strip all \r's from the current buffer."
   (nnheader-skeleton-replace "\r"))
 
-(defalias 'nnheader-cancel-timer 'cancel-timer)
-(defalias 'nnheader-cancel-function-timers 'cancel-function-timers)
+(define-obsolete-function-alias 'nnheader-cancel-timer 'cancel-timer "27.1")
+(define-obsolete-function-alias 'nnheader-cancel-function-timers
+  'cancel-function-timers "27.1")
 
 ;; When changing this function, consider changing `pop3-accept-process-output'
 ;; as well.
diff --git a/lisp/gnus/nnimap.el b/lisp/gnus/nnimap.el
index ac1d28644f..9e52abc1ca 100644
--- a/lisp/gnus/nnimap.el
+++ b/lisp/gnus/nnimap.el
@@ -346,7 +346,7 @@ textual parts.")
   (with-current-buffer
       (generate-new-buffer (format " *nnimap %s %s %s*"
 				   nnimap-address nnimap-server-port
-				   (gnus-buffer-exists-p buffer)))
+                                   buffer))
     (mm-disable-multibyte)
     (buffer-disable-undo)
     (gnus-add-buffer)
@@ -382,7 +382,7 @@ textual parts.")
 (defun nnimap-keepalive ()
   (let ((now (current-time)))
     (dolist (buffer nnimap-process-buffers)
-      (when (buffer-name buffer)
+      (when (buffer-live-p buffer)
 	(with-current-buffer buffer
 	  (when (and nnimap-object
 		     (nnimap-last-command-time nnimap-object)
@@ -1899,7 +1899,7 @@ Return the server's response to the SELECT or EXAMINE command."
   "Find the connection delivering to BUFFER."
   (let ((entry (assoc buffer nnimap-connection-alist)))
     (when entry
-      (if (and (buffer-name (cadr entry))
+      (if (and (buffer-live-p (cadr entry))
 	       (get-buffer-process (cadr entry))
 	       (memq (process-status (get-buffer-process (cadr entry)))
 		     '(open run)))
diff --git a/lisp/gnus/nnir.el b/lisp/gnus/nnir.el
index 37a38a58d4..9d59a4db0d 100644
--- a/lisp/gnus/nnir.el
+++ b/lisp/gnus/nnir.el
@@ -723,7 +723,7 @@ skips all prompting."
 			       (mail-header-number novitem)))
 		   (art (car (rassq artno articleids))))
 	      (when art
-		(mail-header-set-number novitem art)
+		(setf (mail-header-number novitem) art)
 		(push novitem headers))
 	      (forward-line 1)))))
       (setq headers
diff --git a/lisp/gnus/nnmail.el b/lisp/gnus/nnmail.el
index b6dbbea74c..ed3d571270 100644
--- a/lisp/gnus/nnmail.el
+++ b/lisp/gnus/nnmail.el
@@ -34,8 +34,6 @@
 (require 'mm-util)
 (require 'gnus-int)
 
-(autoload 'gnus-add-buffer "gnus")
-(autoload 'gnus-kill-buffer "gnus")
 (autoload 'mail-send-and-exit "sendmail" nil t)
 
 (defgroup nnmail nil
@@ -1563,8 +1561,7 @@ See the documentation for the variable `nnmail-split-fancy' for details."
 
 (defun nnmail-cache-open ()
   (if (or (not nnmail-treat-duplicates)
-	  (and nnmail-cache-buffer
-	       (buffer-name nnmail-cache-buffer)))
+          (buffer-live-p nnmail-cache-buffer))
       ()				; The buffer is open.
     (with-current-buffer
        (setq nnmail-cache-buffer
@@ -1576,9 +1573,8 @@ See the documentation for the variable `nnmail-split-fancy' for details."
       (current-buffer))))
 
 (defun nnmail-cache-close ()
-  (when (and nnmail-cache-buffer
-	     nnmail-treat-duplicates
-	     (buffer-name nnmail-cache-buffer)
+  (when (and nnmail-treat-duplicates
+             (buffer-live-p nnmail-cache-buffer)
 	     (buffer-modified-p nnmail-cache-buffer))
     (with-current-buffer nnmail-cache-buffer
       ;; Weed out the excess number of Message-IDs.
diff --git a/lisp/gnus/nnmaildir.el b/lisp/gnus/nnmaildir.el
index 9d02773d6f..ac125c905a 100644
--- a/lisp/gnus/nnmaildir.el
+++ b/lisp/gnus/nnmaildir.el
@@ -1490,7 +1490,7 @@ This variable is set by `nnmaildir-request-article'.")
 		       'excl)
 	 (when (fboundp 'unix-sync)
 	   (unix-sync)))) ;; no fsync :(
-      (nnheader-cancel-timer 24h)
+      (cancel-timer 24h)
       (condition-case err
 	  (add-name-to-file tmpfile curfile)
 	(error
diff --git a/lisp/gnus/nnmairix.el b/lisp/gnus/nnmairix.el
index 501ea1d390..53275e1964 100644
--- a/lisp/gnus/nnmairix.el
+++ b/lisp/gnus/nnmairix.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author: David Engster <dengste@eml.cc>
+;; Author: David Engster <deng@randomsample.de>
 ;; Keywords: mail searching
 ;; Old-Version: 0.6
 
@@ -1419,12 +1419,12 @@ TYPE is either 'nov or 'headers."
 	     (setq cur (nnheader-parse-nov))
 	     (when corr
 	       (setq article (+ (mail-header-number cur) numc))
-	       (mail-header-set-number cur article))
+	       (setf (mail-header-number cur) article))
 	     (setq xref (mail-header-xref cur))
 	     (when (and (stringp xref)
 			(string-match (format "[ \t]%s:[0-9]+" backendgroup) xref))
 	       (setq xref (replace-match (format " %s:%d" mairixgroup article) t nil xref))
-	       (mail-header-set-xref cur xref))
+	       (setf (mail-header-xref cur) xref))
 	     (set-buffer buf)
 	     (nnheader-insert-nov cur)
 	     (set-buffer nntp-server-buffer)
diff --git a/lisp/gnus/nnmbox.el b/lisp/gnus/nnmbox.el
index bba41336dd..110f39a867 100644
--- a/lisp/gnus/nnmbox.el
+++ b/lisp/gnus/nnmbox.el
@@ -131,18 +131,15 @@
     t)))
 
 (deffoo nnmbox-close-server (&optional server)
-  (when (and nnmbox-mbox-buffer
-	     (buffer-name nnmbox-mbox-buffer))
+  (when (buffer-live-p nnmbox-mbox-buffer)
     (kill-buffer nnmbox-mbox-buffer))
   (nnoo-close-server 'nnmbox server)
   t)
 
 (deffoo nnmbox-server-opened (&optional server)
   (and (nnoo-current-server-p 'nnmbox server)
-       nnmbox-mbox-buffer
-       (buffer-name nnmbox-mbox-buffer)
-       nntp-server-buffer
-       (buffer-name nntp-server-buffer)))
+       (buffer-live-p nnmbox-mbox-buffer)
+       (buffer-live-p nntp-server-buffer)))
 
 (deffoo nnmbox-request-article (article &optional newsgroup server buffer)
   (nnmbox-possibly-change-newsgroup newsgroup server)
@@ -463,8 +460,7 @@
   (when (and server
 	     (not (nnmbox-server-opened server)))
     (nnmbox-open-server server))
-  (when (or (not nnmbox-mbox-buffer)
-	    (not (buffer-name nnmbox-mbox-buffer)))
+  (unless (buffer-live-p nnmbox-mbox-buffer)
     (nnmbox-read-mbox))
   (when (not nnmbox-group-alist)
     (nnmail-activate 'nnmbox))
@@ -622,8 +618,7 @@
 (defun nnmbox-read-mbox ()
   (nnmail-activate 'nnmbox)
   (nnmbox-create-mbox)
-  (if (and nnmbox-mbox-buffer
-	   (buffer-name nnmbox-mbox-buffer)
+  (if (and (buffer-live-p nnmbox-mbox-buffer)
 	   (with-current-buffer nnmbox-mbox-buffer
 	     (= (buffer-size) (nnheader-file-size nnmbox-mbox-file))))
       ()
diff --git a/lisp/gnus/nnml.el b/lisp/gnus/nnml.el
index 205e9e4803..89c8b23b65 100644
--- a/lisp/gnus/nnml.el
+++ b/lisp/gnus/nnml.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1995-2019 Free Software Foundation, Inc.
 
-;; Authors: Didier Verna <didier@xemacs.org> (adding compaction)
+;; Authors: Didier Verna <didier@didierverna.net> (adding compaction)
 ;;	Simon Josefsson <simon@josefsson.org>
 ;;	Lars Magne Ingebrigtsen <larsi@gnus.org>
 ;;	Masanobu UMEDA <umerin@flab.flab.fujitsu.junet>
@@ -772,7 +772,7 @@ article number.  This function is called narrowed to an article."
 (defun nnml-save-incremental-nov ()
   (save-excursion
     (while nnml-incremental-nov-buffer-alist
-      (when (buffer-name (cdar nnml-incremental-nov-buffer-alist))
+      (when (buffer-live-p (cdar nnml-incremental-nov-buffer-alist))
 	(set-buffer (cdar nnml-incremental-nov-buffer-alist))
 	(when (buffer-modified-p)
 	  (nnmail-write-region (point-min) (point-max)
@@ -792,14 +792,14 @@ article number.  This function is called narrowed to an article."
   "Add a nov line for the GROUP nov headers, incrementally."
   (with-current-buffer (nnml-open-incremental-nov group)
     (goto-char (point-max))
-    (mail-header-set-number headers article)
+    (setf (mail-header-number headers) article)
     (nnheader-insert-nov headers)))
 
 (defun nnml-add-nov (group article headers)
   "Add a nov line for the GROUP base."
   (with-current-buffer (nnml-open-nov group)
     (goto-char (point-max))
-    (mail-header-set-number headers article)
+    (setf (mail-header-number headers) article)
     (nnheader-insert-nov headers)))
 
 (defsubst nnml-header-value ()
@@ -816,8 +816,8 @@ article number.  This function is called narrowed to an article."
 	     (1- (point))
 	   (point-max))))
       (let ((headers (nnheader-parse-naked-head)))
-	(mail-header-set-chars headers chars)
-	(mail-header-set-number headers number)
+	(setf (mail-header-chars  headers) chars)
+	(setf (mail-header-number headers) number)
 	headers))))
 
 (defun nnml-get-nov-buffer (group &optional incrementalp)
@@ -838,9 +838,7 @@ article number.  This function is called narrowed to an article."
     buffer))
 
 (defun nnml-open-nov (group)
-  (or (let ((buffer (cdr (assoc group nnml-nov-buffer-alist))))
-	(and (buffer-name buffer)
-	     buffer))
+  (or (gnus-buffer-live-p (cdr (assoc group nnml-nov-buffer-alist)))
       (let ((buffer (nnml-get-nov-buffer group)))
 	(push (cons group buffer) nnml-nov-buffer-alist)
 	buffer)))
@@ -848,7 +846,7 @@ article number.  This function is called narrowed to an article."
 (defun nnml-save-nov ()
   (save-excursion
     (while nnml-nov-buffer-alist
-      (when (buffer-name (cdar nnml-nov-buffer-alist))
+      (when (buffer-live-p (cdar nnml-nov-buffer-alist))
 	(set-buffer (cdar nnml-nov-buffer-alist))
 	(when (buffer-modified-p)
 	  (nnmail-write-region (point-min) (point-max)
diff --git a/lisp/gnus/nnoo.el b/lisp/gnus/nnoo.el
index 0cf2362b36..c65668a719 100644
--- a/lisp/gnus/nnoo.el
+++ b/lisp/gnus/nnoo.el
@@ -269,8 +269,7 @@
 
 (defun nnoo-server-opened (backend server)
   (and (nnoo-current-server-p backend server)
-       nntp-server-buffer
-       (buffer-name nntp-server-buffer)))
+       (buffer-live-p nntp-server-buffer)))
 
 (defmacro nnoo-define-basics (backend)
   "Define `close-server', `server-opened' and `status-message'."
diff --git a/lisp/gnus/nnregistry.el b/lisp/gnus/nnregistry.el
index 4bc74ce5b9..6dcdac5462 100644
--- a/lisp/gnus/nnregistry.el
+++ b/lisp/gnus/nnregistry.el
@@ -3,7 +3,7 @@
 
 ;; Copyright (C) 2010-2019 Free Software Foundation, Inc.
 
-;; Authors: Ludovic Courtès <ludo@gnu.org>
+;; Author: Ludovic Courtès <ludo@gnu.org>
 ;; Keywords: news, mail
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/gnus/nntp.el b/lisp/gnus/nntp.el
index e2fa1d85a3..9bc215c12f 100644
--- a/lisp/gnus/nntp.el
+++ b/lisp/gnus/nntp.el
@@ -400,7 +400,7 @@ retried once before actually displaying the error report."
 	(erase-buffer)))))
 
 (defun nntp-kill-buffer (buffer)
-  (when (buffer-name buffer)
+  (when (buffer-live-p buffer)
     (let ((process (get-buffer-process buffer)))
       (when process
 	(delete-process process)))
@@ -647,7 +647,7 @@ command whose response triggered the error."
                               (nntp-close-server))
                             (signal 'quit nil))))
                  (when -timer
-                   (nnheader-cancel-timer -timer)))
+                   (cancel-timer -timer)))
                nil))
       (setq nntp--report-1 nntp-report-n))
     nntp-with-open-group-internal))
@@ -1228,16 +1228,15 @@ If SEND-IF-FORCE, only send authinfo to the server if the
   (with-current-buffer
       (generate-new-buffer
        (format " *server %s %s %s*"
-               nntp-address nntp-port-number
-               (gnus-buffer-exists-p buffer)))
+               nntp-address nntp-port-number buffer))
     (mm-disable-multibyte)
-    (set (make-local-variable 'after-change-functions) nil)
-    (set (make-local-variable 'nntp-process-wait-for) nil)
-    (set (make-local-variable 'nntp-process-callback) nil)
-    (set (make-local-variable 'nntp-process-to-buffer) nil)
-    (set (make-local-variable 'nntp-process-start-point) nil)
-    (set (make-local-variable 'nntp-process-decode) nil)
-    (set (make-local-variable 'nntp-retrieval-in-progress) nil)
+    (setq-local after-change-functions nil)
+    (setq-local nntp-process-wait-for nil)
+    (setq-local nntp-process-callback nil)
+    (setq-local nntp-process-to-buffer nil)
+    (setq-local nntp-process-start-point nil)
+    (setq-local nntp-process-decode nil)
+    (setq-local nntp-retrieval-in-progress nil)
     (current-buffer)))
 
 (defun nntp-open-connection (buffer)
@@ -1280,7 +1279,7 @@ If SEND-IF-FORCE, only send authinfo to the server if the
 	     (signal 'quit nil)
 	     nil))))
     (when timer
-      (nnheader-cancel-timer timer))
+      (cancel-timer timer))
     (when (and process
 	       (not (memq (process-status process) '(open run))))
       (with-current-buffer pbuffer
@@ -1290,7 +1289,7 @@ If SEND-IF-FORCE, only send authinfo to the server if the
       (setq process nil))
     (unless process
       (nntp-kill-buffer pbuffer))
-    (when (and (buffer-name pbuffer)
+    (when (and (buffer-live-p pbuffer)
 	       process)
       (when (eq (process-type process) 'network)
         ;; Use TCP-keepalive so that connections that pass through a NAT router
@@ -1339,7 +1338,7 @@ If SEND-IF-FORCE, only send authinfo to the server if the
 (defun nntp-async-stop (proc)
   (setq nntp-async-process-list (delq proc nntp-async-process-list))
   (when (and nntp-async-timer (not nntp-async-process-list))
-    (nnheader-cancel-timer nntp-async-timer)
+    (cancel-timer nntp-async-timer)
     (setq nntp-async-timer nil)))
 
 (defun nntp-after-change-function (beg end len)
@@ -1358,17 +1357,17 @@ If SEND-IF-FORCE, only send authinfo to the server if the
 (defun nntp-async-trigger (process)
   (with-current-buffer (process-buffer process)
     (when nntp-process-callback
-      ;; do we have an error message?
+      ;; Do we have an error message?
       (goto-char nntp-process-start-point)
       (if (memq (following-char) '(?4 ?5))
-	  ;; wants credentials?
-	  (if (looking-at "480")
+          ;; Wants credentials?
+          (if (looking-at-p "480")
 	      (nntp-handle-authinfo process)
-	    ;; report error message.
+            ;; Report error message.
 	    (nntp-snarf-error-message)
 	    (nntp-do-callback nil))
 
-	;; got what we expect?
+        ;; Got what we expect?
 	(goto-char (point-max))
 	(when (re-search-backward
 	       nntp-process-wait-for nntp-process-start-point t)
@@ -1376,8 +1375,8 @@ If SEND-IF-FORCE, only send authinfo to the server if the
 	    (with-current-buffer nntp-server-buffer
 	      (setq nntp-process-response response)))
 	  (nntp-async-stop process)
-	  ;; convert it.
-	  (when (gnus-buffer-exists-p nntp-process-to-buffer)
+          ;; Convert it.
+          (when (gnus-buffer-live-p nntp-process-to-buffer)
 	    (let ((buf (current-buffer))
 		  (start nntp-process-start-point)
 		  (decode nntp-process-decode))
@@ -1388,7 +1387,7 @@ If SEND-IF-FORCE, only send authinfo to the server if the
 		  (nnheader-insert-buffer-substring buf start)
 		  (when decode
 		    (nntp-decode-text))))))
-	  ;; report it.
+          ;; Report it.
 	  (goto-char (point-max))
 	  (nntp-do-callback
 	   (buffer-name (get-buffer nntp-process-to-buffer))))))))
diff --git a/lisp/gnus/nnvirtual.el b/lisp/gnus/nnvirtual.el
index c80bbf6187..25f3413fcd 100644
--- a/lisp/gnus/nnvirtual.el
+++ b/lisp/gnus/nnvirtual.el
@@ -491,9 +491,9 @@ If UPDATE-P is not nil, call gnus-group-update-group on the components."
 
 
 
-;;; This is currently O(kn^2) to merge n lists of length k.
-;;; You could do it in O(knlogn), but we have a small n, and the
-;;; overhead of the other approach is probably greater.
+;; This is currently O(kn^2) to merge n lists of length k.
+;; You could do it in O(knlogn), but we have a small n, and the
+;; overhead of the other approach is probably greater.
 (defun nnvirtual-merge-sorted-lists (&rest lists)
   "Merge many sorted lists of numbers."
   (if (null (cdr lists))
@@ -501,68 +501,68 @@ If UPDATE-P is not nil, call gnus-group-update-group on the components."
     (sort (apply 'nconc lists) '<)))
 
 
-;;; We map between virtual articles and real articles in a manner
-;;; which keeps the size of the virtual active list the same as the
-;;; sum of the component active lists.
-
-;;; To achieve fair mixing of the groups, the last article in each of
-;;; N component groups will be in the last N articles in the virtual
-;;; group.
-
-;;; If you have 3 components A, B and C, with articles 1-8, 1-5, and
-;;; 6-7 respectively, then the virtual article numbers look like:
-;;;
-;;;  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
-;;;  A1 A2 A3 A4 B1 A5 B2 A6 B3 A7 B4 C6 A8 B5 C7
-
-;;; To compute these mappings we generate a couple tables and then
-;;; do some fast operations on them.  Tables for the example above:
-;;;
-;;; Offsets - [(A 0) (B -3) (C -1)]
-;;;
-;;;               a  b  c  d  e
-;;; Mapping - ([  3  0  1  3  0 ]
-;;;            [  6  3  2  9  3 ]
-;;;            [  8  6  3 15  9 ])
-;;;
-;;; (note column 'e' is different in real algorithm, which is slightly
-;;;  different than described here, but this gives you the methodology.)
-;;;
-;;; The basic idea is this, when going from component->virtual, apply
-;;; the appropriate offset to the article number.  Then search the first
-;;; column of the table for a row where 'a' is less than or equal to the
-;;; modified number.  You can see that only group A can therefore go to
-;;; the first row, groups A and B to the second, and all to the last.
-;;; The third column of the table is telling us the number of groups
-;;; which might be able to reach that row (it might increase by more than
-;;; 1 if several groups have the same size).
-;;; Then column 'b' provides an additional offset you apply when you have
-;;; found the correct row.  You then multiply by 'c' and add on the groups
-;;; _position_ in the offset table.  The basic idea here is that on
-;;; any given row we are going to map back and forth using X'=X*c+Y and
-;;; X=(X'/c), Y=(X' mod c).  Then once you've done this transformation,
-;;; you apply a final offset from column 'e' to give the virtual article.
-;;;
-;;; Going the other direction, you instead search on column 'd' instead
-;;; of 'a', and apply everything in reverse order.
-
-;;; Convert component -> virtual:
-;;; set num = num - Offset(group)
-;;; find first row in Mapping where num <= 'a'
-;;; num = (num-'b')*c + Position(group) + 'e'
-
-;;; Convert virtual -> component:
-;;; find first row in Mapping where num <= 'd'
-;;; num = num - 'e'
-;;; group_pos = num mod 'c'
-;;; num = (num / 'c') + 'b' + Offset(group_pos)
-
-;;; Easy no? :)
-;;;
-;;; Well actually, you need to keep column e offset smaller by the 'c'
-;;; column for that line, and always add 1 more when going from
-;;; component -> virtual.  Otherwise you run into a problem with
-;;; unique reverse mapping.
+;; We map between virtual articles and real articles in a manner
+;; which keeps the size of the virtual active list the same as the
+;; sum of the component active lists.
+
+;; To achieve fair mixing of the groups, the last article in each of
+;; N component groups will be in the last N articles in the virtual
+;; group.
+
+;; If you have 3 components A, B and C, with articles 1-8, 1-5, and
+;; 6-7 respectively, then the virtual article numbers look like:
+;;
+;;  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
+;;  A1 A2 A3 A4 B1 A5 B2 A6 B3 A7 B4 C6 A8 B5 C7
+
+;; To compute these mappings we generate a couple tables and then
+;; do some fast operations on them.  Tables for the example above:
+;;
+;; Offsets - [(A 0) (B -3) (C -1)]
+;;
+;;               a  b  c  d  e
+;; Mapping - ([  3  0  1  3  0 ]
+;;            [  6  3  2  9  3 ]
+;;            [  8  6  3 15  9 ])
+;;
+;; (note column 'e' is different in real algorithm, which is slightly
+;;  different than described here, but this gives you the methodology.)
+;;
+;; The basic idea is this, when going from component->virtual, apply
+;; the appropriate offset to the article number.  Then search the first
+;; column of the table for a row where 'a' is less than or equal to the
+;; modified number.  You can see that only group A can therefore go to
+;; the first row, groups A and B to the second, and all to the last.
+;; The third column of the table is telling us the number of groups
+;; which might be able to reach that row (it might increase by more than
+;; 1 if several groups have the same size).
+;; Then column 'b' provides an additional offset you apply when you have
+;; found the correct row.  You then multiply by 'c' and add on the groups
+;; _position_ in the offset table.  The basic idea here is that on
+;; any given row we are going to map back and forth using X'=X*c+Y and
+;; X=(X'/c), Y=(X' mod c).  Then once you've done this transformation,
+;; you apply a final offset from column 'e' to give the virtual article.
+;;
+;; Going the other direction, you instead search on column 'd' instead
+;; of 'a', and apply everything in reverse order.
+
+;; Convert component -> virtual:
+;; set num = num - Offset(group)
+;; find first row in Mapping where num <= 'a'
+;; num = (num-'b')*c + Position(group) + 'e'
+
+;; Convert virtual -> component:
+;; find first row in Mapping where num <= 'd'
+;; num = num - 'e'
+;; group_pos = num mod 'c'
+;; num = (num / 'c') + 'b' + Offset(group_pos)
+
+;; Easy no? :)
+;;
+;; Well actually, you need to keep column e offset smaller by the 'c'
+;; column for that line, and always add 1 more when going from
+;; component -> virtual.  Otherwise you run into a problem with
+;; unique reverse mapping.
 
 (defun nnvirtual-map-article (article)
   "Return a cons of the component group and article corresponding to the given virtual ARTICLE."
diff --git a/lisp/gnus/nnweb.el b/lisp/gnus/nnweb.el
index 7b87502d0e..b08b27dd1e 100644
--- a/lisp/gnus/nnweb.el
+++ b/lisp/gnus/nnweb.el
@@ -461,22 +461,21 @@ Valid types include `google', `dejanews', and `gmane'.")
 		    (subject (mail-header-subject header))
 		    (rfc2047-encoding-type 'mime))
 		(when (string-match " \\([^:]+\\)[:/]\\([0-9]+\\)" xref)
-		  (mail-header-set-xref
-		   header
-		   (format "http://article.gmane.org/%s/%s/raw"
-			   (match-string 1 xref)
-			   (match-string 2 xref))))
+		  (setf (mail-header-xref header)
+		        (format "http://article.gmane.org/%s/%s/raw"
+			        (match-string 1 xref)
+			        (match-string 2 xref))))
 
 		;; Add host part to gmane-encrypted addresses
 		(when (string-match "@$" from)
-		  (mail-header-set-from header
-					(concat from "public.gmane.org")))
+		  (setf (mail-header-from header)
+			(concat from "public.gmane.org")))
 
-		(mail-header-set-subject header
-					 (rfc2047-encode-string subject))
+		(setf (mail-header-subject header)
+		      (rfc2047-encode-string subject))
 
 		(unless (nnweb-get-hashtb (mail-header-xref header))
-		  (mail-header-set-number header (cl-incf (cdr active)))
+		  (setf (mail-header-number header) (cl-incf (cdr active)))
 		  (push (list (mail-header-number header) header) map)
 		  (nnweb-set-hashtb (cadar map) (car map))))))
 	  (forward-line 1)))
diff --git a/lisp/help-fns.el b/lisp/help-fns.el
index 50d69e70de..f036a5a4cb 100644
--- a/lisp/help-fns.el
+++ b/lisp/help-fns.el
@@ -104,11 +104,23 @@ and the output should go to `standard-output'.")
         (with-demoted-errors "while loading: %S"
           (load file 'noerror 'nomessage))))))
 
+(defcustom help-enable-completion-auto-load t
+  "Whether completion for Help commands can perform autoloading.
+If non-nil, whenever invoking completion for `describe-function'
+or `describe-variable' load files that might contain definitions
+with the current prefix.  The files are chosen according to
+`definition-prefixes'."
+  :type 'boolean
+  :group 'help
+  :version "26.3")
+
 (defun help--symbol-completion-table (string pred action)
-  (let ((prefixes (radix-tree-prefixes (help-definition-prefixes) string)))
-    (help--load-prefixes prefixes))
+  (when help-enable-completion-auto-load
+    (let ((prefixes (radix-tree-prefixes (help-definition-prefixes) string)))
+      (help--load-prefixes prefixes)))
   (let ((prefix-completions
-         (mapcar #'intern (all-completions string definition-prefixes))))
+         (and help-enable-completion-auto-load
+              (mapcar #'intern (all-completions string definition-prefixes)))))
     (complete-with-action action obarray string
                           (if pred (lambda (sym)
                                      (or (funcall pred sym)
@@ -572,7 +584,7 @@ FILE is the file where FUNCTION was probably defined."
             "including the match data.\n")))
 
 (defun help-fns--first-release (symbol)
-  "Return the likely first release that defined SYMBOL."
+  "Return the likely first release that defined SYMBOL, or nil."
   ;; Code below relies on the etc/NEWS* files.
   ;; FIXME: Maybe we should also use the */ChangeLog* files when available.
   ;; FIXME: Maybe we should also look for announcements of the addition
@@ -580,6 +592,7 @@ FILE is the file where FUNCTION was probably defined."
   (let* ((name (symbol-name symbol))
          (re (concat "\\_<" (regexp-quote name) "\\_>"))
          (news (directory-files data-directory t "\\`NEWS.[1-9]"))
+         (place nil)
          (first nil))
     (with-temp-buffer
       (dolist (f news)
@@ -588,17 +601,21 @@ FILE is the file where FUNCTION was probably defined."
         (goto-char (point-min))
         (search-forward "\n*")
         (while (re-search-forward re nil t)
-          (save-excursion
-            ;; Almost all entries are of the form "* ... in Emacs NN.MM."
-            ;; but there are also a few in the form "* Emacs NN.MM is a bug
-            ;; fix release ...".
-            (if (not (re-search-backward "^\\*.* Emacs \\([0-9.]+[0-9]\\)"
-                                         nil t))
-                (message "Ref found in non-versioned section in %S"
-                         (file-name-nondirectory f))
-              (let ((version (match-string 1)))
-                (when (or (null first) (version< version first))
-                  (setq first version))))))))
+          (let ((pos (match-beginning 0)))
+            (save-excursion
+              ;; Almost all entries are of the form "* ... in Emacs NN.MM."
+              ;; but there are also a few in the form "* Emacs NN.MM is a bug
+              ;; fix release ...".
+              (if (not (re-search-backward "^\\*.* Emacs \\([0-9.]+[0-9]\\)"
+                                           nil t))
+                  (message "Ref found in non-versioned section in %S"
+                           (file-name-nondirectory f))
+                (let ((version (match-string 1)))
+                  (when (or (null first) (version< version first))
+                    (setq place (list f pos))
+                    (setq first version)))))))))
+    (when first
+      (make-text-button first nil 'type 'help-news 'help-args place))
     first))
 
 (add-hook 'help-fns-describe-function-functions
@@ -608,8 +625,9 @@ FILE is the file where FUNCTION was probably defined."
 (defun help-fns--mention-first-release (object)
   (let ((first (if (symbolp object) (help-fns--first-release object))))
     (when first
-      (princ (format "  Probably introduced at or before Emacs version %s.\n"
-                     first)))))
+      (with-current-buffer standard-output
+        (insert (format "  Probably introduced at or before Emacs version %s.\n"
+                        first))))))
 
 (defun help-fns-short-filename (filename)
   (let* ((abbrev (abbreviate-file-name filename))
diff --git a/lisp/help-mode.el b/lisp/help-mode.el
index 6cc3f0d4f7..dc2992cd4a 100644
--- a/lisp/help-mode.el
+++ b/lisp/help-mode.el
@@ -287,12 +287,12 @@ The format is (FUNCTION ARGS...).")
 
 (define-button-type 'help-theme-def
   :supertype 'help-xref
-  'help-function 'find-file
+  'help-function #'find-file
   'help-echo (purecopy "mouse-2, RET: visit theme file"))
 
 (define-button-type 'help-theme-edit
   :supertype 'help-xref
-  'help-function 'customize-create-theme
+  'help-function #'customize-create-theme
   'help-echo (purecopy "mouse-2, RET: edit this theme file"))
 
 (define-button-type 'help-dir-local-var-def
@@ -302,7 +302,13 @@ The format is (FUNCTION ARGS...).")
 		   ;; local variable was defined.
 		   (find-file file))
   'help-echo (purecopy "mouse-2, RET: open directory-local variables file"))
-
+(define-button-type 'help-news
+  :supertype 'help-xref
+  'help-function
+  (lambda (file pos)
+    (pop-to-buffer (find-file-noselect file))
+    (goto-char pos))
+  'help-echo (purecopy "mouse-2, RET: show corresponding NEWS announcement"))
 
 (defvar bookmark-make-record-function)
 
diff --git a/lisp/help.el b/lisp/help.el
index d1f473517d..42ff375565 100644
--- a/lisp/help.el
+++ b/lisp/help.el
@@ -265,17 +265,19 @@ If that doesn't give a function, return nil."
         (condition-case ()
             (save-excursion
               (save-restriction
-                (narrow-to-region (max (point-min)
-                                       (- (point) 1000)) (point-max))
-                ;; Move up to surrounding paren, then after the open.
-                (backward-up-list 1)
-                (forward-char 1)
-                ;; If there is space here, this is probably something
-                ;; other than a real Lisp function call, so ignore it.
-                (if (looking-at "[ \t]")
-                    (error "Probably not a Lisp function call"))
-                (let ((obj (read (current-buffer))))
-                  (and (symbolp obj) (fboundp obj) obj))))
+                (let ((forward-sexp-function nil)) ;Use elisp-mode's value
+                  (narrow-to-region (max (point-min)
+                                         (- (point) 1000))
+                                    (point-max))
+                  ;; Move up to surrounding paren, then after the open.
+                  (backward-up-list 1)
+                  (forward-char 1)
+                  ;; If there is space here, this is probably something
+                  ;; other than a real Lisp function call, so ignore it.
+                  (if (looking-at "[ \t]")
+                      (error "Probably not a Lisp function call"))
+                  (let ((obj (read (current-buffer))))
+                    (and (symbolp obj) (fboundp obj) obj)))))
           (error nil))
         (let* ((str (find-tag-default))
                (sym (if str (intern-soft str))))
@@ -478,7 +480,7 @@ To record all your input, use `open-dribble-file'."
         (while (not (eobp))
           (comment-indent)
 	  (forward-line 1)))
-      ;; jidanni wants to see the last keystrokes immediately.
+      ;; Show point near the end of "lossage", as we did in Emacs 24.
       (set-marker help-window-point-marker (point)))))
 
 
@@ -743,6 +745,7 @@ If NO-MOUSE-MOVEMENT is non-nil, ignore key sequences starting
 with `mouse-movement' events."
   (let ((enable-disabled-menus-and-buttons t)
         (cursor-in-echo-area t)
+        (side-event nil)
         saved-yank-menu)
     (unwind-protect
         (let (last-modifiers key-list)
@@ -761,7 +764,8 @@ with `mouse-movement' events."
                   (and (memq 'click last-modifiers)
                        (not (sit-for (/ double-click-time 1000.0) t))))
             (let* ((seq (read-key-sequence "\
-Describe the following key, mouse click, or menu item: "))
+Describe the following key, mouse click, or menu item: "
+                                           nil nil 'can-return-switch-frame))
                    (raw-seq (this-single-command-raw-keys))
                    (keyn (when (> (length seq) 0)
                            (aref seq (1- (length seq)))))
@@ -770,11 +774,18 @@ Describe the following key, mouse click, or menu item: "))
               (cond
                ((zerop (length seq)))   ;FIXME: Can this happen?
                ((and no-mouse-movement (eq base 'mouse-movement)) nil)
+               ((memq base '(mouse-movement switch-frame select-window))
+                ;; Mostly ignore these events since it's sometimes difficult to
+                ;; generate the event you care about without also generating
+                ;; these side-events along the way.
+                (setq side-event (cons seq raw-seq)))
                ((eq base 'help-echo) nil)
                (t
                 (setq last-modifiers modifiers)
                 (push (cons seq raw-seq) key-list)))))
-          (nreverse key-list))
+          (if side-event
+              (cons side-event (nreverse key-list))
+            (nreverse key-list)))
       ;; Put yank-menu back as it was, if we changed it.
       (when saved-yank-menu
         (setq yank-menu (copy-sequence saved-yank-menu))
diff --git a/lisp/hexl.el b/lisp/hexl.el
index c1c2d70daf..ee5a9c0fce 100644
--- a/lisp/hexl.el
+++ b/lisp/hexl.el
@@ -877,17 +877,18 @@ and their encoded form is inserted byte by byte."
 	    "0x%x -- invalid character code; use \\[hexl-insert-hex-string]"
 	    ch))
 	  (t
-	   (let ((encoded (encode-coding-char ch coding))
-		 (internal (string-as-unibyte (char-to-string ch)))
-		 internal-hex)
-	     ;; If encode-coding-char returns nil, it means our character
-	     ;; cannot be safely encoded with buffer-file-coding-system.
-	     ;; In that case, we offer to insert the internal representation
-	     ;; of that character, byte by byte.
-	     (when (null encoded)
-	       (setq internal-hex
-		     (mapconcat (function (lambda (c) (format "%x" c)))
-				internal " "))
+           (let ((encoded (encode-coding-char ch coding))
+	         (internal (char-to-string ch))
+	         internal-hex)
+             ;; If encode-coding-char returns nil, it means our character
+             ;; cannot be safely encoded with buffer-file-coding-system.
+             ;; In that case, we offer to insert the internal representation
+             ;; of that character, byte by byte.
+             (when (null encoded)
+	       (setq internal (encode-coding-string internal 'utf-8-emacs)
+	             internal-hex
+	             (mapconcat (function (lambda (c) (format "%x" c)))
+			        internal " "))
 	       (if (yes-or-no-p
 		    (format-message
 		     "Insert char 0x%x's internal representation \"%s\"? "
diff --git a/lisp/hfy-cmap.el b/lisp/hfy-cmap.el
index a34efa60b4..70fcd1504e 100644
--- a/lisp/hfy-cmap.el
+++ b/lisp/hfy-cmap.el
@@ -7,7 +7,6 @@
 ;; Filename: hfy-cmap.el
 ;; Keywords: color, rgb
 ;; Author: Vivek Dasmohapatra <vivek@etla.org>
-;; Maintainer: Vivek Dasmohapatra <vivek@etla.org>
 ;; Created: 2002-01-20
 ;; Description: fallback code for color name -> rgb mapping
 ;; URL: http://rtfm.etla.org/emacs/htmlfontify/
diff --git a/lisp/hl-line.el b/lisp/hl-line.el
index 1c09bc26f6..8d929b8bb0 100644
--- a/lisp/hl-line.el
+++ b/lisp/hl-line.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1998, 2000-2019 Free Software Foundation, Inc.
 
-;; Author:  Dave Love <fx@gnu.org>
+;; Author: Dave Love <fx@gnu.org>
 ;; Maintainer: emacs-devel@gnu.org
 ;; Created: 1998-09-13
 ;; Keywords: faces, frames, emulations
diff --git a/lisp/htmlfontify.el b/lisp/htmlfontify.el
index 9fc029ec58..f37a76cd7b 100644
--- a/lisp/htmlfontify.el
+++ b/lisp/htmlfontify.el
@@ -8,7 +8,6 @@
 ;; Version: 0.21
 ;; Keywords: html, hypermedia, markup, etags
 ;; Author: Vivek Dasmohapatra <vivek@etla.org>
-;; Maintainer: Vivek Dasmohapatra <vivek@etla.org>
 ;; Created: 2002-01-05
 ;; Description: htmlize a buffer/source tree with optional hyperlinks
 ;; URL: http://rtfm.etla.org/emacs/htmlfontify/
diff --git a/lisp/ibuffer.el b/lisp/ibuffer.el
index 2d3c140536..628e884094 100644
--- a/lisp/ibuffer.el
+++ b/lisp/ibuffer.el
@@ -2507,8 +2507,8 @@ particular subset of them, and sorting by various criteria.
 
 Operations on marked buffers:
 \\<ibuffer-mode-map>
-  `\\[ibuffer-do-save]' - Save the marked buffers
-  `\\[ibuffer-do-view]' - View the marked buffers in this frame.
+  `\\[ibuffer-do-save]' - Save the marked buffers.
+  `\\[ibuffer-do-view]' - View the marked buffers in the selected frame.
   `\\[ibuffer-do-view-other-frame]' - View the marked buffers in another frame.
   `\\[ibuffer-do-revert]' - Revert the marked buffers.
   `\\[ibuffer-do-toggle-read-only]' - Toggle read-only state of marked buffers.
@@ -2531,7 +2531,7 @@ Operations on marked buffers:
           buffer's file as an argument.
   `\\[ibuffer-do-eval]' - Evaluate a form in each of the marked buffers.  This
           is a very flexible command.  For example, if you want to make all
-          of the marked buffers read only, try using (read-only-mode 1) as
+          of the marked buffers read-only, try using (read-only-mode 1) as
           the input form.
   `\\[ibuffer-do-view-and-eval]' - As above, but view each buffer while the form
           is evaluated.
@@ -2546,21 +2546,20 @@ Marking commands:
           all unmarked buffers.
   `\\[ibuffer-change-marks]' - Change the mark used on marked buffers.
   `\\[ibuffer-unmark-forward]' - Unmark the buffer at point.
-  `\\[ibuffer-unmark-backward]' - Unmark the buffer at point, and move to the
-          previous line.
+  `\\[ibuffer-unmark-backward]' - Unmark the previous buffer.
   `\\[ibuffer-unmark-all]' - Unmark buffers marked with MARK.
   `\\[ibuffer-unmark-all-marks]' - Unmark all marked buffers.
   `\\[ibuffer-mark-by-mode]' - Mark buffers by major mode.
   `\\[ibuffer-mark-unsaved-buffers]' - Mark all \"unsaved\" buffers.
           This means that the buffer is modified, and has an associated file.
   `\\[ibuffer-mark-modified-buffers]' - Mark all modified buffers,
-          regardless of whether or not they have an associated file.
+          regardless of whether they have an associated file.
   `\\[ibuffer-mark-special-buffers]' - Mark all buffers whose name begins and
           ends with `*'.
   `\\[ibuffer-mark-dissociated-buffers]' - Mark all buffers which have
           an associated file, but that file doesn't currently exist.
   `\\[ibuffer-mark-read-only-buffers]' - Mark all read-only buffers.
-  `\\[ibuffer-mark-dired-buffers]' - Mark buffers in `dired' mode.
+  `\\[ibuffer-mark-dired-buffers]' - Mark buffers in `dired-mode'.
   `\\[ibuffer-mark-help-buffers]' - Mark buffers in `help-mode', `apropos-mode', etc.
   `\\[ibuffer-mark-old-buffers]' - Mark buffers older than `ibuffer-old-time'.
   `\\[ibuffer-mark-for-delete]' - Mark the buffer at point for deletion.
@@ -2639,17 +2638,17 @@ Other commands:
 
 ** Information on Filtering:
 
- You can filter your ibuffer view via different criteria.  Each Ibuffer
+You can filter your Ibuffer view via different criteria.  Each Ibuffer
 buffer has its own stack of active filters.  For example, suppose you
 are working on an Emacs Lisp project.  You can create an Ibuffer
-buffer displays buffers in just `emacs-lisp' modes via
+buffer displaying only `emacs-lisp-mode' buffers via
 `\\[ibuffer-filter-by-mode] emacs-lisp-mode RET'.  In this case, there
 is just one entry on the filtering stack.
 
 You can also combine filters.  The various filtering commands push a
 new filter onto the stack, and the filters combine to show just
 buffers which satisfy ALL criteria on the stack.  For example, suppose
-you only want to see buffers in `emacs-lisp' mode, whose names begin
+you only want to see buffers in `emacs-lisp-mode', whose names begin
 with \"gnus\".  You can accomplish this via:
 
   \\[ibuffer-filter-by-mode] emacs-lisp-mode RET
@@ -2693,8 +2692,8 @@ will not be displayed multiple times if they would be included in
 multiple filter groups; instead, the first filter group is used.  The
 filter groups are displayed in this order of precedence.
 
-You may rearrange filter groups by using the regular
-`\\[ibuffer-kill-line]' and `\\[ibuffer-yank]' pair.  Yanked groups
+You may rearrange filter groups by using the usual pair
+`\\[ibuffer-kill-line]' and `\\[ibuffer-yank]'.  Yanked groups
 will be inserted before the group at point."
   ;; Include state info next to the mode name.
   (set (make-local-variable 'mode-line-process)
diff --git a/lisp/icomplete.el b/lisp/icomplete.el
index 10fd3a698c..51f2611c6b 100644
--- a/lisp/icomplete.el
+++ b/lisp/icomplete.el
@@ -3,8 +3,7 @@
 ;; Copyright (C) 1992-1994, 1997, 1999, 2001-2019 Free Software
 ;; Foundation, Inc.
 
-;; Author: Ken Manheimer <klm@i.am>
-;; Maintainer: Ken Manheimer <klm@i.am>
+;; Author: Ken Manheimer <ken dot manheimer at gmail...>
 ;; Created: Mar 1993 Ken Manheimer, klm@nist.gov - first release to usenet
 ;; Keywords: help, abbrev
 
diff --git a/lisp/ido.el b/lisp/ido.el
index 0854014581..1a3a384ae6 100644
--- a/lisp/ido.el
+++ b/lisp/ido.el
@@ -735,6 +735,14 @@ not provide the normal completion.  To show the completions, use \\[ido-toggle-i
 		 (integer :tag "Size in bytes" 30000))
   :group 'ido)
 
+(defcustom ido-big-directories nil
+  "List of directory pattern strings that should be considered big.
+Ido won't attempt to list the contents of directories matching
+any of these regular expressions when completing file names."
+  :type '(repeat regexp)
+  :group 'ido
+  :version "27.1")
+
 (defcustom ido-rotate-file-list-default nil
   "Non-nil means that Ido will always rotate file list to get default in front."
   :type 'boolean
@@ -1743,13 +1751,16 @@ is enabled then some keybindings are changed in the keymap."
   ;; Return t if dir is a directory, but too big to show
   ;; Do not check for non-readable directories via tramp, as this causes a premature
   ;; connect on incomplete tramp paths (after entering just method:).
-  (let ((ido-enable-tramp-completion nil))
-    (and (numberp ido-max-directory-size)
-	 (ido-final-slash dir)
-	 (not (ido-is-unc-host dir))
-	 (file-directory-p dir)
-	 (> (file-attribute-size (file-attributes (file-truename dir)))
-	    ido-max-directory-size))))
+  (let ((ido-enable-tramp-completion nil)
+        (case-fold-search nil))
+    (or (seq-some (lambda (regexp) (string-match-p regexp dir))
+                  ido-big-directories)
+        (and (numberp ido-max-directory-size)
+	     (ido-final-slash dir)
+	     (not (ido-is-unc-host dir))
+	     (file-directory-p dir)
+	     (> (file-attribute-size (file-attributes (file-truename dir)))
+	        ido-max-directory-size)))))
 
 (defun ido-set-current-directory (dir &optional subdir no-merge)
   ;; Set ido's current directory to DIR or DIR/SUBDIR
diff --git a/lisp/ielm.el b/lisp/ielm.el
index 82aff9901b..c7a31a23e6 100644
--- a/lisp/ielm.el
+++ b/lisp/ielm.el
@@ -559,10 +559,11 @@ Customized bindings may be defined in `ielm-map', which currently contains:
   ;; Useful for `hs-minor-mode'.
   (setq-local comment-start ";")
   (setq-local comment-use-syntax t)
+  (setq-local lexical-binding t)
 
-  (set (make-local-variable 'indent-line-function) 'ielm-indent-line)
+  (set (make-local-variable 'indent-line-function) #'ielm-indent-line)
   (set (make-local-variable 'ielm-working-buffer) (current-buffer))
-  (set (make-local-variable 'fill-paragraph-function) 'lisp-fill-paragraph)
+  (set (make-local-variable 'fill-paragraph-function) #'lisp-fill-paragraph)
 
   ;; Value holders
   (set (make-local-variable '*) nil)
diff --git a/lisp/image-file.el b/lisp/image-file.el
index bc5ef446bb..6cadc42110 100644
--- a/lisp/image-file.el
+++ b/lisp/image-file.el
@@ -97,8 +97,9 @@ the variable is set using \\[customize]."
 ;;;###autoload
 (defun insert-image-file (file &optional visit beg end replace)
   "Insert the image file FILE into the current buffer.
-Optional arguments VISIT, BEG, END, and REPLACE are interpreted as for
-the command `insert-file-contents'."
+Optional arguments VISIT, BEG, END, and REPLACE are interpreted
+as for the command `insert-file-contents'.  Return list of
+absolute file name and number of characters inserted."
   (let ((rval
 	 (image-file-call-underlying #'insert-file-contents-literally
 				     'insert-file-contents
@@ -109,11 +110,8 @@ the command `insert-file-contents'."
       (let* ((ibeg (point))
 	     (iend (+ (point) (cadr rval)))
 	     (visitingp (and visit (= ibeg (point-min)) (= iend (point-max))))
-	     (data
-	      (string-make-unibyte
-	       (buffer-substring-no-properties ibeg iend)))
-	     (image
-	      (create-image data nil t))
+             (image (create-image (encode-coding-region ibeg iend 'binary t)
+                                  nil t))
 	     (props
 	      `(display ,image
 			yank-handler
diff --git a/lisp/image.el b/lisp/image.el
index 6da3a0b6cd..b58b1dc954 100644
--- a/lisp/image.el
+++ b/lisp/image.el
@@ -315,7 +315,7 @@ be determined."
 					(buffer-substring
 					 (point-min)
 					 (min (point-max)
-					      (+ (point-min) 256))))))
+					      (+ (point-min) 8192))))))
 		     (setq image-type (cdr image-type))))
 	    (setq type image-type
 		  types nil)
@@ -339,7 +339,7 @@ be determined."
        (file-readable-p file)
        (with-temp-buffer
 	 (set-buffer-multibyte nil)
-	 (insert-file-contents-literally file nil 0 256)
+	 (insert-file-contents-literally file nil 0 8192)
 	 (image-type-from-buffer))))
 
 
@@ -454,10 +454,10 @@ Internal use only."
         ;; plist.  Decouple plist entries where the key matches
         ;; the property.
         (if (eq (cadr image) property)
-            (setcdr image (cddr image))
+            (setcdr image (cdddr image))
           (setq image (cddr image))))
     ;; Just enter the new value.
-    (plist-put (cdr image) property value))
+    (setcdr image (plist-put (cdr image) property value)))
   value)
 
 (defun image-property (image property)
@@ -992,11 +992,12 @@ default is 20%."
     image))
 
 (defun image--get-imagemagick-and-warn ()
-  (unless (or (fboundp 'imagemagick-types) (image-scaling-p))
+  (unless (or (fboundp 'imagemagick-types) (image-transforms-p))
     (error "Cannot rescale images on this terminal"))
   (let ((image (image--get-image)))
     (image-flush image)
-    (when (fboundp 'imagemagick-types)
+    (when (and (fboundp 'imagemagick-types)
+               (not (image-transforms-p)))
       (plist-put (cdr image) :type 'imagemagick))
     image))
 
diff --git a/lisp/imenu.el b/lisp/imenu.el
index df39ff3c07..5084fe61ef 100644
--- a/lisp/imenu.el
+++ b/lisp/imenu.el
@@ -348,98 +348,6 @@ Don't move point."
   (signal 'imenu-unavailable
           (list (apply #'format-message format args))))
 
-(defun imenu-example--lisp-extract-index-name ()
-  ;; Example of a candidate for `imenu-extract-index-name-function'.
-  ;; This will generate a flat index of definitions in a lisp file.
-  (declare (obsolete nil "23.2"))
-  (save-match-data
-    (and (looking-at "(def")
-	 (condition-case nil
-	     (progn
-	       (down-list 1)
-	       (forward-sexp 2)
-	       (let ((beg (point))
-		     (end (progn (forward-sexp -1) (point))))
-		 (buffer-substring beg end)))
-	   (error nil)))))
-
-(defun imenu-example--create-lisp-index ()
-  ;; Example of a candidate for `imenu-create-index-function'.
-  ;; It will generate a nested index of definitions.
-  (declare (obsolete nil "23.2"))
-  (let ((index-alist '())
-	(index-var-alist '())
-	(index-type-alist '())
-	(index-unknown-alist '()))
-    (goto-char (point-max))
-    ;; Search for the function
-    (while (beginning-of-defun)
-	  (save-match-data
-	    (and (looking-at "(def")
-		 (save-excursion
-	       (down-list 1)
-		   (cond
-		((looking-at "def\\(var\\|const\\)")
-		     (forward-sexp 2)
-		     (push (imenu-example--name-and-position)
-			   index-var-alist))
-		((looking-at "def\\(un\\|subst\\|macro\\|advice\\)")
-		     (forward-sexp 2)
-		     (push (imenu-example--name-and-position)
-			   index-alist))
-		((looking-at "def\\(type\\|struct\\|class\\|ine-condition\\)")
-		     (forward-sexp 2)
- 		 (if (= (char-after (1- (point))) ?\))
-			 (progn
- 		       (forward-sexp -1)
-			   (down-list 1)
- 		       (forward-sexp 1)))
-		     (push (imenu-example--name-and-position)
-			   index-type-alist))
-		    (t
-		     (forward-sexp 2)
-		     (push (imenu-example--name-and-position)
-		       index-unknown-alist)))))))
-    (and index-var-alist
-	 (push (cons "Variables" index-var-alist)
-	       index-alist))
-    (and index-type-alist
- 	 (push (cons "Types" index-type-alist)
-  	       index-alist))
-    (and index-unknown-alist
-	 (push (cons "Syntax-unknown" index-unknown-alist)
-	       index-alist))
-    index-alist))
-
-;; Regular expression to find C functions
-(defvar imenu-example--function-name-regexp-c
-  (concat
-   "^[a-zA-Z0-9]+[ \t]?"		; Type specs; there can be no
-   "\\([a-zA-Z0-9_*]+[ \t]+\\)?"	; more than 3 tokens, right?
-   "\\([a-zA-Z0-9_*]+[ \t]+\\)?"
-   "\\([*&]+[ \t]*\\)?"			; Pointer.
-   "\\([a-zA-Z0-9_*]+\\)[ \t]*("	; Name.
-   ))
-
-(defun imenu-example--create-c-index (&optional regexp)
-  (declare (obsolete nil "23.2"))
-  (let ((index-alist '())
-	char)
-    (goto-char (point-min))
-    ;; Search for the function
-    (save-match-data
-      (while (re-search-forward
-	      (or regexp imenu-example--function-name-regexp-c)
-	      nil t)
-	(backward-up-list 1)
-	(save-excursion
-	  (goto-char (scan-sexps (point) 1))
-	  (setq char (following-char)))
-	;; Skip this function name if it is a prototype declaration.
-	(if (not (eq char ?\;))
-	    (push (imenu-example--name-and-position) index-alist))))
-    (nreverse index-alist)))
-
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;;
 ;;; Internal variables
diff --git a/lisp/info-look.el b/lisp/info-look.el
index 1d761c70e1..8a484bbed1 100644
--- a/lisp/info-look.el
+++ b/lisp/info-look.el
@@ -3,8 +3,7 @@
 
 ;; Copyright (C) 1995-1999, 2001-2019 Free Software Foundation, Inc.
 
-;; Author: Ralph Schleicher <rs@nunatak.allgaeu.org>
-;;         (did not show signs of life (Nov 2001)  -stef)
+;; Author: Ralph Schleicher <rs@ralph-schleicher.de>
 ;; Keywords: help languages
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/info.el b/lisp/info.el
index f3b413a2f9..c211887a39 100644
--- a/lisp/info.el
+++ b/lisp/info.el
@@ -380,12 +380,6 @@ with wrapping around the current Info node."
   :type 'hook
   :group 'info)
 
-(defvar Info-edit-mode-hook nil
-  "Hook run when `Info-edit-mode' is activated.")
-
-(make-obsolete-variable 'Info-edit-mode-hook
-			"editing Info nodes by hand is not recommended." "24.4")
-
 (defvar-local Info-current-file nil
   "Info file that Info is now looking at, or nil.
 This is the name that was specified in Info, not the actual file name.
@@ -1531,7 +1525,7 @@ is non-nil)."
 	    (save-restriction
 	      (narrow-to-region start (point))
 	      (goto-char (point-min))
-	      (while (re-search-forward "^\\* \\([^:\n]+:\\(:\\|[^.\n]+\\).\\)" nil 'move)
+	      (while (re-search-forward "^\\* \\([^:\n]+:[^.\n]+.\\)" nil 'move)
 		;; Fold case straight away; `member-ignore-case' here wasteful.
 		(let ((x (downcase (match-string 1))))
 		  (if (member x seen)
@@ -4268,8 +4262,9 @@ With a zero prefix arg, put the name inside a function call to `info'."
 ;; We deliberately fontify only ‘..’ quoting, and not `..', because
 ;; the former can be done much more reliably, i.e. without risking
 ;; false positives.
+;; FIXME: It doesn't handle nested quotes.
 (defvar Info-mode-font-lock-keywords
-  '(("‘\\([^’]*\\)’" (1 'Info-quoted))))
+  '(("‘\\([‘’]\\|[^‘’]*\\)’" (1 'Info-quoted))))
 
 ;; Autoload cookie needed by desktop.el
 ;;;###autoload
@@ -4383,59 +4378,6 @@ Advanced commands:
 		  (copy-marker (marker-position m)))
 	      (make-marker))))))
 
-(define-obsolete-variable-alias 'Info-edit-map 'Info-edit-mode-map "24.1")
-(defvar Info-edit-mode-map (let ((map (make-sparse-keymap)))
-                             (set-keymap-parent map text-mode-map)
-                             (define-key map "\C-c\C-c" 'Info-cease-edit)
-                             map)
-  "Local keymap used within `e' command of Info.")
-
-(make-obsolete-variable 'Info-edit-mode-map
-			"editing Info nodes by hand is not recommended."
-			"24.4")
-
-;; Info-edit mode is suitable only for specially formatted data.
-(put 'Info-edit-mode 'mode-class 'special)
-
-(define-derived-mode Info-edit-mode text-mode "Info Edit"
-  "Major mode for editing the contents of an Info node.
-Like text mode with the addition of `Info-cease-edit'
-which returns to Info mode for browsing."
-  (setq buffer-read-only nil)
-  (force-mode-line-update)
-  (buffer-enable-undo (current-buffer)))
-
-(make-obsolete 'Info-edit-mode
-	       "editing Info nodes by hand is not recommended." "24.4")
-
-(defun Info-edit ()
-  "Edit the contents of this Info node."
-  (interactive)
-  (Info-edit-mode)
-  (message "%s" (substitute-command-keys
-		 "Editing: Type \\<Info-edit-mode-map>\\[Info-cease-edit] to return to info")))
-
-(put 'Info-edit 'disabled "Editing Info nodes by hand is not recommended.
-This feature will be removed in future.")
-
-(make-obsolete 'Info-edit
-	       "editing Info nodes by hand is not recommended." "24.4")
-
-(defun Info-cease-edit ()
-  "Finish editing Info node; switch back to Info proper."
-  (interactive)
-  ;; Do this first, so nothing has changed if user C-g's at query.
-  (and (buffer-modified-p)
-       (y-or-n-p "Save the file? ")
-       (save-buffer))
-  (Info-mode)
-  (force-mode-line-update)
-  (and (marker-position Info-tag-table-marker)
-       (buffer-modified-p)
-       (message "Tags may have changed.  Use Info-tagify if necessary")))
-
-(make-obsolete 'Info-cease-edit
-	       "editing Info nodes by hand is not recommended." "24.4")
 
 (defvar Info-file-list-for-emacs
   '("ediff" "eudc" "forms" "gnus" "info" ("Info" . "info") ("mh" . "mh-e")
diff --git a/lisp/international/isearch-x.el b/lisp/international/isearch-x.el
index 6c2a2dc9b9..dd4c98fc98 100644
--- a/lisp/international/isearch-x.el
+++ b/lisp/international/isearch-x.el
@@ -8,8 +8,7 @@
 
 ;; Keywords: i18n, multilingual, isearch
 
-;; Author: Kenichi HANDA <handa@etl.go.jp>
-;; Maintainer: Kenichi HANDA <handa@etl.go.jp>
+;; Author: Kenichi Handa <handa@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/lisp/international/ja-dic-cnv.el b/lisp/international/ja-dic-cnv.el
index 578cd63a59..e721083189 100644
--- a/lisp/international/ja-dic-cnv.el
+++ b/lisp/international/ja-dic-cnv.el
@@ -124,7 +124,7 @@
 	(setq l (cdr l)))))
 
   ;; Search postfix entries.
-  (while (re-search-forward "^[#<>?]\\(\\(\\cH\\|ー\\)+\\) " nil t)
+  (while (re-search-forward "^[#<>?]\\(\\cH+\\) " nil t)
     (let ((kana (match-string-no-properties 1))
 	  str candidates)
       (while (looking-at "/[#0-9 ]*\\([^/\n]*\\)/")
@@ -157,7 +157,7 @@
     (insert ";; Setting prefix entries.\n"
 	    "(skkdic-set-prefix\n"))
   (save-excursion
-    (while (re-search-forward "^\\(\\(\\cH\\|ー\\)+\\)[<>?] " nil t)
+    (while (re-search-forward "^\\(\\cH+\\)[<>?] " nil t)
       (let ((kana (match-string-no-properties 1))
 	    str candidates)
 	(while (looking-at "/\\([^/\n]+\\)/")
@@ -275,11 +275,11 @@
     (let ((progress (make-progress-reporter "Collecting OKURI-NASI entries"
                                             (point) (point-max)
                                             nil 10)))
-      (while (re-search-forward "^\\(\\(\\cH\\|ー\\)+\\) \\(/\\cj.*\\)/$"
+      (while (re-search-forward "^\\(\\cH+\\) \\(/\\cj.*\\)/$"
 				nil t)
         (let ((kana (match-string-no-properties 1))
-	      (candidates (skkdic-get-candidate-list (match-beginning 3)
-						     (match-end 3))))
+	      (candidates (skkdic-get-candidate-list (match-beginning 2)
+						     (match-end 2))))
 	  (setq skkdic-okuri-nasi-entries
 		(cons (cons kana candidates) skkdic-okuri-nasi-entries))
           (progress-reporter-update progress (point))
diff --git a/lisp/international/mule-cmds.el b/lisp/international/mule-cmds.el
index dfa9e4e6c8..47b07479c3 100644
--- a/lisp/international/mule-cmds.el
+++ b/lisp/international/mule-cmds.el
@@ -1029,7 +1029,13 @@ It is highly recommended to fix it before writing to a file."
 		 ;; This check perhaps isn't ideal, but is probably
 		 ;; the best thing to do.
 		 (not (auto-coding-alist-lookup (or file buffer-file-name "")))
-		 (not (coding-system-equal coding-system auto-cs)))
+		 (not (coding-system-equal coding-system auto-cs))
+                 ;; coding-system-equal barfs on 'charset'.
+                 (or (equal (coding-system-type auto-cs) 'charset)
+                     (equal (coding-system-type coding-system) 'charset)
+                     (not (coding-system-equal (coding-system-type auto-cs)
+                                               (coding-system-type
+                                                coding-system)))))
 	    (unless (yes-or-no-p
 		     (format "Selected encoding %s disagrees with \
 %s specified by file contents.  Really save (else edit coding cookies \
@@ -2892,8 +2898,9 @@ If there's no description string for VALUE, return nil."
     (?\x9b . "CSI")))
 
 (defun encoded-string-description (str coding-system)
-  "Return a pretty description of STR that is encoded by CODING-SYSTEM."
-  (setq str (string-as-unibyte str))
+  "Return a pretty description of STR that is encoded by CODING-SYSTEM.
+STR should be a unibyte string."
+  (cl-assert (not (multibyte-string-p str)))
   (mapconcat
    (if (and coding-system (eq (coding-system-type coding-system) 'iso-2022))
        ;; Try to get a pretty description for ISO 2022 escape sequences.
@@ -2907,13 +2914,13 @@ If there's no description string for VALUE, return nil."
 If CODING-SYSTEM can't safely encode CHAR, return nil.
 The 3rd optional argument CHARSET, if non-nil, is a charset preferred
 on encoding."
-  (let* ((str1 (string-as-multibyte (string char)))
-	 (str2 (string-as-multibyte (string char char)))
+  (let* ((str1 (string char))
+	 (str2 (string char char))
 	 (found (find-coding-systems-string str1))
 	enc1 enc2 i1 i2)
-    (if (and (consp found)
-	     (eq (car found) 'undecided))
-	str1
+    (if (eq (car-safe found) 'undecided) ;Aka (not (multibyte-string-p str1))
+        ;; `char' is ASCII.
+	(encode-coding-string str1 coding-system)
       (when (memq (coding-system-base coding-system) found)
 	;; We must find the encoded string of CHAR.  But, just encoding
 	;; CHAR will put extra control sequences (usually to designate
diff --git a/lisp/international/mule-util.el b/lisp/international/mule-util.el
index 8ad212796a..de5e7d8323 100644
--- a/lisp/international/mule-util.el
+++ b/lisp/international/mule-util.el
@@ -456,7 +456,7 @@ QUALITY can be:
          (lineno (if (= eol 1) (1- (line-number-at-pos position)) 0))
          (type (coding-system-type coding-system))
          (base (coding-system-base coding-system))
-         byte)
+         (point-min 1))                 ;Clarify what the `1' means.
     (and (eq type 'utf-8)
          ;; Any post-read/pre-write conversions mean it's not really UTF-8.
          (not (null (coding-system-get coding-system :post-read-conversion)))
@@ -471,19 +471,17 @@ QUALITY can be:
          (setq type 'single-byte))
     (pcase type
       ('utf-8
-       (setq byte (position-bytes position))
-       (when (null byte)
-         (if (<= position 0)
-             (setq byte 1)
-           (setq byte (position-bytes (point-max)))))
-       (setq byte (1- byte))
-       (+ byte
+       (+ (or (position-bytes position)
+              (if (<= position 0)
+                  point-min
+                (position-bytes (point-max))))
           ;; Account for BOM, if any.
           (if (coding-system-get coding-system :bom) 3 0)
           ;; Account for CR in CRLF pairs.
-          lineno))
+          lineno
+          (- point-min)))
       ('single-byte
-       (+ position -1 lineno))
+       (+ position (- point-min) lineno))
       ((and 'utf-16
             ;; FIXME: For utf-16, we could use the same approach as used for
             ;; dos EOLs (counting the number of non-BMP chars instead of the
@@ -491,14 +489,14 @@ QUALITY can be:
             (guard (not (eq quality 'exact))))
        ;; In approximate mode, assume all characters are within the
        ;; BMP, i.e. each one takes up 2 bytes.
-       (+ (* (1- position) 2)
+       (+ (* (- position point-min) 2)
           ;; Account for BOM, if any.
           (if (coding-system-get coding-system :bom) 2 0)
           ;; Account for CR in CRLF pairs.
           lineno))
       (_
        (pcase quality
-         ('approximate (+ (position-bytes position) -1 lineno))
+         ('approximate (+ (position-bytes position) (- point-min) lineno))
          ('exact
           ;; Rather than assume that the file exists and still holds the right
           ;; data, we reconstruct its relevant portion.
@@ -511,7 +509,7 @@ QUALITY can be:
                     (widen)
                     (encode-coding-region (point-min) (min (point-max) position)
                                           coding-system tmp-buf)))
-                (1- (point-max)))))))))))
+                (buffer-size))))))))))
 
 (provide 'mule-util)
 
diff --git a/lisp/international/mule.el b/lisp/international/mule.el
index ba30fee496..21f3118a98 100644
--- a/lisp/international/mule.el
+++ b/lisp/international/mule.el
@@ -1345,8 +1345,11 @@ just set the variable `buffer-file-coding-system' directly."
       (setq coding-system
 	    (merge-coding-systems coding-system buffer-file-coding-system)))
   (when (and (called-interactively-p 'interactive)
-	     (not (memq 'emacs (coding-system-get coding-system
-						  :charset-list))))
+             ;; FIXME: For some reason
+             ;;     (coding-system-get 'iso-2022-7bit :charset-list)
+             ;; returns `iso-2022' rather than returning a list!
+             (let ((css (coding-system-get coding-system :charset-list)))
+               (not (and (listp css) (memq 'emacs css)))))
     ;; Check whether save would succeed, and jump to the offending char(s)
     ;; if not.
     (let ((css (find-coding-systems-region (point-min) (point-max))))
@@ -2495,7 +2498,18 @@ This function is intended to be added to `auto-coding-functions'."
       (when end
 	(if (re-search-forward "encoding=[\"']\\(.+?\\)[\"']" end t)
 	    (let* ((match (match-string 1))
-		   (sym (intern (downcase match))))
+                   (sym-name (downcase match))
+                   (sym-name
+                    ;; https://www.w3.org/TR/xml/#charencoding says:
+                    ;; "Entities encoded in UTF-16 MUST [...] begin
+                    ;; with the Byte Order Mark."  The trick below is
+                    ;; based on the fact that utf-16be/le don't
+                    ;; specify BOM, while utf-16-be/le do.
+                    (cond
+                     ((equal sym-name "utf-16le") "utf-16-le")
+                     ((equal sym-name "utf-16be") "utf-16-be")
+                     (t sym-name)))
+		   (sym (intern sym-name)))
 	      (if (coding-system-p sym)
                   ;; If the encoding tag is UTF-8 and the buffer's
                   ;; encoding is one of the variants of UTF-8, use the
@@ -2584,9 +2598,14 @@ added by processing software."
       (let ((detected
              (with-coding-priority '(utf-8)
                (coding-system-base
-                (detect-coding-region (point-min) (point-max) t)))))
-        ;; Pure ASCII always comes back as undecided.
+                (detect-coding-region (point-min) (point-max) t))))
+            (bom (list (char-after 1) (char-after 2))))
         (cond
+         ((equal bom '(#xFE #xFF))
+          'utf-16be-with-signature)
+         ((equal bom '(#xFF #xFE))
+          'utf-16le-with-signature)
+         ;; Pure ASCII always comes back as undecided.
          ((memq detected '(utf-8 undecided))
           'utf-8)
          ((eq detected 'utf-16le-with-signature) 'utf-16le-with-signature)
diff --git a/lisp/international/quail.el b/lisp/international/quail.el
index 3266b93b44..a6b7fe5ac7 100644
--- a/lisp/international/quail.el
+++ b/lisp/international/quail.el
@@ -6,9 +6,8 @@
 ;;   National Institute of Advanced Industrial Science and Technology (AIST)
 ;;   Registration Number H14PRO021
 
-;; Author: Kenichi HANDA <handa@etl.go.jp>
-;;	   Naoto TAKAHASHI <ntakahas@etl.go.jp>
-;; Maintainer: Kenichi HANDA <handa@etl.go.jp>
+;; Author: Kenichi Handa <handa@gnu.org>
+;;	   Naoto Takahashi <ntakahas@etl.go.jp>
 ;; Keywords: mule, multilingual, input method, i18n
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/international/utf7.el b/lisp/international/utf7.el
index 0e67a62aa6..73ee5ad27c 100644
--- a/lisp/international/utf7.el
+++ b/lisp/international/utf7.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Jon K Hellan <hellan@acm.org>
-;; Maintainer: bugs@gnus.org
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: mail
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/isearch.el b/lisp/isearch.el
index 6280afebdc..bb29c2914b 100644
--- a/lisp/isearch.el
+++ b/lisp/isearch.el
@@ -832,12 +832,20 @@ This is like `describe-bindings', but displays only Isearch keys."
   'isearch-regexp-function "25.1")
 (defvar isearch-regexp-function nil
   "Regexp-based search mode for words/symbols.
-If the value is a function (e.g. `isearch-symbol-regexp'), it is
-called to convert a plain search string to a regexp used by
-regexp search functions.
+If non-nil, a function to convert a search string to a regexp
+used by regexp search functions.
+
+The function should accept 1 or 2 arguments: the original string
+to convert, and a flag, whose non-nil value means the match
+doesn't have to start or end on a word boundary.  The function
+should return the corresponding regexp, a string.
+
 The symbol property `isearch-message-prefix' put on this function
 specifies the prefix string displayed in the search message.
 
+Existing functions you could use as values are `word-search-regexp',
+`isearch-symbol-regexp', and `char-fold-to-regexp'.
+
 This variable is set and changed during isearch.  To change the
 default behavior used for searches, see `search-default-mode'
 instead.")
diff --git a/lisp/jsonrpc.el b/lisp/jsonrpc.el
index c02e685974..0fffee6866 100644
--- a/lisp/jsonrpc.el
+++ b/lisp/jsonrpc.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2018-2019 Free Software Foundation, Inc.
 
 ;; Author: João Távora <joaotavora@gmail.com>
-;; Maintainer: João Távora <joaotavora@gmail.com>
 ;; Keywords: processes, languages, extensions
 ;; Package-Requires: ((emacs "25.2"))
 ;; Version: 1.0.7
diff --git a/lisp/kmacro.el b/lisp/kmacro.el
index fc34e16708..01dc058614 100644
--- a/lisp/kmacro.el
+++ b/lisp/kmacro.el
@@ -776,6 +776,7 @@ If kbd macro currently being defined end it before activating it."
 ;; letters and digits, provided that we inhibit the keymap while
 ;; executing the macro later on (but that's controversial...)
 
+;;;###autoload
 (defun kmacro-lambda-form (mac &optional counter format)
   "Create lambda form for macro bound to symbol or key."
   (if counter
diff --git a/lisp/language/cyrillic.el b/lisp/language/cyrillic.el
index 75d4249423..564ac5f592 100644
--- a/lisp/language/cyrillic.el
+++ b/lisp/language/cyrillic.el
@@ -9,7 +9,7 @@
 ;;   National Institute of Advanced Industrial Science and Technology (AIST)
 ;;   Registration Number H13PRO009
 
-;; Author: Kenichi Handa <handa@etl.go.jp>
+;; Author: Kenichi Handa <handa@gnu.org>
 ;; Keywords: multilingual, Cyrillic, i18n
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/language/european.el b/lisp/language/european.el
index 8c38175972..fedbca4eb6 100644
--- a/lisp/language/european.el
+++ b/lisp/language/european.el
@@ -525,7 +525,7 @@ method and applying Turkish case rules for the characters i, I, ı, İ.")))
     (set-case-syntax ?ı "w" table)))
 
 ;; Polish ISO 8859-2 environment.
-;; Maintainer: Wlodek Bzyl <matwb@univ.gda.pl>
+;; Maintainer: Włodek Bzyl <matwb@univ.gda.pl>
 ;; Keywords: multilingual, Polish
 
 (set-language-info-alist
diff --git a/lisp/language/ind-util.el b/lisp/language/ind-util.el
index 9b4af19985..2bbfdc190b 100644
--- a/lisp/language/ind-util.el
+++ b/lisp/language/ind-util.el
@@ -2,7 +2,6 @@
 
 ;; Copyright (C) 2001-2019 Free Software Foundation, Inc.
 
-;; Maintainer:  KAWABATA, Taichi <kawabata@m17n.org>
 ;; Keywords: multilingual, Indian, Devanagari
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/language/indian.el b/lisp/language/indian.el
index d63e9b465f..f1e61a354c 100644
--- a/lisp/language/indian.el
+++ b/lisp/language/indian.el
@@ -5,8 +5,6 @@
 ;;   National Institute of Advanced Industrial Science and Technology (AIST)
 ;;   Registration Number H14PRO021
 
-;; Maintainer:  Kenichi Handa <handa@m17n.org>
-;;		KAWABATA, Taichi <kawabata@m17n.org>
 ;; Keywords: 	multilingual, i18n, Indian
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/language/romanian.el b/lisp/language/romanian.el
index 0a5d0ca0f9..55549c7e86 100644
--- a/lisp/language/romanian.el
+++ b/lisp/language/romanian.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1998, 2001-2019 Free Software Foundation, Inc.
 
-;; Author:    Dan Nicolaescu <done@ece.arizona.edu>
+;; Author: Dan Nicolaescu <done@ece.arizona.edu>
 ;; Keywords: multilingual, Romanian, i18n
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/language/thai-word.el b/lisp/language/thai-word.el
index e67dd09343..94c6ab9897 100644
--- a/lisp/language/thai-word.el
+++ b/lisp/language/thai-word.el
@@ -4,7 +4,7 @@
 ;;   National Institute of Advanced Industrial Science and Technology (AIST)
 ;;   Registration Number H14PRO021
 
-;; Author: Kenichi HANDA <handa@etl.go.jp>
+;; Author: Kenichi Handa <handa@gnu.org>
 
 ;; Keywords: thai, word break, emacs
 
diff --git a/lisp/ldefs-boot.el b/lisp/ldefs-boot.el
index ccf2cdc87e..d131bc014f 100644
--- a/lisp/ldefs-boot.el
+++ b/lisp/ldefs-boot.el
@@ -1199,7 +1199,7 @@ archive.
 
 \(fn &optional FORCE)" nil nil)
 
-(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "arc-mode" '("archive-")))
+(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "arc-mode" '("arc")))
 
 ;;;***
 
@@ -1799,7 +1799,7 @@ If `global-auto-revert-non-file-buffers' is non-nil, this mode
 may also revert some non-file buffers, as described in the
 documentation of that variable.  It ignores buffers with modes
 matching `global-auto-revert-ignore-modes', and buffers with a
-non-nil vale of `global-auto-revert-ignore-buffer'.
+non-nil value of `global-auto-revert-ignore-buffer'.
 
 When a buffer is reverted, a message is generated.  This can be
 suppressed by setting `auto-revert-verbose' to nil.
@@ -5200,17 +5200,17 @@ If nil, use Emacs default.")
 
 (custom-autoload 'compilation-window-height "compile" t)
 
-(defvar compilation-process-setup-function nil "\
+(defvar compilation-process-setup-function #'ignore "\
 Function to call to customize the compilation process.
 This function is called immediately before the compilation process is
 started.  It can be used to set any variables or functions that are used
 while processing the output of the compilation process.")
 
-(defvar compilation-buffer-name-function nil "\
+(defvar compilation-buffer-name-function #'compilation--default-buffer-name "\
 Function to compute the name of a compilation buffer.
 The function receives one argument, the name of the major mode of the
 compilation buffer.  It should return a string.
-If nil, compute the name with `(concat \"*\" (downcase major-mode) \"*\")'.")
+By default, it returns `(concat \"*\" (downcase name-of-mode) \"*\")'.")
 
 (defvar compilation-finish-functions nil "\
 Functions to call when a compilation process finishes.
@@ -5887,7 +5887,7 @@ Major mode to edit Cascading Style Sheets (CSS).
 This mode provides syntax highlighting, indentation, completion,
 and documentation lookup for CSS.
 
-Use `\\[complete-symbol]' to complete CSS properties, property values,
+Use `\\[completion-at-point]' to complete CSS properties, property values,
 pseudo-elements, pseudo-classes, at-rules, bang-rules, and HTML
 tags, classes and IDs.  Completion candidates for HTML class
 names and IDs are found by looking through open HTML mode
@@ -6792,19 +6792,19 @@ The most useful commands are:
 (push (purecopy '(delim-col 2 1)) package--builtin-versions)
 
 (autoload 'delimit-columns-customize "delim-col" "\
-Customization of `columns' group." t nil)
+Customize the `columns' group." t nil)
 
 (autoload 'delimit-columns-region "delim-col" "\
 Prettify all columns in a text region.
 
-START and END delimits the text region.
+START and END delimit the text region.
 
 \(fn START END)" t nil)
 
 (autoload 'delimit-columns-rectangle "delim-col" "\
 Prettify all columns in a text rectangle.
 
-START and END delimits the corners of text rectangle.
+START and END delimit the corners of the text rectangle.
 
 \(fn START END)" t nil)
 
@@ -7632,14 +7632,14 @@ Display character C using printable string S.
 (autoload 'standard-display-g1 "disp-table" "\
 Display character C as character SC in the g1 character set.
 This function assumes that your terminal uses the SO/SI characters;
-it is meaningless for an X frame.
+it is meaningless for a graphical frame.
 
 \(fn C SC)" nil nil)
 
 (autoload 'standard-display-graphic "disp-table" "\
 Display character C as character GC in graphics character set.
-This function assumes VT100-compatible escapes; it is meaningless for an
-X frame.
+This function assumes VT100-compatible escapes; it is meaningless
+for a graphical frame.
 
 \(fn C GC)" nil nil)
 
@@ -7693,6 +7693,51 @@ in `.emacs'.
 
 ;;;***
 
+;;;### (autoloads nil "display-fill-column-indicator" "display-fill-column-indicator.el"
+;;;;;;  (0 0 0 0))
+;;; Generated autoloads from display-fill-column-indicator.el
+
+(autoload 'display-fill-column-indicator-mode "display-fill-column-indicator" "\
+Toggle display of fill-column indicator.
+This uses `display-fill-column-indicator' internally.
+
+If called interactively, enable Display-Fill-Column-Indicator mode if ARG is positive, and
+disable it if ARG is zero or negative.  If called from Lisp,
+also enable the mode if ARG is omitted or nil, and toggle it
+if ARG is `toggle'; disable the mode otherwise.
+
+To change the position of the column displayed by default
+customize `display-fill-column-indicator-column'.  You can change the
+character for the indicator setting `display-fill-column-indicator-character'.
+
+\(fn &optional ARG)" t nil)
+
+(defvar global-display-fill-column-indicator-mode nil "\
+Non-nil if Global Display-Fill-Column-Indicator mode is enabled.
+See the `global-display-fill-column-indicator-mode' command
+for a description of this minor mode.
+Setting this variable directly does not take effect;
+either customize it (see the info node `Easy Customization')
+or call the function `global-display-fill-column-indicator-mode'.")
+
+(custom-autoload 'global-display-fill-column-indicator-mode "display-fill-column-indicator" nil)
+
+(autoload 'global-display-fill-column-indicator-mode "display-fill-column-indicator" "\
+Toggle Display-Fill-Column-Indicator mode in all buffers.
+With prefix ARG, enable Global Display-Fill-Column-Indicator mode if ARG is positive;
+otherwise, disable it.  If called from Lisp, enable the mode if
+ARG is omitted or nil.
+
+Display-Fill-Column-Indicator mode is enabled in all buffers where
+`display-fill-column-indicator--turn-on' would do it.
+See `display-fill-column-indicator-mode' for more information on Display-Fill-Column-Indicator mode.
+
+\(fn &optional ARG)" t nil)
+
+(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "display-fill-column-indicator" '("display-fill-column-indicator--turn-on")))
+
+;;;***
+
 ;;;### (autoloads nil "display-line-numbers" "display-line-numbers.el"
 ;;;;;;  (0 0 0 0))
 ;;; Generated autoloads from display-line-numbers.el
@@ -11599,7 +11644,7 @@ fourth arg NOSEP non-nil inhibits this.
 ;;;### (autoloads nil "eww" "net/eww.el" (0 0 0 0))
 ;;; Generated autoloads from net/eww.el
 
-(defvar eww-suggest-uris '(eww-links-at-point url-get-url-at-point eww-current-url) "\
+(defvar eww-suggest-uris '(eww-links-at-point thing-at-point-url-at-point eww-current-url) "\
 List of functions called to form the list of default URIs for `eww'.
 Each of the elements is a function returning either a string or a list
 of strings.  The results will be joined into a single list with
@@ -12774,7 +12819,7 @@ to get the effect of a C-q.
 
 ;;;### (autoloads nil "flymake" "progmodes/flymake.el" (0 0 0 0))
 ;;; Generated autoloads from progmodes/flymake.el
-(push (purecopy '(flymake 1 0 5)) package--builtin-versions)
+(push (purecopy '(flymake 1 0 6)) package--builtin-versions)
 
 (autoload 'flymake-log "flymake" "\
 Log, at level LEVEL, the message MSG formatted with ARGS.
@@ -12827,12 +12872,10 @@ Flymake collects diagnostic information from multiple sources,
 called backends, and visually annotates the buffer with the
 results.
 
-Flymake performs these checks while the user is editing.  The
-customization variables `flymake-start-on-flymake-mode',
-`flymake-no-changes-timeout' and
-`flymake-start-syntax-check-on-newline' determine the exact
-circumstances whereupon Flymake decides to initiate a check of
-the buffer.
+Flymake performs these checks while the user is editing.
+The customization variables `flymake-start-on-flymake-mode',
+`flymake-no-changes-timeout' determine the exact circumstances
+whereupon Flymake decides to initiate a check of the buffer.
 
 The commands `flymake-goto-next-error' and
 `flymake-goto-prev-error' can be used to navigate among Flymake
@@ -13463,18 +13506,6 @@ All keyword parameters default to nil.
 
 \(fn FRAMESET &key PREDICATE FILTERS REUSE-FRAMES FORCE-DISPLAY FORCE-ONSCREEN CLEANUP-FRAMES)" nil nil)
 
-(autoload 'frameset--jump-to-register "frameset" "\
-Restore frameset from DATA stored in register.
-Called from `jump-to-register'.  Internal use only.
-
-\(fn DATA)" nil nil)
-
-(autoload 'frameset--print-register "frameset" "\
-Print basic info about frameset stored in DATA.
-Called from `list-registers' and `view-register'.  Internal use only.
-
-\(fn DATA)" nil nil)
-
 (autoload 'frameset-to-register "frameset" "\
 Store the current frameset in register REGISTER.
 Use \\[jump-to-register] to restore the frameset.
@@ -15986,7 +16017,7 @@ The value (hs . t) is added to `buffer-invisibility-spec'.
 
 The main commands are: `hs-hide-all', `hs-show-all', `hs-hide-block',
 `hs-show-block', `hs-hide-level' and `hs-toggle-hiding'.  There is also
-`hs-hide-initial-comment-block' and `hs-mouse-toggle-hiding'.
+`hs-hide-initial-comment-block'.
 
 Turning hideshow minor mode off reverts the menu bar and the
 variables to default values and disables the hideshow commands.
@@ -17538,8 +17569,9 @@ Return a regular expression matching image-file filenames." nil nil)
 
 (autoload 'insert-image-file "image-file" "\
 Insert the image file FILE into the current buffer.
-Optional arguments VISIT, BEG, END, and REPLACE are interpreted as for
-the command `insert-file-contents'.
+Optional arguments VISIT, BEG, END, and REPLACE are interpreted
+as for the command `insert-file-contents'.  Return list of
+absolute file name and number of characters inserted.
 
 \(fn FILE &optional VISIT BEG END REPLACE)" nil nil)
 
@@ -18691,15 +18723,17 @@ Major mode for editing JavaScript.
 \(fn)" t nil)
 
 (autoload 'js-jsx-mode "js" "\
-Major mode for editing JSX.
+Major mode for editing JavaScript+JSX.
 
-To customize the indentation for this mode, set the SGML offset
-variables (`sgml-basic-offset', `sgml-attribute-offset' et al.)
-locally, like so:
+Simply makes `js-jsx-syntax' buffer-local and sets it to t.
 
-  (defun set-jsx-indentation ()
-    (setq-local sgml-basic-offset js-indent-level))
-  (add-hook \\='js-jsx-mode-hook #\\='set-jsx-indentation)
+`js-mode' may detect and enable support for JSX automatically if
+it appears to be used in a JavaScript file.  You could also
+customize `js-jsx-regexps' to improve that detection; or, you
+could set `js-jsx-syntax' to t in your init file, or in a
+.dir-locals.el file, or using file variables; or, you could call
+`js-jsx-enable' in `js-mode-hook'.  You may be better served by
+one of the aforementioned options instead of using this mode.
 
 \(fn)" t nil)
  (defalias 'javascript-mode 'js-mode)
@@ -18951,6 +18985,11 @@ If kbd macro currently being defined end it before activating it.
 
 \(fn EVENT)" t nil)
 
+(autoload 'kmacro-lambda-form "kmacro" "\
+Create lambda form for macro bound to symbol or key.
+
+\(fn MAC &optional COUNTER FORMAT)" nil nil)
+
 (if (fboundp 'register-definition-prefixes) (register-definition-prefixes "kmacro" '("kmacro-")))
 
 ;;;***
@@ -19590,6 +19629,8 @@ and then select the region of un-tablified names and use
 \(fn TOP BOTTOM &optional MACRO)" t nil)
  (define-key ctl-x-map "q" 'kbd-macro-query)
 
+(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "macros" '("macros--insert-vector-macro")))
+
 ;;;***
 
 ;;;### (autoloads nil "mail-extr" "mail/mail-extr.el" (0 0 0 0))
@@ -20176,42 +20217,9 @@ recursion depth in the minibuffer prompt.  This is only useful if
 
 (autoload 'message-mode "message" "\
 Major mode for editing mail and news to be sent.
-Like Text Mode but with these additional commands:\\<message-mode-map>
-C-c C-s  `message-send' (send the message)  C-c C-c  `message-send-and-exit'
-C-c C-d  Postpone sending the message       C-c C-k  Kill the message
-C-c C-f  move to a header field (and create it if there isn't):
-	 C-c C-f C-t  move to To	C-c C-f C-s  move to Subject
-	 C-c C-f C-c  move to Cc	C-c C-f C-b  move to Bcc
-	 C-c C-f C-w  move to Fcc	C-c C-f C-r  move to Reply-To
-	 C-c C-f C-u  move to Summary	C-c C-f C-n  move to Newsgroups
-	 C-c C-f C-k  move to Keywords	C-c C-f C-d  move to Distribution
-	 C-c C-f C-o  move to From (\"Originator\")
-	 C-c C-f C-f  move to Followup-To
-	 C-c C-f C-m  move to Mail-Followup-To
-	 C-c C-f C-e  move to Expires
-	 C-c C-f C-i  cycle through Importance values
-	 C-c C-f s    change subject and append \"(was: <Old Subject>)\"
-	 C-c C-f x    crossposting with FollowUp-To header and note in body
-	 C-c C-f t    replace To: header with contents of Cc: or Bcc:
-	 C-c C-f a    Insert X-No-Archive: header and a note in the body
-C-c C-t  `message-insert-to' (add a To header to a news followup)
-C-c C-l  `message-to-list-only' (removes all but list address in to/cc)
-C-c C-n  `message-insert-newsgroups' (add a Newsgroup header to a news reply)
-C-c C-b  `message-goto-body' (move to beginning of message text).
-C-c C-i  `message-goto-signature' (move to the beginning of the signature).
-C-c C-w  `message-insert-signature' (insert `message-signature-file' file).
-C-c C-y  `message-yank-original' (insert current message, if any).
-C-c C-q  `message-fill-yanked-message' (fill what was yanked).
-C-c C-e  `message-elide-region' (elide the text between point and mark).
-C-c C-v  `message-delete-not-region' (remove the text outside the region).
-C-c C-z  `message-kill-to-signature' (kill the text up to the signature).
-C-c C-r  `message-caesar-buffer-body' (rot13 the message body).
-C-c C-a  `mml-attach-file' (attach a file as MIME).
-C-c C-u  `message-insert-or-toggle-importance'  (insert or cycle importance).
-C-c M-n  `message-insert-disposition-notification-to'  (request receipt).
-C-c M-m  `message-mark-inserted-region' (mark region with enclosing tags).
-C-c M-f  `message-mark-insert-file' (insert file marked with enclosing tags).
-M-RET    `message-newline-and-reformat' (break the line and reformat).
+Like `text-mode', but with these additional commands:
+
+\\{message-mode-map}
 
 \(fn)" t nil)
 
@@ -22071,7 +22079,7 @@ This command does not work if you use short group names." t nil)
 ;;;### (autoloads nil "nnheader" "gnus/nnheader.el" (0 0 0 0))
 ;;; Generated autoloads from gnus/nnheader.el
 
-(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nnheader" '("gnus-" "mail-header-" "make-" "nnheader-" "nntp-")))
+(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nnheader" '("gnus-" "mail-header-" "make-mail-header" "nnheader-" "nntp-")))
 
 ;;;***
 
@@ -28113,6 +28121,7 @@ CHAR
 `(seq SEXP1 SEXP2 ...)'
 `(sequence SEXP1 SEXP2 ...)'
      matches what SEXP1 matches, followed by what SEXP2 matches, etc.
+     Without arguments, matches the empty string.
 
 `(submatch SEXP1 SEXP2 ...)'
 `(group SEXP1 SEXP2 ...)'
@@ -28128,7 +28137,7 @@ CHAR
 `(| SEXP1 SEXP2 ...)'
      matches anything that matches SEXP1 or SEXP2, etc.  If all
      args are strings, use `regexp-opt' to optimize the resulting
-     regular expression.
+     regular expression.  Without arguments, never matches anything.
 
 `(minimal-match SEXP)'
      produce a non-greedy regexp for SEXP.  Normally, regexps matching
@@ -29263,6 +29272,7 @@ The default value matches citations like `foo-bar>' plus whitespace.")
 
 (defvar mail-signature t "\
 Text inserted at end of mail buffer when a message is initialized.
+If nil, no signature is inserted.
 If t, it means to insert the contents of the file `mail-signature-file'.
 If a string, that string is inserted.
  (To make a proper signature, the string should begin with \\n\\n-- \\n,
@@ -34358,9 +34368,11 @@ STATUS is a plist representing what happened during the request,
 with most recent events first, or an empty list if no events have
 occurred.  Each pair is one of:
 
-\(:redirect REDIRECTED-TO) - the request was redirected to this URL
-\(:error (ERROR-SYMBOL . DATA)) - an error occurred.  The error can be
-signaled with (signal ERROR-SYMBOL DATA).
+\(:redirect REDIRECTED-TO) - the request was redirected to this URL.
+
+\(:error (error type . DATA)) - an error occurred.  TYPE is a
+symbol that says something about where the error occurred, and
+DATA is a list (possibly nil) that describes the error further.
 
 Return the buffer URL will load into, or nil if the process has
 already completed (i.e. URL was a mailto URL or similar; in this case
@@ -34620,23 +34632,19 @@ if ARG is `toggle'; disable the mode otherwise.
 
 (autoload 'url-file-handler "url-handlers" "\
 Function called from the `file-name-handler-alist' routines.
-OPERATION is what needs to be done (`file-exists-p', etc).  ARGS are
-the arguments that would have been passed to OPERATION.
+OPERATION is what needs to be done (`file-exists-p', etc.).
+ARGS are the arguments that would have been passed to OPERATION.
 
 \(fn OPERATION &rest ARGS)" nil nil)
 
 (autoload 'url-copy-file "url-handlers" "\
-Copy URL to NEWNAME.  Both args must be strings.
-Signal a `file-already-exists' error if file NEWNAME already exists,
-unless a third argument OK-IF-ALREADY-EXISTS is supplied and non-nil.
-A number as third arg means request confirmation if NEWNAME already exists.
-This is what happens in interactive use with M-x.
-Fourth arg KEEP-TIME non-nil means give the new file the same
-last-modified time as the old one.  (This works on only some systems.)
-Args PRESERVE-UID-GID and PRESERVE-PERMISSIONS are ignored.
-A prefix arg makes KEEP-TIME non-nil.
-
-\(fn URL NEWNAME &optional OK-IF-ALREADY-EXISTS KEEP-TIME PRESERVE-UID-GID PRESERVE-PERMISSIONS)" nil nil)
+Copy URL to NEWNAME.  Both arguments must be strings.
+Signal a `file-already-exists' error if file NEWNAME already
+exists, unless a third argument OK-IF-ALREADY-EXISTS is supplied
+and non-nil.  An integer as third argument means request
+confirmation if NEWNAME already exists.
+
+\(fn URL NEWNAME &optional OK-IF-ALREADY-EXISTS &rest IGNORED)" nil nil)
 
 (autoload 'url-file-local-copy "url-handlers" "\
 Copy URL into a temporary file on this machine.
@@ -35307,7 +35315,12 @@ first backend that could register the file is used.
 \(fn &optional VC-FILESET COMMENT)" t nil)
 
 (autoload 'vc-version-diff "vc" "\
-Report diffs between REV1 and REV2 revisions of the fileset.
+Report diffs between revisions REV1 and REV2 in the repository history.
+This compares two revisions of the current fileset.
+If REV1 is nil, it defaults to the current revision, i.e. revision
+of the last commit.
+If REV2 is nil, it defaults to the work tree, i.e. the current
+state of each file in the fileset.
 
 \(fn FILES REV1 REV2)" t nil)
 
@@ -35334,8 +35347,14 @@ The merge base is a common ancestor between REV1 and REV2 revisions.
 \(fn FILES REV1 REV2)" t nil)
 
 (autoload 'vc-version-ediff "vc" "\
-Show differences between revisions of the fileset in the
-repository history using ediff.
+Show differences between REV1 and REV2 of FILES using ediff.
+This compares two revisions of the files in FILES.  Currently,
+only a single file's revisions can be compared, i.e. FILES can
+specify only one file name.
+If REV1 is nil, it defaults to the current revision, i.e. revision
+of the last commit.
+If REV2 is nil, it defaults to the work tree, i.e. the current
+state of each file in FILES.
 
 \(fn FILES REV1 REV2)" t nil)
 
@@ -38171,43 +38190,45 @@ Zone out, completely." t nil)
 ;;;;;;  "international/uni-digit.el" "international/uni-lowercase.el"
 ;;;;;;  "international/uni-mirrored.el" "international/uni-name.el"
 ;;;;;;  "international/uni-numeric.el" "international/uni-old-name.el"
-;;;;;;  "international/uni-titlecase.el" "international/uni-uppercase.el"
-;;;;;;  "isearch.el" "jit-lock.el" "jka-cmpr-hook.el" "language/burmese.el"
-;;;;;;  "language/cham.el" "language/chinese.el" "language/cyrillic.el"
-;;;;;;  "language/czech.el" "language/english.el" "language/ethiopic.el"
-;;;;;;  "language/european.el" "language/georgian.el" "language/greek.el"
-;;;;;;  "language/hebrew.el" "language/indian.el" "language/japanese.el"
-;;;;;;  "language/khmer.el" "language/korean.el" "language/lao.el"
-;;;;;;  "language/misc-lang.el" "language/romanian.el" "language/sinhala.el"
-;;;;;;  "language/slovak.el" "language/tai-viet.el" "language/thai.el"
-;;;;;;  "language/tibetan.el" "language/utf-8-lang.el" "language/vietnamese.el"
-;;;;;;  "ldefs-boot.el" "leim/ja-dic/ja-dic.el" "leim/leim-list.el"
-;;;;;;  "leim/quail/4Corner.el" "leim/quail/ARRAY30.el" "leim/quail/CCDOSPY.el"
-;;;;;;  "leim/quail/CTLau-b5.el" "leim/quail/CTLau.el" "leim/quail/ECDICT.el"
-;;;;;;  "leim/quail/ETZY.el" "leim/quail/PY-b5.el" "leim/quail/PY.el"
-;;;;;;  "leim/quail/Punct-b5.el" "leim/quail/Punct.el" "leim/quail/QJ-b5.el"
-;;;;;;  "leim/quail/QJ.el" "leim/quail/SW.el" "leim/quail/TONEPY.el"
-;;;;;;  "leim/quail/ZIRANMA.el" "leim/quail/ZOZY.el" "leim/quail/arabic.el"
-;;;;;;  "leim/quail/croatian.el" "leim/quail/cyril-jis.el" "leim/quail/cyrillic.el"
-;;;;;;  "leim/quail/czech.el" "leim/quail/georgian.el" "leim/quail/greek.el"
-;;;;;;  "leim/quail/hanja-jis.el" "leim/quail/hanja.el" "leim/quail/hanja3.el"
-;;;;;;  "leim/quail/hebrew.el" "leim/quail/ipa-praat.el" "leim/quail/latin-alt.el"
-;;;;;;  "leim/quail/latin-ltx.el" "leim/quail/latin-post.el" "leim/quail/latin-pre.el"
-;;;;;;  "leim/quail/persian.el" "leim/quail/programmer-dvorak.el"
-;;;;;;  "leim/quail/py-punct.el" "leim/quail/pypunct-b5.el" "leim/quail/quick-b5.el"
-;;;;;;  "leim/quail/quick-cns.el" "leim/quail/rfc1345.el" "leim/quail/sami.el"
-;;;;;;  "leim/quail/sgml-input.el" "leim/quail/slovak.el" "leim/quail/symbol-ksc.el"
-;;;;;;  "leim/quail/tamil-dvorak.el" "leim/quail/tsang-b5.el" "leim/quail/tsang-cns.el"
-;;;;;;  "leim/quail/vntelex.el" "leim/quail/vnvni.el" "leim/quail/welsh.el"
-;;;;;;  "loadup.el" "mail/blessmail.el" "mail/rmailedit.el" "mail/rmailkwd.el"
-;;;;;;  "mail/rmailmm.el" "mail/rmailmsc.el" "mail/rmailsort.el"
-;;;;;;  "mail/rmailsum.el" "mail/undigest.el" "menu-bar.el" "mh-e/mh-gnus.el"
-;;;;;;  "mh-e/mh-loaddefs.el" "minibuffer.el" "mouse.el" "net/tramp-loaddefs.el"
-;;;;;;  "newcomment.el" "obarray.el" "org/ob-core.el" "org/ob-keys.el"
-;;;;;;  "org/ob-lob.el" "org/ob-matlab.el" "org/ob-tangle.el" "org/ob.el"
-;;;;;;  "org/org-archive.el" "org/org-attach.el" "org/org-bbdb.el"
-;;;;;;  "org/org-clock.el" "org/org-datetree.el" "org/org-element.el"
-;;;;;;  "org/org-feed.el" "org/org-footnote.el" "org/org-id.el" "org/org-indent.el"
+;;;;;;  "international/uni-special-lowercase.el" "international/uni-special-titlecase.el"
+;;;;;;  "international/uni-special-uppercase.el" "international/uni-titlecase.el"
+;;;;;;  "international/uni-uppercase.el" "isearch.el" "jit-lock.el"
+;;;;;;  "jka-cmpr-hook.el" "language/burmese.el" "language/cham.el"
+;;;;;;  "language/chinese.el" "language/cyrillic.el" "language/czech.el"
+;;;;;;  "language/english.el" "language/ethiopic.el" "language/european.el"
+;;;;;;  "language/georgian.el" "language/greek.el" "language/hebrew.el"
+;;;;;;  "language/indian.el" "language/japanese.el" "language/khmer.el"
+;;;;;;  "language/korean.el" "language/lao.el" "language/misc-lang.el"
+;;;;;;  "language/romanian.el" "language/sinhala.el" "language/slovak.el"
+;;;;;;  "language/tai-viet.el" "language/thai.el" "language/tibetan.el"
+;;;;;;  "language/utf-8-lang.el" "language/vietnamese.el" "ldefs-boot.el"
+;;;;;;  "leim/ja-dic/ja-dic.el" "leim/leim-list.el" "leim/quail/4Corner.el"
+;;;;;;  "leim/quail/ARRAY30.el" "leim/quail/CCDOSPY.el" "leim/quail/CTLau-b5.el"
+;;;;;;  "leim/quail/CTLau.el" "leim/quail/ECDICT.el" "leim/quail/ETZY.el"
+;;;;;;  "leim/quail/PY-b5.el" "leim/quail/PY.el" "leim/quail/Punct-b5.el"
+;;;;;;  "leim/quail/Punct.el" "leim/quail/QJ-b5.el" "leim/quail/QJ.el"
+;;;;;;  "leim/quail/SW.el" "leim/quail/TONEPY.el" "leim/quail/ZIRANMA.el"
+;;;;;;  "leim/quail/ZOZY.el" "leim/quail/arabic.el" "leim/quail/croatian.el"
+;;;;;;  "leim/quail/cyril-jis.el" "leim/quail/cyrillic.el" "leim/quail/czech.el"
+;;;;;;  "leim/quail/georgian.el" "leim/quail/greek.el" "leim/quail/hanja-jis.el"
+;;;;;;  "leim/quail/hanja.el" "leim/quail/hanja3.el" "leim/quail/hebrew.el"
+;;;;;;  "leim/quail/ipa-praat.el" "leim/quail/latin-alt.el" "leim/quail/latin-ltx.el"
+;;;;;;  "leim/quail/latin-post.el" "leim/quail/latin-pre.el" "leim/quail/persian.el"
+;;;;;;  "leim/quail/programmer-dvorak.el" "leim/quail/py-punct.el"
+;;;;;;  "leim/quail/pypunct-b5.el" "leim/quail/quick-b5.el" "leim/quail/quick-cns.el"
+;;;;;;  "leim/quail/rfc1345.el" "leim/quail/sami.el" "leim/quail/sgml-input.el"
+;;;;;;  "leim/quail/slovak.el" "leim/quail/symbol-ksc.el" "leim/quail/tamil-dvorak.el"
+;;;;;;  "leim/quail/tsang-b5.el" "leim/quail/tsang-cns.el" "leim/quail/vntelex.el"
+;;;;;;  "leim/quail/vnvni.el" "leim/quail/welsh.el" "loadup.el" "mail/blessmail.el"
+;;;;;;  "mail/rmailedit.el" "mail/rmailkwd.el" "mail/rmailmm.el"
+;;;;;;  "mail/rmailmsc.el" "mail/rmailsort.el" "mail/rmailsum.el"
+;;;;;;  "mail/undigest.el" "menu-bar.el" "mh-e/mh-gnus.el" "mh-e/mh-loaddefs.el"
+;;;;;;  "minibuffer.el" "mouse.el" "net/tramp-loaddefs.el" "newcomment.el"
+;;;;;;  "obarray.el" "org/ob-core.el" "org/ob-keys.el" "org/ob-lob.el"
+;;;;;;  "org/ob-matlab.el" "org/ob-tangle.el" "org/ob.el" "org/org-archive.el"
+;;;;;;  "org/org-attach.el" "org/org-bbdb.el" "org/org-clock.el"
+;;;;;;  "org/org-datetree.el" "org/org-element.el" "org/org-feed.el"
+;;;;;;  "org/org-footnote.el" "org/org-id.el" "org/org-indent.el"
 ;;;;;;  "org/org-install.el" "org/org-irc.el" "org/org-mobile.el"
 ;;;;;;  "org/org-plot.el" "org/org-table.el" "org/org-timer.el" "org/ox-ascii.el"
 ;;;;;;  "org/ox-beamer.el" "org/ox-html.el" "org/ox-icalendar.el"
diff --git a/lisp/leim/quail/croatian.el b/lisp/leim/quail/croatian.el
index 9d3def9827..8fefe1cf82 100644
--- a/lisp/leim/quail/croatian.el
+++ b/lisp/leim/quail/croatian.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2003-2019 Free Software Foundation, Inc.
 
-;; Author: Hrvoje Nikšić <hniksic@xemacs.org>
+;; Author: Hrvoje Nikšić <hrvoje.niksic@avl.com>
 ;; Keywords: i18n
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/leim/quail/latin-pre.el b/lisp/leim/quail/latin-pre.el
index bcf81f4a14..8e0b2748e3 100644
--- a/lisp/leim/quail/latin-pre.el
+++ b/lisp/leim/quail/latin-pre.el
@@ -32,7 +32,6 @@
 ;;
 ;; polish-slash:
 ;; Author: Włodek Bzyl <matwb@univ.gda.pl>
-;; Maintainer: Włodek Bzyl <matwb@univ.gda.pl>
 ;;
 ;; latin-[89]-prefix: Dave Love <fx@gnu.org>
 ;;
diff --git a/lisp/leim/quail/py-punct.el b/lisp/leim/quail/py-punct.el
index eed70a82ee..49ea66effb 100644
--- a/lisp/leim/quail/py-punct.el
+++ b/lisp/leim/quail/py-punct.el
@@ -6,7 +6,7 @@
 ;;   National Institute of Advanced Industrial Science and Technology (AIST)
 ;;   Registration Number H14PRO021
 
-;; Author: Ken'ichi HANDA <handa@etl.go.jp>
+;; Author: Ken'ichi Handa <handa@gnu.org>
 
 ;; Keywords: multilingual, input method, Chinese
 
diff --git a/lisp/leim/quail/pypunct-b5.el b/lisp/leim/quail/pypunct-b5.el
index 45597a4ef6..9f4e73c9f0 100644
--- a/lisp/leim/quail/pypunct-b5.el
+++ b/lisp/leim/quail/pypunct-b5.el
@@ -5,7 +5,7 @@
 ;;   National Institute of Advanced Industrial Science and Technology (AIST)
 ;;   Registration Number H14PRO021
 
-;; Author: Ken'ichi HANDA <handa@etl.go.jp>
+;; Author: Ken'ichi Handa <handa@gnu.org>
 
 ;; Keywords: multilingual, input method, Chinese
 
diff --git a/lisp/leim/quail/sami.el b/lisp/leim/quail/sami.el
index 7cfd0b7348..88d34092dd 100644
--- a/lisp/leim/quail/sami.el
+++ b/lisp/leim/quail/sami.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2019 Free Software Foundation, Inc.
 
 ;; Author: Wojciech S. Gac <wojciech.s.gac@gmail.com>
-;; Maintainer: Wojciech S. Gac <wojciech.s.gac@gmail.com>>
 ;; Keywords: i18n, multilingual, input method, Sámi
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/leim/quail/vntelex.el b/lisp/leim/quail/vntelex.el
index 78b467de54..9faa5d2278 100644
--- a/lisp/leim/quail/vntelex.el
+++ b/lisp/leim/quail/vntelex.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2001-2019 Free Software Foundation, Inc.
 
-;; Author:   Werner Lemberg <wl@gnu.org>
+;; Author: Werner Lemberg <wl@gnu.org>
 ;; Keywords: multilingual, input method, Vietnamese
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/macros.el b/lisp/macros.el
index ba6a840d60..4b38506d8a 100644
--- a/lisp/macros.el
+++ b/lisp/macros.el
@@ -36,6 +36,16 @@
 ;;;###autoload
 (defalias 'name-last-kbd-macro #'kmacro-name-last-macro)
 
+(defun macros--insert-vector-macro (definition)
+  "Print DEFINITION, a vector, into the current buffer."
+  (dotimes (i (length definition))
+    (let ((char (aref definition i)))
+      (insert (if (zerop i) ?\[ ?\s))
+      (if (characterp char)
+          (princ (prin1-char char) (current-buffer))
+        (prin1 char (current-buffer)))))
+  (insert ?\]))
+
 ;;;###autoload
 (defun insert-kbd-macro (macroname &optional keys)
   "Insert in buffer the definition of kbd macro MACRONAME, as Lisp code.
@@ -111,19 +121,17 @@ use this command, and then save the file."
 		     (delete-region (point) (1+ (point)))
 		     (insert "\\M-\\C-?"))))))
       (if (vectorp definition)
-	  (let ((len (length definition)) (i 0) char)
-	    (while (< i len)
-	      (insert (if (zerop i) ?\[ ?\s))
-	      (setq char (aref definition i)
-		    i (1+ i))
-	      (if (not (numberp char))
-                  (prin1 char (current-buffer))
-                (princ (prin1-char char) (current-buffer))))
-	    (insert ?\]))
-        ;; FIXME: For kmacros, we shouldn't write the (lambda ...)
-        ;; gunk but instead we should write something more abstract like
-        ;; (kmacro-create [<keys>] 0 "%d").
-	(prin1 definition (current-buffer))))
+          (macros--insert-vector-macro definition)
+        (pcase (kmacro-extract-lambda definition)
+          (`(,vecdef ,counter ,format)
+           (insert "(kmacro-lambda-form ")
+           (macros--insert-vector-macro vecdef)
+           (insert " ")
+           (prin1 counter (current-buffer))
+           (insert " ")
+           (prin1 format (current-buffer))
+           (insert ")"))
+          (_ (prin1 definition (current-buffer))))))
     (insert ")\n")
     (if keys
         (let ((keys (or (where-is-internal (symbol-function macroname)
diff --git a/lisp/mail/feedmail.el b/lisp/mail/feedmail.el
index a90d9c4657..180e32bee4 100644
--- a/lisp/mail/feedmail.el
+++ b/lisp/mail/feedmail.el
@@ -1657,7 +1657,7 @@ local gurus."
 (declare-function smtp-via-smtp "ext:smtp" (sender recipients smtp-text-buffer))
 (defvar smtp-server)
 
-;; FLIM's smtp.el pointed out to me by Kenichi Handa <handa@etl.go.jp>
+;; FLIM's smtp.el pointed out to me by Kenichi Handa <handa@gnu.org>
 (defun feedmail-buffer-to-smtp (prepped errors-to addr-listoid)
   "Function which actually calls smtp-via-smtp to send buffer as e-mail."
   (feedmail-say-debug ">in-> feedmail-buffer-to-smtp %s" addr-listoid)
diff --git a/lisp/mail/footnote.el b/lisp/mail/footnote.el
index 81dc11de76..bbc42e11f7 100644
--- a/lisp/mail/footnote.el
+++ b/lisp/mail/footnote.el
@@ -73,50 +73,38 @@
 
 (defcustom footnote-mode-line-string " FN"
   "String to display in modes section of the mode-line."
-  :type 'string
-  :group 'footnote)
-
-(defcustom footnote-mode-hook nil
-  "Hook functions run when footnote-mode is activated."
-  :type 'hook
-  :group 'footnote)
+  :type 'string)
 
 (defcustom footnote-narrow-to-footnotes-when-editing nil
   "If non-nil, narrow to footnote text body while editing a footnote."
-  :type 'boolean
-  :group 'footnote)
+  :type 'boolean)
 
 (defcustom footnote-prompt-before-deletion t
   "If non-nil, prompt before deleting a footnote.
 There is currently no way to undo deletions."
-  :type 'boolean
-  :group 'footnote)
+  :type 'boolean)
 
 (defcustom footnote-spaced-footnotes t
   "If non-nil, insert an empty line between footnotes.
 Customizing this variable has no effect on buffers already
 displaying footnotes."
-  :type 'boolean
-  :group 'footnote)
+  :type 'boolean)
 
 (defcustom footnote-use-message-mode t ; Nowhere used.
   "If non-nil, assume Footnoting will be done in `message-mode'."
-  :type 'boolean
-  :group 'footnote)
+  :type 'boolean)
 
 (defcustom footnote-body-tag-spacing 2
   "Number of spaces separating a footnote body tag and its text.
 Customizing this variable has no effect on buffers already
 displaying footnotes."
-  :type 'integer
-  :group 'footnote)
+  :type 'integer)
 
 (defcustom footnote-prefix [(control ?c) ?!]
-  "Prefix key to use for Footnote command in Footnote minor mode.
+  "Prefix key to use for Footnote commands in Footnote minor mode.
 The value of this variable is checked as part of loading Footnote mode.
 After that, changing the prefix key requires manipulating keymaps."
-  :type 'key-sequence
-  :group 'footnote)
+  :type 'key-sequence)
 
 ;;; Interface variables that probably shouldn't be changed
 
@@ -127,8 +115,7 @@ value of `footnote-section-tag-regexp' is ignored.  Customizing
 this variable has no effect on buffers already displaying
 footnotes."
   :version "27.1"
-  :type 'string
-  :group 'footnote)
+  :type 'string)
 
 (defcustom footnote-section-tag-regexp
   ;; Even if `footnote-section-tag' has a trailing space, let's not require it
@@ -139,31 +126,27 @@ This variable is disregarded when `footnote-section-tag' is the
 empty string.  Customizing this variable has no effect on buffers
 already displaying footnotes."
   :version "27.1"
-  :type 'regexp
-  :group 'footnote)
+  :type 'regexp)
 
 ;; The following three should be consumed by footnote styles.
 (defcustom footnote-start-tag "["
   "String used to denote start of numbered footnote.
 Should not be set to the empty string.  Customizing this variable
 has no effect on buffers already displaying footnotes."
-  :type 'string
-  :group 'footnote)
+  :type 'string)
 
 (defcustom footnote-end-tag "]"
   "String used to denote end of numbered footnote.
 Should not be set to the empty string.  Customizing this variable
 has no effect on buffers already displaying footnotes."
-  :type 'string
-  :group 'footnote)
+  :type 'string)
 
 (defcustom footnote-signature-separator
   (if (boundp 'message-signature-separator)
       message-signature-separator
     "^-- $")
   "Regexp used by Footnote mode to recognize signatures."
-  :type 'regexp
-  :group 'footnote)
+  :type 'regexp)
 
 (defcustom footnote-align-to-fn-text t
   "How to left-align footnote text.
@@ -174,19 +157,19 @@ left with the first character of footnote text."
 
 ;;; Private variables
 
-(defvar footnote-style-number nil
-  "Footnote style represented as an index into footnote-style-alist.")
-(make-variable-buffer-local 'footnote-style-number)
-
-(defvar footnote-text-marker-alist nil
-  "List of markers pointing to text of footnotes in message buffer.")
-(make-variable-buffer-local 'footnote-text-marker-alist)
+(defvar-local footnote-style-number nil
+  "Footnote style represented as an index into `footnote-style-alist'.")
 
-(defvar footnote-pointer-marker-alist nil
-  "List of markers pointing to footnote pointers in message buffer.")
-(make-variable-buffer-local 'footnote-pointer-marker-alist)
+(defvar-local footnote--markers-alist nil
+  "List of (FN TEXT . POINTERS).
+Where FN is the footnote number, TEXT is a marker pointing to
+the footnote's text, and POINTERS is a list of markers pointing
+to the places from which the footnote is referenced.
+Both TEXT and POINTERS points right *before* the [...]")
 
 (defvar footnote-mouse-highlight 'highlight
+  ;; FIXME: This `highlight' property is not currently used.
+  ;; We should use `mouse-face' and make mouse clicks work on them.
   "Text property name to enable mouse over highlight.")
 
 (defvar footnote-mode)
@@ -365,7 +348,7 @@ Use Unicode characters for footnoting."
 (defconst footnote-hebrew-numeric-regex
   (let ((numchars (string-to-list
 		   (apply #'concat (apply #'append footnote-hebrew-numeric)))))
-    (concat (regexp-opt-charset (cons ?' numchars)) "+")))
+    (rx-to-string `(1+ (in ?' ,@numchars)))))
 ;; (defconst footnote-hebrew-numeric-regex "\\([אבגדהוזחט]'\\)?\\(ת\\)?\\(ת\\)?\\([קרשת]\\)?\\([טיכלמנסעפצ]\\)?\\([אבגדהוזחט]\\)?")
 
 (defun footnote--hebrew-numeric (n)
@@ -441,159 +424,122 @@ Customizing this variable has no effect on buffers already
 displaying footnotes.  To change the style of footnotes in such a
 buffer use the command `footnote-set-style'."
   :type (cons 'choice (mapcar (lambda (x) (list 'const (car x)))
-			      footnote-style-alist))
-  :group 'footnote)
+			      footnote-style-alist)))
 
 ;;; Style utilities & functions
-(defun footnote--style-p (style)
-  "Return non-nil if style is a valid style known to `footnote-mode'."
-  (assq style footnote-style-alist))
 
 (defun footnote--index-to-string (index)
   "Convert a binary index into a string to display as a footnote.
 Conversion is done based upon the current selected style."
-  (let ((alist (if (footnote--style-p footnote-style)
-		   (assq footnote-style footnote-style-alist)
-		 (nth 0 footnote-style-alist))))
+  (let ((alist (or (assq footnote-style footnote-style-alist)
+		   (nth 0 footnote-style-alist))))
     (funcall (nth 1 alist) index)))
 
-(defun footnote--current-regexp ()
+(defun footnote--current-regexp (&optional index-regexp)
   "Return the regexp of the index of the current style."
-  (let ((regexp (nth 2 (or (assq footnote-style footnote-style-alist)
-			   (nth 0 footnote-style-alist)))))
+  (let ((regexp (or index-regexp
+                    (nth 2 (or (assq footnote-style footnote-style-alist)
+			       (nth 0 footnote-style-alist))))))
     (concat
+     (regexp-quote footnote-start-tag) "\\("
      ;; Hack to avoid repetition of repetition.
      ;; FIXME: I'm not sure the added * makes sense at all; there is
      ;; always a single number within the footnote-{start,end}-tag pairs.
-     ;; Worse, the code goes on and adds yet another + later on, in
-     ;; footnote-refresh-footnotes, just in case. That makes even less sense.
-     ;; Likely, both the * and the extra + should go away.
      (if (string-match "[^\\]\\\\\\{2\\}*[*+?]\\'" regexp)
 	 (substring regexp 0 -1)
        regexp)
-     "*")))
+     "*\\)" (regexp-quote footnote-end-tag))))
 
 (defun footnote--refresh-footnotes (&optional index-regexp)
   "Redraw all footnotes.
-You must call this or arrange to have this called after changing footnote
-styles."
-  (unless index-regexp
-    (setq index-regexp (footnote--current-regexp)))
-  (save-excursion
-    ;; Take care of the pointers first
-    (let ((i 0) locn alist)
-      (while (setq alist (nth i footnote-pointer-marker-alist))
-	(setq locn (cdr alist))
-	(while locn
-	  (goto-char (car locn))
+You must call this or arrange to have this called after changing
+footnote styles."
+  (let ((fn-regexp (footnote--current-regexp index-regexp)))
+    (save-excursion
+      (pcase-dolist (`(,fn ,text . ,pointers) footnote--markers-alist)
+        ;; Take care of the pointers first.
+	(dolist (locn pointers)
+	  (goto-char locn)
 	  ;; Try to handle the case where `footnote-start-tag' and
 	  ;; `footnote-end-tag' are the same string.
-	  (when (looking-back (concat
-			       (regexp-quote footnote-start-tag)
-			       "\\(" index-regexp "+\\)"
-			       (regexp-quote footnote-end-tag))
-			      (line-beginning-position))
+	  (when (looking-at fn-regexp)
 	    (replace-match
 	     (propertize
 	      (concat
 	       footnote-start-tag
-	       (footnote--index-to-string (1+ i))
+	       (footnote--index-to-string fn)
 	       footnote-end-tag)
-	      'footnote-number (1+ i) footnote-mouse-highlight t)
-	     nil "\\1"))
-	  (setq locn (cdr locn)))
-	(setq i (1+ i))))
-
-    ;; Now take care of the text section
-    (let ((i 0) alist)
-      (while (setq alist (nth i footnote-text-marker-alist))
-	(goto-char (cdr alist))
-	(when (looking-at (concat
-			   (regexp-quote footnote-start-tag)
-			   "\\(" index-regexp "+\\)"
-			   (regexp-quote footnote-end-tag)))
+	      'footnote-number fn footnote-mouse-highlight t)
+	     t t)))
+
+        ;; Now take care of the text section
+	(goto-char text)
+	(when (looking-at fn-regexp)
 	  (replace-match
 	   (propertize
 	    (concat
 	     footnote-start-tag
-	     (footnote--index-to-string (1+ i))
+	     (footnote--index-to-string fn)
 	     footnote-end-tag)
-	    'footnote-number (1+ i))
-	   nil "\\1"))
-	(setq i (1+ i))))))
-
-(defun footnote--assoc-index (key alist)
-  "Give index of key in alist."
-  (let ((i 0) (max (length alist)) rc)
-    (while (and (null rc)
-		(< i max))
-      (when (eq key (car (nth i alist)))
-	(setq rc i))
-      (setq i (1+ i)))
-    rc))
+	    'footnote-number fn)
+	   t t))))))
 
 (defun footnote-cycle-style ()
   "Select next defined footnote style."
   (interactive)
-  (let ((old (footnote--assoc-index footnote-style footnote-style-alist))
-	(max (length footnote-style-alist))
-	idx)
-    (setq idx (1+ old))
-    (when (>= idx max)
-      (setq idx 0))
-    (setq footnote-style (car (nth idx footnote-style-alist)))
-    (footnote--refresh-footnotes (nth 2 (nth old footnote-style-alist)))))
-
-(defun footnote-set-style (&optional style)
+  (let ((old-desc (assq footnote-style footnote-style-alist)))
+    (setq footnote-style (caar (or (cdr (memq old-desc footnote-style-alist))
+                                   footnote-style-alist)))
+    (footnote--refresh-footnotes (nth 2 old-desc))
+    (message "Style set to %s" footnote-style)))
+
+(defun footnote-set-style (style)
   "Select a specific style."
   (interactive
    (list (intern (completing-read
 		  "Footnote Style: "
-		  obarray #'footnote--style-p 'require-match))))
-  (let ((old (footnote--assoc-index footnote-style footnote-style-alist)))
+		  footnote-style-alist nil 'require-match))))
+  (let ((old-desc (assq footnote-style footnote-style-alist)))
     (setq footnote-style style)
-    (footnote--refresh-footnotes (nth 2 (nth old footnote-style-alist)))))
+    (footnote--refresh-footnotes (nth 2 old-desc))))
 
 ;; Internal functions
 (defun footnote--insert-numbered-footnote (arg &optional mousable)
-  "Insert numbered footnote at (point)."
+  "Insert numbered footnote at point.
+Return a marker pointing to the beginning of the [...]."
   (let ((string (concat footnote-start-tag
 			(footnote--index-to-string arg)
-			footnote-end-tag)))
-    (insert-before-markers
+			footnote-end-tag))
+        (pos (point)))
+    (insert
      (if mousable
 	 (propertize
 	  string 'footnote-number arg footnote-mouse-highlight t)
-       (propertize string 'footnote-number arg)))))
+       (propertize string 'footnote-number arg)))
+    (copy-marker pos t)))
 
-(defun footnote--renumber (_from to pointer-alist text-alist)
+(defun footnote--renumber (to alist-elem)
   "Renumber a single footnote."
-  (let* ((posn-list (cdr pointer-alist)))
-    (setcar pointer-alist to)
-    (setcar text-alist to)
-    (while posn-list
-      (goto-char (car posn-list))
-      (when (looking-back (concat (regexp-quote footnote-start-tag)
-				  (footnote--current-regexp)
-				  (regexp-quote footnote-end-tag))
-			  (line-beginning-position))
-	(replace-match
-	 (propertize
+  (unless (equal to (car alist-elem))   ;Nothing to do.
+    (let* ((fn-regexp (footnote--current-regexp)))
+      (setcar alist-elem to)
+      (dolist (posn (cddr alist-elem))
+        (goto-char posn)
+        (when (looking-at fn-regexp)
+	  (replace-match
+	   (propertize
+	    (concat footnote-start-tag
+		    (footnote--index-to-string to)
+		    footnote-end-tag)
+	    'footnote-number to footnote-mouse-highlight t))))
+      (goto-char (cadr alist-elem))
+      (when (looking-at fn-regexp)
+        (replace-match
+         (propertize
 	  (concat footnote-start-tag
 		  (footnote--index-to-string to)
 		  footnote-end-tag)
-	  'footnote-number to footnote-mouse-highlight t)))
-      (setq posn-list (cdr posn-list)))
-    (goto-char (cdr text-alist))
-    (when (looking-at (concat (regexp-quote footnote-start-tag)
-			      (footnote--current-regexp)
-			      (regexp-quote footnote-end-tag)))
-      (replace-match
-       (propertize
-	(concat footnote-start-tag
-		(footnote--index-to-string to)
-		footnote-end-tag)
-	'footnote-number to)))))
+	  'footnote-number to))))))
 
 (defun footnote--narrow-to-footnotes ()
   "Restrict text in buffer to show only text of footnotes."
@@ -607,93 +553,66 @@ styles."
   (or (re-search-backward footnote-signature-separator nil t)
       (point)))
 
-(defun footnote--insert-text-marker (arg locn)
-  "Insert a marker pointing to footnote ARG, at buffer location LOCN."
-  (let ((marker (make-marker)))
-    (unless (assq arg footnote-text-marker-alist)
-      (set-marker marker locn)
-      (setq footnote-text-marker-alist
-	    (cons (cons arg marker) footnote-text-marker-alist))
-      (setq footnote-text-marker-alist
-	    (footnote--sort footnote-text-marker-alist)))))
-
-(defun footnote--insert-pointer-marker (arg locn)
-  "Insert a marker pointing to footnote ARG, at buffer location LOCN."
-  (let ((marker (make-marker))
-	alist)
-    (set-marker marker locn)
-    (if (setq alist (assq arg footnote-pointer-marker-alist))
-	(setf alist
-	      (cons marker (cdr alist)))
-      (setq footnote-pointer-marker-alist
-	    (cons (cons arg (list marker)) footnote-pointer-marker-alist))
-      (setq footnote-pointer-marker-alist
-	    (footnote--sort footnote-pointer-marker-alist)))))
+(defun footnote--insert-markers (arg text ptr)
+  "Insert the markers of new footnote ARG."
+  (cl-assert (and (numberp arg) (markerp text) (markerp ptr)))
+  (cl-assert (not (assq arg footnote--markers-alist)))
+  (push `(,arg ,text ,ptr) footnote--markers-alist)
+  (setq footnote--markers-alist
+	(footnote--sort footnote--markers-alist)))
+
+(defun footnote--goto-first ()
+  "Go to beginning of footnote area and return non-nil if successful.
+Presumes we're within the footnote area already."
+  (cond
+   ((not (string-equal footnote-section-tag ""))
+    (re-search-backward
+     (concat "^" footnote-section-tag-regexp) nil t))
+   (footnote--markers-alist
+    (goto-char (cadr (car footnote--markers-alist))))))
 
 (defun footnote--insert-footnote (arg)
   "Insert a footnote numbered ARG, at (point)."
   (push-mark)
-  (footnote--insert-pointer-marker arg (point))
-  (footnote--insert-numbered-footnote arg t)
-  (footnote--goto-char-point-max)
-  (if (cond
-       ((not (string-equal footnote-section-tag ""))
-	(re-search-backward (concat "^" footnote-section-tag-regexp) nil t))
-       (footnote-text-marker-alist
-	(goto-char (cdar footnote-text-marker-alist))))
-      (save-restriction
-	(when footnote-narrow-to-footnotes-when-editing
-	  (footnote--narrow-to-footnotes))
-	(footnote-goto-footnote (1- arg)) ; evil, FIXME (less evil now)
-	;; (message "Inserting footnote %d" arg)
-	(unless
-	    (or (eq arg 1)
-		(when (re-search-forward
-		       (if footnote-spaced-footnotes
-			   "\n\n"
-			 (concat "\n"
-				 (regexp-quote footnote-start-tag)
-				 (footnote--current-regexp)
-				 (regexp-quote footnote-end-tag)))
-		       nil t)
-		  (unless (beginning-of-line) t))
-		(footnote--goto-char-point-max)
-		(cond
-		 ((not (string-equal footnote-section-tag ""))
-		  (re-search-backward
-		   (concat "^" footnote-section-tag-regexp) nil t))
-		 (footnote-text-marker-alist
-		  (goto-char (cdar footnote-text-marker-alist)))))))
-    (unless (looking-at "^$")
-      (insert "\n"))
-    (when (eobp)
-      (insert "\n"))
-    (unless (string-equal footnote-section-tag "")
-      (insert footnote-section-tag "\n")))
-  (let ((old-point (point)))
-    (footnote--insert-numbered-footnote arg nil)
-    (footnote--insert-text-marker arg old-point)))
+  (let ((ptr (footnote--insert-numbered-footnote arg t)))
+    (footnote--goto-char-point-max)
+    (if (footnote--goto-first)
+        (save-restriction
+	  (when footnote-narrow-to-footnotes-when-editing
+	    (footnote--narrow-to-footnotes))
+	  (footnote-goto-footnote (1- arg)) ; evil, FIXME (less evil now)
+	  ;; (message "Inserting footnote %d" arg)
+	  (or (eq arg 1)
+	      (when (re-search-forward
+		     (if footnote-spaced-footnotes
+			 "\n\n"
+		       (concat "\n" (footnote--current-regexp)))
+		     nil t)
+		(beginning-of-line)
+                t)
+	      (footnote--goto-char-point-max)
+	      (footnote--goto-first)))
+      (unless (looking-at "^$")
+        (insert "\n"))
+      (when (eobp)
+        (insert "\n"))
+      (unless (string-equal footnote-section-tag "")
+        (insert footnote-section-tag "\n")))
+    (let ((text (footnote--insert-numbered-footnote arg nil)))
+      (footnote--insert-markers arg text ptr))))
 
 (defun footnote--sort (list)
-  (sort list (lambda (e1 e2)
-	       (< (car e1) (car e2)))))
+  (sort list #'car-less-than-car))
 
 (defun footnote--text-under-cursor ()
   "Return the number of the current footnote if in footnote text.
 Return nil if the cursor is not positioned over the text of
 a footnote."
-  (when (and footnote-text-marker-alist
-             (<= (footnote--get-area-point-min)
-                 (point)
-                 (footnote--get-area-point-max)))
-    (let ((i 1) alist-txt result)
-      (while (and (setq alist-txt (nth i footnote-text-marker-alist))
-                  (null result))
-        (when (< (point) (cdr alist-txt))
-          (setq result (car (nth (1- i) footnote-text-marker-alist))))
-        (setq i (1+ i)))
-      (when (and (null result) (null alist-txt))
-        (setq result (car (nth (1- i) footnote-text-marker-alist))))
+  (when (<= (point) (footnote--get-area-point-max))
+    (let ((result nil))
+      (pcase-dolist (`(,fn ,text . ,_) footnote--markers-alist)
+        (if (<= text (point))
+            (setq result fn)))
       result)))
 
 (defun footnote--under-cursor ()
@@ -710,7 +629,7 @@ Return nil if the cursor is not over a footnote."
      (string-width
       (concat footnote-start-tag  footnote-end-tag
               (footnote--index-to-string
-               (caar (last footnote-text-marker-alist)))))))
+               (caar (last footnote--markers-alist)))))))
 
 (defun footnote--fill-prefix-string ()
   "Return the fill prefix to be used by footnote mode."
@@ -730,15 +649,14 @@ With optional arg BEFORE-TAG, return position of the `footnote-section-tag'
 instead, if applicable."
   (cond
    ;; FIXME: Shouldn't we use `footnote--get-area-point-max' instead?
-   ((not footnote-text-marker-alist) (point-max))
-   ((not before-tag) (cdr (car footnote-text-marker-alist)))
-   ((string-equal footnote-section-tag "")
-    (cdr (car footnote-text-marker-alist)))
+   ((not footnote--markers-alist) (point-max))
+   ((not before-tag) (cadr (car footnote--markers-alist)))
+   ((string-equal footnote-section-tag "") (cadr (car footnote--markers-alist)))
    (t
     (save-excursion
-      (goto-char (cdr (car footnote-text-marker-alist)))
+      (goto-char (cadr (car footnote--markers-alist)))
       (if (re-search-backward (concat "^" footnote-section-tag-regexp) nil t)
-          (match-beginning 0)
+          (point)
         (message "Footnote section tag not found!")
         ;; This `else' should never happen, and indicates an error,
         ;; ie. footnotes already exist and a footnote-section-tag is defined,
@@ -756,7 +674,7 @@ instead, if applicable."
         ;; function, and repeat.
         ;;
         ;; TODO: integrate sanity checks at reasonable operational points.
-        (cdr (car footnote-text-marker-alist)))))))
+        (point))))))
 
 (defun footnote--get-area-point-max ()
   "Return the end of footnote area.
@@ -780,27 +698,23 @@ footnote area, returns `point-max'."
 ;;; User functions
 
 (defun footnote--make-hole ()
+  "Make room in the alist for a new footnote at point.
+Return the footnote number to use."
   (save-excursion
-    (let ((i 0)
-	  (notes (length footnote-pointer-marker-alist))
-	  alist-ptr alist-txt rc)
-      (while (< i notes)
-	(setq alist-ptr (nth i footnote-pointer-marker-alist))
-	(setq alist-txt (nth i footnote-text-marker-alist))
-	(when (< (point) (- (cadr alist-ptr) 3))
+    (let (rc)
+      (dolist (alist-elem footnote--markers-alist)
+	(when (<= (point) (cl-caddr alist-elem))
 	  (unless rc
-	    (setq rc (car alist-ptr)))
+	    (setq rc (car alist-elem)))
 	  (save-excursion
 	    (message "Renumbering from %s to %s"
-		     (footnote--index-to-string (car alist-ptr))
+		     (footnote--index-to-string (car alist-elem))
 		     (footnote--index-to-string
-		      (1+ (car alist-ptr))))
-	    (footnote--renumber (car alist-ptr)
-			       (1+ (car alist-ptr))
-			       alist-ptr
-			       alist-txt)))
-	(setq i (1+ i)))
-      rc)))
+		      (1+ (car alist-elem))))
+	    (footnote--renumber (1+ (car alist-elem))
+			        alist-elem))))
+      (or rc
+          (1+ (or (caar (last footnote--markers-alist)) 0))))))
 
 (defun footnote-add-footnote ()
   "Add a numbered footnote.
@@ -810,26 +724,17 @@ If the variable `footnote-narrow-to-footnotes-when-editing' is set,
 the buffer is narrowed to the footnote body.  The restriction is removed
 by using `footnote-back-to-message'."
   (interactive "*")
-  (let ((num
-         (if footnote-text-marker-alist
-             (if (< (point) (cl-cadar (last footnote-pointer-marker-alist)))
-                 (footnote--make-hole)
-               (1+ (caar (last footnote-text-marker-alist))))
-           1)))
+  (let ((num (footnote--make-hole)))
     (message "Adding footnote %d" num)
     (footnote--insert-footnote num)
-    (insert-before-markers (make-string footnote-body-tag-spacing ? ))
-    (let ((opoint (point)))
-      (save-excursion
-	(insert-before-markers
-	 (if footnote-spaced-footnotes
-	     "\n\n"
-	   "\n"))
-	(when footnote-narrow-to-footnotes-when-editing
-	  (footnote--narrow-to-footnotes)))
-      ;; Emacs/XEmacs bug?  save-excursion doesn't restore point when using
-      ;; insert-before-markers.
-      (goto-char opoint))))
+    (insert (make-string footnote-body-tag-spacing ? ))
+    (save-excursion
+      (insert
+       (if footnote-spaced-footnotes
+	   "\n\n"
+	 "\n"))
+      (when footnote-narrow-to-footnotes-when-editing
+	(footnote--narrow-to-footnotes)))))
 
 (defun footnote-delete-footnote (&optional arg)
   "Delete a numbered footnote.
@@ -841,23 +746,16 @@ delete the footnote with that number."
   (when (and arg
 	     (or (not footnote-prompt-before-deletion)
 		 (y-or-n-p (format "Really delete footnote %d?" arg))))
-    (let (alist-ptr alist-txt locn)
-      (setq alist-ptr (assq arg footnote-pointer-marker-alist))
-      (setq alist-txt (assq arg footnote-text-marker-alist))
-      (unless (and alist-ptr alist-txt)
-	(error "Can't delete footnote %d" arg))
-      (setq locn (cdr alist-ptr))
-      (while (car locn)
+    (let ((alist-elem (or (assq arg footnote--markers-alist)
+                          (error "Can't delete footnote %d" arg)))
+          (fn-regexp (footnote--current-regexp)))
+      (dolist (locn (cddr alist-elem))
 	(save-excursion
-	  (goto-char (car locn))
-	  (when (looking-back (concat (regexp-quote footnote-start-tag)
-				      (footnote--current-regexp)
-				      (regexp-quote footnote-end-tag))
-			      (line-beginning-position))
-	    (delete-region (match-beginning 0) (match-end 0))))
-	(setq locn (cdr locn)))
+	  (goto-char locn)
+	  (when (looking-at fn-regexp)
+	    (delete-region (match-beginning 0) (match-end 0)))))
       (save-excursion
-	(goto-char (cdr alist-txt))
+	(goto-char (cadr alist-elem))
 	(delete-region
 	 (point)
 	 (if footnote-spaced-footnotes
@@ -866,13 +764,10 @@ delete the footnote with that number."
 	     (end-of-line)
 	     (next-single-char-property-change
 	      (point) 'footnote-number nil (footnote--goto-char-point-max))))))
-      (setq footnote-pointer-marker-alist
-	    (delq alist-ptr footnote-pointer-marker-alist))
-      (setq footnote-text-marker-alist
-	    (delq alist-txt footnote-text-marker-alist))
-      (footnote-renumber-footnotes)
-      (when (and (null footnote-text-marker-alist)
-		 (null footnote-pointer-marker-alist))
+      (setq footnote--markers-alist
+	    (delq alist-elem footnote--markers-alist))
+      (if footnote--markers-alist
+          (footnote-renumber-footnotes)
 	(save-excursion
 	  (if (not (string-equal footnote-section-tag ""))
 	      (let* ((end (footnote--goto-char-point-max))
@@ -893,14 +788,9 @@ delete the footnote with that number."
   "Renumber footnotes, starting from 1."
   (interactive "*")
   (save-excursion
-    (let ((i 0)
-	  (notes (length footnote-pointer-marker-alist))
-	  alist-ptr alist-txt)
-      (while (< i notes)
-	(setq alist-ptr (nth i footnote-pointer-marker-alist))
-	(setq alist-txt (nth i footnote-text-marker-alist))
-	(unless (= (1+ i) (car alist-ptr))
-	  (footnote--renumber (car alist-ptr) (1+ i) alist-ptr alist-txt))
+    (let ((i 1))
+      (dolist (alist-elem footnote--markers-alist)
+	(footnote--renumber i alist-elem)
 	(setq i (1+ i))))))
 
 (defun footnote-goto-footnote (&optional arg)
@@ -910,18 +800,18 @@ specified, jump to the text of that footnote."
   (interactive "P")
   (unless arg
     (setq arg (footnote--under-cursor)))
-  (let ((footnote (assq arg footnote-text-marker-alist)))
+  (let ((footnote (assq arg footnote--markers-alist)))
     (cond
      (footnote
-      (goto-char (cdr footnote)))
+      (goto-char (cadr footnote)))
      ((eq arg 0)
       (goto-char (point-max))
       (cond
        ((not (string-equal footnote-section-tag ""))
 	(re-search-backward (concat "^" footnote-section-tag-regexp))
 	(forward-line 1))
-       (footnote-text-marker-alist
-	(goto-char (cdar footnote-text-marker-alist)))))
+       (footnote--markers-alist
+	(goto-char (cadr (car footnote--markers-alist))))))
      (t
       (error "I don't see a footnote here")))))
 
@@ -935,17 +825,19 @@ being set it is automatically widened."
     (when note
       (when footnote-narrow-to-footnotes-when-editing
 	(widen))
-      (goto-char (cadr (assq note footnote-pointer-marker-alist))))))
+      (goto-char (cl-caddr (assq note footnote--markers-alist)))
+      (when (looking-at (footnote--current-regexp))
+        (goto-char (match-end 0))))))
 
 (defvar footnote-mode-map
   (let ((map (make-sparse-keymap)))
-    (define-key map "a" 'footnote-add-footnote)
-    (define-key map "b" 'footnote-back-to-message)
-    (define-key map "c" 'footnote-cycle-style)
-    (define-key map "d" 'footnote-delete-footnote)
-    (define-key map "g" 'footnote-goto-footnote)
-    (define-key map "r" 'footnote-renumber-footnotes)
-    (define-key map "s" 'footnote-set-style)
+    (define-key map "a" #'footnote-add-footnote)
+    (define-key map "b" #'footnote-back-to-message)
+    (define-key map "c" #'footnote-cycle-style)
+    (define-key map "d" #'footnote-delete-footnote)
+    (define-key map "g" #'footnote-goto-footnote)
+    (define-key map "r" #'footnote-renumber-footnotes)
+    (define-key map "s" #'footnote-set-style)
     map))
 
 (defvar footnote-minor-mode-map
@@ -984,8 +876,7 @@ play around with the following keys:
     (add-function :around (local 'adaptive-fill-function)
                   #'footnote--adaptive-fill-function)
 
-    ;; filladapt is an XEmacs package which AFAIK has never been ported
-    ;; to Emacs.
+    ;; Filladapt was an XEmacs package which is now in GNU ELPA.
     (when (boundp 'filladapt-token-table)
       ;; add tokens to filladapt to match footnotes
       ;; 1] xxxxxxxxxxx x x x or [1] x x x x x x x
diff --git a/lisp/mail/mail-extr.el b/lisp/mail/mail-extr.el
index a0b9688650..c1e90c3dcb 100644
--- a/lisp/mail/mail-extr.el
+++ b/lisp/mail/mail-extr.el
@@ -383,7 +383,7 @@ by translating things like \"foo!bar!baz@host\" into \"baz@bar.UUCP\"."
 ;; Matches telephone extensions.
 (defconst mail-extr-telephone-extension-pattern
   (purecopy
-   "\\(\\([Ee]xt\\|[Tt]ph\\|[Tt]el\\|[Xx]\\).?\\)? *\\+?[0-9][- 0-9]+"))
+   "\\(\\([Ee]xt\\|[Tt]ph\\|[Tt]el\\|[Xx]\\)\\.?\\)? *\\+?[0-9][- 0-9]+"))
 
 ;; Matches ham radio call signs.
 ;; Help from: Mat Maessen N2NJZ <maessm@rpi.edu>, Mark Feit
diff --git a/lisp/mail/mspools.el b/lisp/mail/mspools.el
index 9c8e72e7f4..b1cbd9e549 100644
--- a/lisp/mail/mspools.el
+++ b/lisp/mail/mspools.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1997, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Stephen Eglen <stephen@gnu.org>
-;; Maintainer: Stephen Eglen <stephen@gnu.org>
 ;; Created: 22 Jan 1997
 ;; Keywords: mail
 ;; location: http://www.anc.ed.ac.uk/~stephen/emacs/
diff --git a/lisp/mail/sendmail.el b/lisp/mail/sendmail.el
index 93b6c90521..208ebb6801 100644
--- a/lisp/mail/sendmail.el
+++ b/lisp/mail/sendmail.el
@@ -370,6 +370,7 @@ By default, this is the file specified by `mail-personal-alias-file'." t)
 ;;;###autoload
 (defcustom mail-signature t
   "Text inserted at end of mail buffer when a message is initialized.
+If nil, no signature is inserted.
 If t, it means to insert the contents of the file `mail-signature-file'.
 If a string, that string is inserted.
  (To make a proper signature, the string should begin with \\n\\n-- \\n,
diff --git a/lisp/mail/smtpmail.el b/lisp/mail/smtpmail.el
index f31e0b45d2..c5af3eac94 100644
--- a/lisp/mail/smtpmail.el
+++ b/lisp/mail/smtpmail.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1995-1996, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Tomoji Kagatani <kagatani@rbc.ncl.omron.co.jp>
-;; Maintainer: Simon Josefsson <simon@josefsson.org>
 ;; w32 Maintainer: Brian D. Carlstrom <bdc@ai.mit.edu>
 ;; ESMTP support: Simon Leinen <simon@switch.ch>
 ;; Hacked by Mike Taylor, 11th October 1999 to add support for
@@ -101,9 +100,9 @@ don't define this value."
 
 (defcustom smtpmail-stream-type nil
   "Type of SMTP connections to use.
-This may be either nil (possibly upgraded to STARTTLS if possible),
-or `starttls' (refuse to send if STARTTLS isn't available), or `plain'
-\(never use STARTTLS), or `ssl' (to use TLS/SSL)."
+This may be either nil (upgrade with STARTTLS if possible),
+`starttls' (refuse to send if STARTTLS isn't available),
+`plain' (never use STARTTLS), or `ssl' (to use TLS/SSL)."
   :version "24.1"
   :group 'smtpmail
   :type '(choice (const :tag "Possibly upgrade to STARTTLS" nil)
diff --git a/lisp/makesum.el b/lisp/makesum.el
index 10ad78ea17..50f5d63871 100644
--- a/lisp/makesum.el
+++ b/lisp/makesum.el
@@ -1,4 +1,4 @@
-;;; makesum.el --- generate key binding summary for Emacs
+;;; makesum.el --- generate key binding summary for Emacs  -*- lexical-binding:t -*-
 
 ;; Copyright (C) 1985, 2001-2019 Free Software Foundation, Inc.
 
@@ -59,15 +59,14 @@ Previous contents of that buffer are killed first."
        (while (search-forward "C-i" nil t)
 	 (replace-match "TAB"))
        (goto-char (point-min))
-       (if (re-search-forward "^Local Bindings:" nil t)
-	   (progn
-	    (forward-char -1)
-	    (insert " for " (format-mode-line cur-mode) " Mode")
-	    (while (search-forward "??\n" nil t)
-	      (delete-region (point)
-			     (progn
-			      (forward-line -1)
-			      (point))))))
+       (when (re-search-forward "^Local Bindings:" nil t)
+         (forward-char -1)
+         (insert " for " (format-mode-line cur-mode) " Mode")
+         (while (search-forward "??\n" nil t)
+           (delete-region (point)
+                          (progn
+                            (forward-line -1)
+                            (point)))))
        (goto-char (point-min))
        (insert "Emacs command summary, " (substring (current-time-string) 0 10)
 	       ".\n")
@@ -84,28 +83,25 @@ Previous contents of that buffer are killed first."
   (message "Making command summary...done"))
 
 (defun double-column (start end)
+  "Reformat buffer contents from START to END into two columns."
   (interactive "r")
-  (let (half line lines nlines
+  (let (half lines
+        (nlines (count-lines start end))
 	(from-end (- (point-max) end)))
-    (setq nlines (count-lines start end))
-    (if (<= nlines 1)
-	nil
+    (when (> nlines 1)
       (setq half (/ (1+ nlines) 2))
       (goto-char start)
       (save-excursion
        (forward-line half)
-       (while (< half nlines)
-	 (setq half (1+ half))
-	 (setq line (buffer-substring (point) (line-end-position)))
-	 (setq lines (cons line lines))
+       (dotimes (_ (- nlines half))
+         (push (buffer-substring (point) (line-end-position))
+               lines)
 	 (delete-region (point) (progn (forward-line 1) (point)))))
-      (setq lines (nreverse lines))
-      (while lines
-	(end-of-line)
+      (dolist (line (nreverse lines))
+        (end-of-line)
 	(indent-to 41)
-	(insert (car lines))
-	(forward-line 1)
-	(setq lines (cdr lines))))
+        (insert line)
+        (forward-line 1)))
     (goto-char (- (point-max) from-end))))
 
 (provide 'makesum)
diff --git a/lisp/man.el b/lisp/man.el
index b1d0fd3d17..d52ca2156d 100644
--- a/lisp/man.el
+++ b/lisp/man.el
@@ -1206,10 +1206,7 @@ Same for the ANSI bold and normal escape sequences."
   (interactive)
   (goto-char (point-min))
   ;; Fontify ANSI escapes.
-  (let ((ansi-color-apply-face-function
-	 (lambda (beg end face)
-	   (when face
-	     (put-text-property beg end 'face face))))
+  (let ((ansi-color-apply-face-function #'ansi-color-apply-text-property-face)
 	(ansi-color-map Man-ansi-color-map))
     (ansi-color-apply-on-region (point-min) (point-max)))
   ;; Other highlighting.
@@ -1220,31 +1217,33 @@ Same for the ANSI bold and normal escape sequences."
 	  (goto-char (point-min))
 	  (while (and (search-forward "__\b\b" nil t) (not (eobp)))
 	    (backward-delete-char 4)
-	    (put-text-property (point) (1+ (point)) 'face 'Man-underline))
+            (put-text-property (point) (1+ (point))
+                               'font-lock-face 'Man-underline))
 	  (goto-char (point-min))
 	  (while (search-forward "\b\b__" nil t)
 	    (backward-delete-char 4)
-	    (put-text-property (1- (point)) (point) 'face 'Man-underline))))
+            (put-text-property (1- (point)) (point)
+                               'font-lock-face 'Man-underline))))
     (goto-char (point-min))
     (while (and (search-forward "_\b" nil t) (not (eobp)))
       (backward-delete-char 2)
-      (put-text-property (point) (1+ (point)) 'face 'Man-underline))
+      (put-text-property (point) (1+ (point)) 'font-lock-face 'Man-underline))
     (goto-char (point-min))
     (while (search-forward "\b_" nil t)
       (backward-delete-char 2)
-      (put-text-property (1- (point)) (point) 'face 'Man-underline))
+      (put-text-property (1- (point)) (point) 'font-lock-face 'Man-underline))
     (goto-char (point-min))
     (while (re-search-forward "\\(.\\)\\(\b+\\1\\)+" nil t)
       (replace-match "\\1")
-      (put-text-property (1- (point)) (point) 'face 'Man-overstrike))
+      (put-text-property (1- (point)) (point) 'font-lock-face 'Man-overstrike))
     (goto-char (point-min))
     (while (re-search-forward "o\b\\+\\|\\+\bo" nil t)
       (replace-match "o")
-      (put-text-property (1- (point)) (point) 'face 'bold))
+      (put-text-property (1- (point)) (point) 'font-lock-face 'bold))
     (goto-char (point-min))
     (while (re-search-forward "[-|]\\(\b[-|]\\)+" nil t)
       (replace-match "+")
-      (put-text-property (1- (point)) (point) 'face 'bold))
+      (put-text-property (1- (point)) (point) 'font-lock-face 'bold))
     ;; When the header is longer than the manpage name, groff tries to
     ;; condense it to a shorter line interspersed with ^H.  Remove ^H with
     ;; their preceding chars (but don't put Man-overstrike).  (Bug#5566)
@@ -1258,7 +1257,7 @@ Same for the ANSI bold and normal escape sequences."
     (while (re-search-forward Man-heading-regexp nil t)
       (put-text-property (match-beginning 0)
 			 (match-end 0)
-			 'face 'Man-overstrike))))
+			 'font-lock-face 'Man-overstrike))))
 
 (defun Man-highlight-references (&optional xref-man-type)
   "Highlight the references on mouse-over.
diff --git a/lisp/master.el b/lisp/master.el
index a054d7f597..36384a8df0 100644
--- a/lisp/master.el
+++ b/lisp/master.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Alex Schroeder <alex@gnu.org>
-;; Maintainer: Alex Schroeder <alex@gnu.org>
 ;; Version: 1.0.2
 ;; Keywords: comm
 
diff --git a/lisp/mh-e/mh-buffers.el b/lisp/mh-e/mh-buffers.el
index 3c0c481495..13a1901b69 100644
--- a/lisp/mh-e/mh-buffers.el
+++ b/lisp/mh-e/mh-buffers.el
@@ -4,7 +4,6 @@
 ;; Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-comp.el b/lisp/mh-e/mh-comp.el
index b96ef74538..a5614f5255 100644
--- a/lisp/mh-e/mh-comp.el
+++ b/lisp/mh-e/mh-comp.el
@@ -4,7 +4,6 @@
 ;; Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-compat.el b/lisp/mh-e/mh-compat.el
index eb173df47c..a459d27ee2 100644
--- a/lisp/mh-e/mh-compat.el
+++ b/lisp/mh-e/mh-compat.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2006-2019 Free Software Foundation, Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-e.el b/lisp/mh-e/mh-e.el
index bc09764656..c70e11e773 100644
--- a/lisp/mh-e/mh-e.el
+++ b/lisp/mh-e/mh-e.el
@@ -4,7 +4,6 @@
 ;; Software Foundation, Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Version: 8.6+git
 ;; Keywords: mail
 
diff --git a/lisp/mh-e/mh-folder.el b/lisp/mh-e/mh-folder.el
index caf4071583..5b4c34fb6a 100644
--- a/lisp/mh-e/mh-folder.el
+++ b/lisp/mh-e/mh-folder.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2002-2003, 2005-2019 Free Software Foundation, Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-funcs.el b/lisp/mh-e/mh-funcs.el
index da7c87ea81..9f603c0c71 100644
--- a/lisp/mh-e/mh-funcs.el
+++ b/lisp/mh-e/mh-funcs.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1993, 1995, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-letter.el b/lisp/mh-e/mh-letter.el
index 4fc31ed121..46762f12fd 100644
--- a/lisp/mh-e/mh-letter.el
+++ b/lisp/mh-e/mh-letter.el
@@ -4,7 +4,6 @@
 ;; Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-limit.el b/lisp/mh-e/mh-limit.el
index 27dda79484..ee6fa83abb 100644
--- a/lisp/mh-e/mh-limit.el
+++ b/lisp/mh-e/mh-limit.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2001-2003, 2006-2019 Free Software Foundation, Inc.
 
 ;; Author: Peter S. Galbraith <psg@debian.org>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-mime.el b/lisp/mh-e/mh-mime.el
index 9901548b90..6f126967fe 100644
--- a/lisp/mh-e/mh-mime.el
+++ b/lisp/mh-e/mh-mime.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1993, 1995, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-scan.el b/lisp/mh-e/mh-scan.el
index cd689d6250..8c1a07dadc 100644
--- a/lisp/mh-e/mh-scan.el
+++ b/lisp/mh-e/mh-scan.el
@@ -4,7 +4,6 @@
 ;; Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-seq.el b/lisp/mh-e/mh-seq.el
index f7d7c62795..9989dc9f1c 100644
--- a/lisp/mh-e/mh-seq.el
+++ b/lisp/mh-e/mh-seq.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1993, 1995, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-show.el b/lisp/mh-e/mh-show.el
index 7dad81dbce..4f7068156e 100644
--- a/lisp/mh-e/mh-show.el
+++ b/lisp/mh-e/mh-show.el
@@ -4,7 +4,6 @@
 ;; Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-utils.el b/lisp/mh-e/mh-utils.el
index cad6278719..0938729e78 100644
--- a/lisp/mh-e/mh-utils.el
+++ b/lisp/mh-e/mh-utils.el
@@ -4,7 +4,6 @@
 ;; Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/mh-e/mh-xface.el b/lisp/mh-e/mh-xface.el
index ddb001ac8f..4ff84a66f7 100644
--- a/lisp/mh-e/mh-xface.el
+++ b/lisp/mh-e/mh-xface.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2002-2003, 2005-2019 Free Software Foundation, Inc.
 
 ;; Author: Bill Wohler <wohler@newt.com>
-;; Maintainer: Bill Wohler <wohler@newt.com>
 ;; Keywords: mail
 ;; See: mh-e.el
 
diff --git a/lisp/midnight.el b/lisp/midnight.el
index 86c1e219f0..fa41d80a69 100644
--- a/lisp/midnight.el
+++ b/lisp/midnight.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1998, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Sam Steingold <sds@gnu.org>
-;; Maintainer: Sam Steingold <sds@gnu.org>
 ;; Created: 1998-05-18
 ;; Keywords: utilities
 
diff --git a/lisp/minibuffer.el b/lisp/minibuffer.el
index dbd24dfa0a..ed610c16ee 100644
--- a/lisp/minibuffer.el
+++ b/lisp/minibuffer.el
@@ -846,6 +846,8 @@ styles for specific categories, such as files, buffers, etc."
 (defvar completion-category-defaults
   '((buffer (styles . (basic substring)))
     (unicode-name (styles . (basic substring)))
+    ;; A new style that combines substring and pcm might be better,
+    ;; e.g. one that does not anchor to bos.
     (project-file (styles . (substring)))
     (info-menu (styles . (basic substring))))
   "Default settings for specific completion categories.
@@ -2969,28 +2971,6 @@ or a symbol, see `completion-pcm--merge-completions'."
       ;; It should be avoided properly, but it's so easy to remove it here.
       (delete "" (nreverse pattern)))))
 
-(defun completion-pcm--optimize-pattern (p)
-  ;; Remove empty strings in a separate phase since otherwise a ""
-  ;; might prevent some other optimization, as in '(any "" any).
-  (setq p (delete "" p))
-  (let ((n '()))
-    (while p
-      (pcase p
-        (`(,(and s1 (pred stringp)) ,(and s2 (pred stringp)) . ,rest)
-         (setq p (cons (concat s1 s2) rest)))
-        (`(,(and p1 (pred symbolp)) ,(and p2 (guard (eq p1 p2))) . ,_)
-         ;; Unused lexical variable warning due to body not using p1, p2.
-         ;; https://debbugs.gnu.org/16771
-         (setq p (cdr p)))
-        (`(star ,(pred symbolp) . ,rest) (setq p `(star . ,rest)))
-        (`(,(pred symbolp) star . ,rest) (setq p `(star . ,rest)))
-        (`(point ,(or 'any 'any-delim) . ,rest) (setq p `(point . ,rest)))
-        (`(,(or 'any 'any-delim) point . ,rest) (setq p `(point . ,rest)))
-        (`(any ,(or 'any 'any-delim) . ,rest) (setq p `(any . ,rest)))
-        (`(,(pred symbolp)) (setq p nil)) ;Implicit terminating `any'.
-        (_ (push (pop p) n))))
-    (nreverse n)))
-
 (defun completion-pcm--pattern->regex (pattern &optional group)
   (let ((re
          (concat "\\`"
diff --git a/lisp/mouse.el b/lisp/mouse.el
index 835eaa32c6..8428c1e013 100644
--- a/lisp/mouse.el
+++ b/lisp/mouse.el
@@ -2402,6 +2402,10 @@ highlight the original region when
 `mouse-drag-and-drop-region-show-cursor' is non-nil."
   :version "26.1")
 
+(declare-function rectangle-dimensions "rect" (start end))
+(declare-function rectangle-position-as-coordinates "rect" (position))
+(declare-function rectangle-intersect-p "rect" (pos1 size1 pos2 size2))
+
 (defun mouse-drag-and-drop-region (event)
   "Move text in the region to point where mouse is dragged to.
 The transportation of text is also referred as `drag and drop'.
diff --git a/lisp/msb.el b/lisp/msb.el
index 7a1a338fcc..1d43dc0dfa 100644
--- a/lisp/msb.el
+++ b/lisp/msb.el
@@ -64,7 +64,7 @@
 ;;  Larry Rosenberg <ljr@ictv.com>
 ;;  Will Henney <will@astroscu.unam.mx>
 ;;  Jari Aalto <jaalto@tre.tele.nokia.fi>
-;;  Michael Kifer <kifer@sbkifer.cs.sunysb.edu>
+;;  Michael Kifer <kifer@cs.stonybrook.edu>
 ;;  Gael Marziou <gael@gnlab030.grenoble.hp.com>
 ;;  Dave Gillespie <daveg@thymus.synaptics.com>
 ;;  Alon Albert <alon@milcse.rtsg.mot.com>
diff --git a/lisp/mwheel.el b/lisp/mwheel.el
index 23f491db0f..eb665632ff 100644
--- a/lisp/mwheel.el
+++ b/lisp/mwheel.el
@@ -1,7 +1,6 @@
 ;;; mwheel.el --- Wheel mouse support
 
 ;; Copyright (C) 1998, 2000-2019 Free Software Foundation, Inc.
-;; Maintainer: William M. Perry <wmperry@gnu.org>
 ;; Keywords: mouse
 ;; Package: emacs
 
diff --git a/lisp/net/ange-ftp.el b/lisp/net/ange-ftp.el
index 5af9ea75ed..b0a1e1799f 100644
--- a/lisp/net/ange-ftp.el
+++ b/lisp/net/ange-ftp.el
@@ -1989,7 +1989,7 @@ on the gateway machine to do the FTP instead."
   (make-local-variable 'comint-password-prompt-regexp)
   ;; This is a regexp that can't match anything.
   ;; ange-ftp has its own ways of handling passwords.
-  (setq comint-password-prompt-regexp "\\`a\\`")
+  (setq comint-password-prompt-regexp regexp-unmatchable)
   (make-local-variable 'paragraph-start)
   (setq paragraph-start comint-prompt-regexp))
 
diff --git a/lisp/net/eww.el b/lisp/net/eww.el
index 3e9334532c..206f9cfdf3 100644
--- a/lisp/net/eww.el
+++ b/lisp/net/eww.el
@@ -29,7 +29,7 @@
 (require 'shr)
 (require 'url)
 (require 'url-queue)
-(require 'url-util)			; for url-get-url-at-point
+(require 'thingatpt)
 (require 'mm-url)
 (require 'puny)
 (eval-when-compile (require 'subr-x)) ;; for string-trim
@@ -64,17 +64,17 @@
 ;;;###autoload
 (defcustom eww-suggest-uris
   '(eww-links-at-point
-    url-get-url-at-point
+    thing-at-point-url-at-point
     eww-current-url)
   "List of functions called to form the list of default URIs for `eww'.
 Each of the elements is a function returning either a string or a list
 of strings.  The results will be joined into a single list with
 duplicate entries (if any) removed."
-  :version "25.1"
+  :version "27.1"
   :group 'eww
   :type 'hook
   :options '(eww-links-at-point
-             url-get-url-at-point
+             thing-at-point-url-at-point
              eww-current-url))
 
 (defcustom eww-bookmarks-directory user-emacs-directory
@@ -223,6 +223,10 @@ See also `eww-form-checkbox-selected-symbol'."
 (defvar eww-local-regex "localhost"
   "When this regex is found in the URL, it's not a keyword but an address.")
 
+(defvar eww-accept-content-types
+  "text/html, text/plain, text/sgml, text/css, application/xhtml+xml, */*;q=0.01"
+  "Value used for the HTTP 'Accept' header.")
+
 (defvar eww-link-keymap
   (let ((map (copy-keymap shr-map)))
     (define-key map "\r" 'eww-follow-link)
@@ -290,8 +294,9 @@ the default EWW buffer."
   (let ((inhibit-read-only t))
     (insert (format "Loading %s..." url))
     (goto-char (point-min)))
-  (url-retrieve url 'eww-render
-                (list url nil (current-buffer))))
+  (let ((url-mime-accept-string eww-accept-content-types))
+    (url-retrieve url 'eww-render
+                  (list url nil (current-buffer)))))
 
 (defun eww--dwim-expand-url (url)
   (setq url (string-trim url))
@@ -952,8 +957,9 @@ just re-display the HTML already fetched."
 	    (error "No current HTML data")
 	  (eww-display-html 'utf-8 url (plist-get eww-data :dom)
 			    (point) (current-buffer)))
-      (url-retrieve url 'eww-render
-		    (list url (point) (current-buffer) encode)))))
+      (let ((url-mime-accept-string eww-accept-content-types))
+        (url-retrieve url 'eww-render
+		      (list url (point) (current-buffer) encode))))))
 
 ;; Form support.
 
@@ -1519,6 +1525,7 @@ If EXTERNAL is double prefix, browse in new buffer."
 	   (eww-same-page-p url (plist-get eww-data :url)))
       (let ((dom (plist-get eww-data :dom)))
 	(eww-save-history)
+	(plist-put eww-data :url url)
 	(eww-display-html 'utf-8 url dom nil (current-buffer))))
      (t
       (eww-browse-url url external)))))
diff --git a/lisp/net/mairix.el b/lisp/net/mairix.el
index 07415667e1..0c699c976c 100644
--- a/lisp/net/mairix.el
+++ b/lisp/net/mairix.el
@@ -266,9 +266,7 @@ Currently there are `threads' and `flags'.")
 
 ;;; Gnus
 
-;; For gnus-buffer-exists-p, although it seems that could be replaced by:
-;; (and buffer (get-buffer buffer))
-(eval-when-compile (require 'gnus-util))
+(eval-when-compile (require 'gnus-util)) ; For `gnus-buffer-live-p'.
 (defvar gnus-article-buffer)
 (declare-function gnus-group-read-ephemeral-group "gnus-group"
 		  (group method &optional activate quit-config
@@ -296,7 +294,7 @@ Currently there are `threads' and `flags'.")
   (unless (and (fboundp 'gnus-alive-p)
 	       (gnus-alive-p))
     (error "Gnus is not running"))
-  (unless (gnus-buffer-exists-p gnus-article-buffer)
+  (unless (gnus-buffer-live-p gnus-article-buffer)
     (error "No article buffer available"))
   (with-current-buffer gnus-article-buffer
     ;; gnus-art requires gnus-sum and message.
diff --git a/lisp/net/net-utils.el b/lisp/net/net-utils.el
index e61d889765..dcc7e01b6b 100644
--- a/lisp/net/net-utils.el
+++ b/lisp/net/net-utils.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1998-2019 Free Software Foundation, Inc.
 
-;; Author:  Peter Breton <pbreton@cs.umb.edu>
+;; Author: Peter Breton <pbreton@cs.umb.edu>
 ;; Created: Sun Mar 16 1997
 ;; Keywords: network comm
 
diff --git a/lisp/net/quickurl.el b/lisp/net/quickurl.el
index 3f7e9d192d..91e980e4f1 100644
--- a/lisp/net/quickurl.el
+++ b/lisp/net/quickurl.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Dave Pearson <davep@davep.org>
-;; Maintainer: Dave Pearson <davep@davep.org>
 ;; Created: 1999-05-28
 ;; Keywords: hypermedia
 
diff --git a/lisp/net/rcirc.el b/lisp/net/rcirc.el
index b1a6c1ce8d..9c3828caf5 100644
--- a/lisp/net/rcirc.el
+++ b/lisp/net/rcirc.el
@@ -39,14 +39,14 @@
 ;; Open a new irc connection with:
 ;; M-x irc RET
 
-;;; Todo:
-
 ;;; Code:
 
 (require 'cl-lib)
 (require 'ring)
 (require 'time-date)
 
+(defconst rcirc-id-string (concat "rcirc on GNU Emacs " emacs-version))
+
 (defgroup rcirc nil
   "Simple IRC client."
   :version "22.1"
@@ -119,35 +119,39 @@ display purposes. If absent, the real server name will be displayed instead."
                                     (:channels (repeat string))
                                     (:encryption (choice (const tls)
                                                          (const plain)))
-                                    (:server-alias string))))
-  :group 'rcirc)
+                                    (:server-alias string)))))
 
 (defcustom rcirc-default-port 6667
   "The default port to connect to."
-  :type 'integer
-  :group 'rcirc)
+  :type 'integer)
 
 (defcustom rcirc-default-nick (user-login-name)
   "Your nick."
-  :type 'string
-  :group 'rcirc)
+  :type 'string)
 
 (defcustom rcirc-default-user-name "user"
   "Your user name sent to the server when connecting."
   :version "24.1"                       ; changed default
-  :type 'string
-  :group 'rcirc)
+  :type 'string)
 
 (defcustom rcirc-default-full-name "unknown"
   "The full name sent to the server when connecting."
   :version "24.1"                       ; changed default
-  :type 'string
-  :group 'rcirc)
+  :type 'string)
+
+(defcustom rcirc-default-part-reason rcirc-id-string
+  "The default reason to send when parting from a channel.
+Used when no reason is explicitly given."
+  :type 'string)
+
+(defcustom rcirc-default-quit-reason rcirc-id-string
+  "The default reason to send when quitting a server.
+Used when no reason is explicitly given."
+  :type 'string)
 
 (defcustom rcirc-fill-flag t
   "Non-nil means line-wrap messages printed in channel buffers."
-  :type 'boolean
-  :group 'rcirc)
+  :type 'boolean)
 
 (defcustom rcirc-fill-column nil
   "Column beyond which automatic line-wrapping should happen.
@@ -157,24 +161,21 @@ call it to compute the number of columns."
   :risky t                              ; can get funcalled
   :type '(choice (const :tag "Value of `fill-column'" nil)
 		 (integer :tag "Number of columns")
-		 (function :tag "Function returning the number of columns"))
-  :group 'rcirc)
+                 (function :tag "Function returning the number of columns")))
 
 (defcustom rcirc-fill-prefix nil
   "Text to insert before filled lines.
 If nil, calculate the prefix dynamically to line up text
 underneath each nick."
   :type '(choice (const :tag "Dynamic" nil)
-		 (string :tag "Prefix text"))
-  :group 'rcirc)
+		 (string :tag "Prefix text")))
 
 (defcustom rcirc-url-max-length nil
   "Maximum number of characters in displayed URLs.
 If nil, no maximum is applied."
   :version "27.1"
   :type '(choice (const :tag "No maximum" nil)
-                 (integer :tag "Number of characters"))
-  :group 'rcirc)
+                 (integer :tag "Number of characters")))
 
 (defvar rcirc-ignore-buffer-activity-flag nil
   "If non-nil, ignore activity in this buffer.")
@@ -187,8 +188,7 @@ If nil, no maximum is applied."
 (defcustom rcirc-omit-responses
   '("JOIN" "PART" "QUIT" "NICK")
   "Responses which will be hidden when `rcirc-omit-mode' is enabled."
-  :type '(repeat string)
-  :group 'rcirc)
+  :type '(repeat string))
 
 (defvar rcirc-prompt-start-marker nil)
 
@@ -211,32 +211,27 @@ Uninteresting lines are those whose responses are listed in
 (defcustom rcirc-time-format "%H:%M "
   "Describes how timestamps are printed.
 Used as the first arg to `format-time-string'."
-  :type 'string
-  :group 'rcirc)
+  :type 'string)
 
 (defcustom rcirc-input-ring-size 1024
   "Size of input history ring."
-  :type 'integer
-  :group 'rcirc)
+  :type 'integer)
 
 (defcustom rcirc-read-only-flag t
   "Non-nil means make text in IRC buffers read-only."
-  :type 'boolean
-  :group 'rcirc)
+  :type 'boolean)
 
 (defcustom rcirc-buffer-maximum-lines nil
   "The maximum size in lines for rcirc buffers.
 Channel buffers are truncated from the top to be no greater than this
 number.  If zero or nil, no truncating is done."
   :type '(choice (const :tag "No truncation" nil)
-		 (integer :tag "Number of lines"))
-  :group 'rcirc)
+                 (integer :tag "Number of lines")))
 
 (defcustom rcirc-scroll-show-maximum-output t
   "If non-nil, scroll buffer to keep the point at the bottom of
 the window."
-  :type 'boolean
-  :group 'rcirc)
+  :type 'boolean)
 
 (defcustom rcirc-authinfo nil
   "List of authentication passwords.
@@ -275,21 +270,18 @@ Examples:
                                     (list :tag "QuakeNet"
                                           (const quakenet)
                                           (string :tag "Account")
-                                          (string :tag "Password"))))
-  :group 'rcirc)
+                                          (string :tag "Password")))))
 
 (defcustom rcirc-auto-authenticate-flag t
   "Non-nil means automatically send authentication string to server.
 See also `rcirc-authinfo'."
-  :type 'boolean
-  :group 'rcirc)
+  :type 'boolean)
 
 (defcustom rcirc-authenticate-before-join t
   "Non-nil means authenticate to services before joining channels.
 Currently only works with NickServ on some networks."
   :version "24.1"
-  :type 'boolean
-  :group 'rcirc)
+  :type 'boolean)
 
 (defcustom rcirc-prompt "> "
   "Prompt string to use in IRC buffers.
@@ -303,19 +295,16 @@ Setting this alone will not affect the prompt;
 use either M-x customize or also call `rcirc-update-prompt'."
   :type 'string
   :set 'rcirc-set-changed
-  :initialize 'custom-initialize-default
-  :group 'rcirc)
+  :initialize 'custom-initialize-default)
 
 (defcustom rcirc-keywords nil
   "List of keywords to highlight in message text."
-  :type '(repeat string)
-  :group 'rcirc)
+  :type '(repeat string))
 
 (defcustom rcirc-ignore-list ()
   "List of ignored nicks.
 Use /ignore to list them, use /ignore NICK to add or remove a nick."
-  :type '(repeat string)
-  :group 'rcirc)
+  :type '(repeat string))
 
 (defvar rcirc-ignore-list-automatic ()
   "List of ignored nicks added to `rcirc-ignore-list' because of renaming.
@@ -326,42 +315,36 @@ parts.")
 (defcustom rcirc-bright-nicks nil
   "List of nicks to be emphasized.
 See `rcirc-bright-nick' face."
-  :type '(repeat string)
-  :group 'rcirc)
+  :type '(repeat string))
 
 (defcustom rcirc-dim-nicks nil
   "List of nicks to be deemphasized.
 See `rcirc-dim-nick' face."
-  :type '(repeat string)
-  :group 'rcirc)
+  :type '(repeat string))
 
 (define-obsolete-variable-alias 'rcirc-print-hooks
   'rcirc-print-functions "24.3")
 (defcustom rcirc-print-functions nil
   "Hook run after text is printed.
 Called with 5 arguments, PROCESS, SENDER, RESPONSE, TARGET and TEXT."
-  :type 'hook
-  :group 'rcirc)
+  :type 'hook)
 
 (defvar rcirc-authenticated-hook nil
   "Hook run after successfully authenticated.")
 
 (defcustom rcirc-always-use-server-buffer-flag nil
   "Non-nil means messages without a channel target will go to the server buffer."
-  :type 'boolean
-  :group 'rcirc)
+  :type 'boolean)
 
 (defcustom rcirc-decode-coding-system 'utf-8
   "Coding system used to decode incoming irc messages.
 Set to `undecided' if you want the encoding of the incoming
 messages autodetected."
-  :type 'coding-system
-  :group 'rcirc)
+  :type 'coding-system)
 
 (defcustom rcirc-encode-coding-system 'utf-8
   "Coding system used to encode outgoing irc messages."
-  :type 'coding-system
-  :group 'rcirc)
+  :type 'coding-system)
 
 (defcustom rcirc-coding-system-alist nil
   "Alist to decide a coding system to use for a channel I/O operation.
@@ -380,13 +363,11 @@ and the cdr part is used for encoding."
 						(string :tag "Server Regexp")))
 		:value-type (choice coding-system
 				    (cons (coding-system :tag "Decode")
-					  (coding-system :tag "Encode"))))
-  :group 'rcirc)
+                                          (coding-system :tag "Encode")))))
 
 (defcustom rcirc-multiline-major-mode 'fundamental-mode
   "Major-mode function to use in multiline edit buffers."
-  :type 'function
-  :group 'rcirc)
+  :type 'function)
 
 (defcustom rcirc-nick-completion-format "%s: "
   "Format string to use in nick completions.
@@ -395,16 +376,14 @@ The format string is only used when completing at the beginning
 of a line.  The string is passed as the first argument to
 `format' with the nickname as the second argument."
   :version "24.1"
-  :type 'string
-  :group 'rcirc)
+  :type 'string)
 
 (defcustom rcirc-kill-channel-buffers nil
   "When non-nil, kill channel buffers when the server buffer is killed.
 Only the channel buffers associated with the server in question
 will be killed."
   :version "24.3"
-  :type 'boolean
-  :group 'rcirc)
+  :type 'boolean)
 
 (defvar rcirc-nick nil)
 
@@ -446,7 +425,6 @@ will be killed."
 (defvar rcirc-timeout-seconds 600
   "Kill connection after this many seconds if there is no activity.")
 
-(defconst rcirc-id-string (concat "rcirc on GNU Emacs " emacs-version))
 
 (defvar rcirc-startup-channels nil)
 
@@ -679,16 +657,24 @@ last ping."
   "If non-nil, write information to `rcirc-debug-buffer'.")
 (defun rcirc-debug (process text)
   "Add an entry to the debug log including PROCESS and TEXT.
-Debug text is written to `rcirc-debug-buffer' if `rcirc-debug-flag'
-is non-nil."
+Debug text is appended to `rcirc-debug-buffer' if `rcirc-debug-flag'
+is non-nil.
+
+For convenience, the read-only state of the debug buffer is ignored.
+When the point is at the end of the visible portion of the buffer, it
+is moved to after the text inserted.  Otherwise the point is not moved."
   (when rcirc-debug-flag
     (with-current-buffer (get-buffer-create rcirc-debug-buffer)
-      (goto-char (point-max))
-      (insert (concat
-	       "["
-	       (format-time-string "%Y-%m-%dT%T ") (process-name process)
-	       "] "
-	       text)))))
+      (let ((old (point-marker)))
+        (set-marker-insertion-type old t)
+        (goto-char (point-max))
+        (let ((inhibit-read-only t))
+          (terpri (current-buffer) t)
+          (insert "["
+                  (format-time-string "%FT%T ") (process-name process)
+                  "] "
+                  text))
+        (goto-char old)))))
 
 (define-obsolete-variable-alias 'rcirc-sentinel-hooks
   'rcirc-sentinel-functions "24.3")
@@ -700,8 +686,7 @@ Functions are called with PROCESS and SENTINEL arguments.")
   "The minimum interval in seconds between reconnect attempts.
 When 0, do not auto-reconnect."
   :version "25.1"
-  :type 'integer
-  :group 'rcirc)
+  :type 'integer)
 
 (defvar rcirc-last-connect-time nil
   "The last time the buffer was connected.")
@@ -1168,14 +1153,12 @@ If ALL is non-nil, update prompts in all IRC buffers."
 
 (defcustom rcirc-log-directory "~/.emacs.d/rcirc-log"
   "Directory to keep IRC logfiles."
-  :type 'directory
-  :group 'rcirc)
+  :type 'directory)
 
 (defcustom rcirc-log-flag nil
   "Non-nil means log IRC activity to disk.
 Logfiles are kept in `rcirc-log-directory'."
-  :type 'boolean
-  :group 'rcirc)
+  :type 'boolean)
 
 (defun rcirc-kill-buffer-hook ()
   "Part the channel when killing an rcirc buffer.
@@ -1364,7 +1347,6 @@ Create the buffer if it doesn't exist."
   :lighter " rcirc-mline"
   :keymap rcirc-multiline-minor-mode-map
   :global nil
-  :group 'rcirc
   (setq fill-column rcirc-max-message-length))
 
 (defun rcirc-multiline-minor-submit ()
@@ -1426,8 +1408,7 @@ the of the following escape sequences replaced by the described values:
   %%        A literal `%' character"
   :type '(alist :key-type (choice (string :tag "Type")
 				  (const :tag "Default" t))
-		:value-type string)
-  :group 'rcirc)
+                :value-type string))
 
 (defun rcirc-format-response-string (process sender response target text)
   "Return a nicely-formatted response string, incorporating TEXT
@@ -1509,12 +1490,10 @@ is found by looking up RESPONSE in `rcirc-response-formats'."
 
 (defcustom rcirc-omit-threshold 100
   "Number of lines since last activity from a nick before `rcirc-omit-responses' are omitted."
-  :type 'integer
-  :group 'rcirc)
+  :type 'integer)
 
 (defcustom rcirc-log-process-buffers nil
   "Non-nil if rcirc process buffers should be logged to disk."
-  :group 'rcirc
   :type 'boolean
   :version "24.1")
 
@@ -1707,7 +1686,6 @@ is put into `rcirc-log-directory'.
 
 The filename is then cleaned using `convert-standard-filename' to
 guarantee valid filenames for the current OS."
-  :group 'rcirc
   :type 'function)
 
 (defun rcirc-log (process sender response target text)
@@ -1875,7 +1853,6 @@ This function does not alter the INPUT string."
   :lighter ""
   :keymap rcirc-track-minor-mode-map
   :global t
-  :group 'rcirc
   (or global-mode-string (setq global-mode-string '("")))
   ;; toggle the mode-line channel indicator
   (if rcirc-track-minor-mode
@@ -2219,12 +2196,21 @@ CHANNELS is a comma- or space-separated string of channel names."
 		 (read-string "Channel: "))))
   (rcirc-send-string process (concat "INVITE " nick-channel)))
 
-;; TODO: /part #channel reason, or consider removing #channel altogether
 (defun-rcirc-command part (channel)
-  "Part CHANNEL."
+  "Part CHANNEL.
+CHANNEL should be a string of the form \"#CHANNEL-NAME REASON\".
+If omitted, CHANNEL-NAME defaults to TARGET, and REASON defaults
+to `rcirc-default-part-reason'."
   (interactive "sPart channel: ")
-  (let ((channel (if (> (length channel) 0) channel target)))
-    (rcirc-send-string process (concat "PART " channel " :" rcirc-id-string))))
+  (let ((channel (if (> (length channel) 0) channel target))
+        (msg rcirc-default-part-reason))
+    (when (string-match "\\`\\([&#+!]\\S-+\\)?\\s-*\\(.+\\)?\\'" channel)
+      (when (match-beginning 2)
+        (setq msg (match-string 2 channel)))
+      (setq channel (if (match-beginning 1)
+                        (match-string 1 channel)
+                      target)))
+    (rcirc-send-string process (concat "PART " channel " :" msg))))
 
 (defun-rcirc-command quit (reason)
   "Send a quit message to server with REASON."
@@ -2232,7 +2218,7 @@ CHANNELS is a comma- or space-separated string of channel names."
   (rcirc-send-string process (concat "QUIT :"
 				     (if (not (zerop (length reason)))
 					 reason
-				       rcirc-id-string))))
+                                       rcirc-default-quit-reason))))
 
 (defun-rcirc-command reconnect (_)
   "Reconnect to current server."
@@ -2963,8 +2949,7 @@ Passwords are stored in `rcirc-authinfo' (which see)."
     (((class color) (min-colors 16) (background dark))  :foreground "LightSkyBlue")
     (((class color) (min-colors 8)) :foreground "blue" :weight bold)
     (t :inverse-video t :weight bold))
-  "Rcirc face for my messages."
-  :group 'rcirc-faces)
+  "Rcirc face for my messages.")
 
 (defface rcirc-other-nick	     ; font-lock-variable-name-face
   '((((class grayscale) (background light))
@@ -2977,8 +2962,7 @@ Passwords are stored in `rcirc-authinfo' (which see)."
     (((class color) (min-colors 16) (background dark))  :foreground "LightGoldenrod")
     (((class color) (min-colors 8)) :foreground "yellow" :weight light)
     (t :weight bold :slant italic))
-  "Rcirc face for other users' messages."
-  :group 'rcirc-faces)
+  "Rcirc face for other users' messages.")
 
 (defface rcirc-bright-nick
   '((((class grayscale) (background light))
@@ -2991,13 +2975,11 @@ Passwords are stored in `rcirc-authinfo' (which see)."
     (((class color) (min-colors 16) (background dark))  :foreground "Aquamarine")
     (((class color) (min-colors 8)) :foreground "magenta")
     (t :weight bold :underline t))
-  "Rcirc face for nicks matched by `rcirc-bright-nicks'."
-  :group 'rcirc-faces)
+  "Rcirc face for nicks matched by `rcirc-bright-nicks'.")
 
 (defface rcirc-dim-nick
   '((t :inherit default))
-  "Rcirc face for nicks in `rcirc-dim-nicks'."
-  :group 'rcirc-faces)
+  "Rcirc face for nicks in `rcirc-dim-nicks'.")
 
 (defface rcirc-server			; font-lock-comment-face
   '((((class grayscale) (background light))
@@ -3015,8 +2997,7 @@ Passwords are stored in `rcirc-authinfo' (which see)."
     (((class color) (min-colors 8) (background light)))
     (((class color) (min-colors 8) (background dark)))
     (t :weight bold :slant italic))
-  "Rcirc face for server messages."
-  :group 'rcirc-faces)
+  "Rcirc face for server messages.")
 
 (defface rcirc-server-prefix	 ; font-lock-comment-delimiter-face
   '((default :inherit rcirc-server)
@@ -3026,13 +3007,11 @@ Passwords are stored in `rcirc-authinfo' (which see)."
      :foreground "red")
     (((class color) (min-colors 8) (background dark))
      :foreground "red1"))
-  "Rcirc face for server prefixes."
-  :group 'rcirc-faces)
+  "Rcirc face for server prefixes.")
 
 (defface rcirc-timestamp
   '((t :inherit default))
-  "Rcirc face for timestamps."
-  :group 'rcirc-faces)
+  "Rcirc face for timestamps.")
 
 (defface rcirc-nick-in-message		; font-lock-keyword-face
   '((((class grayscale) (background light)) :foreground "LightGray" :weight bold)
@@ -3043,37 +3022,30 @@ Passwords are stored in `rcirc-authinfo' (which see)."
     (((class color) (min-colors 16) (background dark))  :foreground "Cyan")
     (((class color) (min-colors 8)) :foreground "cyan" :weight bold)
     (t :weight bold))
-  "Rcirc face for instances of your nick within messages."
-  :group 'rcirc-faces)
+  "Rcirc face for instances of your nick within messages.")
 
 (defface rcirc-nick-in-message-full-line '((t :weight bold))
-  "Rcirc face for emphasizing the entire message when your nick is mentioned."
-  :group 'rcirc-faces)
+  "Rcirc face for emphasizing the entire message when your nick is mentioned.")
 
 (defface rcirc-prompt			; comint-highlight-prompt
   '((((min-colors 88) (background dark)) :foreground "cyan1")
     (((background dark)) :foreground "cyan")
     (t :foreground "dark blue"))
-  "Rcirc face for prompts."
-  :group 'rcirc-faces)
+  "Rcirc face for prompts.")
 
 (defface rcirc-track-nick
   '((((type tty)) :inherit default)
     (t :inverse-video t))
-  "Rcirc face used in the mode-line when your nick is mentioned."
-  :group 'rcirc-faces)
+  "Rcirc face used in the mode-line when your nick is mentioned.")
 
 (defface rcirc-track-keyword '((t :weight bold))
-  "Rcirc face used in the mode-line when keywords are mentioned."
-  :group 'rcirc-faces)
+  "Rcirc face used in the mode-line when keywords are mentioned.")
 
 (defface rcirc-url '((t :weight bold))
-  "Rcirc face used to highlight urls."
-  :group 'rcirc-faces)
+  "Rcirc face used to highlight urls.")
 
 (defface rcirc-keyword '((t :inherit highlight))
-  "Rcirc face used to highlight keywords."
-  :group 'rcirc-faces)
+  "Rcirc face used to highlight keywords.")
 
 
 ;; When using M-x flyspell-mode, only check words after the prompt
diff --git a/lisp/net/rfc2104.el b/lisp/net/rfc2104.el
index 68c35aa313..9d4957ddb5 100644
--- a/lisp/net/rfc2104.el
+++ b/lisp/net/rfc2104.el
@@ -84,14 +84,6 @@
       (setq ls (cdr ls)))
     v))
 
-(eval-when-compile
-  (defmacro rfc2104-string-make-unibyte (string)
-    "Return the unibyte equivalent of STRING.
-In XEmacs return just STRING."
-    (if (featurep 'xemacs)
-	string
-      `(string-make-unibyte ,string))))
-
 (defun rfc2104-hash (hash block-length hash-length key text)
   (let* (;; if key is longer than B, reset it to HASH(key)
 	 (key (if (> (length key) block-length)
@@ -107,7 +99,7 @@ In XEmacs return just STRING."
       (aset ipad i (logxor rfc2104-ipad c))
       (aset opad i (logxor rfc2104-opad c)))
     ;; Perform inner hash.
-    (setq partial (rfc2104-string-make-unibyte
+    (setq partial (string-make-unibyte
 		   (funcall hash (concat ipad text))))
     ;; Pack latter part of opad.
     (cl-do ((r 0 (+ 2 r))
@@ -117,7 +109,7 @@ In XEmacs return just STRING."
             (+ (* 16 (aref rfc2104-nybbles (aref partial     r)))
                (      aref rfc2104-nybbles (aref partial (1+ r))))))
     ;; Perform outer hash.
-    (rfc2104-string-make-unibyte (funcall hash opad))))
+    (string-make-unibyte (funcall hash opad))))
 
 (provide 'rfc2104)
 
diff --git a/lisp/net/rlogin.el b/lisp/net/rlogin.el
index bf6f5359aa..9da3548836 100644
--- a/lisp/net/rlogin.el
+++ b/lisp/net/rlogin.el
@@ -3,8 +3,7 @@
 ;; Copyright (C) 1992-1995, 1997-1998, 2001-2019 Free Software
 ;; Foundation, Inc.
 
-;; Author: Noah Friedman
-;; Maintainer: Noah Friedman <friedman@splode.com>
+;; Author: Noah Friedman <friedman@splode.com>
 ;; Keywords: unix, comm
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/net/sasl-cram.el b/lisp/net/sasl-cram.el
index a4d80c92e5..cbca829b03 100644
--- a/lisp/net/sasl-cram.el
+++ b/lisp/net/sasl-cram.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2000, 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Daiki Ueno <ueno@unixuser.org>
+;; Author: Daiki Ueno <ueno@gnu.org>
 ;;	Kenichi OKADA <okada@opaopa.org>
 ;; Keywords: SASL, CRAM-MD5
 ;; Package: sasl
diff --git a/lisp/net/sasl.el b/lisp/net/sasl.el
index 492f6574e7..bd0351644a 100644
--- a/lisp/net/sasl.el
+++ b/lisp/net/sasl.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2000, 2007-2019 Free Software Foundation, Inc.
 
-;; Author: Daiki Ueno <ueno@unixuser.org>
+;; Author: Daiki Ueno <ueno@gnu.org>
 ;; Keywords: SASL
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/net/shr.el b/lisp/net/shr.el
index 2f628e1caa..c1e9fdd30d 100644
--- a/lisp/net/shr.el
+++ b/lisp/net/shr.el
@@ -1101,8 +1101,7 @@ WIDTH and HEIGHT are the sizes given in the HTML data, if any.
 The size of the displayed image will not exceed
 MAX-WIDTH/MAX-HEIGHT.  If not given, use the current window
 width/height instead."
-  (if (or (not (fboundp 'imagemagick-types))
-          (not (get-buffer-window (current-buffer))))
+  (if (not (get-buffer-window (current-buffer)))
       (create-image data nil t :ascent 100)
     (let* ((edges (window-inside-pixel-edges
                    (get-buffer-window (current-buffer))))
@@ -1123,13 +1122,13 @@ width/height instead."
                (< (* width scaling) max-width)
                (< (* height scaling) max-height))
           (create-image
-           data 'imagemagick t
+           data nil t
            :ascent 100
            :width width
            :height height
            :format content-type)
         (create-image
-         data 'imagemagick t
+         data nil t
          :ascent 100
          :max-width max-width
          :max-height max-height
@@ -1790,7 +1789,10 @@ The preference is a float determined from `shr-prefer-media-type'."
 
 (defun shr-mark-fill (start)
   ;; We may not have inserted any text to fill.
-  (unless (= start (point))
+  (when (and (/= start (point))
+             ;; Tables insert themselves with the correct indentation,
+             ;; so don't do anything if we're at the start of a table.
+             (not (get-text-property start 'shr-table-id)))
     (put-text-property start (1+ start)
 		       'shr-indentation shr-indentation)))
 
@@ -2087,7 +2089,8 @@ flags that control whether to collect or render objects."
 			(setq max (max max (nth 2 column))))
 		      max)))
 	(dotimes (_ (max height 1))
-	  (shr-indent)
+          (when (bolp)
+	    (shr-indent))
 	  (insert shr-table-vertical-line "\n"))
 	(dolist (column row)
 	  (when (> (nth 2 column) -1)
diff --git a/lisp/net/tramp-adb.el b/lisp/net/tramp-adb.el
index f3aa55f16f..9a214c369a 100644
--- a/lisp/net/tramp-adb.el
+++ b/lisp/net/tramp-adb.el
@@ -53,7 +53,7 @@ It is used for TCP/IP devices."
   "When this method name is used, forward all calls to Android Debug Bridge.")
 
 (defcustom tramp-adb-prompt
-  "^[[:digit:]]*|?\\(?:[[:alnum:]\e;[]*@?[[:alnum:]]*[^#\\$]*\\)?[#\\$][[:space:]]"
+  "^[[:digit:]]*|?[[:alnum:]\e;[]*@?[[:alnum:]]*[^#\\$]*[#\\$][[:space:]]"
   "Regexp used as prompt in almquist shell."
   :type 'string
   :version "24.4"
@@ -934,7 +934,6 @@ PRESERVE-UID-GID and PRESERVE-EXTENDED-ATTRIBUTES are completely ignored."
 	    (command (plist-get args :command))
 	    (coding (plist-get args :coding))
 	    (noquery (plist-get args :noquery))
-	    (stop (plist-get args :stop))
 	    (connection-type (plist-get args :connection-type))
 	    (filter (plist-get args :filter))
 	    (sentinel (plist-get args :sentinel))
@@ -976,9 +975,7 @@ PRESERVE-UID-GID and PRESERVE-EXTENDED-ATTRIBUTES are completely ignored."
 		(or (null program) tramp-process-connection-type))
 	       (bmp (and (buffer-live-p buffer) (buffer-modified-p buffer)))
 	       (name1 name)
-	       (i 0)
-	       ;; We do not want to run timers.
-	       timer-list timer-idle-list)
+	       (i 0))
 
 	  (while (get-process name1)
 	    ;; NAME must be unique as process name.
@@ -1010,9 +1007,6 @@ PRESERVE-UID-GID and PRESERVE-EXTENDED-ATTRIBUTES are completely ignored."
 		      ;; Send the command.
 		      (let* ((p (tramp-get-connection-process v)))
                         (tramp-adb-send-command v command nil t) ; nooutput
-			;; Stop process if indicated.
-			(when stop
-			  (stop-process p))
 			;; Set sentinel and filter.
 			(when sentinel
 			  (set-process-sentinel p sentinel))
@@ -1300,8 +1294,11 @@ connection if a previous connection has died for some reason."
 
 ;; Default settings for connection-local variables.
 (defconst tramp-adb-connection-local-default-profile
-  '((shell-file-name . "/system/bin/sh")
-    (shell-command-switch . "-c"))
+  ;; `w32-shell-name' is derived from `shell-file-name'.  Don't let it
+  ;; be confused.
+  (unless (eq system-type 'windows-nt)
+    '((shell-file-name . "/system/bin/sh")
+      (shell-command-switch . "-c")))
   "Default connection-local variables for remote adb connections.")
 
 ;; `connection-local-set-profile-variables' and
diff --git a/lisp/net/tramp-archive.el b/lisp/net/tramp-archive.el
index ba4c26cdf2..e6ae73aae6 100644
--- a/lisp/net/tramp-archive.el
+++ b/lisp/net/tramp-archive.el
@@ -129,6 +129,8 @@
 (setq tramp-archive-enabled tramp-gvfs-enabled)
 
 ;; <https://github.com/libarchive/libarchive/wiki/LibarchiveFormats>
+;; Note: "arc" and "zoo" are supported by `archive-mode', but they
+;; don't work here.
 ;;;###autoload
 (defconst tramp-archive-suffixes
   ;; "cab", "lzh", "msu" and "zip" are included with lower and upper
@@ -318,10 +320,11 @@ pass to the OPERATION."
 			      operation args))
 	     (archive (tramp-archive-file-name-archive filename)))
 
-        ;; The file archive could be a directory, see Bug#30293.
-        (if (and archive
-	         (tramp-archive-run-real-handler
-                  #'file-directory-p (list archive)))
+        ;; `filename' could be a quoted file name.  Or the file
+        ;; archive could be a directory, see Bug#30293.
+        (if (or (null archive)
+	        (tramp-archive-run-real-handler
+                 #'file-directory-p (list archive)))
             (tramp-archive-run-real-handler operation args)
           ;; Now run the handler.
           (let ((tramp-methods (cons `(,tramp-archive-method) tramp-methods))
@@ -384,6 +387,8 @@ pass to the OPERATION."
 (defun tramp-archive-file-name-p (name)
   "Return t if NAME is a string with archive file name syntax."
   (and (stringp name)
+       ;; `tramp-archive-file-name-regexp' does not suppress quoted file names.
+       (not (tramp-compat-file-name-quoted-p name t))
        ;; We cannot use `string-match-p', the matches are used.
        (string-match tramp-archive-file-name-regexp name)
        t))
diff --git a/lisp/net/tramp-compat.el b/lisp/net/tramp-compat.el
index e3d0343569..21a819f79f 100644
--- a/lisp/net/tramp-compat.el
+++ b/lisp/net/tramp-compat.el
@@ -35,15 +35,11 @@
 (defun tramp-unload-file-name-handlers ())
 
 (require 'auth-source)
-(require 'advice)
-(require 'cl-lib)
-(require 'custom)
 (require 'format-spec)
 (require 'parse-time)
-(require 'password-cache)
 (require 'shell)
-(require 'timer)
-(require 'ucs-normalize)
+
+(declare-function tramp-handle-temporary-file-directory "tramp")
 
 ;; For not existing functions, obsolete functions, or functions with a
 ;; changed argument list, there are compiler warnings.  We want to
@@ -74,7 +70,7 @@ Add the extension of F, if existing."
 (defalias 'tramp-compat-temporary-file-directory-function
   (if (fboundp 'temporary-file-directory)
       #'temporary-file-directory
-    'tramp-handle-temporary-file-directory))
+    #'tramp-handle-temporary-file-directory))
 
 (defun tramp-compat-process-running-p (process-name)
   "Returns t if system process PROCESS-NAME is running for `user-login-name'."
@@ -106,79 +102,85 @@ Add the extension of F, if existing."
 
 ;; `file-attribute-*' are introduced in Emacs 25.1.
 
-(if (fboundp 'file-attribute-type)
-    (defalias 'tramp-compat-file-attribute-type #'file-attribute-type)
-  (defsubst tramp-compat-file-attribute-type (attributes)
-    "The type field in ATTRIBUTES returned by `file-attributes'.
+(defalias 'tramp-compat-file-attribute-type
+  (if (fboundp 'file-attribute-type)
+      #'file-attribute-type
+    (lambda (attributes)
+      "The type field in ATTRIBUTES returned by `file-attributes'.
 The value is either t for directory, string (name linked to) for
 symbolic link, or nil."
-    (nth 0 attributes)))
-
-(if (fboundp 'file-attribute-link-number)
-    (defalias 'tramp-compat-file-attribute-link-number
-      #'file-attribute-link-number)
-  (defsubst tramp-compat-file-attribute-link-number (attributes)
-    "Return the number of links in ATTRIBUTES returned by `file-attributes'."
-    (nth 1 attributes)))
-
-(if (fboundp 'file-attribute-user-id)
-    (defalias 'tramp-compat-file-attribute-user-id #'file-attribute-user-id)
-  (defsubst tramp-compat-file-attribute-user-id (attributes)
-    "The UID field in ATTRIBUTES returned by `file-attributes'.
+      (nth 0 attributes))))
+
+(defalias 'tramp-compat-file-attribute-link-number
+  (if (fboundp 'file-attribute-link-number)
+      #'file-attribute-link-number
+    (lambda (attributes)
+      "Return the number of links in ATTRIBUTES returned by `file-attributes'."
+      (nth 1 attributes))))
+
+(defalias 'tramp-compat-file-attribute-user-id
+  (if (fboundp 'file-attribute-user-id)
+      #'file-attribute-user-id
+    (lambda (attributes)
+      "The UID field in ATTRIBUTES returned by `file-attributes'.
 This is either a string or a number.  If a string value cannot be
 looked up, a numeric value, either an integer or a float, is
 returned."
-    (nth 2 attributes)))
+      (nth 2 attributes))))
 
-(if (fboundp 'file-attribute-group-id)
-    (defalias 'tramp-compat-file-attribute-group-id #'file-attribute-group-id)
-  (defsubst tramp-compat-file-attribute-group-id (attributes)
-    "The GID field in ATTRIBUTES returned by `file-attributes'.
+(defalias 'tramp-compat-file-attribute-group-id
+  (if (fboundp 'file-attribute-group-id)
+      #'file-attribute-group-id
+    (lambda (attributes)
+      "The GID field in ATTRIBUTES returned by `file-attributes'.
 This is either a string or a number.  If a string value cannot be
 looked up, a numeric value, either an integer or a float, is
 returned."
-    (nth 3 attributes)))
+      (nth 3 attributes))))
 
-(if (fboundp 'file-attribute-modification-time)
-    (defalias 'tramp-compat-file-attribute-modification-time
-      #'file-attribute-modification-time)
-  (defsubst tramp-compat-file-attribute-modification-time (attributes)
-    "The modification time in ATTRIBUTES returned by `file-attributes'.
+(defalias 'tramp-compat-file-attribute-modification-time
+  (if (fboundp 'file-attribute-modification-time)
+      #'file-attribute-modification-time
+    (lambda (attributes)
+      "The modification time in ATTRIBUTES returned by `file-attributes'.
 This is the time of the last change to the file's contents, and
 is a Lisp timestamp in the style of `current-time'."
-    (nth 5 attributes)))
+      (nth 5 attributes))))
 
-(if (fboundp 'file-attribute-size)
-    (defalias 'tramp-compat-file-attribute-size #'file-attribute-size)
-  (defsubst tramp-compat-file-attribute-size (attributes)
-    "The size (in bytes) in ATTRIBUTES returned by `file-attributes'.
+(defalias 'tramp-compat-file-attribute-size
+  (if (fboundp 'file-attribute-size)
+      #'file-attribute-size
+    (lambda (attributes)
+      "The size (in bytes) in ATTRIBUTES returned by `file-attributes'.
 If the size is too large for a fixnum, this is a bignum in Emacs 27
 and later, and is a float in Emacs 26 and earlier."
-    (nth 7 attributes)))
+      (nth 7 attributes))))
 
-(if (fboundp 'file-attribute-modes)
-    (defalias 'tramp-compat-file-attribute-modes #'file-attribute-modes)
-  (defsubst tramp-compat-file-attribute-modes (attributes)
-    "The file modes in ATTRIBUTES returned by `file-attributes'.
+(defalias 'tramp-compat-file-attribute-modes
+  (if (fboundp 'file-attribute-modes)
+      #'file-attribute-modes
+    (lambda (attributes)
+      "The file modes in ATTRIBUTES returned by `file-attributes'.
 This is a string of ten letters or dashes as in ls -l."
-    (nth 8 attributes)))
+      (nth 8 attributes))))
 
 ;; `format-message' is new in Emacs 25.1.
 (unless (fboundp 'format-message)
   (defalias 'format-message #'format))
 
 ;; `directory-name-p' is new in Emacs 25.1.
-(if (fboundp 'directory-name-p)
-    (defalias 'tramp-compat-directory-name-p #'directory-name-p)
-  (defsubst tramp-compat-directory-name-p (name)
-    "Return non-nil if NAME ends with a directory separator character."
-    (let ((len (length name))
-          (lastc ?.))
-      (if (> len 0)
-          (setq lastc (aref name (1- len))))
-      (or (= lastc ?/)
-          (and (memq system-type '(windows-nt ms-dos))
-               (= lastc ?\\))))))
+(defalias 'tramp-compat-directory-name-p
+  (if (fboundp 'directory-name-p)
+      #'directory-name-p
+    (lambda (name)
+      "Return non-nil if NAME ends with a directory separator character."
+      (let ((len (length name))
+            (lastc ?.))
+	(if (> len 0)
+            (setq lastc (aref name (1- len))))
+	(or (= lastc ?/)
+            (and (memq system-type '(windows-nt ms-dos))
+		 (= lastc ?\\)))))))
 
 ;; `file-missing' is introduced in Emacs 26.1.
 (defconst tramp-file-missing
@@ -187,35 +189,42 @@ This is a string of ten letters or dashes as in ls -l."
 
 ;; `file-local-name', `file-name-quoted-p', `file-name-quote' and
 ;; `file-name-unquote' are introduced in Emacs 26.
-(eval-and-compile
+(defalias 'tramp-compat-file-local-name
   (if (fboundp 'file-local-name)
-      (defalias 'tramp-compat-file-local-name #'file-local-name)
-    (defsubst tramp-compat-file-local-name (name)
+      #'file-local-name
+    (lambda (name)
       "Return the local name component of NAME.
 It returns a file name which can be used directly as argument of
 `process-file', `start-file-process', or `shell-command'."
-      (or (file-remote-p name 'localname) name)))
-
-  (if (fboundp 'file-name-quoted-p)
-      (defalias 'tramp-compat-file-name-quoted-p #'file-name-quoted-p)
-    (defsubst tramp-compat-file-name-quoted-p (name)
+      (or (file-remote-p name 'localname) name))))
+
+;; `file-name-quoted-p' got a second argument in Emacs 27.1.
+(defalias 'tramp-compat-file-name-quoted-p
+  (if (and
+       (fboundp 'file-name-quoted-p)
+       (equal (tramp-compat-funcall 'func-arity #'file-name-quoted-p) '(1 . 2)))
+      #'file-name-quoted-p
+    (lambda (name &optional top)
       "Whether NAME is quoted with prefix \"/:\".
-If NAME is a remote file name, check the local part of NAME."
-      (string-prefix-p "/:" (tramp-compat-file-local-name name))))
+If NAME is a remote file name and TOP is nil, check the local part of NAME."
+      (let ((file-name-handler-alist (unless top file-name-handler-alist)))
+	(string-prefix-p "/:" (tramp-compat-file-local-name name))))))
 
+(defalias 'tramp-compat-file-name-quote
   (if (fboundp 'file-name-quote)
-      (defalias 'tramp-compat-file-name-quote #'file-name-quote)
-    (defsubst tramp-compat-file-name-quote (name)
+      #'file-name-quote
+    (lambda (name)
       "Add the quotation prefix \"/:\" to file NAME.
 If NAME is a remote file name, the local part of NAME is quoted."
       (if (tramp-compat-file-name-quoted-p name)
 	  name
 	(concat
-	 (file-remote-p name) "/:" (tramp-compat-file-local-name name)))))
+	 (file-remote-p name) "/:" (tramp-compat-file-local-name name))))))
 
+(defalias 'tramp-compat-file-name-unquote
   (if (fboundp 'file-name-unquote)
-      (defalias 'tramp-compat-file-name-unquote #'file-name-unquote)
-    (defsubst tramp-compat-file-name-unquote (name)
+      #'file-name-unquote
+    (lambda (name)
       "Remove quotation prefix \"/:\" from file NAME.
 If NAME is a remote file name, the local part of NAME is unquoted."
       (let ((localname (tramp-compat-file-local-name name)))
@@ -240,16 +249,16 @@ If NAME is a remote file name, the local part of NAME is unquoted."
     '(cdr (mapcar #'car (get 'tramp-file-name 'cl-struct-slots)))))
 
 ;; The signature of `tramp-make-tramp-file-name' has been changed.
-;; Therefore, we cannot us `url-tramp-convert-url-to-tramp' prior
+;; Therefore, we cannot use `url-tramp-convert-url-to-tramp' prior
 ;; Emacs 26.1.  We use `temporary-file-directory' as indicator.
 (defconst tramp-compat-use-url-tramp-p (fboundp 'temporary-file-directory)
   "Whether to use url-tramp.el.")
 
 ;; `exec-path' is new in Emacs 27.1.
-(eval-and-compile
+(defalias 'tramp-compat-exec-path
   (if (fboundp 'exec-path)
-      (defalias 'tramp-compat-exec-path #'exec-path)
-    (defun tramp-compat-exec-path ()
+      #'exec-path
+    (lambda ()
       "List of directories to search programs to run in remote subprocesses."
       (let ((handler (find-file-name-handler default-directory 'exec-path)))
 	(if handler
@@ -257,27 +266,29 @@ If NAME is a remote file name, the local part of NAME is unquoted."
 	  exec-path)))))
 
 ;; `time-equal-p' has appeared in Emacs 27.1.
-(if (fboundp 'time-equal-p)
-    (defalias 'tramp-compat-time-equal-p #'time-equal-p)
-  (defsubst tramp-compat-time-equal-p (t1 t2)
-    "Return non-nil if time value T1 is equal to time value T2.
+(defalias 'tramp-compat-time-equal-p
+  (if (fboundp 'time-equal-p)
+      #'time-equal-p
+    (lambda (t1 t2)
+      "Return non-nil if time value T1 is equal to time value T2.
 A nil value for either argument stands for the current time."
-    (equal (or t1 (current-time)) (or t2 (current-time)))))
+      (equal (or t1 (current-time)) (or t2 (current-time))))))
 
 ;; `flatten-tree' has appeared in Emacs 27.1.
-(if (fboundp 'flatten-tree)
-    (defalias 'tramp-compat-flatten-tree #'flatten-tree)
-  (defun tramp-compat-flatten-tree (tree)
-    "Take TREE and \"flatten\" it."
-    (let (elems)
-      (setq tree (list tree))
-      (while (let ((elem (pop tree)))
-               (cond ((consp elem)
-                      (setq tree (cons (car elem) (cons (cdr elem) tree))))
-                     (elem
-                      (push elem elems)))
-               tree))
-      (nreverse elems))))
+(defalias 'tramp-compat-flatten-tree
+  (if (fboundp 'flatten-tree)
+      #'flatten-tree
+    (lambda (tree)
+      "Take TREE and \"flatten\" it."
+      (let (elems)
+	(setq tree (list tree))
+	(while (let ((elem (pop tree)))
+		 (cond ((consp elem)
+			(setq tree (cons (car elem) (cons (cdr elem) tree))))
+                       (elem
+			(push elem elems)))
+		 tree))
+	(nreverse elems)))))
 
 (add-hook 'tramp-unload-hook
 	  (lambda ()
diff --git a/lisp/net/tramp-gvfs.el b/lisp/net/tramp-gvfs.el
index 8fea82d97c..17c2e79833 100644
--- a/lisp/net/tramp-gvfs.el
+++ b/lisp/net/tramp-gvfs.el
@@ -99,20 +99,26 @@
 
 (eval-when-compile (require 'cl-lib))
 (require 'tramp)
-
 (require 'dbus)
 (require 'url-parse)
 (require 'url-util)
-(require 'zeroconf)
 
 ;; Pacify byte-compiler.
 (eval-when-compile
   (require 'custom))
 
+(declare-function zeroconf-init "zeroconf")
+(declare-function zeroconf-list-service-types "zeroconf")
+(declare-function zeroconf-list-services "zeroconf")
+(declare-function zeroconf-service-host "zeroconf")
+(declare-function zeroconf-service-port "zeroconf")
+(declare-function zeroconf-service-txt "zeroconf")
+
 ;; We don't call `dbus-ping', because this would load dbus.el.
 (defconst tramp-gvfs-enabled
   (ignore-errors
     (and (featurep 'dbusbind)
+	 (autoload 'zeroconf-init "zeroconf")
 	 (tramp-compat-funcall 'dbus-get-unique-name :system)
 	 (tramp-compat-funcall 'dbus-get-unique-name :session)
 	 (or (tramp-compat-process-running-p "gvfs-fuse-daemon")
@@ -1187,6 +1193,7 @@ If FILE-SYSTEM is non-nil, return file system attributes."
 	(process-put p 'adjust-window-size-function #'ignore)
 	(set-process-query-on-exit-flag p nil)
 	(set-process-filter p #'tramp-gvfs-monitor-process-filter)
+	(set-process-sentinel p #'tramp-file-notify-process-sentinel)
 	;; There might be an error if the monitor is not supported.
 	;; Give the filter a chance to read the output.
 	(while (tramp-accept-process-output p 0))
@@ -1758,7 +1765,7 @@ connection if a previous connection has died for some reason."
   ;; better solution?
   (unless (get-buffer-process (tramp-get-connection-buffer vec))
     (let ((p (make-network-process
-	      :name (tramp-buffer-name vec)
+	      :name (tramp-get-connection-name vec)
 	      :buffer (tramp-get-connection-buffer vec)
 	      :server t :host 'local :service t :noquery t)))
       (process-put p 'vector vec)
diff --git a/lisp/net/tramp-integration.el b/lisp/net/tramp-integration.el
index da168adce7..6e3b0279ec 100644
--- a/lisp/net/tramp-integration.el
+++ b/lisp/net/tramp-integration.el
@@ -31,10 +31,10 @@
 
 ;; Pacify byte-compiler.
 (require 'cl-lib)
+(declare-function recentf-cleanup "recentf")
 (declare-function tramp-dissect-file-name "tramp")
 (declare-function tramp-file-name-equal-p "tramp")
 (declare-function tramp-tramp-file-p "tramp")
-(declare-function recentf-cleanup "recentf")
 (defvar eshell-path-env)
 (defvar recentf-exclude)
 (defvar tramp-current-connection)
@@ -174,8 +174,11 @@ NAME must be equal to `tramp-current-connection'."
 ;;; Default connection-local variables for Tramp:
 
 (defconst tramp-connection-local-default-profile
-  '((shell-file-name . "/bin/sh")
-    (shell-command-switch . "-c"))
+  ;; `w32-shell-name' is derived from `shell-file-name'.  Don't let it
+  ;; be confused.
+  (unless (eq system-type 'windows-nt)
+    '((shell-file-name . "/bin/sh")
+      (shell-command-switch . "-c")))
   "Default connection-local variables for remote connections.")
 
 ;; `connection-local-set-profile-variables' and
diff --git a/lisp/net/tramp-rclone.el b/lisp/net/tramp-rclone.el
index 0148116d73..9e99493cbf 100644
--- a/lisp/net/tramp-rclone.el
+++ b/lisp/net/tramp-rclone.el
@@ -543,7 +543,7 @@ connection if a previous connection has died for some reason."
       ;; we create a dummy process.  Maybe there is a better solution?
       (unless (get-buffer-process (tramp-get-connection-buffer vec))
 	(let ((p (make-network-process
-		  :name (tramp-buffer-name vec)
+		  :name (tramp-get-connection-name vec)
 		  :buffer (tramp-get-connection-buffer vec)
 		  :server t :host 'local :service t :noquery t)))
 	  (process-put p 'vector vec)
diff --git a/lisp/net/tramp-sh.el b/lisp/net/tramp-sh.el
index 7d903c5769..34fda5af17 100644
--- a/lisp/net/tramp-sh.el
+++ b/lisp/net/tramp-sh.el
@@ -30,10 +30,6 @@
 (eval-when-compile (require 'cl-lib))
 (require 'tramp)
 
-;; Pacify byte-compiler.
-(eval-when-compile
-  (require 'dired))
-
 (declare-function dired-remove-file "dired-aux")
 (defvar dired-compress-file-suffixes)
 (defvar vc-handled-backends)
@@ -1031,11 +1027,13 @@ component is used as the target of the symlink."
 
     (with-parsed-tramp-file-name linkname nil
       ;; If TARGET is a Tramp name, use just the localname component.
-      (when (and (tramp-tramp-file-p target)
-		 (tramp-file-name-equal-p v (tramp-dissect-file-name target)))
-	(setq target
-	      (tramp-file-name-localname
-	       (tramp-dissect-file-name (expand-file-name target)))))
+      ;; Don't check for a proper method.
+      (let ((non-essential t))
+	(when (and (tramp-tramp-file-p target)
+		   (tramp-file-name-equal-p v (tramp-dissect-file-name target)))
+	  (setq target
+		(tramp-file-name-localname
+		 (tramp-dissect-file-name (expand-file-name target))))))
 
       ;; If TARGET is still remote, quote it.
       (if (tramp-tramp-file-p target)
@@ -2417,9 +2415,7 @@ The method used must be an out-of-band method."
 	      ;; The default directory must be remote.
 	      (let ((default-directory
 		      (file-name-directory (if t1 filename newname)))
-		    (process-environment (copy-sequence process-environment))
-		    ;; We do not want to run timers.
-		    timer-list timer-idle-list)
+		    (process-environment (copy-sequence process-environment)))
 		;; Set the transfer process properties.
 		(tramp-set-connection-property
 		 v "process-name" (buffer-name (current-buffer)))
@@ -2781,7 +2777,6 @@ the result will be a local, non-Tramp, file name."
 	    (command (plist-get args :command))
 	    (coding (plist-get args :coding))
 	    (noquery (plist-get args :noquery))
-	    (stop (plist-get args :stop))
 	    (connection-type (plist-get args :connection-type))
 	    (filter (plist-get args :filter))
 	    (sentinel (plist-get args :sentinel))
@@ -2879,8 +2874,6 @@ the result will be a local, non-Tramp, file name."
 	       ;; has been started several times in `eshell' and
 	       ;; friends.
 	       tramp-current-connection
-	       ;; We do not want to run timers.
-	       timer-list timer-idle-list
 	       p)
 
 	  (while (get-process name1)
@@ -2903,7 +2896,8 @@ the result will be a local, non-Tramp, file name."
 		    ;; otherwise we might be interrupted by
 		    ;; `verify-visited-file-modtime'.
 		    (let ((buffer-undo-list t)
-			  (inhibit-read-only t))
+			  (inhibit-read-only t)
+			  (mark (point-max)))
 		      (clear-visited-file-modtime)
 		      (narrow-to-region (point-max) (point-max))
 		      ;; We call `tramp-maybe-open-connection', in
@@ -2916,7 +2910,12 @@ the result will be a local, non-Tramp, file name."
 			(let ((pid (tramp-send-command-and-read v "echo $$")))
 			  (process-put p 'remote-pid pid)
 			  (tramp-set-connection-property p "remote-pid" pid))
-			(delete-region (point-min) (point-max))
+			;; `tramp-maybe-open-connection' and
+			;; `tramp-send-command-and-read' could have
+			;; trashed the connection buffer.  Remove this.
+			(widen)
+			(delete-region mark (point-max))
+			(narrow-to-region (point-max) (point-max))
 			;; Now do it.
 			(if command
 			    ;; Send the command.
@@ -2927,9 +2926,6 @@ the result will be a local, non-Tramp, file name."
 			     v 'file-error
 			     "pty association is not supported for `%s'"
 			     name))))
-		      ;; Stop process if indicated.
-		      (when stop
-			(stop-process p))
 		      ;; Set sentinel and filter.
 		      (when sentinel
 			(set-process-sentinel p sentinel))
@@ -3442,88 +3438,89 @@ the result will be a local, non-Tramp, file name."
 ;; any other remote command.
 (defun tramp-sh-handle-vc-registered (file)
   "Like `vc-registered' for Tramp files."
-  (with-temp-message ""
-    (with-parsed-tramp-file-name file nil
-      (with-tramp-progress-reporter
-	  v 3 (format-message "Checking `vc-registered' for %s" file)
-
-	;; There could be new files, created by the vc backend.  We
-	;; cannot reuse the old cache entries, therefore.  In
-	;; `tramp-get-file-property', `remote-file-name-inhibit-cache'
-	;; could also be a timestamp as `current-time' returns.  This
-	;; means invalidate all cache entries with an older timestamp.
-	(let (tramp-vc-registered-file-names
-	      (remote-file-name-inhibit-cache (current-time))
-	      (file-name-handler-alist
-	       `((,tramp-file-name-regexp . tramp-vc-file-name-handler))))
-
-	  ;; Here we collect only file names, which need an operation.
-	  (tramp-with-demoted-errors
-	      v "Error in 1st pass of `vc-registered': %s"
-	    (tramp-run-real-handler #'vc-registered (list file)))
-	  (tramp-message v 10 "\n%s" tramp-vc-registered-file-names)
-
-	  ;; Send just one command, in order to fill the cache.
-	  (when tramp-vc-registered-file-names
-	    (tramp-maybe-send-script
-	     v
-	     (format tramp-vc-registered-read-file-names
-		     (tramp-get-file-exists-command v)
-		     (format "%s -r" (tramp-get-test-command v)))
-	     "tramp_vc_registered_read_file_names")
-
-	    (dolist
-		(elt
-		 (ignore-errors
-		   ;; We cannot use `tramp-send-command-and-read',
-		   ;; because this does not cooperate well with
-		   ;; heredoc documents.
-		   (tramp-send-command
-		    v
-		    (format
-		     "tramp_vc_registered_read_file_names <<'%s'\n%s\n%s\n"
-		     tramp-end-of-heredoc
-		     (mapconcat #'tramp-shell-quote-argument
-				tramp-vc-registered-file-names
-				"\n")
-		     tramp-end-of-heredoc))
-		   (with-current-buffer (tramp-get-connection-buffer v)
-		     ;; Read the expression.
-		     (goto-char (point-min))
-		     (read (current-buffer)))))
-
-	      (tramp-set-file-property
-	       v (car elt) (cadr elt) (cadr (cdr elt))))))
-
-	;; Second run.  Now all `file-exists-p' or `file-readable-p'
-	;; calls shall be answered from the file cache.  We unset
-	;; `process-file-side-effects' and `remote-file-name-inhibit-cache'
-	;; in order to keep the cache.
-	(let ((vc-handled-backends vc-handled-backends)
-	      remote-file-name-inhibit-cache process-file-side-effects)
-	  ;; Reduce `vc-handled-backends' in order to minimize process calls.
-	  (when (and (memq 'Bzr vc-handled-backends)
-		     (boundp 'vc-bzr-program)
-		     (not (with-tramp-connection-property v vc-bzr-program
-			    (tramp-find-executable
-			     v vc-bzr-program (tramp-get-remote-path v)))))
-	    (setq vc-handled-backends (remq 'Bzr vc-handled-backends)))
-	  (when (and (memq 'Git vc-handled-backends)
-		     (boundp 'vc-git-program)
-		     (not (with-tramp-connection-property v vc-git-program
-			    (tramp-find-executable
-			     v vc-git-program (tramp-get-remote-path v)))))
-	    (setq vc-handled-backends (remq 'Git vc-handled-backends)))
-	  (when (and (memq 'Hg vc-handled-backends)
-		     (boundp 'vc-hg-program)
-		     (not (with-tramp-connection-property v vc-hg-program
-			    (tramp-find-executable
-			     v vc-hg-program (tramp-get-remote-path v)))))
-	    (setq vc-handled-backends (remq 'Hg vc-handled-backends)))
-	  ;; Run.
-	  (tramp-with-demoted-errors
-	      v "Error in 2nd pass of `vc-registered': %s"
-	    (tramp-run-real-handler #'vc-registered (list file))))))))
+  (when vc-handled-backends
+    (with-temp-message ""
+      (with-parsed-tramp-file-name file nil
+        (with-tramp-progress-reporter
+	    v 3 (format-message "Checking `vc-registered' for %s" file)
+
+	  ;; There could be new files, created by the vc backend.  We
+	  ;; cannot reuse the old cache entries, therefore.  In
+	  ;; `tramp-get-file-property', `remote-file-name-inhibit-cache'
+	  ;; could also be a timestamp as `current-time' returns.  This
+	  ;; means invalidate all cache entries with an older timestamp.
+	  (let (tramp-vc-registered-file-names
+	        (remote-file-name-inhibit-cache (current-time))
+	        (file-name-handler-alist
+	         `((,tramp-file-name-regexp . tramp-vc-file-name-handler))))
+
+	    ;; Here we collect only file names, which need an operation.
+	    (tramp-with-demoted-errors
+	        v "Error in 1st pass of `vc-registered': %s"
+	      (tramp-run-real-handler #'vc-registered (list file)))
+	    (tramp-message v 10 "\n%s" tramp-vc-registered-file-names)
+
+	    ;; Send just one command, in order to fill the cache.
+	    (when tramp-vc-registered-file-names
+	      (tramp-maybe-send-script
+	       v
+	       (format tramp-vc-registered-read-file-names
+		       (tramp-get-file-exists-command v)
+		       (format "%s -r" (tramp-get-test-command v)))
+	       "tramp_vc_registered_read_file_names")
+
+	      (dolist
+		  (elt
+		   (ignore-errors
+		     ;; We cannot use `tramp-send-command-and-read',
+		     ;; because this does not cooperate well with
+		     ;; heredoc documents.
+		     (tramp-send-command
+		      v
+		      (format
+		       "tramp_vc_registered_read_file_names <<'%s'\n%s\n%s\n"
+		       tramp-end-of-heredoc
+		       (mapconcat #'tramp-shell-quote-argument
+				  tramp-vc-registered-file-names
+				  "\n")
+		       tramp-end-of-heredoc))
+		     (with-current-buffer (tramp-get-connection-buffer v)
+		       ;; Read the expression.
+		       (goto-char (point-min))
+		       (read (current-buffer)))))
+
+	        (tramp-set-file-property
+	         v (car elt) (cadr elt) (cadr (cdr elt))))))
+
+	  ;; Second run.  Now all `file-exists-p' or `file-readable-p'
+	  ;; calls shall be answered from the file cache.  We unset
+	  ;; `process-file-side-effects' and `remote-file-name-inhibit-cache'
+	  ;; in order to keep the cache.
+	  (let ((vc-handled-backends vc-handled-backends)
+	        remote-file-name-inhibit-cache process-file-side-effects)
+	    ;; Reduce `vc-handled-backends' in order to minimize process calls.
+	    (when (and (memq 'Bzr vc-handled-backends)
+		       (boundp 'vc-bzr-program)
+		       (not (with-tramp-connection-property v vc-bzr-program
+			      (tramp-find-executable
+			       v vc-bzr-program (tramp-get-remote-path v)))))
+	      (setq vc-handled-backends (remq 'Bzr vc-handled-backends)))
+	    (when (and (memq 'Git vc-handled-backends)
+		       (boundp 'vc-git-program)
+		       (not (with-tramp-connection-property v vc-git-program
+			      (tramp-find-executable
+			       v vc-git-program (tramp-get-remote-path v)))))
+	      (setq vc-handled-backends (remq 'Git vc-handled-backends)))
+	    (when (and (memq 'Hg vc-handled-backends)
+		       (boundp 'vc-hg-program)
+		       (not (with-tramp-connection-property v vc-hg-program
+			      (tramp-find-executable
+			       v vc-hg-program (tramp-get-remote-path v)))))
+	      (setq vc-handled-backends (remq 'Hg vc-handled-backends)))
+	    ;; Run.
+	    (tramp-with-demoted-errors
+	        v "Error in 2nd pass of `vc-registered': %s"
+	      (tramp-run-real-handler #'vc-registered (list file)))))))))
 
 ;;;###tramp-autoload
 (defun tramp-sh-file-name-handler (operation &rest args)
@@ -3547,24 +3544,29 @@ Fall back to normal file name handler if no Tramp handler exists."
 	   (tramp-replace-environment-variables
 	    (apply #'tramp-file-name-for-operation operation args)))
 	  (fn (assoc operation tramp-sh-file-name-handler-alist)))
-      (with-parsed-tramp-file-name filename nil
-	(cond
-	 ;; That's what we want: file names, for which checks are
-	 ;; applied.  We assume that VC uses only `file-exists-p' and
-	 ;; `file-readable-p' checks; otherwise we must extend the
-	 ;; list.  We do not perform any action, but return nil, in
-	 ;; order to keep `vc-registered' running.
-	 ((and fn (memq operation '(file-exists-p file-readable-p)))
-	  (add-to-list 'tramp-vc-registered-file-names localname 'append)
-	  nil)
-	 ;; `process-file' and `start-file-process' shall be ignored.
-	 ((and fn (eq operation 'process-file) 0))
-	 ((and fn (eq operation 'start-file-process) nil))
-	 ;; Tramp file name handlers like `expand-file-name'.  They
-	 ;; must still work.
-	 (fn (save-match-data (apply (cdr fn) args)))
-	 ;; Default file name handlers, we don't care.
-	 (t (tramp-run-real-handler operation args)))))))
+      (if (tramp-tramp-file-p filename)
+	  (with-parsed-tramp-file-name filename nil
+	    (cond
+	     ;; That's what we want: file names, for which checks are
+	     ;; applied.  We assume that VC uses only `file-exists-p'
+	     ;; and `file-readable-p' checks; otherwise we must extend
+	     ;; the list.  We do not perform any action, but return
+	     ;; nil, in order to keep `vc-registered' running.
+	     ((and fn (memq operation '(file-exists-p file-readable-p)))
+	      (add-to-list 'tramp-vc-registered-file-names localname 'append)
+	      nil)
+	     ;; `process-file' and `start-file-process' shall be ignored.
+	     ((and fn (eq operation 'process-file) 0))
+	     ((and fn (eq operation 'start-file-process) nil))
+	     ;; Tramp file name handlers like `expand-file-name'.  They
+	     ;; must still work.
+	     (fn (save-match-data (apply (cdr fn) args)))
+	     ;; Default file name handlers, we don't care.
+	     (t (tramp-run-real-handler operation args))))
+
+	;; When `tramp-mode' is not enabled, or the file name is
+	;; quoted, we don't do anything.
+	(tramp-run-real-handler operation args)))))
 
 (defun tramp-sh-handle-file-notify-add-watch (file-name flags _callback)
   "Like `file-notify-add-watch' for Tramp files."
@@ -3642,6 +3644,7 @@ Fall back to normal file name handler if no Tramp handler exists."
 	(process-put p 'watch-name localname)
 	(set-process-query-on-exit-flag p nil)
 	(set-process-filter p filter)
+	(set-process-sentinel p #'tramp-file-notify-process-sentinel)
 	;; There might be an error if the monitor is not supported.
 	;; Give the filter a chance to read the output.
 	(while (tramp-accept-process-output p 0))
@@ -4617,21 +4620,19 @@ Goes through the list `tramp-inline-compress-commands'."
 
     ;; Ad-hoc proxy definitions.
     (dolist (proxy (reverse (split-string hops tramp-postfix-hop-regexp 'omit)))
-      (let ((user-domain (tramp-file-name-user-domain item))
-	    (host-port (tramp-file-name-host-port item))
-	    (proxy (concat
-		    tramp-prefix-format proxy tramp-postfix-host-format)))
-	(tramp-message
-	 vec 5 "Add proxy (\"%s\" \"%s\" \"%s\")"
-	 (and (stringp host-port) (regexp-quote host-port))
-	 (and (stringp user-domain) (regexp-quote user-domain))
-	 proxy)
+      (let* ((host-port (tramp-file-name-host-port item))
+	     (user-domain (tramp-file-name-user-domain item))
+	     (proxy (concat
+		     tramp-prefix-format proxy tramp-postfix-host-format))
+	     (entry
+	      (list (and (stringp host-port)
+			 (concat "^" (regexp-quote host-port) "$"))
+		    (and (stringp user-domain)
+			 (concat "^" (regexp-quote user-domain) "$"))
+		    (propertize proxy 'tramp-ad-hoc t))))
+	(tramp-message vec 5 "Add %S to `tramp-default-proxies-alist'" entry)
 	;; Add the hop.
-	(add-to-list
-	 'tramp-default-proxies-alist
-	 (list (and (stringp host-port) (regexp-quote host-port))
-	       (and (stringp user-domain) (regexp-quote user-domain))
-	       (propertize proxy 'tramp-ad-hoc t)))
+	(add-to-list 'tramp-default-proxies-alist entry)
 	(setq item (tramp-dissect-file-name proxy))))
     ;; Save the new value.
     (when (and hops tramp-save-ad-hoc-proxies)
@@ -5954,5 +5955,7 @@ function cell is returned to be applied on a buffer."
 ;; * Implement detaching/re-attaching remote sessions.  By this, a
 ;;   session could be reused after a connection loss.  Use dtach, or
 ;;   screen, or tmux, or mosh.
+;;
+;; * Implement `:stderr' of `make-process' as pipe process.
 
 ;;; tramp-sh.el ends here
diff --git a/lisp/net/tramp-smb.el b/lisp/net/tramp-smb.el
index 66476305c2..84725db216 100644
--- a/lisp/net/tramp-smb.el
+++ b/lisp/net/tramp-smb.el
@@ -452,9 +452,7 @@ pass to the OPERATION."
 			       (expand-file-name
 				tramp-temp-name-prefix
 				(tramp-compat-temporary-file-directory))))
-		   (args      (list (concat "//" host "/" share) "-E"))
-		   ;; We do not want to run timers.
-		   timer-list timer-idle-list)
+		   (args      (list (concat "//" host "/" share) "-E")))
 
 	      (if (not (zerop (length user)))
 		  (setq args (append args (list "-U" user)))
@@ -742,9 +740,7 @@ PRESERVE-UID-GID and PRESERVE-EXTENDED-ATTRIBUTES are completely ignored."
 	  (let* ((share     (tramp-smb-get-share v))
 		 (localname (replace-regexp-in-string
 			     "\\\\" "/" (tramp-smb-get-localname v)))
-		 (args      (list (concat "//" host "/" share) "-E"))
-		 ;; We do not want to run timers.
-		 timer-list timer-idle-list)
+		 (args      (list (concat "//" host "/" share) "-E")))
 
 	    (if (not (zerop (length user)))
 		(setq args (append args (list "-U" user)))
@@ -1165,11 +1161,13 @@ component is used as the target of the symlink."
 
     (with-parsed-tramp-file-name linkname nil
       ;; If TARGET is a Tramp name, use just the localname component.
-      (when (and (tramp-tramp-file-p target)
-		 (tramp-file-name-equal-p v (tramp-dissect-file-name target)))
-	(setq target
-	      (tramp-file-name-localname
-	       (tramp-dissect-file-name (expand-file-name target)))))
+      ;; Don't check for a proper method.
+      (let ((non-essential t))
+	(when (and (tramp-tramp-file-p target)
+		   (tramp-file-name-equal-p v (tramp-dissect-file-name target)))
+	  (setq target
+		(tramp-file-name-localname
+		 (tramp-dissect-file-name (expand-file-name target))))))
 
       ;; If TARGET is still remote, quote it.
       (if (tramp-tramp-file-p target)
@@ -1218,8 +1216,6 @@ component is used as the target of the symlink."
     (let* ((name (file-name-nondirectory program))
 	   (name1 name)
 	   (i 0)
-	   ;; We do not want to run timers.
-	   timer-list timer-idle-list
 	   input tmpinput outbuf command ret)
 
       ;; Determine input.
@@ -1395,9 +1391,7 @@ component is used as the target of the symlink."
 			   "\\\\" "/" (tramp-smb-get-localname v)))
 	       (args      (list (concat "//" host "/" share) "-E" "-S"
 				(replace-regexp-in-string
-				 "\n" "," acl-string)))
-	       ;; We do not want to run timers.
-	       timer-list timer-idle-list)
+				 "\n" "," acl-string))))
 
 	  (if (not (zerop (length user)))
 	      (setq args (append args (list "-U" user)))
@@ -1477,9 +1471,7 @@ component is used as the target of the symlink."
 	   (command (mapconcat #'identity (cons program args) " "))
 	   (bmp (and (buffer-live-p buffer) (buffer-modified-p buffer)))
 	   (name1 name)
-	   (i 0)
-	   ;; We do not want to run timers.
-	   timer-list timer-idle-list)
+	   (i 0))
       (unwind-protect
 	  (save-excursion
 	    (save-restriction
diff --git a/lisp/net/tramp-sudoedit.el b/lisp/net/tramp-sudoedit.el
index 0d9e04d0bd..f056e73366 100644
--- a/lisp/net/tramp-sudoedit.el
+++ b/lisp/net/tramp-sudoedit.el
@@ -607,11 +607,13 @@ component is used as the target of the symlink."
 
     (with-parsed-tramp-file-name linkname nil
       ;; If TARGET is a Tramp name, use just the localname component.
-      (when (and (tramp-tramp-file-p target)
-		 (tramp-file-name-equal-p v (tramp-dissect-file-name target)))
-	(setq target
-	      (tramp-file-name-localname
-	       (tramp-dissect-file-name (expand-file-name target)))))
+      ;; Don't check for a proper method.
+      (let ((non-essential t))
+	(when (and (tramp-tramp-file-p target)
+		   (tramp-file-name-equal-p v (tramp-dissect-file-name target)))
+	  (setq target
+		(tramp-file-name-localname
+		 (tramp-dissect-file-name (expand-file-name target))))))
 
       ;; If TARGET is still remote, quote it.
       (if (tramp-tramp-file-p target)
@@ -780,7 +782,7 @@ connection if a previous connection has died for some reason."
       (throw 'non-essential 'non-essential))
 
     (let ((p (make-network-process
-	      :name (tramp-buffer-name vec)
+	      :name (tramp-get-connection-name vec)
 	      :buffer (tramp-get-connection-buffer vec)
 	      :server t :host 'local :service t :noquery t)))
       (process-put p 'vector vec)
diff --git a/lisp/net/tramp.el b/lisp/net/tramp.el
index 32963ac543..f6dd6b5866 100644
--- a/lisp/net/tramp.el
+++ b/lisp/net/tramp.el
@@ -9,6 +9,7 @@
 ;; Package: tramp
 ;; Version: 2.4.2-pre
 ;; Package-Requires: ((emacs "24.1"))
+;; URL: https://savannah.gnu.org/projects/tramp
 
 ;; This file is part of GNU Emacs.
 
@@ -605,7 +606,10 @@ The regexp should match at end of buffer."
 
 (defcustom tramp-yesno-prompt-regexp
   (concat
-   (regexp-opt '("Are you sure you want to continue connecting (yes/no)?") t)
+   (regexp-opt
+    '("Are you sure you want to continue connecting (yes/no)?"
+      "Are you sure you want to continue connecting (yes/no/[fingerprint])?")
+    t)
    "\\s-*")
   "Regular expression matching all yes/no queries which need to be confirmed.
 The confirmation should be done with yes or no.
@@ -1431,6 +1435,12 @@ default values are used."
 	    (setq v (make-tramp-file-name
 		     :method method :user user :domain domain :host host
 		     :port port :localname localname :hop hop))
+	  ;; The method must be known.
+	  (unless (or (tramp-completion-mode-p)
+		      (string-equal method tramp-default-method-marker)
+		      (assoc method tramp-methods))
+	    (tramp-user-error
+	     v "Method `%s' is not known." method))
 	  ;; Only some methods from tramp-sh.el do support multi-hops.
 	  (when (and
 		 hop
@@ -1637,8 +1647,6 @@ The outline level is equal to the verbosity of the Tramp message."
       (get-buffer-create (tramp-debug-buffer-name vec))
     (when (bobp)
       (setq buffer-undo-list t)
-      ;; So it does not get loaded while `outline-regexp' is let-bound.
-      (require 'outline)
       ;; Activate `outline-mode'.  This runs `text-mode-hook' and
       ;; `outline-mode-hook'.  We must prevent that local processes
       ;; die.  Yes: I've seen `flyspell-mode', which starts "ispell".
@@ -2138,7 +2146,11 @@ pass to the OPERATION."
 ;; function as well but regexp only.
 (defun tramp-file-name-for-operation (operation &rest args)
   "Return file name related to OPERATION file primitive.
-ARGS are the arguments OPERATION has been called with."
+ARGS are the arguments OPERATION has been called with.
+
+It does not always return a Tramp file name, for example if the
+first argument of `expand-file-name' is absolute and not remote.
+Must be handled by the callers."
   (cond
    ;; FILE resp DIRECTORY.
    ((member operation
@@ -2169,17 +2181,16 @@ ARGS are the arguments OPERATION has been called with."
     (if (file-name-absolute-p (nth 0 args))
 	(nth 0 args)
       default-directory))
+   ;; STRING FILE.
+   ;; Starting with Emacs 26.1, just the 2nd argument of
+   ;; `make-symbolic-link' matters.
+   ((eq operation 'make-symbolic-link) (nth 1 args))
    ;; FILE DIRECTORY resp FILE1 FILE2.
    ((member operation
 	    '(add-name-to-file copy-directory copy-file
 	      file-equal-p file-in-directory-p
 	      file-name-all-completions file-name-completion
-	      ;; Starting with Emacs 26.1, just the 2nd argument of
-	      ;; `make-symbolic-link' matters.  For backward
-	      ;; compatibility, we still accept the first argument as
-	      ;; file name to be checked.  Handled properly in
-	      ;; `tramp-handle-*-make-symbolic-link'.
-	      file-newer-than-file-p make-symbolic-link rename-file))
+	      file-newer-than-file-p rename-file))
     (cond
      ((tramp-tramp-file-p (nth 0 args)) (nth 0 args))
      ((tramp-tramp-file-p (nth 1 args)) (nth 1 args))
@@ -2274,7 +2285,10 @@ preventing reentrant calls of Tramp.")
 (defun tramp-file-name-handler (operation &rest args)
   "Invoke Tramp file name handler.
 Falls back to normal file name handler if no Tramp file name handler exists."
-  (let ((filename (apply #'tramp-file-name-for-operation operation args)))
+  (let ((filename (apply #'tramp-file-name-for-operation operation args))
+	;; `file-remote-p' is called for everything, even for symbolic
+	;; links which look remote.  We don't want to get an error.
+	(non-essential (or non-essential (eq operation 'file-remote-p))))
     (if (tramp-tramp-file-p filename)
 	(save-match-data
           (setq filename (tramp-replace-environment-variables filename))
@@ -2950,7 +2964,9 @@ Host is always \"localhost\"."
 (defun tramp-parse-netrc (filename)
   "Return a list of (user host) tuples allowed to access.
 User may be nil."
-  (require 'netrc)
+  ;; The declaration is not sufficient at runtime, because netrc.el is
+  ;; not autoloaded.
+  (autoload 'netrc-parse "netrc")
   (mapcar
    (lambda (item)
      (and (assoc "machine" item)
@@ -3383,6 +3399,7 @@ User is always nil."
     (access-file filename "Reading directory"))
   (with-parsed-tramp-file-name (expand-file-name filename) nil
     (with-tramp-progress-reporter v 0 (format "Opening directory %s" filename)
+      ;; We must load it in order to get the advice around `insert-directory'.
       (require 'ls-lisp)
       (let (ls-lisp-use-insert-directory-program start)
 	(tramp-run-real-handler
@@ -3638,17 +3655,25 @@ support symbolic links."
 	(erase-buffer)))
 
     (if (and (not current-buffer-p) (integerp asynchronous))
-	(prog1
-	    ;; Run the process.
-	    (setq p (start-file-process-shell-command
-		     (buffer-name output-buffer) buffer command))
-	  ;; Display output.
-	  (with-current-buffer output-buffer
-	    (display-buffer output-buffer '(nil (allow-no-window . t)))
-	    (setq mode-line-process '(":%s"))
-	    (shell-mode)
-	    (set-process-sentinel p #'shell-command-sentinel)
-	    (set-process-filter p #'comint-output-filter)))
+	(let ((tramp-remote-process-environment
+	       ;; `async-shell-command-width' has been introduced with
+	       ;; Emacs 27.1.
+	       (if (natnump (bound-and-true-p async-shell-command-width))
+		   (cons (format "COLUMNS=%d"
+				 (bound-and-true-p async-shell-command-width))
+			 tramp-remote-process-environment)
+		 tramp-remote-process-environment)))
+	  (prog1
+	      ;; Run the process.
+	      (setq p (start-file-process-shell-command
+		       (buffer-name output-buffer) buffer command))
+	    ;; Display output.
+	    (with-current-buffer output-buffer
+	      (display-buffer output-buffer '(nil (allow-no-window . t)))
+	      (setq mode-line-process '(":%s"))
+	      (shell-mode)
+	      (set-process-sentinel p #'shell-command-sentinel)
+	      (set-process-filter p #'comint-output-filter))))
 
       (prog1
 	  ;; Run the process.
@@ -3847,6 +3872,12 @@ of."
 	  (concat (file-remote-p default-directory)
 		  (process-get proc 'watch-name))))))
 
+(defun tramp-file-notify-process-sentinel (proc event)
+  "Call `file-notify-rm-watch'."
+  (unless (process-live-p proc)
+    (tramp-message proc 5 "Sentinel called: `%S' `%s'" proc event)
+    (tramp-compat-funcall 'file-notify-rm-watch proc)))
+
 ;;; Functions for establishing connection:
 
 ;; The following functions are actions to be taken when seeing certain
@@ -4073,15 +4104,7 @@ for process communication also."
   (with-current-buffer (process-buffer proc)
     (let ((inhibit-read-only t)
 	  last-coding-system-used
-	  ;; We do not want to run timers.
-	  (tl timer-list)
-          (stimers (with-timeout-suspend))
-	  timer-list timer-idle-list
 	  result)
-      ;; Enable our progress reporter.
-      (dolist (timer tl)
-	(if (eq (timer--function timer) #'tramp-progress-reporter-update)
-            (push timer timer-list)))
       ;; JUST-THIS-ONE is set due to Bug#12145.
       (tramp-message
        proc 10 "%s %s %s %s\n%s"
@@ -4089,8 +4112,6 @@ for process communication also."
        (with-local-quit
 	 (setq result (accept-process-output proc timeout nil t)))
        (buffer-string))
-      ;; Reenable the timers.
-      (with-timeout-unsuspend stimers)
       result)))
 
 (defun tramp-check-for-regexp (proc regexp)
@@ -4171,20 +4192,12 @@ The STRING is expected to use Unix line-endings, but the lines sent to
 the remote host use line-endings as defined in the variable
 `tramp-rsh-end-of-line'.  The communication buffer is erased before sending."
   (let* ((p (tramp-get-connection-process vec))
-	 (chunksize (tramp-get-connection-property p "chunksize" nil))
-	 ;; We do not want to run timers.
-	 (tl timer-list)
-         (stimers (with-timeout-suspend))
-	 timer-list timer-idle-list)
+	 (chunksize (tramp-get-connection-property p "chunksize" nil)))
     (unless p
       (tramp-error
        vec 'file-error "Can't send string to remote host -- not logged in"))
     (tramp-set-connection-property p "last-cmd-time" (current-time))
     (tramp-message vec 10 "%s" string)
-    ;; Enable our progress reporter.
-    (dolist (timer tl)
-      (if (eq (timer--function timer) #'tramp-progress-reporter-update)
-          (push timer timer-list)))
     (with-current-buffer (tramp-get-connection-buffer vec)
       ;; Clean up the buffer.  We cannot call `erase-buffer' because
       ;; narrowing might be in effect.
@@ -4208,9 +4221,7 @@ the remote host use line-endings as defined in the variable
 		(process-send-string
 		 p (substring string pos (min (+ pos chunksize) end)))
 		(setq pos (+ pos chunksize))))
-	  (process-send-string p string)))
-      ;; Reenable the timers.
-      (with-timeout-unsuspend stimers))))
+	  (process-send-string p string))))))
 
 (defun tramp-process-sentinel (proc event)
   "Flush file caches and remove shell prompt."
@@ -4634,6 +4645,7 @@ It always returns a return code.  The Lisp error raised when
 PROGRAM is nil is trapped also, returning 1.  Furthermore, traces
 are written with verbosity of 6."
   (let ((default-directory (tramp-compat-temporary-file-directory))
+	(process-environment (default-toplevel-value 'process-environment))
 	(destination (if (eq destination t) (current-buffer) destination))
 	(vec (or vec (car tramp-current-connection)))
 	output error result)
@@ -4667,6 +4679,7 @@ It always returns a return code.  The Lisp error raised when
 PROGRAM is nil is trapped also, returning 1.  Furthermore, traces
 are written with verbosity of 6."
   (let ((default-directory (tramp-compat-temporary-file-directory))
+	(process-environment (default-toplevel-value 'process-environment))
 	(buffer (if (eq buffer t) (current-buffer) buffer))
 	result)
     (tramp-message
@@ -4696,6 +4709,7 @@ are written with verbosity of 6."
 If an error occurs, it returns nil.  Traces are written with
 verbosity of 6."
   (let ((default-directory (tramp-compat-temporary-file-directory))
+	(process-environment (default-toplevel-value 'process-environment))
 	(vec (or vec (car tramp-current-connection)))
 	result)
     (if args
@@ -4863,13 +4877,11 @@ Only works for Bourne-like shells."
 	(tramp-compat-funcall
 	 'tramp-send-command
 	 (process-get proc 'vector)
-	 (format "kill -2 %d" pid))
+	 (format "kill -2 -%d" pid))
 	;; Wait, until the process has disappeared.  If it doesn't,
 	;; fall back to the default implementation.
-	(with-timeout (1 (ignore))
-	  (while (tramp-accept-process-output proc))
-	  ;; Report success.
-	  proc)))))
+        (while (tramp-accept-process-output proc 0))
+	(not (process-live-p proc))))))
 
 ;; `interrupt-process-functions' exists since Emacs 26.1.
 (when (boundp 'interrupt-process-functions)
@@ -4883,7 +4895,6 @@ Only works for Bourne-like shells."
 ;; - Unload all `tramp-*' packages
 ;; - Reset `file-name-handler-alist'
 ;; - Cleanup hooks where Tramp functions are in
-;; - Cleanup advised functions
 ;; - Cleanup autoloads
 ;;;###autoload
 (defun tramp-unload-tramp ()
diff --git a/lisp/newcomment.el b/lisp/newcomment.el
index 9d919ccbbe..ac706b949b 100644
--- a/lisp/newcomment.el
+++ b/lisp/newcomment.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: code extracted from Emacs-20's simple.el
-;; Maintainer: Stefan Monnier <monnier@iro.umontreal.ca>
+;; Maintainer: Stefan Monnier <monnier@gnu.org>
 ;; Keywords: comment uncomment
 ;; Package: emacs
 
@@ -1001,7 +1001,15 @@ This function is the default value of `uncomment-region-function'."
 		       (re-search-forward sre (line-end-position) t))
 		(replace-match "" t t nil (if (match-end 2) 2 1)))))
 	  ;; Go to the end for the next comment.
-	  (goto-char (point-max))))))
+	  (goto-char (point-max)))
+        ;; Remove any obtrusive spaces left preceding a tab at `spt'.
+        (when (and (eq (char-after spt) ?\t) (eq (char-before spt) ? )
+                   (> tab-width 0))
+          (save-excursion
+            (goto-char spt)
+            (let* ((fcol (current-column))
+                   (slim (- (point) (mod fcol tab-width))))
+              (delete-char (- (skip-chars-backward " " slim)))))))))
   (set-marker end nil))
 
 (defun uncomment-region-default (beg end &optional arg)
diff --git a/lisp/nxml/nxml-mode.el b/lisp/nxml/nxml-mode.el
index 6f80912dd5..5c906a9d51 100644
--- a/lisp/nxml/nxml-mode.el
+++ b/lisp/nxml/nxml-mode.el
@@ -424,6 +424,30 @@ reference.")
     (when rng-validate-mode
       (rng-validate-while-idle (current-buffer)))))
 
+(defvar nxml-prolog-end) ;; nxml-rap.el
+
+(defun nxml-syntax-propertize (start end)
+  "Syntactic keywords for `nxml-mode'."
+  ;; Like `sgml-syntax-propertize', but handle `nxml-prolog-regions'.
+  (when (< start nxml-prolog-end)
+    (catch 'done-prolog
+      (dolist (prolog-elem nxml-prolog-regions)
+        (let ((type (aref prolog-elem 0))
+              (pbeg (aref prolog-elem 1))
+              (pend (aref prolog-elem 2)))
+          (when (eq type 'comment)
+            (put-text-property pbeg (1+ pbeg)
+                               'syntax-table (string-to-syntax "< b"))
+            (put-text-property (1- pend) pend
+                               'syntax-table (string-to-syntax "> b")))
+          (when (> pend end)
+            (throw 'done-prolog t)))))
+    (setq start nxml-prolog-end))
+  (if (>= start end)
+      (goto-char end)
+    (goto-char start)
+    (sgml-syntax-propertize start end)))
+
 (defvar tildify-space-string)
 (defvar tildify-foreach-region-function)
 
@@ -518,8 +542,9 @@ Many aspects this mode can be customized using
 	(nxml-with-invisible-motion
 	  (nxml-scan-prolog)))))
   (setq-local syntax-ppss-table sgml-tag-syntax-table)
-  (setq-local syntax-propertize-function #'sgml-syntax-propertize)
+  (setq-local syntax-propertize-function #'nxml-syntax-propertize)
   (add-hook 'change-major-mode-hook #'nxml-cleanup nil t)
+  (add-hook 'after-change-functions #'nxml-maybe-rescan-prolog nil t)
 
   ;; Emacs 23 handles the encoding attribute on the xml declaration
   ;; transparently to nxml-mode, so there is no longer a need for the below
@@ -540,7 +565,9 @@ Many aspects this mode can be customized using
           nil  ; no special syntax table
           (font-lock-extend-region-functions . (nxml-extend-region))
           (jit-lock-contextually . t)
-          (font-lock-unfontify-region-function . nxml-unfontify-region)))
+          (font-lock-unfontify-region-function . nxml-unfontify-region)
+          (font-lock-syntactic-face-function
+           . sgml-font-lock-syntactic-face)))
 
   (with-demoted-errors (rng-nxml-mode-init)))
 
@@ -2379,7 +2406,9 @@ With a prefix argument, inserts the character directly."
 (put 'nxml-char-ref 'evaporate t)
 
 (defun nxml-char-ref-display-extra (start end n)
-  (when nxml-char-ref-extra-display
+  (when (and ;; Displaying literal newline is unhelpful.
+         (not (eql n ?\n))
+         nxml-char-ref-extra-display)
     (let ((name (or (get-char-code-property n 'name)
                     (get-char-code-property n 'old-name)))
 	  (glyph-string (and nxml-char-ref-display-glyph-flag
diff --git a/lisp/nxml/nxml-rap.el b/lisp/nxml/nxml-rap.el
index 2bd758be3a..3be413ae00 100644
--- a/lisp/nxml/nxml-rap.el
+++ b/lisp/nxml/nxml-rap.el
@@ -35,35 +35,25 @@
 ;;
 ;; Our strategy is to keep track of just the problematic things.
 ;; Specifically, we keep track of all comments, CDATA sections and
-;; processing instructions in the instance.  We do this by marking all
-;; except the first character of these with a non-nil nxml-inside text
-;; property. The value of the nxml-inside property is comment,
-;; cdata-section or processing-instruction.  The first character does
-;; not have the nxml-inside property so we can find the beginning of
-;; the construct by looking for a change in a text property value
-;; (Emacs provides primitives for this).  We use text properties
-;; rather than overlays, since the implementation of overlays doesn't
-;; look like it scales to large numbers of overlays in a buffer.
-;;
-;; We don't in fact track all these constructs, but only track them in
-;; some initial part of the instance.
+;; processing instructions in the instance.  We do this by marking
+;; the first character of these with the generic string syntax by setting
+;; a 'syntax-table' text property in `sgml-syntax-propertize'.
 ;;
 ;; Thus to parse some random point in the file we first ensure that we
-;; have scanned up to that point.  Then we search backwards for a
-;; <. Then we check whether the < has an nxml-inside property. If it
-;; does we go backwards to first character that does not have an
-;; nxml-inside property (this character must be a <).  Then we start
-;; parsing forward from the < we have found.
+;; have scanned up to that point.  Then we search backwards for a <.
+;; Then we check whether the < has the generic string syntax.  If it
+;; does we go backwards to first character of the generic string (this
+;; character must be a <).  Then we start parsing forward from the <
+;; we have found.
 ;;
 ;; The prolog has to be parsed specially, so we also keep track of the
 ;; end of the prolog in `nxml-prolog-end'. The prolog is reparsed on
 ;; every change to the prolog.  This won't work well if people try to
 ;; edit huge internal subsets. Hopefully that will be rare.
 ;;
-;; We keep track of the changes by adding to the buffer's
-;; after-change-functions hook.  Scanning is also done as a
-;; prerequisite to fontification by adding to fontification-functions
-;; (in the same way as jit-lock).  This means that scanning for these
+;; We rely on the `syntax-propertize-function' machinery to keep track
+;; of the changes in the buffer.  Fontification also relies on correct
+;; `syntax-table' properties.  This means that scanning for these
 ;; constructs had better be quick.  Fortunately it is. Firstly, the
 ;; typical proportion of comments, CDATA sections and processing
 ;; instructions is small relative to other things.  Secondly, to scan
@@ -79,7 +69,15 @@
   "Integer giving position following end of the prolog.")
 
 (defsubst nxml-get-inside (pos)
-  (save-excursion (nth 8 (syntax-ppss pos))))
+  "Return non-nil if inside comment, CDATA, or PI."
+  (let ((ppss (save-excursion (syntax-ppss pos))))
+    (or
+     ;; Inside comment.
+     (nth 4 ppss)
+     ;; Inside "generic" string which is used for CDATA, and PI.
+     ;; "Normal" double and single quoted strings are used for
+     ;; attribute values.
+     (eq t (nth 3 ppss)))))
 
 (defun nxml-inside-end (pos)
   "Return the end of the inside region containing POS.
@@ -110,6 +108,12 @@ Return nil if the character at POS is not inside."
     (setq nxml-prolog-regions (xmltok-forward-prolog))
     (setq nxml-prolog-end (point))))
 
+(defun nxml-maybe-rescan-prolog (start _end _length)
+  "Reparse the prolog if START lies within it.
+`nxml-mode' adds this function on `after-change-functions'."
+  (when (<= start nxml-prolog-end)
+    (save-excursion
+      (nxml-scan-prolog))))
 
 ;;; Random access parsing
 
diff --git a/lisp/obsolete/fast-lock.el b/lisp/obsolete/fast-lock.el
index 5180d4527b..9ae6d91bde 100644
--- a/lisp/obsolete/fast-lock.el
+++ b/lisp/obsolete/fast-lock.el
@@ -161,7 +161,7 @@
 ;; - XEmacs: Add `font-lock-value-in-major-mode' if necessary
 ;; - Removed `fast-lock-submit-bug-report' and bade farewell
 ;; 3.11--3.12:
-;; - Added Custom support (Hrvoje Niksic help)
+;; - Added Custom support (Hrvoje Nikšić help)
 ;; - Made `save-buffer-state' wrap `inhibit-point-motion-hooks'
 ;; - Made `fast-lock-cache-data' simplify calls of `font-lock-compile-keywords'
 ;; 3.12--3.13:
@@ -214,23 +214,6 @@
                     (setq faces (cdr faces))))
            faces)))))
 
-;;(defun fast-lock-submit-bug-report ()
-;;  "Submit via mail a bug report on fast-lock.el."
-;;  (interactive)
-;;  (let ((reporter-prompt-for-summary-p t))
-;;    (reporter-submit-bug-report "simon@gnu.org" "fast-lock 3.14"
-;;     '(fast-lock-cache-directories fast-lock-minimum-size
-;;       fast-lock-save-others fast-lock-save-events fast-lock-save-faces
-;;       fast-lock-verbose)
-;;     nil nil
-;;     (concat "Hi Si.,
-;;
-;;I want to report a bug.  I've read the `Bugs' section of `Info' on Emacs, so I
-;;know how to make a clear and unambiguous report.  To reproduce the bug:
-;;
-;;Start a fresh editor via `" invocation-name " -no-init-file -no-site-file'.
-;;In the `*scratch*' buffer, evaluate:"))))
-
 (defgroup fast-lock nil
   "Font Lock support mode to cache fontification."
   :load 'fast-lock
diff --git a/lisp/obsolete/info-edit.el b/lisp/obsolete/info-edit.el
new file mode 100644
index 0000000000..b64e84003f
--- /dev/null
+++ b/lisp/obsolete/info-edit.el
@@ -0,0 +1,83 @@
+;; info-edit.el --- Editing info files  -*- lexical-binding:t -*-
+
+;; Copyright (C) 1985-1986, 1992-2019 Free Software Foundation, Inc.
+
+;; Maintainer: emacs-devel@gnu.org
+;; Keywords: help
+;; Obsolete-since: 24.4
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;; Code:
+
+(require 'info)
+
+(defvar Info-edit-mode-hook nil
+  "Hook run when `Info-edit-mode' is activated.")
+
+(make-obsolete-variable 'Info-edit-mode-hook
+			"editing Info nodes by hand is not recommended." "24.4")
+
+(define-obsolete-variable-alias 'Info-edit-map 'Info-edit-mode-map "24.1")
+(defvar Info-edit-mode-map (let ((map (make-sparse-keymap)))
+                             (set-keymap-parent map text-mode-map)
+                             (define-key map "\C-c\C-c" 'Info-cease-edit)
+                             map)
+  "Local keymap used within `e' command of Info.")
+
+(make-obsolete-variable 'Info-edit-mode-map
+			"editing Info nodes by hand is not recommended."
+			"24.4")
+
+;; Info-edit mode is suitable only for specially formatted data.
+(put 'Info-edit-mode 'mode-class 'special)
+
+(define-derived-mode Info-edit-mode text-mode "Info Edit"
+  "Major mode for editing the contents of an Info node.
+Like text mode with the addition of `Info-cease-edit'
+which returns to Info mode for browsing."
+  (setq buffer-read-only nil)
+  (force-mode-line-update)
+  (buffer-enable-undo (current-buffer)))
+
+(defun Info-edit ()
+  "Edit the contents of this Info node."
+  (interactive)
+  (Info-edit-mode)
+  (message "%s" (substitute-command-keys
+		 "Editing: Type \\<Info-edit-mode-map>\\[Info-cease-edit] to return to info")))
+
+(put 'Info-edit 'disabled "Editing Info nodes by hand is not recommended.
+This feature will be removed in future.")
+
+(defun Info-cease-edit ()
+  "Finish editing Info node; switch back to Info proper."
+  (interactive)
+  ;; Do this first, so nothing has changed if user C-g's at query.
+  (and (buffer-modified-p)
+       (y-or-n-p "Save the file? ")
+       (save-buffer))
+  (Info-mode)
+  (force-mode-line-update)
+  (and (marker-position Info-tag-table-marker)
+       (buffer-modified-p)
+       (message "Tags may have changed.  Use Info-tagify if necessary")))
+
+(provide 'info-edit)
+
+;;; info-edit.el ends here
diff --git a/lisp/obsolete/iswitchb.el b/lisp/obsolete/iswitchb.el
index 5b0df1e695..ad2067fdef 100644
--- a/lisp/obsolete/iswitchb.el
+++ b/lisp/obsolete/iswitchb.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1996-1997, 2000-2019 Free Software Foundation, Inc.
 
 ;; Author: Stephen Eglen <stephen@gnu.org>
-;; Maintainer: Stephen Eglen <stephen@gnu.org>
 ;; Keywords: completion convenience
 ;; Obsolete-since: 24.4
 
diff --git a/lisp/obsolete/longlines.el b/lisp/obsolete/longlines.el
index 2ef5324e51..f221322824 100644
--- a/lisp/obsolete/longlines.el
+++ b/lisp/obsolete/longlines.el
@@ -5,7 +5,6 @@
 ;; Authors:    Kai Grossjohann <Kai.Grossjohann@CS.Uni-Dortmund.DE>
 ;;             Alex Schroeder <alex@gnu.org>
 ;;             Chong Yidong <cyd@stupidchicken.com>
-;; Maintainer: Chong Yidong <cyd@stupidchicken.com>
 ;; Obsolete-since: 24.4
 ;; Keywords: convenience, wp
 
diff --git a/lisp/obsolete/tpu-edt.el b/lisp/obsolete/tpu-edt.el
index 8db1c4f5f1..0848135715 100644
--- a/lisp/obsolete/tpu-edt.el
+++ b/lisp/obsolete/tpu-edt.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1993-1995, 2000-2019 Free Software Foundation, Inc.
 
 ;; Author: Rob Riepel <riepel@networking.stanford.edu>
-;; Maintainer: Rob Riepel <riepel@networking.stanford.edu>
 ;; Version: 4.5
 ;; Keywords: emulations
 ;; Obsolete-since: 24.5
diff --git a/lisp/obsolete/tpu-extras.el b/lisp/obsolete/tpu-extras.el
index f19a67dd48..8b5818dfca 100644
--- a/lisp/obsolete/tpu-extras.el
+++ b/lisp/obsolete/tpu-extras.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1993-1995, 2000-2019 Free Software Foundation, Inc.
 
 ;; Author: Rob Riepel <riepel@networking.stanford.edu>
-;; Maintainer: Rob Riepel <riepel@networking.stanford.edu>
 ;; Keywords: emulations
 ;; Package: tpu-edt
 ;; Obsolete-since: 24.5
diff --git a/lisp/obsolete/tpu-mapper.el b/lisp/obsolete/tpu-mapper.el
index 60e0e49b8b..a7aa0cb0d0 100644
--- a/lisp/obsolete/tpu-mapper.el
+++ b/lisp/obsolete/tpu-mapper.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1993-1995, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Rob Riepel <riepel@networking.stanford.edu>
-;; Maintainer: Rob Riepel <riepel@networking.stanford.edu>
 ;; Keywords: emulations
 ;; Package: tpu-edt
 ;; Obsolete-since: 24.5
diff --git a/lisp/obsolete/ws-mode.el b/lisp/obsolete/ws-mode.el
index 05dca959da..1615610671 100644
--- a/lisp/obsolete/ws-mode.el
+++ b/lisp/obsolete/ws-mode.el
@@ -1,4 +1,4 @@
-;;; ws-mode.el --- WordStar emulation mode for GNU Emacs
+;;; ws-mode.el --- WordStar emulation mode for GNU Emacs -*- lexical-binding: t -*-
 
 ;; Copyright (C) 1991, 2001-2019 Free Software Foundation, Inc.
 
@@ -24,9 +24,20 @@
 
 ;;; Commentary:
 
-;; This emulates WordStar, with a major mode.
+;; This provides emulation of WordStar with a minor mode.
 
 ;;; Code:
+
+(defgroup wordstar nil
+  "WordStar emulation within Emacs."
+  :prefix "wordstar-"
+  :prefix "ws-"
+  :group 'emulations)
+
+(defcustom wordstar-mode-lighter " WordStar"
+  "Lighter shown in the modeline for `wordstar' mode."
+  :type 'string)
+
 (defvar wordstar-C-k-map
   (let ((map (make-keymap)))
     (define-key map " " ())
@@ -98,8 +109,7 @@
     (define-key map "wh" 'split-window-right)
     (define-key map "wo" 'other-window)
     (define-key map "wv" 'split-window-below)
-    map)
-  "")
+    map))
 
 (defvar wordstar-C-q-map
   (let ((map (make-keymap)))
@@ -174,12 +184,9 @@
 ;; wordstar-C-j-map not yet implemented
 (defvar wordstar-C-j-map nil)
 
-
-(put 'wordstar-mode 'mode-class 'special)
-
 ;;;###autoload
-(define-derived-mode wordstar-mode fundamental-mode "WordStar"
-  "Major mode with WordStar-like key bindings.
+(define-minor-mode wordstar-mode
+  "Minor mode with WordStar-like key bindings.
 
 BUGS:
  - Help menus with WordStar commands (C-j just calls help-for-help)
@@ -189,8 +196,18 @@ BUGS:
  - Search and replace (C-q a) is only available in forward direction
 
 No key bindings beginning with ESC are installed, they will work
-Emacs-like.")
+Emacs-like."
+  :group 'wordstar
+  :lighter wordstar-mode-lighter
+  :keymap wordstar-mode-map)
+
+(defun turn-on-wordstar-mode ()
+  (when (and (not (minibufferp))
+             (not wordstar-mode))
+    (wordstar-mode 1)))
 
+(define-globalized-minor-mode global-wordstar-mode wordstar-mode
+  turn-on-wordstar-mode)
 
 (defun wordstar-center-paragraph ()
   "Center each line in the paragraph at or after point.
@@ -254,7 +271,7 @@ the distance between the end of the text and `fill-column'."
 
 (defvar ws-search-string nil "String of last search in WordStar mode.")
 (defvar ws-search-direction t
-  "Direction of last search in WordStar mode. t if forward, nil if backward.")
+  "Direction of last search in WordStar mode.  t if forward, nil if backward.")
 
 (defvar ws-last-cursorposition nil
   "Position before last search etc. in WordStar mode.")
@@ -266,71 +283,12 @@ the distance between the end of the text and `fill-column'."
 ;; wordstar special functions:
 
 (defun ws-error (string)
-  "Report error of a WordStar special function. Error message is saved
-in ws-last-errormessage for recovery with C-q w."
+  "Report error of a WordStar special function.
+Error message is saved in `ws-last-errormessage' for recovery
+with C-q w."
   (setq ws-last-errormessage string)
   (error string))
 
-(defun ws-set-marker-0 ()
-  "In WordStar mode: Set marker 0 to current cursor position."
-  (interactive)
-  (setq ws-marker-0 (point-marker))
-  (message "Marker 0 set"))
-
-(defun ws-set-marker-1 ()
-  "In WordStar mode: Set marker 1 to current cursor position."
-  (interactive)
-  (setq ws-marker-1 (point-marker))
-  (message "Marker 1 set"))
-
-(defun ws-set-marker-2 ()
-  "In WordStar mode: Set marker 2 to current cursor position."
-  (interactive)
-  (setq ws-marker-2 (point-marker))
-  (message "Marker 2 set"))
-
-(defun ws-set-marker-3 ()
-  "In WordStar mode: Set marker 3 to current cursor position."
-  (interactive)
-  (setq ws-marker-3 (point-marker))
-  (message "Marker 3 set"))
-
-(defun ws-set-marker-4 ()
-  "In WordStar mode: Set marker 4 to current cursor position."
-  (interactive)
-  (setq ws-marker-4 (point-marker))
-  (message "Marker 4 set"))
-
-(defun ws-set-marker-5 ()
-  "In WordStar mode: Set marker 5 to current cursor position."
-  (interactive)
-  (setq ws-marker-5 (point-marker))
-  (message "Marker 5 set"))
-
-(defun ws-set-marker-6 ()
-  "In WordStar mode: Set marker 6 to current cursor position."
-  (interactive)
-  (setq ws-marker-6 (point-marker))
-  (message "Marker 6 set"))
-
-(defun ws-set-marker-7 ()
-  "In WordStar mode: Set marker 7 to current cursor position."
-  (interactive)
-  (setq ws-marker-7 (point-marker))
-  (message "Marker 7 set"))
-
-(defun ws-set-marker-8 ()
-  "In WordStar mode: Set marker 8 to current cursor position."
-  (interactive)
-  (setq ws-marker-8 (point-marker))
-  (message "Marker 8 set"))
-
-(defun ws-set-marker-9 ()
-  "In WordStar mode: Set marker 9 to current cursor position."
-  (interactive)
-  (setq ws-marker-9 (point-marker))
-  (message "Marker 9 set"))
-
 (defun ws-begin-block ()
   "In WordStar mode: Set block begin marker to current cursor position."
   (interactive)
@@ -358,7 +316,6 @@ in ws-last-errormessage for recovery with C-q w."
 	(message ""))
     (message "Block markers not set")))
 
-
 (defun ws-indent-block ()
   "In WordStar mode: Indent block (not yet implemented)."
   (interactive)
@@ -373,7 +330,7 @@ in ws-last-errormessage for recovery with C-q w."
 (defun ws-print-block ()
   "In WordStar mode: Print block."
   (interactive)
-  (message "Don't do this. Write block to a file (C-k w) and print this file."))
+  (message "Don't do this. Write block to a file (C-k w) and print this file"))
 
 (defun ws-mark-word ()
   "In WordStar mode: Mark current word as block."
@@ -389,7 +346,7 @@ in ws-last-errormessage for recovery with C-q w."
 (defun ws-exdent-block ()
   "I don't know what this (C-k u) should do."
   (interactive)
-  (ws-error "This won't be done -- not yet implemented."))
+  (ws-error "This won't be done -- not yet implemented"))
 
 (defun ws-move-block ()
   "In WordStar mode: Move block to current cursor position."
@@ -430,96 +387,6 @@ in ws-last-errormessage for recovery with C-q w."
 		    (ws-block-end-marker "Block begin marker not set")
 		    (t "Block markers not set")))))
 
-(defun ws-find-marker-0 ()
-  "In WordStar mode: Go to marker 0."
-  (interactive)
-  (if ws-marker-0
-      (progn
-	(setq ws-last-cursorposition (point-marker))
-	(goto-char ws-marker-0))
-    (ws-error "Marker 0 not set")))
-
-(defun ws-find-marker-1 ()
-  "In WordStar mode: Go to marker 1."
-  (interactive)
-  (if ws-marker-1
-      (progn
-	(setq ws-last-cursorposition (point-marker))
-	(goto-char ws-marker-1))
-    (ws-error "Marker 1 not set")))
-
-(defun ws-find-marker-2 ()
-  "In WordStar mode: Go to marker 2."
-  (interactive)
-  (if ws-marker-2
-      (progn
-	(setq ws-last-cursorposition (point-marker))
-	(goto-char ws-marker-2))
-    (ws-error "Marker 2 not set")))
-
-(defun ws-find-marker-3 ()
-  "In WordStar mode: Go to marker 3."
-  (interactive)
-  (if ws-marker-3
-      (progn
-	(setq ws-last-cursorposition (point-marker))
-	(goto-char ws-marker-3))
-    (ws-error "Marker 3 not set")))
-
-(defun ws-find-marker-4 ()
-  "In WordStar mode: Go to marker 4."
-  (interactive)
-  (if ws-marker-4
-      (progn
-	(setq ws-last-cursorposition (point-marker))
-	(goto-char ws-marker-4))
-    (ws-error "Marker 4 not set")))
-
-(defun ws-find-marker-5 ()
-  "In WordStar mode: Go to marker 5."
-  (interactive)
-  (if ws-marker-5
-      (progn
-	(setq ws-last-cursorposition (point-marker))
-	(goto-char ws-marker-5))
-    (ws-error "Marker 5 not set")))
-
-(defun ws-find-marker-6 ()
-  "In WordStar mode: Go to marker 6."
-  (interactive)
-  (if ws-marker-6
-      (progn
-	(setq ws-last-cursorposition (point-marker))
-	(goto-char ws-marker-6))
-    (ws-error "Marker 6 not set")))
-
-(defun ws-find-marker-7 ()
-  "In WordStar mode: Go to marker 7."
-  (interactive)
-  (if ws-marker-7
-      (progn
-	(setq ws-last-cursorposition (point-marker))
-	(goto-char ws-marker-7))
-    (ws-error "Marker 7 not set")))
-
-(defun ws-find-marker-8 ()
-  "In WordStar mode: Go to marker 8."
-  (interactive)
-  (if ws-marker-8
-      (progn
-	(setq ws-last-cursorposition (point-marker))
-	(goto-char ws-marker-8))
-    (ws-error "Marker 8 not set")))
-
-(defun ws-find-marker-9 ()
-  "In WordStar mode: Go to marker 9."
-  (interactive)
-  (if ws-marker-9
-      (progn
-	(setq ws-last-cursorposition (point-marker))
-	(goto-char ws-marker-9))
-    (ws-error "Marker 9 not set")))
-
 (defun ws-goto-block-begin ()
   "In WordStar mode: Go to block begin marker."
   (interactive)
@@ -560,16 +427,16 @@ in ws-last-errormessage for recovery with C-q w."
   "In WordStar mode: Undo and give message about undoing more changes."
   (interactive)
   (undo)
-  (message "Repeat C-q l to undo more changes."))
+  (message "Repeat C-q l to undo more changes"))
 
 (defun ws-goto-last-cursorposition ()
-  "In WordStar mode: "
+  "In WordStar mode: Go to position before last search."
   (interactive)
   (if ws-last-cursorposition
       (progn
 	(setq ws-last-cursorposition (point-marker))
 	(goto-char ws-last-cursorposition))
-    (ws-error "No last cursor position available.")))
+    (ws-error "No last cursor position available")))
 
 (defun ws-last-error ()
   "In WordStar mode: repeat last error message.
@@ -577,7 +444,7 @@ This will only work for errors raised by WordStar mode functions."
   (interactive)
   (if ws-last-errormessage
       (message "%s" ws-last-errormessage)
-    (message "No WordStar error yet.")))
+    (message "No WordStar error yet")))
 
 (defun ws-kill-eol ()
   "In WordStar mode: Kill to end of line (like WordStar, not like Emacs)."
@@ -587,8 +454,7 @@ This will only work for errors raised by WordStar mode functions."
     (kill-region p (point))))
 
 (defun ws-kill-bol ()
-  "In WordStar mode: Kill to beginning of line
-\(like WordStar, not like Emacs)."
+  "In WordStar mode: Kill to beginning of line (like WordStar, not like Emacs)."
   (interactive)
   (let ((p (point)))
     (beginning-of-line)
@@ -638,6 +504,36 @@ sWith: " )
 		    (ws-block-end-marker "Block begin marker not set")
 		    (t "Block markers not set")))))
 
+(defmacro ws-set-marker (&rest indices)
+  (let (n forms)
+    (while indices
+      (setq n (pop indices))
+      (push `(defun ,(intern (format "ws-set-marker-%d" n)) ()
+               ,(format "In WordStar mode: Set marker %d to current cursor position" n)
+               (interactive)
+               (setq ,(intern (format "ws-marker-%d" n)) (point-marker))
+               (message ,(format "Marker %d set" n)))
+            forms))
+    `(progn ,@(nreverse forms))))
+
+(ws-set-marker 0 1 2 3 4 5 6 7 8 9)
+
+(defmacro ws-find-marker (&rest indices)
+  (let (n forms)
+    (while indices
+      (setq n (pop indices))
+      (push `(defun ,(intern (format "ws-find-marker-%d" n)) ()
+               ,(format "In WordStar mode: Go to marker %d." n)
+               (interactive)
+               (if ,(intern (format "ws-marker-%d" n))
+                   (progn (setq ws-last-cursorposition (point-marker))
+                          (goto-char ,(intern (format "ws-marker-%d" n))))
+                 (ws-error ,(format "Marker %d not set" n))))
+            forms))
+    `(progn ,@(nreverse forms))))
+
+(ws-find-marker 0 1 2 3 4 5 6 7 8 9)
+
 (provide 'ws-mode)
 
 ;;; ws-mode.el ends here
diff --git a/lisp/obsolete/yow.el b/lisp/obsolete/yow.el
index 5cbb2ef21e..eeeaaec812 100644
--- a/lisp/obsolete/yow.el
+++ b/lisp/obsolete/yow.el
@@ -2,8 +2,8 @@
 
 ;; Copyright (C) 1993-1995, 2000-2019 Free Software Foundation, Inc.
 
-;; Maintainer: emacs-devel@gnu.org
 ;; Author: Richard Mlynarik
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: games
 ;; Obsolete-since: 24.4
 
diff --git a/lisp/org/org-id.el b/lisp/org/org-id.el
index 6a9d729c0a..44cc7b2f14 100644
--- a/lisp/org/org-id.el
+++ b/lisp/org/org-id.el
@@ -83,8 +83,7 @@
 
 (defcustom org-id-link-to-org-use-id nil
   "Non-nil means storing a link to an Org file will use entry IDs.
-\\<org-mode-map>\
-
+\\<org-mode-map>
 The variable can have the following values:
 
 t     Create an ID if needed to make a link to the current entry.
diff --git a/lisp/org/org.el b/lisp/org/org.el
index ce6dd24a83..5aa49b29d6 100644
--- a/lisp/org/org.el
+++ b/lisp/org/org.el
@@ -4,7 +4,6 @@
 ;; Copyright (C) 2004-2019 Free Software Foundation, Inc.
 ;;
 ;; Author: Carsten Dominik <carsten at orgmode dot org>
-;; Maintainer: Carsten Dominik <carsten at orgmode dot org>
 ;; Keywords: outlines, hypermedia, calendar, wp
 ;; Homepage: https://orgmode.org
 ;; Version: 9.1.9
@@ -863,8 +862,7 @@ depends on, if any."
 
 (defcustom org-support-shift-select nil
   "Non-nil means make shift-cursor commands select text when possible.
-\\<org-mode-map>\
-
+\\<org-mode-map>
 In Emacs 23, when `shift-select-mode' is on, shifted cursor keys
 start selecting a region, or enlarge regions started in this way.
 In Org mode, in special contexts, these same keys are used for
@@ -2259,8 +2257,7 @@ See `org-file-apps'.")
     ("\\.x?html?\\'" . default)
     ("\\.pdf\\'" . default))
   "External applications for opening `file:path' items in a document.
-\\<org-mode-map>\
-
+\\<org-mode-map>
 Org mode uses system defaults for different file types, but
 you can use this variable to set the application for a given file
 extension.  The entries in this list are cons cells where the car identifies
diff --git a/lisp/org/ox-publish.el b/lisp/org/ox-publish.el
index 74312bc20f..9126647e7c 100644
--- a/lisp/org/ox-publish.el
+++ b/lisp/org/ox-publish.el
@@ -2,7 +2,7 @@
 ;; Copyright (C) 2006-2019 Free Software Foundation, Inc.
 
 ;; Author: David O'Toole <dto@gnu.org>
-;; Maintainer: Carsten Dominik <carsten DOT dominik AT gmail DOT com>
+;; Maintainer: Carsten Dominik <carsten at orgmode dot org>
 ;; Keywords: hypermedia, outlines, wp
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/paren.el b/lisp/paren.el
index 13908d46ee..c7d782a8a1 100644
--- a/lisp/paren.el
+++ b/lisp/paren.el
@@ -1,4 +1,4 @@
-;;; paren.el --- highlight matching paren
+;;; paren.el --- highlight matching paren  -*- lexical-binding:t -*-
 
 ;; Copyright (C) 1993, 1996, 2001-2019 Free Software Foundation, Inc.
 
@@ -173,7 +173,7 @@ if there's no opener/closer near point, or a list of the form
 Where HERE-BEG..HERE-END is expected to be near point.")
 
 (defun show-paren--default ()
-  "Finds the opener/closer near point and its match.
+  "Find the opener/closer near point and its match.
 
 It is the default value of `show-paren-data-function'."
   (let* ((temp (show-paren--locate-near-paren))
diff --git a/lisp/play/5x5.el b/lisp/play/5x5.el
index e13a3c9a25..28748cc351 100644
--- a/lisp/play/5x5.el
+++ b/lisp/play/5x5.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Dave Pearson <davep@davep.org>
-;; Maintainer: Dave Pearson <davep@davep.org>
 ;; Created: 1998-10-03
 ;; Keywords: games puzzles
 
diff --git a/lisp/play/gamegrid.el b/lisp/play/gamegrid.el
index 4a9dac7f74..54eeafd2b5 100644
--- a/lisp/play/gamegrid.el
+++ b/lisp/play/gamegrid.el
@@ -663,6 +663,7 @@ FILE is created there."
 	      (revert-buffer nil t nil)
 	      (display-buffer buf))
 	  (find-file-read-only target))
+        (view-mode)
         (goto-char (point-min))
         (search-forward (concat (int-to-string score)
 				" " (user-login-name) " "
@@ -691,7 +692,8 @@ FILE is created there."
     (forward-line gamegrid-score-file-length)
     (delete-region (point) (point-max))
     (setq buffer-read-only t)
-    (save-buffer)))
+    (save-buffer)
+    (view-mode)))
 
 
 ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
diff --git a/lisp/play/morse.el b/lisp/play/morse.el
index 1f62ec3c03..f498971655 100644
--- a/lisp/play/morse.el
+++ b/lisp/play/morse.el
@@ -1,4 +1,4 @@
-;;; morse.el --- convert text to morse code and back
+;;; morse.el --- convert text to morse code and back  -*- lexical-binding: t -*-
 
 ;; Copyright (C) 1995, 2001-2019 Free Software Foundation, Inc.
 
diff --git a/lisp/play/studly.el b/lisp/play/studly.el
index ff1bf03e11..c4b32414bd 100644
--- a/lisp/play/studly.el
+++ b/lisp/play/studly.el
@@ -1,4 +1,4 @@
-;;; studly.el --- StudlyCaps (tm)(r)(c)(xxx)
+;;; studly.el --- StudlyCaps (tm)(r)(c)(xxx)  -*- lexical-binding: t -*-
 
 ;;; This is in the public domain, since it was distributed
 ;;; by its author in 1986 without a copyright notice.
diff --git a/lisp/play/tetris.el b/lisp/play/tetris.el
index 1e0681d7ff..a797a26d59 100644
--- a/lisp/play/tetris.el
+++ b/lisp/play/tetris.el
@@ -277,6 +277,7 @@ each one of its four blocks.")
 (defvar tetris-null-map
   (let ((map (make-sparse-keymap 'tetris-null-map)))
     (define-key map "n"		'tetris-start-game)
+    (define-key map "q"         'quit-window)
     map))
 
 ;; ;;;;;;;;;;;;;;;; game functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
diff --git a/lisp/plstore.el b/lisp/plstore.el
index f24bac343a..cd29283cfb 100644
--- a/lisp/plstore.el
+++ b/lisp/plstore.el
@@ -1,7 +1,7 @@
 ;;; plstore.el --- secure plist store -*- lexical-binding: t -*-
 ;; Copyright (C) 2011-2019 Free Software Foundation, Inc.
 
-;; Author: Daiki Ueno <ueno@unixuser.org>
+;; Author: Daiki Ueno <ueno@gnu.org>
 ;; Keywords: PGP, GnuPG
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/printing.el b/lisp/printing.el
index f2495ecda3..d584e46cec 100644
--- a/lisp/printing.el
+++ b/lisp/printing.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2000-2001, 2003-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, print, PostScript
 ;; Version: 6.9.3
 ;; X-URL: http://www.emacswiki.org/cgi-bin/wiki/ViniciusJoseLatorre
diff --git a/lisp/proced.el b/lisp/proced.el
index ce379a7c6a..b05046bfbd 100644
--- a/lisp/proced.el
+++ b/lisp/proced.el
@@ -1744,9 +1744,10 @@ The value returned is the value of the last form in BODY."
        (save-window-excursion
          ;; Analogous to `dired-pop-to-buffer'
          ;; Don't split window horizontally.  (Bug#1806)
-         (let (split-width-threshold)
-           (pop-to-buffer (current-buffer)))
-         (fit-window-to-buffer (get-buffer-window) nil 1)
+         (display-buffer (current-buffer)
+                         '(display-buffer-in-direction
+                           (direction . bottom)
+                           (window-height . fit-window-to-buffer)))
          ,@body))))
 
 (defun proced-send-signal (&optional signal process-alist)
diff --git a/lisp/progmodes/ada-mode.el b/lisp/progmodes/ada-mode.el
index e01f1e8ecb..77c1e5e2d8 100644
--- a/lisp/progmodes/ada-mode.el
+++ b/lisp/progmodes/ada-mode.el
@@ -2,10 +2,10 @@
 
 ;; Copyright (C) 1994-1995, 1997-2019 Free Software Foundation, Inc.
 
-;; Author: Rolf Ebert      <ebert@inf.enst.fr>
+;; Author: Rolf Ebert <ebert@inf.enst.fr>
 ;;      Markus Heritsch <Markus.Heritsch@studbox.uni-stuttgart.de>
 ;;      Emmanuel Briot  <briot@gnat.com>
-;; Maintainer: Stephen Leake <stephen_leake@member.fsf.org>
+;; Maintainer: Stephen Leake <stephen_leake@stephe-leake.org>
 ;; Keywords: languages ada
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/progmodes/cc-align.el b/lisp/progmodes/cc-align.el
index 009f58ea58..74548f643a 100644
--- a/lisp/progmodes/cc-align.el
+++ b/lisp/progmodes/cc-align.el
@@ -90,26 +90,26 @@ Works with: topmost-intro-cont."
 
 (defun c-lineup-gnu-DEFUN-intro-cont (langelem)
   "Line up the continuation lines of a DEFUN macro in the Emacs C source.
-These lines are indented as though they were `knr-argdecl-intro' lines.
+These lines are indented `c-basic-offset' columns, usually from column 0.
 Return nil when we're not in such a construct.
 
-This function is for historical compatibility with how previous CC Modes (5.28
-and earlier) indented such lines.
+This function was formally for use in DEFUNs, which used to have knr
+argument lists.  Now (2019-05) it just indents the argument list of the
+DEFUN's function, which would otherwise go to column 0.
 
 Here is an example:
 
 DEFUN (\"forward-char\", Fforward_char, Sforward_char, 0, 1, \"p\",
        doc: /* Move point right N characters (left if N is negative).
 On reaching end of buffer, stop and signal error.  */)
-     (n)                      <- c-lineup-gnu-DEFUN-into-cont
-     Lisp_Object n;           <- c-lineup-gnu-DEFUN-into-cont
+  (Lisp_Object n)             <- c-lineup-gnu-DEFUN-into-cont
 
 Works with: topmost-intro-cont."
   (save-excursion
     (let (case-fold-search)
       (goto-char (c-langelem-pos langelem))
       (if (looking-at "\\<DEFUN\\>")
-	  (c-calc-offset '(knr-argdecl-intro))))))
+	  c-basic-offset))))
 
 (defun c-block-in-arglist-dwim (arglist-start)
   ;; This function implements the DWIM to avoid far indentation of
diff --git a/lisp/progmodes/cc-awk.el b/lisp/progmodes/cc-awk.el
index 70aa3c4b1f..1a67a95927 100644
--- a/lisp/progmodes/cc-awk.el
+++ b/lisp/progmodes/cc-awk.el
@@ -95,7 +95,7 @@
 ;; Emacs has in the past used \r to mark hidden lines in some fashion (and
 ;; maybe still does).
 
-(defconst c-awk-esc-pair-re "\\\\\\(.\\|\n\\|\r\\|\\'\\)")
+(defconst c-awk-esc-pair-re "\\\\\\(.\\|\n\\|\\'\\)")
 ;;   Matches any escaped (with \) character-pair, including an escaped newline.
 (defconst c-awk-non-eol-esc-pair-re "\\\\\\(.\\|\\'\\)")
 ;;   Matches any escaped (with \) character-pair, apart from an escaped newline.
diff --git a/lisp/progmodes/cc-defs.el b/lisp/progmodes/cc-defs.el
index 87ddf3ac1e..d20e3ef32d 100644
--- a/lisp/progmodes/cc-defs.el
+++ b/lisp/progmodes/cc-defs.el
@@ -81,7 +81,7 @@
   (progn
     (require 'font-lock)
     (let (font-lock-keywords)
-      (font-lock-compile-keywords '("a\\`")) ; doesn't match anything.
+      (font-lock-compile-keywords (list regexp-unmatchable))
       font-lock-keywords))))
 
 
@@ -503,6 +503,31 @@ to it is returned.  This function does not modify the point or the mark."
     ;; Emacs <22 + XEmacs
     '(default-value 'sentence-end)))
 
+(defconst c-c++-raw-string-opener-re "R\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)(")
+;; Matches a C++ raw string opener.  Submatch 1 is its identifier.
+
+(defconst c-c++-raw-string-opener-1-re "\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)(")
+;; Matches a C++ raw string opener starting after the initial R.
+
+(defmacro c-sub-at-c++-raw-string-opener ()
+  `(save-excursion
+     (and
+      (if (eq (char-after) ?R)
+	  (progn (forward-char) t)
+	(eq (char-before) ?R))
+      (looking-at c-c++-raw-string-opener-1-re))))
+
+(defmacro c-at-c++-raw-string-opener (&optional pos)
+  ;; Return non-nil if POS (default point) is either at the start of a C++ raw
+  ;; string opener, or after the introductory R of one.  The match data is
+  ;; overwritten.  On success the opener's identifier will be (match-string
+  ;; 1).  Text properties on any characters are ignored.
+  (if pos
+      `(save-excursion
+	 (goto-char ,pos)
+	 (c-sub-at-c++-raw-string-opener))
+    `(c-sub-at-c++-raw-string-opener)))
+
 ;; The following is essentially `save-buffer-state' from lazy-lock.el.
 ;; It ought to be a standard macro.
 (defmacro c-save-buffer-state (varlist &rest body)
@@ -1865,8 +1890,8 @@ when it's needed.  The default is the current language taken from
 
     ;; Produce a regexp that doesn't match anything.
     (if adorn
-	"\\(a\\`\\)"
-      "a\\`")))
+	(concat "\\(" regexp-unmatchable "\\)")
+      regexp-unmatchable)))
 
 (put 'c-make-keywords-re 'lisp-indent-function 1)
 
diff --git a/lisp/progmodes/cc-engine.el b/lisp/progmodes/cc-engine.el
index fc8c377f27..13b38b439a 100644
--- a/lisp/progmodes/cc-engine.el
+++ b/lisp/progmodes/cc-engine.el
@@ -152,6 +152,10 @@
 (cc-require-when-compile 'cc-langs)
 (cc-require 'cc-vars)
 
+(defvar c-doc-line-join-re)
+(defvar c-doc-bright-comment-start-re)
+(defvar c-doc-line-join-end-ch)
+
 
 ;; Make declarations for all the `c-lang-defvar' variables in cc-langs.
 
@@ -283,7 +287,8 @@ otherwise return nil and leave point unchanged.
 
 Note that this function might do hidden buffer changes.  See the
 comment at the start of cc-engine.el for more info."
-  (let ((here (point)))
+  (let ((here (point))
+	(pause (c-point 'eol)))
     (when c-opt-cpp-prefix
       (if (and (car c-macro-cache)
 	       (>= (point) (car c-macro-cache))
@@ -303,8 +308,23 @@ comment at the start of cc-engine.el for more info."
 	(save-restriction
 	  (if lim (narrow-to-region lim (point-max)))
 	  (beginning-of-line)
-	  (while (eq (char-before (1- (point))) ?\\)
-	    (forward-line -1))
+	  (when (or (null lim)
+		    (>= here lim))
+	    (while
+		(progn
+		  (while (eq (char-before (1- (point))) ?\\)
+		    (forward-line -1))
+		  (when (and c-last-c-comment-end-on-line-re
+			     (re-search-forward
+			      c-last-c-comment-end-on-line-re pause t))
+		    (goto-char (match-end 1))
+		    (if (c-backward-single-comment)
+			(progn
+			  (beginning-of-line)
+			  (setq pause (point)))
+		      (goto-char pause)
+		      nil)))))
+
 	  (back-to-indentation)
 	  (if (and (<= (point) here)
 		   (save-match-data (looking-at c-opt-cpp-start))
@@ -341,12 +361,23 @@ comment at the start of cc-engine.el for more info."
 	      c-macro-cache-start-pos nil
 	      c-macro-cache-syntactic nil
 	      c-macro-cache-no-comment nil))
-      (while (progn
-	       (end-of-line)
-	       (when (and (eq (char-before) ?\\)
-			  (not (eobp)))
-		 (forward-char)
-		 t)))
+      (while
+	  (progn
+	    (while (progn
+		     (end-of-line)
+		     (when (and (eq (char-before) ?\\)
+				(not (eobp)))
+		       (forward-char)
+		       t)))
+	    (if (and c-last-open-c-comment-start-on-line-re
+		     (re-search-backward
+		      c-last-open-c-comment-start-on-line-re
+		      (c-point 'bol) t))
+		(progn
+		  (goto-char (match-beginning 1))
+		  (c-forward-single-comment))
+	      nil)))
+
       (when (and (car c-macro-cache)
 		 (bolp)
 		 (not (eq (char-before (1- (point))) ?\\)))
@@ -876,7 +907,7 @@ comment at the start of cc-engine.el for more info."
 	stack
 	;; Regexp which matches "for", "if", etc.
 	(cond-key (or c-opt-block-stmt-key
-		      "a\\`"))	; Doesn't match anything.
+		      regexp-unmatchable))
 	;; Return value.
 	(ret 'same)
 	;; Positions of the last three sexps or bounds we've stopped at.
@@ -1112,6 +1143,9 @@ comment at the start of cc-engine.el for more info."
 			 ;; Have we moved into a macro?
 			 ((and (not macro-start)
 			       (c-beginning-of-macro))
+			  (save-excursion
+			    (c-backward-syntactic-ws)
+			    (setq before-sws-pos (point)))
 			  ;; Have we crossed a statement boundary?  If not,
 			  ;; keep going back until we find one or a "real" sexp.
 			  (and
@@ -1219,12 +1253,20 @@ comment at the start of cc-engine.el for more info."
 		  ;; (including a case label) or something like C++'s "public:"?
 		  ;; A case label might use an expression rather than a token.
 		  (setq after-case:-pos (or tok start))
-		  (if (or (looking-at c-nonlabel-token-key) ; e.g. "while" or "'a'"
+		  (if (or (looking-at c-nonlabel-nonparen-token-key)
+					; e.g. "while" or "'a'"
 			  ;; Catch C++'s inheritance construct "class foo : bar".
 			  (save-excursion
 			    (and
 			     (c-safe (c-backward-sexp) t)
-			     (looking-at c-nonlabel-token-2-key))))
+			     (looking-at c-nonlabel-token-2-key)))
+			  ;; Catch C++'s "case a(1):"
+			  (and (c-major-mode-is 'c++-mode)
+			       (eq (char-after) ?\()
+			       (save-excursion
+				 (not (and
+				       (zerop (c-backward-token-2 2))
+				       (looking-at c-case-kwds-regexp))))))
 		      (setq c-maybe-labelp nil)
 		    (if after-labels-pos ; Have we already encountered a label?
 			(if (not last-label-pos)
@@ -1808,7 +1850,7 @@ comment at the start of cc-engine.el for more info."
 	  (setcar c-sws-lit-limits (match-beginning 1))
 	(setq c-sws-lit-limits (cons (match-beginning 1) (match-end 1)))))))
 
-(defun c-invalidate-sws-region-after-del (beg end old-len)
+(defun c-invalidate-sws-region-after-del (beg end _old-len)
   ;; Text has been deleted, OLD-LEN characters of it starting from position
   ;; BEG.  END is typically eq to BEG.  Should there have been a comment or
   ;; CPP construct open at END before the deletion, check whether this
@@ -1930,7 +1972,8 @@ comment at the start of cc-engine.el for more info."
     (skip-chars-forward " \t\n\r\f\v")
     (when (or (looking-at c-syntactic-ws-start)
 	      (and c-opt-cpp-prefix
-		   (looking-at c-noise-macro-name-re)))
+		   (looking-at c-noise-macro-name-re))
+	      (looking-at c-doc-line-join-re))
 
       (setq rung-end-pos (min (1+ (point)) (point-max)))
       (if (setq rung-is-marked (text-property-any rung-pos rung-end-pos
@@ -2002,6 +2045,10 @@ comment at the start of cc-engine.el for more info."
 	    ;; Take elaborate precautions to detect an open block comment at
 	    ;; the end of a macro.  If we find one, we set `safe-start' to nil
 	    ;; and break off any further scanning of comments.
+	    ;;
+	    ;; (2019-05-02): `c-end-of-macro' now moves completely over block
+	    ;; comments, even multiline ones lacking \s at their EOLs.  So a
+	    ;; lot of the following is probably redundant now.
 	    (let ((com-begin (point)) com-end in-macro)
 	      (when (and (c-forward-single-comment)
 			 (setq com-end (point))
@@ -2060,6 +2107,13 @@ comment at the start of cc-engine.el for more info."
 		   (looking-at c-noise-macro-name-re))
 	      ;; Skip over a noise macro.
 	      (goto-char (match-end 1))
+	      (not (eobp)))
+
+	     ((looking-at c-doc-line-join-re)
+	      ;; Skip over a line join in (e.g.) Pike autodoc.
+	      (goto-char (match-end 0))
+	      (setq safe-start nil) ; Never cache this; the doc style could be
+					; changed at any time.
 	      (not (eobp)))))
 
 	;; We've searched over a piece of non-white syntactic ws.  See if this
@@ -2154,7 +2208,8 @@ comment at the start of cc-engine.el for more info."
   (let (;; `rung-pos' is set to a position as late as possible in the unmarked
 	;; part of the simple ws region.
 	(rung-pos (point)) next-rung-pos last-put-in-sws-pos
-	rung-is-marked simple-ws-beg cmt-skip-pos)
+	rung-is-marked simple-ws-beg cmt-skip-pos
+	(doc-line-join-here (concat c-doc-line-join-re "\\=")))
 
     ;; Skip simple horizontal ws and do a quick check on the preceding
     ;; character to see if it's anything that can't end syntactic ws, so we can
@@ -2164,12 +2219,17 @@ comment at the start of cc-engine.el for more info."
     (skip-chars-backward " \t\f")
     (when (and (not (bobp))
 	       (save-excursion
-		 (backward-char)
-		 (or (looking-at c-syntactic-ws-end)
-		     (and c-opt-cpp-prefix
-			  (looking-at c-symbol-char-key)
-			  (progn (c-beginning-of-current-token)
-				 (looking-at c-noise-macro-name-re))))))
+		 (or (and
+		      (memq (char-before) c-doc-line-join-end-ch) ; For speed.
+		      (re-search-backward doc-line-join-here
+					  (c-point 'bopl) t))
+		     (progn
+		       (backward-char)
+		       (or (looking-at c-syntactic-ws-end)
+			   (and c-opt-cpp-prefix
+				(looking-at c-symbol-char-key)
+				(progn (c-beginning-of-current-token)
+				       (looking-at c-noise-macro-name-re))))))))
       ;; Try to find a rung position in the simple ws preceding point, so that
       ;; we can get a cache hit even if the last bit of the simple ws has
       ;; changed recently.
@@ -2309,7 +2369,11 @@ comment at the start of cc-engine.el for more info."
 				 (looking-at c-noise-macro-name-re)))))
 	      ;; Skipped over a noise macro
 	      (goto-char next-rung-pos)
-	      t)))
+	      t)
+
+	     ((and
+	       (memq (char-before) c-doc-line-join-end-ch) ; For speed.
+	       (re-search-backward doc-line-join-here (c-point 'bopl) t)))))
 
 	;; We've searched over a piece of non-white syntactic ws.  See if this
 	;; can be cached.
@@ -2406,245 +2470,73 @@ comment at the start of cc-engine.el for more info."
 		 (c-skip-ws-forward end+1)
 		 (eq (point) end+1))))))
 
-;; A system for finding noteworthy parens before the point.
-
-(defconst c-state-cache-too-far 5000)
-;; A maximum comfortable scanning distance, e.g. between
-;; `c-state-cache-good-pos' and "HERE" (where we call c-parse-state).  When
-;; this distance is exceeded, we take "emergency measures", e.g. by clearing
-;; the cache and starting again from point-min or a beginning of defun.  This
-;; value can be tuned for efficiency or set to a lower value for testing.
-
-(defvar c-state-cache nil)
-(make-variable-buffer-local 'c-state-cache)
-;; The state cache used by `c-parse-state' to cut down the amount of
-;; searching.  It's the result from some earlier `c-parse-state' call.  See
-;; `c-parse-state''s doc string for details of its structure.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; We maintain a sopisticated cache of positions which are in a literal,
+;; disregarding macros (i.e. we don't distinguish between "in a macro" and
+;; not).
 ;;
-;; The use of the cached info is more effective if the next
-;; `c-parse-state' call is on a line close by the one the cached state
-;; was made at; the cache can actually slow down a little if the
-;; cached state was made very far back in the buffer.  The cache is
-;; most effective if `c-parse-state' is used on each line while moving
-;; forward.
-
-(defvar c-state-cache-good-pos 1)
-(make-variable-buffer-local 'c-state-cache-good-pos)
-;; This is a position where `c-state-cache' is known to be correct, or
-;; nil (see below).  It's a position inside one of the recorded unclosed
-;; parens or the top level, but not further nested inside any literal or
-;; subparen that is closed before the last recorded position.
+;; This cache is in three parts: two "near" caches, which are association
+;; lists of a small number (currently six) of positions and the parser states
+;; there; the "far" cache (also known as "the cache"), a list of compressed
+;; parser states going back to the beginning of the buffer, one entry every
+;; 3000 characters.
 ;;
-;; The exact position is chosen to try to be close to yet earlier than
-;; the position where `c-state-cache' will be called next.  Right now
-;; the heuristic is to set it to the position after the last found
-;; closing paren (of any type) before the line on which
-;; `c-parse-state' was called.  That is chosen primarily to work well
-;; with refontification of the current line.
+;; The two main callable functions embodying this cache are
+;; `c-semi-pp-to-literal', which returns a `parse-partial-sexp' state at a
+;; given position, together with the start of any literal enclosing it, and
+;; `c-full-pp-to-literal', which additionally returns the end of such literal.
+;; One of the above "near" caches is associated with each of these functions.
 ;;
-;; 2009-07-28: When `c-state-point-min' and the last position where
-;; `c-parse-state' or for which `c-invalidate-state-cache' was called, are
-;; both in the same literal, there is no such "good position", and
-;; c-state-cache-good-pos is then nil.  This is the ONLY circumstance in which
-;; it can be nil.  In this case, `c-state-point-min-literal' will be non-nil.
+;; When searching this cache, these functions first seek an exact match, then
+;; a "close" match from the assiciated near cache.  If neither of these
+;; succeed, the nearest preceding entry in the far cache is used.
 ;;
-;; 2009-06-12: In a brace desert, c-state-cache-good-pos may also be in
-;; the middle of the desert, as long as it is not within a brace pair
-;; recorded in `c-state-cache' or a paren/bracket pair.
-
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-;; We maintain a simple cache of positions which aren't in a literal, so as to
-;; speed up testing for non-literality.
-(defconst c-state-nonlit-pos-interval 3000)
-;; The approximate interval between entries in `c-state-nonlit-pos-cache'.
 
-(defvar c-state-nonlit-pos-cache nil)
-(make-variable-buffer-local 'c-state-nonlit-pos-cache)
-;; A list of buffer positions which are known not to be in a literal or a cpp
-;; construct.  This is ordered with higher positions at the front of the list.
-;; Only those which are less than `c-state-nonlit-pos-cache-limit' are valid.
+(defvar c-semi-lit-near-cache nil)
+(make-variable-buffer-local 'c-semi-lit-near-cache)
+;; A list of up to six recent results from `c-semi-pp-to-literal'.  Each
+;; element is a cons of the buffer position and the `parse-partial-sexp' state
+;; at that position.
 
-(defvar c-state-nonlit-pos-cache-limit 1)
-(make-variable-buffer-local 'c-state-nonlit-pos-cache-limit)
-;; An upper limit on valid entries in `c-state-nonlit-pos-cache'.  This is
+(defvar c-semi-near-cache-limit 1)
+(make-variable-buffer-local 'c-semi-near-cache-limit)
+;; An upper limit on valid entries in `c-semi-lit-near-cache'.  This is
 ;; reduced by buffer changes, and increased by invocations of
-;; `c-state-literal-at'.
-
-(defvar c-state-semi-nonlit-pos-cache nil)
-(make-variable-buffer-local 'c-state-semi-nonlit-pos-cache)
-;; A list of elements which are either buffer positions (when such positions
-;; are not in literals) or lists of the form (POS TYPE START), where POS is
-;; a buffer position inside a literal, TYPE is the type of the literal
-;; ('string, 'c, or 'c++) and START is the start of the literal.
-
-(defvar c-state-semi-nonlit-pos-cache-limit 1)
-(make-variable-buffer-local 'c-state-semi-nonlit-pos-cache-limit)
-;; An upper limit on valid entries in `c-state-semi-nonlit-pos-cache'.  This
+;; `c-semi-pp-to-literal'.
+
+(defvar c-lit-pos-cache nil)
+(make-variable-buffer-local 'c-lit-pos-cache)
+;; A list of elements in descending order of POS of one of the forms:
+;;   o - POS (when point is not in a literal);
+;;   o - (POS CHAR-1) (when the last character before point is potentially
+;;       the first of a two-character construct
+;;   o - (POS TYPE STARTING-POS) (when in a literal);
+;;   o - (POS TYPE STARTING-POS CHAR-1) (Combination of the previous two),
+;;
+;; where POS is the position for which the entry is valid, TYPE is the type of
+;; the comment ('c or 'c++) or the character which should close the string
+;; (e.g. ?\") or t for a generic string.  STARTING-POS is the starting
+;; position of the comment or string.  CHAR-1 is either the character
+;; potentially forming the first half of a two-char construct (in Emacs <= 25
+;; and XEmacs) or the syntax of the character (Emacs >= 26).
+
+(defvar c-lit-pos-cache-limit 1)
+(make-variable-buffer-local 'c-lit-pos-cache-limit)
+;; An upper limit on valid entries in `c-lit-pos-cache'.  This
 ;; is reduced by buffer changes, and increased by invocations of
 ;; `c-parse-ps-state-below'.
 
-(defsubst c-truncate-semi-nonlit-pos-cache (pos)
-  ;; Truncate the upper bound of the cache `c-state-semi-nonlit-pos-cache' to
-  ;; POS, if it is higher than that position.
-  (setq c-state-semi-nonlit-pos-cache-limit
-	(min c-state-semi-nonlit-pos-cache-limit pos)))
-
-(defun c-state-semi-pp-to-literal (here &optional not-in-delimiter)
-  ;; Do a parse-partial-sexp from a position in the buffer before HERE which
-  ;; isn't in a literal, and return information about HERE, either:
-  ;; (STATE TYPE BEG)          if HERE is in a literal; or
-  ;; (STATE)                   otherwise,
-  ;; where STATE is the parsing state at HERE, TYPE is the type of the literal
-  ;; enclosing HERE, (one of 'string, 'c, 'c++) and BEG is the starting
-  ;; position of that literal (including the delimiter).
-  ;;
-  ;; Unless NOT-IN-DELIMITER is non-nil, when TO is inside a two-character
-  ;; comment opener, this is recognized as being in a comment literal.
-  ;;
-  ;; Only elements 3 (in a string), 4 (in a comment), 5 (following a quote), 7
-  ;; (comment type), and 8 (start of comment/string), and possibly 10 (in
-  ;; newer Emacsen only, the syntax of a position after a potential first char
-  ;; of a two char construct) of STATE are valid.
-  (save-excursion
-    (save-restriction
-      (widen)
-      (save-match-data
-	(let* ((base-and-state (c-parse-ps-state-below here))
-	       (base (car base-and-state))
-	       (s (cdr base-and-state))
-	       (s (parse-partial-sexp base here nil nil s))
-	       ty)
-	  (cond
-	   ((or (nth 3 s)
-		(and (nth 4 s)
-		     (not (eq (nth 7 s) 'syntax-table)))) ; in a string or comment
-	    (setq ty (cond
-		      ((nth 3 s) 'string)
-		      ((nth 7 s) 'c++)
-		      (t 'c)))
-	    (list s ty (nth 8 s)))
-
-	   ((and (not not-in-delimiter)	; inside a comment starter
-		 (not (bobp))
-		 (progn (backward-char)
-			(and (not (and (memq 'category-properties c-emacs-features)
-				       (looking-at "\\s!")))
-			     (looking-at c-comment-start-regexp))))
-	    (setq ty (if (looking-at c-block-comment-start-regexp) 'c 'c++))
-	    (list s ty (point)))
-
-	   (t (list s))))))))
-
-(defun c-state-full-pp-to-literal (here &optional not-in-delimiter)
-  ;; This function will supersede c-state-pp-to-literal.
-  ;;
-  ;; Do a parse-partial-sexp from a position in the buffer before HERE which
-  ;; isn't in a literal, and return information about HERE, either:
-  ;; (STATE TYPE (BEG . END))   if HERE is in a literal; or
-  ;; (STATE)                    otherwise,
-  ;; where STATE is the parsing state at HERE, TYPE is the type of the literal
-  ;; enclosing HERE, (one of 'string, 'c, 'c++) and (BEG . END) is the
-  ;; boundaries of that literal (including the delimiters).
-  ;;
-  ;; Unless NOT-IN-DELIMITER is non-nil, when TO is inside a two-character
-  ;; comment opener, this is recognized as being in a comment literal.
-  ;;
-  ;; Only elements 3 (in a string), 4 (in a comment), 5 (following a quote), 7
-  ;; (comment type), and 8 (start of comment/string), and possibly 10 (in
-  ;; newer Emacsen only, the syntax of a position after a potential first char
-  ;; of a two char construct) of STATE are valid.
-  (save-excursion
-    (save-restriction
-      (widen)
-      (save-match-data
-	(let* ((base-and-state (c-parse-ps-state-below here))
-	       (base (car base-and-state))
-	       (s (cdr base-and-state))
-	       (s (parse-partial-sexp base here nil nil s))
-	       ty start)
-	  (cond
-	   ((or (nth 3 s)
-		(and (nth 4 s)
-		     (not (eq (nth 7 s) 'syntax-table)))) ; in a string or comment
-	    (setq ty (cond
-		      ((nth 3 s) 'string)
-		      ((nth 7 s) 'c++)
-		      (t 'c)))
-	    (setq start (nth 8 s))
-	    (parse-partial-sexp here (point-max)
-				nil	     ; TARGETDEPTH
-				nil	     ; STOPBEFORE
-				s	     ; OLDSTATE
-				'syntax-table) ; stop at end of literal
-	    (list s ty (cons start (point))))
-
-	   ((and (not not-in-delimiter)	; inside a comment starter
-		 (not (bobp))
-		 (progn (backward-char)
-			(and (not (and (memq 'category-properties c-emacs-features)
-				       (looking-at "\\s!")))
-			     (looking-at c-comment-start-regexp))))
-	    (setq ty (if (looking-at c-block-comment-start-regexp) 'c 'c++)
-		  start (point))
-	    (forward-comment 1)
-	    (list s ty (cons start (point))))
-
-	   (t (list s))))))))
-
-(defun c-state-pp-to-literal (from to &optional not-in-delimiter)
-  ;; Do a parse-partial-sexp from FROM to TO, returning either
-  ;;     (STATE TYPE (BEG . END))     if TO is in a literal; or
-  ;;     (STATE)                      otherwise,
-  ;; where STATE is the parsing state at TO, TYPE is the type of the literal
-  ;; (one of 'c, 'c++, 'string) and (BEG . END) is the boundaries of the literal,
-  ;; including the delimiters.
-  ;;
-  ;; Unless NOT-IN-DELIMITER is non-nil, when TO is inside a two-character
-  ;; comment opener, this is recognized as being in a comment literal.
-  ;;
-  ;; Only elements 3 (in a string), 4 (in a comment), 5 (following a quote),
-  ;; 7 (comment type) and 8 (start of comment/string) (and possibly 9) of
-  ;; STATE are valid.
-  (save-excursion
-    (save-match-data
-      (let ((s (parse-partial-sexp from to))
-	    ty co-st)
-	(cond
-	 ((or (nth 3 s)
-	      (and (nth 4 s)
-		   (not (eq (nth 7 s) 'syntax-table))))	; in a string or comment
-	  (setq ty (cond
-		    ((nth 3 s) 'string)
-		    ((nth 7 s) 'c++)
-		    (t 'c)))
-	  (parse-partial-sexp (point) (point-max)
-			      nil	   ; TARGETDEPTH
-			      nil	   ; STOPBEFORE
-			      s		   ; OLDSTATE
-			      'syntax-table) ; stop at end of literal
-	  `(,s ,ty (,(nth 8 s) . ,(point))))
-
-	 ((and (not not-in-delimiter)	; inside a comment starter
-	       (not (bobp))
-	       (progn (backward-char)
-		      (and (not (looking-at "\\s!"))
-			   (looking-at c-comment-start-regexp))))
-	  (setq ty (if (looking-at c-block-comment-start-regexp) 'c 'c++)
-		co-st (point))
-	  (forward-comment 1)
-	  `(,s ,ty (,co-st . ,(point))))
-
-	 (t `(,s)))))))
-
+;; Note that as of 2019-05-27, the forms involving CHAR-1 are no longer used.
 (defun c-cache-to-parse-ps-state (elt)
   ;; Create a list suitable to use as the old-state parameter to
   ;; `parse-partial-sexp', out of ELT, a member of
-  ;; `c-state-semi-nonlit-pos-cache'.  ELT is either just a number, or a list
+  ;; `c-lit-pos-cache'.  ELT is either just a number, or a list
   ;; with 2, 3, or 4 members (See `c-parse-ps-state-to-cache').  That number
   ;; or the car of the list is the "position element" of ELT, the position
   ;; where ELT is valid.
   ;;
-  ;; POINT is left at the position for which the returned state is valid.  It
+  ;; POINT is left at the postition for which the returned state is valid.  It
   ;; will be either the position element of ELT, or one character before
   ;; that.  (The latter happens in Emacs <= 25 and XEmacs, when ELT indicates
   ;; its position element directly follows a potential first character of a
@@ -2666,16 +2558,14 @@ comment at the start of cc-engine.el for more info."
 		com-style (if (eq type 'c++) 1 nil)))
 	 (t (c-benign-error "Invalid type %s in c-cache-to-parse-ps-state"
 			    elt)))
+	(goto-char (if char-1
+		       (1- pos)
+		     pos))
 	(if (memq 'pps-extended-state c-emacs-features)
-	    (progn
-	      (goto-char pos)
-	      (list depth containing last
-		    in-string in-comment after-quote
-		    min-depth com-style com-str-start
-		    intermediate char-1))
-	  (goto-char (if char-1
-			 (1- pos)
-		       pos))
+	    (list depth containing last
+		  in-string in-comment nil
+		  min-depth com-style com-str-start
+		  intermediate nil)
 	  (list depth containing last
 		in-string in-comment nil
 		min-depth com-style com-str-start
@@ -2695,9 +2585,10 @@ comment at the start of cc-engine.el for more info."
 		     nil
 		     0 nil nil nil)))))
 
+;; Note that as of 2019-05-27, the forms involving CHAR-1 are no longer used.
 (defun c-parse-ps-state-to-cache (state)
   ;; Convert STATE, a `parse-partial-sexp' state valid at POINT, to an element
-  ;; for the `c-state-semi-nonlit-pos-cache' cache.  This is one of
+  ;; for the `c-lit-pos-cache' cache.  This is one of
   ;;   o - POINT (when point is not in a literal);
   ;;   o - (POINT CHAR-1) (when the last character before point is potentially
   ;;       the first of a two-character construct
@@ -2715,7 +2606,7 @@ comment at the start of cc-engine.el for more info."
 	      ((nth 3 state)		; A string
 	       (list (point) (nth 3 state) (nth 8 state)))
 	      ((and (nth 4 state)		 ; A comment
-		    (not (eq (nth 7 state) 'syntax-table))) ; but not a pseudo comment.
+		    (not (eq (nth 7 state) 'syntax-table))) ; but not a psuedo comment.
 	       (list (point)
 		     (if (eq (nth 7 state) 1) 'c++ 'c)
 		     (nth 8 state)))
@@ -2751,11 +2642,22 @@ comment at the start of cc-engine.el for more info."
 
 (defsubst c-ps-state-cache-pos (elt)
   ;; Get the buffer position from ELT, an element from the cache
-  ;; `c-state-semi-nonlit-pos-cache'.
+  ;; `c-lit-pos-cache'.
   (if (atom elt)
       elt
     (car elt)))
 
+(defun c-trim-lit-pos-cache ()
+  ;; Trim the `c-lit-pos-cache' to take account of buffer
+  ;; changes, indicated by `c-lit-pos-cache-limit'.
+  (while (and c-lit-pos-cache
+	      (> (c-ps-state-cache-pos (car c-lit-pos-cache))
+		 c-lit-pos-cache-limit))
+    (setq c-lit-pos-cache (cdr c-lit-pos-cache))))
+
+(defconst c-state-nonlit-pos-interval 3000)
+;; The approximate interval between entries in `c-state-nonlit-pos-cache'.
+
 (defun c-parse-ps-state-below (here)
   ;; Given a buffer position HERE, Return a cons (CACHE-POS . STATE), where
   ;; CACHE-POS is a position not very far before HERE for which the
@@ -2766,14 +2668,9 @@ comment at the start of cc-engine.el for more info."
   (save-excursion
     (save-restriction
       (widen)
-      (let ((c c-state-semi-nonlit-pos-cache)
+      (c-trim-lit-pos-cache)
+      (let ((c c-lit-pos-cache)
 	    elt state npos high-elt)
-	;; Trim the cache to take account of buffer changes.
-	(while (and c (> (c-ps-state-cache-pos (car c))
-			 c-state-semi-nonlit-pos-cache-limit))
-	  (setq c (cdr c)))
-	(setq c-state-semi-nonlit-pos-cache c)
-
 	(while (and c (> (c-ps-state-cache-pos (car c)) here))
 	  (setq high-elt (car c))
 	  (setq c (cdr c)))
@@ -2786,19 +2683,435 @@ comment at the start of cc-engine.el for more info."
 
 	(when (not high-elt)
 	  ;; We need to extend the cache.  Add an element to
-	  ;; `c-state-semi-nonlit-pos-cache' each iteration of the following.
+	  ;; `c-lit-pos-cache' each iteration of the following.
 	  (while
 	      (<= (setq npos (+ (point) c-state-nonlit-pos-interval)) here)
 	    (setq state (parse-partial-sexp (point) npos nil nil state))
+	    ;; If we're after a \ or a / or * which might be a comment
+	    ;; delimiter half, move back a character.
+	    (when (or (nth 5 state)	; After a quote character
+		      (and (memq 'pps-extended-state c-emacs-features)
+			   (nth 10 state))) ; in the middle of a 2-char seq.
+	      (setq npos (1- npos))
+	      (backward-char)
+	      (when (nth 10 state)
+		(setcar (nthcdr 10 state) nil))
+	      (when (nth 5 state)
+		(setcar (nthcdr 5 state) nil)))
+
 	    (setq elt (c-parse-ps-state-to-cache state))
-	    (setq c-state-semi-nonlit-pos-cache
-		  (cons elt c-state-semi-nonlit-pos-cache))))
+	    (setq c-lit-pos-cache
+		  (cons elt c-lit-pos-cache))))
 
-	(if (> (point) c-state-semi-nonlit-pos-cache-limit)
-	    (setq c-state-semi-nonlit-pos-cache-limit (point)))
+	(if (> (point) c-lit-pos-cache-limit)
+	    (setq c-lit-pos-cache-limit (point)))
 
 	(cons (point) state)))))
 
+(defun c-semi-trim-near-cache ()
+  ;; Remove stale entries in `c-semi-lit-near-cache', i.e. those
+  ;; whose positions are above `c-lit-pos-cache-limit'.
+  (let ((nc-list c-semi-lit-near-cache))
+    (while nc-list
+      (if (> (caar nc-list) c-semi-near-cache-limit)
+	  (setq c-semi-lit-near-cache
+		(delq (car nc-list) c-semi-lit-near-cache)
+		nc-list c-semi-lit-near-cache) ; start again in case
+					; of list breakage.
+	(setq nc-list (cdr nc-list))))))
+
+(defun c-semi-get-near-cache-entry (here)
+  ;; Return the near cache entry at the highest postion before HERE, if any,
+  ;; or nil.  The near cache entry is of the form (POSITION . STATE), where
+  ;; STATE has the form of a result of `parse-partial-sexp'.
+  (let ((nc-pos-state
+	 (or (assq here c-semi-lit-near-cache)
+	     (let ((nc-list c-semi-lit-near-cache)
+		   pos (nc-pos 0) cand-pos-state)
+	       (catch 'found
+		 (while nc-list
+		   (setq pos (caar nc-list))
+		   (when (>= here pos)
+		     (cond
+		      ((and (cdar nc-list)
+			    (nth 8 (cdar nc-list))
+			    (< here (nth 8 (cdar nc-list))))
+		       (throw 'found (car nc-list)))
+		      ((> pos nc-pos)
+		       (setq nc-pos pos
+			     cand-pos-state (car nc-list)))))
+		   (setq nc-list (cdr nc-list)))
+		 cand-pos-state)))))
+    (when (and nc-pos-state
+	       (not (eq nc-pos-state (car c-semi-lit-near-cache))))
+      ;; Move the found cache entry to the front of the list.
+      (setq c-semi-lit-near-cache
+	    (delq nc-pos-state c-semi-lit-near-cache))
+      (push nc-pos-state c-semi-lit-near-cache))
+    (copy-tree nc-pos-state)))
+
+(defun c-semi-put-near-cache-entry (here state)
+  ;; Put a new near cache entry into the near cache.
+  (while (>= (length c-semi-lit-near-cache) 6)
+    (setq c-semi-lit-near-cache
+	  (delq (car (last c-semi-lit-near-cache))
+		c-semi-lit-near-cache)))
+  (push (cons here state) c-semi-lit-near-cache)
+  (setq c-semi-near-cache-limit
+	(max c-semi-near-cache-limit here)))
+
+(defun c-semi-pp-to-literal (here &optional not-in-delimiter)
+  ;; Do a parse-partial-sexp from a position in the buffer before HERE which
+  ;; isn't in a literal, and return information about HERE, either:
+  ;; (STATE TYPE BEG)          if HERE is in a literal; or
+  ;; (STATE)                   otherwise,
+  ;; where STATE is the parsing state at HERE, TYPE is the type of the literal
+  ;; enclosing HERE, (one of 'string, 'c, 'c++) and BEG is the starting
+  ;; position of that literal (including the delimiter).
+  ;;
+  ;; Unless NOT-IN-DELIMITER is non-nil, when TO is inside a two-character
+  ;; comment opener, this is recognized as being in a comment literal.
+  ;;
+  ;; Only elements 3 (in a string), 4 (in a comment), 5 (following a quote), 7
+  ;; (comment type), and 8 (start of comment/string), and possibly 10 (in
+  ;; newer Emacsen only, the syntax of a position after a potential first char
+  ;; of a two char construct) of STATE are valid.
+  (save-excursion
+    (save-restriction
+      (widen)
+      (c-trim-lit-pos-cache)
+      (c-semi-trim-near-cache)
+      (save-match-data
+	(let* ((pos-and-state (c-semi-get-near-cache-entry here))
+	       (pos (car pos-and-state))
+	       (near-pos pos)
+	       (s (cdr pos-and-state))
+	       far-pos-and-state far-pos far-s ty)
+	  (if (or (not pos)
+		  (< pos (- here 100)))
+	      (progn
+		(setq far-pos-and-state (c-parse-ps-state-below here)
+		      far-pos (car far-pos-and-state)
+		      far-s (cdr far-pos-and-state))
+		(when (or (not pos) (> far-pos pos))
+		  (setq pos far-pos
+			s far-s))))
+	  (when
+	      (or
+	       (> here pos)
+	       (null (nth 8 s))
+	       (< here (nth 8 s))	; Can't happen, can it?
+	       (not
+		(or
+		 (and (nth 3 s)		; string
+		      (not (eq (char-before here) ?\\)))
+		 (and (nth 4 s) (not (nth 7 s)) ; Block comment
+		      (not (memq (char-before here)
+				 c-block-comment-awkward-chars)))
+		 (and (nth 4 s) (nth 7 s) ; Line comment
+		      (not (memq (char-before here) '(?\\ ?\n)))))))
+	    (setq s (parse-partial-sexp pos here nil nil s)))
+	  (when (not (eq near-pos here))
+	    (c-semi-put-near-cache-entry here s))
+	  (cond
+	   ((or (nth 3 s)
+		(and (nth 4 s)
+		     (not (eq (nth 7 s) 'syntax-table)))) ; in a string or comment
+	    (setq ty (cond
+		      ((nth 3 s) 'string)
+		      ((nth 7 s) 'c++)
+		      (t 'c)))
+	    (list s ty (nth 8 s)))
+
+	   ((and (not not-in-delimiter)	; inside a comment starter
+		 (not (bobp))
+		 (progn (backward-char)
+			(and (not (and (memq 'category-properties c-emacs-features)
+				       (looking-at "\\s!")))
+			     (looking-at c-comment-start-regexp))))
+	    (setq ty (if (looking-at c-block-comment-start-regexp) 'c 'c++))
+	    (list s ty (point)))
+
+	   (t (list s))))))))
+
+(defvar c-full-near-cache-limit 1)
+(make-variable-buffer-local 'c-full-near-cache-limit)
+;; An upper limit on valid entries in `c-full-lit-near-cache'.  This
+;; is reduced by buffer changes, and increased by invocations of
+;; `c-full-pp-to-literal'.
+
+(defvar c-full-lit-near-cache nil)
+(make-variable-buffer-local 'c-full-lit-near-cache)
+;; A list of up to six recent results from `c-full-pp-to-literal'.  Each
+;; element is a list (HERE STATE END)), where HERE is the buffer position the
+;; function was called for, STATE is the `parse-partial-sexp' state there, and
+;; END is the end of the literal enclosing HERE, if any, or nil otherwise.
+
+(defun c-full-trim-near-cache ()
+  ;; Remove stale entries in `c-full-lit-near-cache', i.e. those whose END
+  ;; entries, or positions, are above `c-full-near-cache-limit'.
+  (let ((nc-list c-full-lit-near-cache) elt)
+    (while nc-list
+      (let ((elt (car nc-list)))
+	(if (if (car (cddr elt))
+		(< c-full-near-cache-limit (car (cddr elt)))
+	      (< c-full-near-cache-limit (car elt)))
+	    (setq c-full-lit-near-cache
+		  (delq elt c-full-lit-near-cache)
+		  nc-list c-full-lit-near-cache) ; start again in
+					; case of list breakage.
+	  (setq nc-list (cdr nc-list)))))))
+
+(defun c-full-get-near-cache-entry (here)
+  ;; Return a near cache entry which either represents a literal which
+  ;; encloses HERE, or is at the highest position before HERE.  The returned
+  ;; cache entry is of the form (POSITION STATE END), where STATE has the form
+  ;; of a result from `parse-partial-sexp' which is valid at POSITION and END
+  ;; is the end of any enclosing literal, or nil.
+  (let ((nc-pos-state
+	 (or (assq here c-full-lit-near-cache)
+	     (let ((nc-list c-full-lit-near-cache)
+		   elt (nc-pos 0) cand-pos-state)
+	       (catch 'found
+		 (while nc-list
+		   (setq elt (car nc-list))
+		   (when
+		       (and (car (cddr elt))
+			    (>= here (nth 8 (cadr elt)))
+			    (< here (car (cddr elt))))
+		     (throw 'found elt))
+		   (when
+		       (and (< (car elt) here)
+			    (> (car elt) nc-pos))
+		     (setq nc-pos (car elt)
+			   cand-pos-state elt))
+		   (setq nc-list (cdr nc-list)))
+		 cand-pos-state)))))
+    ;; Move the found cache entry, if any, to the front of the list.
+    (when (and nc-pos-state
+	       (not (eq nc-pos-state (car c-full-lit-near-cache))))
+      (setq c-full-lit-near-cache
+	    (delq nc-pos-state c-full-lit-near-cache))
+      (push nc-pos-state c-full-lit-near-cache))
+    (copy-tree nc-pos-state)))
+
+(defun c-full-put-near-cache-entry (here state end)
+  ;; Put a new near chace entry into the near cache.
+  (while (>= (length c-full-lit-near-cache) 6)
+    (setq c-full-lit-near-cache
+	  (delq (car (last c-full-lit-near-cache))
+		c-full-lit-near-cache)))
+  (push (list here state end) c-full-lit-near-cache)
+  (setq c-full-near-cache-limit
+	(max c-full-near-cache-limit (or end here))))
+
+(defun c-full-pp-to-literal (here &optional not-in-delimiter)
+  ;; This function will supersede c-state-pp-to-literal.
+  ;;
+  ;; Do a parse-partial-sexp from a position in the buffer before HERE which
+  ;; isn't in a literal, and return information about HERE, either:
+  ;; (STATE TYPE (BEG . END))   if HERE is in a literal; or
+  ;; (STATE)                    otherwise,
+  ;; where STATE is the parsing state at HERE, TYPE is the type of the literal
+  ;; enclosing HERE, (one of 'string, 'c, 'c++) and (BEG . END) is the
+  ;; boundaries of that literal (including the delimiters).
+  ;;
+  ;; Unless NOT-IN-DELIMITER is non-nil, when TO is inside a two-character
+  ;; comment opener, this is recognized as being in a comment literal.
+  ;;
+  ;; Only elements 3 (in a string), 4 (in a comment), 5 (following a quote), 7
+  ;; (comment type), and 8 (start of comment/string), and possibly 10 (in
+  ;; newer Emacsen only, the syntax of a position after a potential first char
+  ;; of a two char construct) of STATE are valid.
+  (save-excursion
+    (save-restriction
+      (widen)
+      (c-trim-lit-pos-cache)
+      (c-full-trim-near-cache)
+      (save-match-data
+	(let* ((elt (c-full-get-near-cache-entry here))
+	       (base (car elt))
+	       (near-base base)
+	       (s (cadr elt))
+	       (end (car (cddr elt)))
+	       far-base-and-state far-base far-s ty start)
+	  (if (or
+	       (not base)   ; FIXME!!! Compare base and far-base??
+					; (2019-05-21)
+	       (not end)
+	       (> here end))
+	      (progn
+		(setq far-base-and-state (c-parse-ps-state-below here)
+		      far-base (car far-base-and-state)
+		      far-s (cdr far-base-and-state))
+		(when (or (not base) (> far-base base))
+		  (setq base far-base
+			s far-s
+			end nil))))
+	  (when
+	      (or
+	       (and (> here base) (null end))
+	       (null (nth 8 s))
+	       (and end (> here end))
+	       (not
+		(or
+		 (and (nth 3 s)		; string
+		      (not (eq (char-before here) ?\\)))
+		 (and (nth 4 s) (not (nth 7 s)) ; Block comment
+		      (not (memq (char-before here)
+				 c-block-comment-awkward-chars)))
+		 (and (nth 4 s) (nth 7 s) ; Line comment
+		      (not (memq (char-before here) '(?\\ ?\n)))))))
+	    (setq s (parse-partial-sexp base here nil nil s)))
+	  (cond
+	   ((or (nth 3 s)
+		(and (nth 4 s)
+		     (not (eq (nth 7 s) 'syntax-table)))) ; in a string or comment
+	    (setq ty (cond
+		      ((nth 3 s) 'string)
+		      ((nth 7 s) 'c++)
+		      (t 'c)))
+	    (setq start (nth 8 s))
+	    (unless end
+	      (parse-partial-sexp here (point-max)
+				  nil	     ; TARGETDEPTH
+				  nil	     ; STOPBEFORE
+				  s	     ; OLDSTATE
+				  'syntax-table) ; stop at end of literal
+	      (setq end (point)))
+	    (unless (eq near-base here)
+	      (c-full-put-near-cache-entry here s end))
+	    (list s ty (cons start end)))
+
+	   ((and (not not-in-delimiter)	; inside a comment starter
+		 (not (bobp))
+		 (progn (backward-char)
+			(and (not (and (memq 'category-properties c-emacs-features)
+				       (looking-at "\\s!")))
+			     (looking-at c-comment-start-regexp))))
+	    (setq ty (if (looking-at c-block-comment-start-regexp) 'c 'c++)
+		  start (point))
+	    (forward-comment 1)
+	    (list s ty (cons start (point))))
+
+	   (t
+	    (c-full-put-near-cache-entry here s nil)
+	    (list s))))))))
+
+(defsubst c-truncate-lit-pos-cache (pos)
+  ;; Truncate the upper bound of each of the three caches to POS, if it is
+  ;; higher than that position.
+  (setq c-lit-pos-cache-limit (min c-lit-pos-cache-limit pos)
+	c-semi-near-cache-limit (min c-semi-near-cache-limit pos)
+	c-full-near-cache-limit (min c-full-near-cache-limit pos)))
+
+
+;; A system for finding noteworthy parens before the point.
+
+(defconst c-state-cache-too-far 5000)
+;; A maximum comfortable scanning distance, e.g. between
+;; `c-state-cache-good-pos' and "HERE" (where we call c-parse-state).  When
+;; this distance is exceeded, we take "emergency measures", e.g. by clearing
+;; the cache and starting again from point-min or a beginning of defun.  This
+;; value can be tuned for efficiency or set to a lower value for testing.
+
+(defvar c-state-cache nil)
+(make-variable-buffer-local 'c-state-cache)
+;; The state cache used by `c-parse-state' to cut down the amount of
+;; searching.  It's the result from some earlier `c-parse-state' call.  See
+;; `c-parse-state''s doc string for details of its structure.
+;;
+;; The use of the cached info is more effective if the next
+;; `c-parse-state' call is on a line close by the one the cached state
+;; was made at; the cache can actually slow down a little if the
+;; cached state was made very far back in the buffer.  The cache is
+;; most effective if `c-parse-state' is used on each line while moving
+;; forward.
+
+(defvar c-state-cache-good-pos 1)
+(make-variable-buffer-local 'c-state-cache-good-pos)
+;; This is a position where `c-state-cache' is known to be correct, or
+;; nil (see below).  It's a position inside one of the recorded unclosed
+;; parens or the top level, but not further nested inside any literal or
+;; subparen that is closed before the last recorded position.
+;;
+;; The exact position is chosen to try to be close to yet earlier than
+;; the position where `c-state-cache' will be called next.  Right now
+;; the heuristic is to set it to the position after the last found
+;; closing paren (of any type) before the line on which
+;; `c-parse-state' was called.  That is chosen primarily to work well
+;; with refontification of the current line.
+;;
+;; 2009-07-28: When `c-state-point-min' and the last position where
+;; `c-parse-state' or for which `c-invalidate-state-cache' was called, are
+;; both in the same literal, there is no such "good position", and
+;; c-state-cache-good-pos is then nil.  This is the ONLY circumstance in which
+;; it can be nil.  In this case, `c-state-point-min-literal' will be non-nil.
+;;
+;; 2009-06-12: In a brace desert, c-state-cache-good-pos may also be in
+;; the middle of the desert, as long as it is not within a brace pair
+;; recorded in `c-state-cache' or a paren/bracket pair.
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; We maintain a simple cache of positions which aren't in a literal, so as to
+;; speed up testing for non-literality.
+(defvar c-state-nonlit-pos-cache nil)
+(make-variable-buffer-local 'c-state-nonlit-pos-cache)
+;; A list of buffer positions which are known not to be in a literal or a cpp
+;; construct.  This is ordered with higher positions at the front of the list.
+;; Only those which are less than `c-state-nonlit-pos-cache-limit' are valid.
+
+(defvar c-state-nonlit-pos-cache-limit 1)
+(make-variable-buffer-local 'c-state-nonlit-pos-cache-limit)
+;; An upper limit on valid entries in `c-state-nonlit-pos-cache'.  This is
+;; reduced by buffer changes, and increased by invocations of
+;; `c-state-literal-at'.
+
+(defun c-state-pp-to-literal (from to &optional not-in-delimiter)
+  ;; Do a parse-partial-sexp from FROM to TO, returning either
+  ;;     (STATE TYPE (BEG . END))     if TO is in a literal; or
+  ;;     (STATE)                      otherwise,
+  ;; where STATE is the parsing state at TO, TYPE is the type of the literal
+  ;; (one of 'c, 'c++, 'string) and (BEG . END) is the boundaries of the literal,
+  ;; including the delimiters.
+  ;;
+  ;; Unless NOT-IN-DELIMITER is non-nil, when TO is inside a two-character
+  ;; comment opener, this is recognized as being in a comment literal.
+  ;;
+  ;; Only elements 3 (in a string), 4 (in a comment), 5 (following a quote),
+  ;; 7 (comment type) and 8 (start of comment/string) (and possibly 9) of
+  ;; STATE are valid.
+  (save-excursion
+    (save-match-data
+      (let ((s (parse-partial-sexp from to))
+	    ty co-st)
+	(cond
+	 ((or (nth 3 s)
+	      (and (nth 4 s)
+		   (not (eq (nth 7 s) 'syntax-table))))	; in a string or comment
+	  (setq ty (cond
+		    ((nth 3 s) 'string)
+		    ((nth 7 s) 'c++)
+		    (t 'c)))
+	  (parse-partial-sexp (point) (point-max)
+			      nil	   ; TARGETDEPTH
+			      nil	   ; STOPBEFORE
+			      s		   ; OLDSTATE
+			      'syntax-table) ; stop at end of literal
+	  `(,s ,ty (,(nth 8 s) . ,(point))))
+
+	 ((and (not not-in-delimiter)	; inside a comment starter
+	       (not (bobp))
+	       (progn (backward-char)
+		      (and (not (looking-at "\\s!"))
+			   (looking-at c-comment-start-regexp))))
+	  (setq ty (if (looking-at c-block-comment-start-regexp) 'c 'c++)
+		co-st (point))
+	  (forward-comment 1)
+	  `(,s ,ty (,co-st . ,(point))))
+
+	 (t `(,s)))))))
+
 (defun c-state-safe-place (here)
   ;; Return a buffer position before HERE which is "safe", i.e. outside any
   ;; string, comment, or macro.
@@ -3724,8 +4037,6 @@ comment at the start of cc-engine.el for more info."
 	c-state-cache-good-pos 1
 	c-state-nonlit-pos-cache nil
 	c-state-nonlit-pos-cache-limit 1
-	c-state-semi-nonlit-pos-cache nil
-	c-state-semi-nonlit-pos-cache-limit 1
 	c-state-brace-pair-desert nil
 	c-state-point-min 1
 	c-state-point-min-lit-type nil
@@ -3775,7 +4086,7 @@ comment at the start of cc-engine.el for more info."
   ;; HERE.
   (if (<= here c-state-nonlit-pos-cache-limit)
       (setq c-state-nonlit-pos-cache-limit (1- here)))
-  (c-truncate-semi-nonlit-pos-cache here)
+  (c-truncate-lit-pos-cache here)
 
   ;; `c-state-cache':
   ;; Case 1: if `here' is in a literal containing point-min, everything
@@ -4000,8 +4311,6 @@ comment at the start of cc-engine.el for more info."
 	   c-state-cache-good-pos
 	   c-state-nonlit-pos-cache
 	   c-state-nonlit-pos-cache-limit
-	   c-state-semi-nonlit-pos-cache
-	   c-state-semi-nonlit-pos-cache-limit
 	   c-state-brace-pair-desert
 	   c-state-point-min
 	   c-state-point-min-lit-type
@@ -4323,6 +4632,30 @@ comment at the start of cc-engine.el for more info."
 		       (goto-char pos))))))
       (< (point) start)))
 
+(defun c-end-of-token (&optional back-limit)
+  ;; Move to the end of the token we're just before or in the middle of.
+  ;; BACK-LIMIT may be used to bound the backward search; if given it's
+  ;; assumed to be at the boundary between two tokens.  Return non-nil if the
+  ;; point is moved, nil otherwise.
+  ;;
+  ;; This function might do hidden buffer changes.
+  (let ((start (point)))
+    (cond ;; ((< (skip-syntax-backward "w_" (1- start)) 0)
+     ;;  (skip-syntax-forward "w_"))
+     ((> (skip-syntax-forward "w_") 0))
+     ((< (skip-syntax-backward ".()" back-limit) 0)
+      (while (< (point) start)
+	(if (looking-at c-nonsymbol-token-regexp)
+	    (goto-char (match-end 0))
+	  ;; `c-nonsymbol-token-regexp' should always match since
+	  ;; we've skipped backward over punctuation or paren
+	  ;; syntax, but move forward in case it doesn't so that
+	  ;; we don't leave point earlier than we started with.
+	  (forward-char))))
+     (t (if (looking-at c-nonsymbol-token-regexp)
+	    (goto-char (match-end 0)))))
+    (> (point) start)))
+
 (defun c-end-of-current-token (&optional back-limit)
   ;; Move to the end of the current token.  Do not move if not in the
   ;; middle of one.  BACK-LIMIT may be used to bound the backward
@@ -5055,7 +5388,7 @@ Note that this function might do hidden buffer changes.  See the
 comment at the start of cc-engine.el for more info."
   (save-restriction
     (widen)
-    (let ((lit (c-state-semi-pp-to-literal (point))))
+    (let ((lit (c-semi-pp-to-literal (point))))
       (or (cadr lit)
 	  (and detect-cpp
 	       (save-excursion (c-beginning-of-macro))
@@ -5090,7 +5423,7 @@ comment at the start of cc-engine.el for more info."
 						   s
 						   'syntax-table)
 			       (point)))))
-	    (let ((pp-to-lit (c-state-full-pp-to-literal pos not-in-delimiter)))
+	    (let ((pp-to-lit (c-full-pp-to-literal pos not-in-delimiter)))
 	      (car (cddr pp-to-lit))))))
       (cond
        (lit-limits)
@@ -5139,7 +5472,7 @@ a known \"safe position\", i.e. outside of any string or comment."
 	(and (or (nth 3 s)
 		 (and (nth 4 s) (not (eq (nth 7 s) 'syntax-table))))
 	     (nth 8 s)))
-    (car (cddr (c-state-semi-pp-to-literal (point))))))
+    (car (cddr (c-semi-pp-to-literal (point))))))
 
 ;; In case external callers use this; it did have a docstring.
 (defalias 'c-literal-limits-fast 'c-literal-limits)
@@ -5210,7 +5543,7 @@ comment at the start of cc-engine.el for more info."
   (c-backward-syntactic-ws)
   (setq start (point))
   (let* ((pos (max (- start try-size) (point-min)))
-	 (s (c-state-semi-pp-to-literal pos))
+	 (s (c-semi-pp-to-literal pos))
 	 (cand (or (car (cddr s)) pos)))
     (if (>= cand (point-min))
 	cand
@@ -5453,6 +5786,9 @@ comment at the start of cc-engine.el for more info."
   (setq c-bs-cache-limit
 	(min c-bs-cache-limit pos)))
 
+(defvar c-restricted-<>-arglists)	;FIXME: Move definition here?
+(defvar c-parse-and-markup-<>-arglists)	;FIXME: Move definition here?
+
 (defun c-update-brace-stack (stack from to)
   ;; Given a brace-stack which has the value STACK at position FROM, update it
   ;; to its value at position TO, where TO is after (or equal to) FROM.
@@ -5507,7 +5843,9 @@ comment at the start of cc-engine.el for more info."
 		      (prog1 (looking-at "\\s(")
 			(forward-char))))
 	  (backward-char)
-	  (if (c-forward-<>-arglist nil) ; Should always work.
+	  (if (let ((c-parse-and-markup-<>-arglists t)
+		    (c-restricted-<>-arglists t))
+		(c-forward-<>-arglist nil)) ; Should always work.
 	      (when (> (point) to)
 		(setq bound-<> (point)))
 	    (forward-char)))
@@ -5556,7 +5894,7 @@ comment at the start of cc-engine.el for more info."
 	(when (not high-elt)
 	  (setq stack (cdr elt))
 	  (while
-	      ;; Add an element to `c-state-semi-nonlit-pos-cache' each iteration.
+	      ;; Add an element to `c-bs-cache' each iteration.
 	      (<= (setq npos (+ pos c-bs-interval)) here)
 	    (setq elt (c-update-brace-stack stack pos npos))
 	    (setq npos (car elt))
@@ -5634,7 +5972,10 @@ comment at the start of cc-engine.el for more info."
 	       (setq cfd-re-match cfd-limit)
 	       nil)
 	      ((c-got-face-at
-		(if (setq cfd-re-match (match-end 1))
+		(if (setq cfd-re-match
+			  (or (match-end 1)
+			      (and c-dposr-cpp-macro-depth
+				   (match-end (1+ c-dposr-cpp-macro-depth)))))
 		    ;; Matched the end of a token preceding a decl spot.
 		    (progn
 		      (goto-char cfd-re-match)
@@ -5645,15 +5986,19 @@ comment at the start of cc-engine.el for more info."
 		c-literal-faces)
 	       ;; Pseudo match inside a comment or string literal.  Skip out
 	       ;; of comments and string literals.
-	       (while (progn
-			(unless
-			    (and (match-end 1)
-				 (c-got-face-at (1- (point)) c-literal-faces)
-				 (not (c-got-face-at (point) c-literal-faces)))
-			  (goto-char (c-next-single-property-change
-				      (point) 'face nil cfd-limit)))
-			(and (< (point) cfd-limit)
-			     (c-got-face-at (point) c-literal-faces))))
+	       (while
+		   (progn
+		     (unless
+			 (and
+			  (or (match-end 1)
+			      (and c-dposr-cpp-macro-depth
+				   (match-end (1+ c-dposr-cpp-macro-depth))))
+			  (c-got-face-at (1- (point)) c-literal-faces)
+			  (not (c-got-face-at (point) c-literal-faces)))
+		       (goto-char (c-next-single-property-change
+				   (point) 'face nil cfd-limit)))
+		     (and (< (point) cfd-limit)
+			  (c-got-face-at (point) c-literal-faces))))
 	       t)		      ; Continue the loop over pseudo matches.
 	      ((and c-opt-identifier-concat-key
 		    (match-string 1)
@@ -5691,7 +6036,21 @@ comment at the start of cc-engine.el for more info."
 
      (when (< cfd-match-pos cfd-limit)
        ;; Skip forward past comments only so we don't skip macros.
-       (c-forward-comments)
+       (while
+	   (progn
+	     (c-forward-comments)
+	     ;; The following is of use within a doc comment when a doc
+	     ;; comment style has removed face properties from a construct,
+	     ;; and is relying on `c-font-lock-declarations' to add them
+	     ;; again.
+	     (cond
+	      ((looking-at c-noise-macro-name-re)
+	       (c-forward-noise-clause-not-macro-decl nil)) ; Returns t.
+	      ((looking-at c-noise-macro-with-parens-name-re)
+	       (c-forward-noise-clause-not-macro-decl t)) ; Always returns t.
+	      ((and (< (point) cfd-limit)
+		    (looking-at c-doc-line-join-re))
+	       (goto-char (match-end 0))))))
        ;; Set the position to continue at.  We can avoid going over
        ;; the comments skipped above a second time, but it's possible
        ;; that the comment skipping has taken us past `cfd-prop-match'
@@ -5720,6 +6079,8 @@ comment at the start of cc-engine.el for more info."
   ;; o	The first token after the end of submatch 1 in
   ;;	`c-decl-prefix-or-start-re' when that submatch matches.	 This
   ;;	submatch is typically a (L or R) brace or paren, a ;, or a ,.
+  ;;    As a special case, noise macros are skipped over and the next
+  ;;    token regarded as the spot.
   ;; o	The start of each `c-decl-prefix-or-start-re' match when
   ;;	submatch 1 doesn't match.  This is, for example, the keyword
   ;;	"class" in Pike.
@@ -5796,7 +6157,7 @@ comment at the start of cc-engine.el for more info."
     ;; before the point, and do the first `c-decl-prefix-or-start-re'
     ;; search unless we're at bob.
 
-    (let (start-in-literal start-in-macro syntactic-pos)
+    (let (start-in-literal start-in-macro syntactic-pos hash-define-pos)
       ;; Must back up a bit since we look for the end of the previous
       ;; statement or declaration, which is earlier than the first
       ;; returned match.
@@ -5950,8 +6311,22 @@ comment at the start of cc-engine.el for more info."
 	  (goto-char (or start-in-literal cfd-start-pos))
 	  ;; The only syntactic ws in macros are comments.
 	  (c-backward-comments)
-	  (backward-char)
-	  (c-beginning-of-current-token))
+	  (or (bobp) (backward-char))
+	  (c-beginning-of-current-token)
+	  ;; If we're in a macro without argument parentheses, we could have
+	  ;; now ended up at the macro's identifier.  We need to be at #define
+	  ;; for `c-find-decl-prefix-search' to find the first token of the
+	  ;; macro's expansion.
+	  (when (and (c-on-identifier)
+		     (setq hash-define-pos
+			   (save-excursion
+			     (and
+			      (zerop (c-backward-token-2 2)) ; over define, #
+			      (save-excursion
+				(beginning-of-line)
+				(looking-at c-opt-cpp-macro-define-id))
+			      (point)))))
+	    (goto-char hash-define-pos)))
 
 	 (start-in-literal
 	  ;; If we're in a comment it can only be the closest
@@ -5975,7 +6350,8 @@ comment at the start of cc-engine.el for more info."
 			  (not (eq (c-get-char-property (point) 'c-type)
 				   'c-decl-end))))))
 
-	  (when (= (point) start-in-literal)
+	  (when (and (= (point) start-in-literal)
+		     (not (looking-at c-doc-bright-comment-start-re)))
 	    ;; Didn't find any property inside the comment, so we can
 	    ;; skip it entirely.  (This won't skip past a string, but
 	    ;; that'll be handled quickly by the next
@@ -6377,44 +6753,52 @@ comment at the start of cc-engine.el for more info."
   ;;
   ;; FIXME!!!  This routine ignores the possibility of macros entirely.
   ;; 2010-01-29.
-  (save-excursion
-    (c-save-buffer-state
-	((beg-lit-start (progn (goto-char beg) (c-literal-start)))
-	 (end-lit-limits (progn (goto-char end) (c-literal-limits)))
-	 new-beg new-end beg-limit end-limit)
-      ;; Locate the earliest < after the barrier before the changed region,
-      ;; which isn't already marked as a paren.
-      (goto-char (or beg-lit-start beg))
-      (setq beg-limit (c-determine-limit 512))
-
-      ;; Remove the syntax-table/category properties from each pertinent <...>
-      ;; pair.  Firstly, the ones with the < before beg and > after beg....
-      (while (progn (c-syntactic-skip-backward "^;{}<" beg-limit)
-		    (eq (char-before) ?<))
-	(c-backward-token-2)
-	(when (eq (char-after) ?<)
-	  (c-clear-<-pair-props-if-match-after beg)
-	  (setq new-beg (point))))
-      (c-forward-syntactic-ws)
+  (when (and (> end beg)
+	     (or
+	      (progn
+		(goto-char beg)
+		(search-backward "<" (max (- (point) 1024) (point-min)) t))
+	      (progn
+		(goto-char end)
+		(search-forward ">" (min (+ (point) 1024) (point-max)) t))))
+    (save-excursion
+      (c-save-buffer-state
+	  ((beg-lit-start (progn (goto-char beg) (c-literal-start)))
+	   (end-lit-limits (progn (goto-char end) (c-literal-limits)))
+	   new-beg new-end beg-limit end-limit)
+	;; Locate the earliest < after the barrier before the changed region,
+	;; which isn't already marked as a paren.
+	(goto-char (or beg-lit-start beg))
+	(setq beg-limit (c-determine-limit 512))
+
+	;; Remove the syntax-table/category properties from each pertinent <...>
+	;; pair.  Firstly, the ones with the < before beg and > after beg....
+	(while (progn (c-syntactic-skip-backward "^;{}<" beg-limit)
+		      (eq (char-before) ?<))
+	  (c-backward-token-2)
+	  (when (eq (char-after) ?<)
+	    (c-clear-<-pair-props-if-match-after beg)
+	    (setq new-beg (point))))
+	(c-forward-syntactic-ws)
 
-      ;; ...Then the ones with < before end and > after end.
-      (goto-char (if end-lit-limits (cdr end-lit-limits) end))
-      (setq end-limit (c-determine-+ve-limit 512))
-      (while (and (c-syntactic-re-search-forward "[;{}>]" end-limit 'end)
-		  (eq (char-before) ?>))
-	(c-end-of-current-token)
-	(when (eq (char-before) ?>)
-	  (c-clear->-pair-props-if-match-before end (1- (point)))
-	  (setq new-end (point))))
-      (c-backward-syntactic-ws)
-
-      ;; Extend the fontification region, if needed.
-      (and new-beg
-	   (< new-beg c-new-BEG)
-	   (setq c-new-BEG new-beg))
-      (and new-end
-	   (> new-end c-new-END)
-	   (setq c-new-END new-end)))))
+	;; ...Then the ones with < before end and > after end.
+	(goto-char (if end-lit-limits (cdr end-lit-limits) end))
+	(setq end-limit (c-determine-+ve-limit 512))
+	(while (and (c-syntactic-re-search-forward "[;{}>]" end-limit 'end)
+		    (eq (char-before) ?>))
+	  (c-end-of-current-token)
+	  (when (eq (char-before) ?>)
+	    (c-clear->-pair-props-if-match-before end (1- (point)))
+	    (setq new-end (point))))
+	(c-backward-syntactic-ws)
+
+	;; Extend the fontification region, if needed.
+	(and new-beg
+	     (< new-beg c-new-BEG)
+	     (setq c-new-BEG new-beg))
+	(and new-end
+	     (> new-end c-new-END)
+	     (setq c-new-END new-end))))))
 
 (defun c-after-change-check-<>-operators (beg end)
   ;; This is called from `after-change-functions' when
@@ -6454,9 +6838,6 @@ comment at the start of cc-engine.el for more info."
 	    (c-clear-<>-pair-props)
 	    (forward-char)))))))
 
-(defvar c-restricted-<>-arglists)	;FIXME: Move definition here?
-(defvar c-parse-and-markup-<>-arglists)	;FIXME: Move definition here?
-
 (defun c-restore-<>-properties (_beg _end _old-len)
   ;; This function is called as an after-change function.  It restores the
   ;; category/syntax-table properties on template/generic <..> pairs between
@@ -6535,6 +6916,9 @@ comment at the start of cc-engine.el for more info."
 ;; BEG and END.
 (defvar c-old-beg-rs nil)
 (defvar c-old-end-rs nil)
+;; Whether a buffer change has disrupted or will disrupt the terminating id of
+;; a raw string.
+(defvar c-raw-string-end-delim-disrupted nil)
 
 (defun c-raw-string-pos ()
   ;; Get POINT's relationship to any containing raw string.
@@ -6553,7 +6937,7 @@ comment at the start of cc-engine.el for more info."
   ;;
   ;; Note: this function is dependant upon the correct syntax-table text
   ;; properties being set.
-  (let ((state (c-state-semi-pp-to-literal (point)))
+  (let ((state (c-semi-pp-to-literal (point)))
 	open-quote-pos open-paren-pos close-paren-pos close-quote-pos id)
     (save-excursion
       (when
@@ -6572,15 +6956,14 @@ comment at the start of cc-engine.el for more info."
 		      (while
 			  (and
 			   (search-forward-regexp
-			    "R\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)("
+			    c-c++-raw-string-opener-re
 			    (1+ here) 'limit)
 			   (< (point) here)))
 		      (and (eq (point) (1+ here))
 			   (match-beginning 1)
 			   (goto-char (1- (match-beginning 1)))))))
 		  (not (bobp)))))
-	   (eq (char-before) ?R)
-	   (looking-at "\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)("))
+	   (c-at-c++-raw-string-opener))
 	(setq open-quote-pos (point)
 	      open-paren-pos (match-end 1)
 	      id (match-string-no-properties 1))
@@ -6635,7 +7018,7 @@ comment at the start of cc-engine.el for more info."
     ;; the 'syntax-table property from all of them.
     (setq first (c-clear-char-property-with-value-on-char
 		 open-quote open-paren 'syntax-table '(1) ?\"))
-    (if first (c-truncate-semi-nonlit-pos-cache first))
+    (if first (c-truncate-lit-pos-cache first))
     (cond
      ((null open-paren-prop)
       ;; Should be a terminated raw string...
@@ -6645,7 +7028,7 @@ comment at the start of cc-engine.el for more info."
 	(setq first (c-clear-char-property-with-value-on-char
 		     (1+ (match-beginning 0)) (1- (match-end 0))
 		     'syntax-table '(1) ?\"))
-	(if first (c-truncate-semi-nonlit-pos-cache first))
+	(if first (c-truncate-lit-pos-cache first))
 	;; Clear any random `syntax-table' text properties from the contents.
 	(let* ((closing-paren (match-beginning 0))
 	       (first-st
@@ -6663,7 +7046,7 @@ comment at the start of cc-engine.el for more info."
 	  (when first-st
 	    (c-clear-char-properties first-st (match-beginning 0)
 				     'syntax-table)
-	    (c-truncate-semi-nonlit-pos-cache first-st))
+	    (c-truncate-lit-pos-cache first-st))
 	  (when (c-get-char-property (1- (match-end 0)) 'syntax-table)
 	    ;; Was previously an unterminated (ordinary) string
 	    (save-excursion
@@ -6671,19 +7054,19 @@ comment at the start of cc-engine.el for more info."
 	      (when (c-safe (c-forward-sexp)) ; to '(1) at EOL.
 		(c-clear-char-property (1- (point)) 'syntax-table))
 	      (c-clear-char-property (1- (match-end 0)) 'syntax-table)
-	      (c-truncate-semi-nonlit-pos-cache (1- (match-end 0))))))))
+	      (c-truncate-lit-pos-cache (1- (match-end 0))))))))
      ((or (and (equal open-paren-prop '(15)) (null bound))
 	  (equal open-paren-prop '(1)))
       ;; An unterminated raw string either not in a macro, or in a macro with
       ;; the open parenthesis right up against the end of macro
       (c-clear-char-property open-quote 'syntax-table)
-      (c-truncate-semi-nonlit-pos-cache open-quote)
+      (c-truncate-lit-pos-cache open-quote)
       (c-clear-char-property open-paren 'syntax-table))
      (t
       ;; An unterminated string in a macro, with at least one char after the
       ;; open paren
       (c-clear-char-property open-quote 'syntax-table)
-      (c-truncate-semi-nonlit-pos-cache open-quote)
+      (c-truncate-lit-pos-cache open-quote)
       (c-clear-char-property open-paren 'syntax-table)
       (c-clear-char-property-with-value (1+ open-paren) bound 'syntax-table
 					'(15))))))
@@ -6698,7 +7081,7 @@ comment at the start of cc-engine.el for more info."
 	       (concat "\\("				     ; 1
 		       c-anchored-cpp-prefix		     ; 2
 		       "\\)\\|\\("			     ; 3
-		       "R\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)("  ; 4
+		       c-c++-raw-string-opener-re	     ; 4
 		       "\\)")
 	       finish t))
     (when (save-excursion
@@ -6717,7 +7100,7 @@ comment at the start of cc-engine.el for more info."
 	  (goto-char (match-end 2))	; after the "#".
 	  (while (and (< (point) eom)
 		      (c-syntactic-re-search-forward
-		       "R\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)(" eom t))
+		       c-c++-raw-string-opener-re eom t))
 	    (c-depropertize-raw-string
 	     (match-string-no-properties 1) ; id
 	     (1+ (match-beginning 0))	    ; open quote
@@ -6736,17 +7119,12 @@ comment at the start of cc-engine.el for more info."
   ;; This function is called as a before-change function solely due to its
   ;; membership of the C++ value of `c-get-state-before-change-functions'.
   (goto-char end)
+  (setq c-raw-string-end-delim-disrupted nil)
   ;; We use the following to detect a R"<id>( being swallowed into a string by
   ;; the pending change.
   (setq c-old-END-literality (c-in-literal))
   (c-save-buffer-state
-      (;; (beg-rs (progn (goto-char beg) (c-raw-string-pos)))
-       ;; (end-rs (progn (goto-char end) (c-raw-string-pos)))
-					; FIXME!!!
-					; Optimize this so that we don't call
-					; `c-raw-string-pos' twice when once
-					; will do.  (2016-06-02).
-       (term-del (c-raw-string-in-end-delim beg end))
+      ((term-del (c-raw-string-in-end-delim beg end))
        Rquote close-quote)
     (setq c-old-beg-rs (progn (goto-char beg) (c-raw-string-pos))
 	  c-old-end-rs (progn (goto-char end) (c-raw-string-pos)))
@@ -6760,6 +7138,7 @@ comment at the start of cc-engine.el for more info."
 	       (<= (car term-del) (nth 3 c-old-beg-rs))))
       (setq Rquote (1- (cadr c-old-beg-rs))
 	    close-quote (1+ (cdr term-del)))
+      (setq c-raw-string-end-delim-disrupted t)
       (c-depropertize-raw-strings-in-region Rquote close-quote)
       (setq c-new-BEG (min c-new-BEG Rquote)
 	    c-new-END (max c-new-END close-quote)))
@@ -6807,7 +7186,7 @@ comment at the start of cc-engine.el for more info."
     (while (and (skip-chars-forward "^\"" end)
 		(< (point) end))
       (c-put-char-property (point) 'syntax-table '(1))
-      (c-truncate-semi-nonlit-pos-cache (point))
+      (c-truncate-lit-pos-cache (point))
       (forward-char))))
 
 (defun c-propertize-raw-string-opener (id open-quote open-paren bound)
@@ -6834,12 +7213,12 @@ comment at the start of cc-engine.el for more info."
 	    (while (progn (skip-syntax-forward "^\"" end-string)
 			  (< (point) end-string))
 	      (c-put-char-property (point) 'syntax-table '(1)) ; punctuation
-	      (c-truncate-semi-nonlit-pos-cache (point))
+	      (c-truncate-lit-pos-cache (point))
 	      (forward-char))
 	    (goto-char after-quote)
 	    t)
 	(c-put-char-property open-quote 'syntax-table '(1)) ; punctuation
-	(c-truncate-semi-nonlit-pos-cache open-quote)
+	(c-truncate-lit-pos-cache open-quote)
 	(c-put-char-property open-paren 'syntax-table '(15)) ; generic string
 	(when bound
 	  ;; In a CPP construct, we try to apply a generic-string
@@ -6870,10 +7249,10 @@ comment at the start of cc-engine.el for more info."
 	      (if (match-beginning 10)
 		  (progn
 		    (c-put-char-property (match-beginning 10) 'syntax-table '(15))
-		    (c-truncate-semi-nonlit-pos-cache (match-beginning 10)))
+		    (c-truncate-lit-pos-cache (match-beginning 10)))
 		(c-put-char-property (match-beginning 5) 'syntax-table '(1))
 		(c-put-char-property (1+ (match-beginning 5)) 'syntax-table '(15))
-		(c-truncate-semi-nonlit-pos-cache (1+ (match-beginning 5))))
+		(c-truncate-lit-pos-cache (1+ (match-beginning 5))))
 	    ;; (c-put-char-property open-paren 'syntax-table '(1))
 	    )
 	  (goto-char bound))
@@ -6895,14 +7274,13 @@ comment at the start of cc-engine.el for more info."
   ;; This functions is called as an after-change function by virtue of its
   ;; membership of the C++ value of `c-before-font-lock-functions'.
   ;; (when (< beg end)
-    (c-save-buffer-state (found eoll state id found-beg found-end)
+    (c-save-buffer-state (found eoll state id found-beg)
       ;; Has an inserted " swallowed up a R"(, turning it into "...R"(?
       (goto-char end)
       (setq eoll (c-point 'eoll))
       (when (and (null c-old-END-literality)
-		 (search-forward-regexp "R\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)("
-				 eoll t))
-	(setq state (c-state-semi-pp-to-literal end))
+		 (search-forward-regexp c-c++-raw-string-opener-re eoll t))
+	(setq state (c-semi-pp-to-literal end))
 	(when (eq (cadr state) 'string)
 	  (unwind-protect
 	      ;; Temporarily insert a closing string delimiter....
@@ -6914,7 +7292,7 @@ comment at the start of cc-engine.el for more info."
 		 ((eq (nth 3 (car state)) t)
 		  (insert ?\")
 		  (c-put-char-property end 'syntax-table '(15))))
-		(c-truncate-semi-nonlit-pos-cache end)
+		(c-truncate-lit-pos-cache end)
 		;; ....ensure c-new-END extends right to the end of the about
 		;; to be un-stringed raw string....
 		(save-excursion
@@ -6938,7 +7316,7 @@ comment at the start of cc-engine.el for more info."
       (while
 	  (and
 	   (setq found
-		 (search-forward-regexp "R\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)("
+		 (search-forward-regexp c-c++-raw-string-opener-re
 				       c-new-END 'bound))
 	   (<= (match-end 0) beg)))
       (when (and found (<= (match-beginning 0) end))
@@ -6952,49 +7330,52 @@ comment at the start of cc-engine.el for more info."
 					     'syntax-table)
 			'(1)))
 	(goto-char (1- (cadr c-old-beg-rs)))
-	(unless (looking-at "R\"[^ ()\\\n\r\t]\\{0,16\\}(")
+	(unless (looking-at c-c++-raw-string-opener-re)
 	  (c-clear-char-property (1+ (point)) 'syntax-table)
-	  (c-truncate-semi-nonlit-pos-cache (1+ (point)))
+	  (c-truncate-lit-pos-cache (1+ (point)))
 	  (if (c-search-forward-char-property 'syntax-table '(15)
 					      (c-point 'eol))
 	      (c-clear-char-property (1- (point)) 'syntax-table))))
 
+      ;; Have we matched up with an existing terminator by typing into an
+      ;; opening delimiter? ... or by messing up a raw string's terminator so
+      ;; that it now matches a later terminator?
+      (when
+	  (or c-raw-string-end-delim-disrupted
+	      (and c-old-beg-rs
+		   (eq (car c-old-beg-rs) 'open-delim)))
+	(goto-char (cadr c-old-beg-rs))
+	(when (looking-at c-c++-raw-string-opener-1-re)
+	  (setq id (match-string-no-properties 1))
+	  (when (re-search-forward (concat ")" id "\"") nil t) ; No bound.
+	    (setq c-new-END (point-max))
+	    (c-clear-char-properties (cadr c-old-beg-rs) c-new-END
+				     'syntax-table)
+	    (c-truncate-lit-pos-cache (cadr c-old-beg-rs)))))
       ;; Have we terminated an existing raw string by inserting or removing
       ;; text?
       (when (eq c-old-END-literality 'string)
-	(setq state (c-state-semi-pp-to-literal beg))
-	(cond
-	 ;; Possibly terminating a(n un)terminated raw string.
-	 ((eq (nth 3 (car state)) t)
-	  (goto-char (nth 8 (car state)))
-	  (when
-	      (and (eq (char-after) ?\()
-		   (search-backward-regexp
-		    "R\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)\\=" (- (point) 18) t))
-	    (setq id (match-string-no-properties 1)
-		  found-beg (match-beginning 0)
-		  found-end (1+ (match-end 0)))))
-	 ;; Possibly terminating an already terminated raw string.
-	 ((eq (nth 3 (car state)) ?\")
-	  (goto-char (nth 8 (car state)))
-	  (when
-	      (and (eq (char-before) ?R)
-		   (looking-at "\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)("))
-	    (setq id (match-string-no-properties 1)
-		  found-beg (1- (point))
-		  found-end (match-end 0)))))
-	(when id
-	  (goto-char (max (- beg 18) (point-min)))
-	  (when (search-forward (concat ")" id "\"") (+ end 1 (length id)) t)
-	    ;; Has an earlier close delimiter just been inserted into an
-	    ;; already terminated raw string?
-	    (if (and (eq (nth 3 (car state)) ?\")
-		     (search-forward (concat ")" id "\"") nil t))
-		(setq found-end (point)))
-	    (setq c-new-BEG (min c-new-BEG found-beg)
-		  c-new-END (max c-new-END found-end))
-	    (c-clear-char-properties found-beg found-end 'syntax-table)
-	    (c-truncate-semi-nonlit-pos-cache found-beg))))
+	;; Have we just made or modified a closing delimiter?
+	(goto-char (max (- beg 18) (point-min)))
+	(while
+	    (and
+	     (setq found
+		   (search-forward-regexp ")\\([^ ()\\\n\r\t]\\{0,16\\}\\)\""
+					  (+ end 17) t))
+	     (< (match-end 0) beg)))
+	(when (and found (<= (match-beginning 0) end))
+	  (setq id (match-string-no-properties 1))
+	  (goto-char (match-beginning 0))
+	  (while
+	      (and
+	       (setq found (search-backward (concat "R\"" id "(") nil t))
+	       (setq state (c-semi-pp-to-literal (point)))
+	       (memq (nth 3 (car state)) '(t ?\"))))
+	  (when found
+	    (setq c-new-BEG (min (point) c-new-BEG)
+		  c-new-END (point-max))
+	    (c-clear-char-properties (point) c-new-END 'syntax-table)
+	    (c-truncate-lit-pos-cache (point)))))
 
       ;; Are there any raw strings in a newly created macro?
       (when (< beg end)
@@ -7005,77 +7386,33 @@ comment at the start of cc-engine.el for more info."
 	  (c-depropertize-raw-strings-in-region found-beg (point))))))
 
 (defun c-maybe-re-mark-raw-string ()
-  ;; When this function is called, point is immediately after a ".  If this "
-  ;; is the characteristic " of of a raw string delimiter, apply the pertinent
-  ;; `syntax-table' text properties to the entire raw string (when properly
-  ;; terminated) or just the delimiter (otherwise).
+  ;; When this function is called, point is immediately after a " which opens
+  ;; a string.  If this " is the characteristic " of of a raw string
+  ;; opener, apply the pertinent `syntax-table' text properties to the
+  ;; entire raw string (when properly terminated) or just the delimiter
+  ;; (otherwise).  In either of these cases, return t, otherwise return nil.
   ;;
-  ;; If the " is in any way part of a raw string, return non-nil.  Otherwise
-  ;; return nil.
   (let ((here (point))
 	in-macro macro-end id Rquote found)
-    (cond
-     ((and
-       (eq (char-before (1- (point))) ?R)
-       (looking-at "\\([^ ()\\\n\r\t]\\{0,16\\}\\)("))
+    (when
+	(and
+	 (eq (char-before (1- (point))) ?R)
+	 (looking-at "\\([^ ()\\\n\r\t]\\{0,16\\}\\)("))
       (save-excursion
 	(setq in-macro (c-beginning-of-macro))
 	(setq macro-end (when in-macro
 			  (c-end-of-macro)
 			  (point) ;; (min (1+ (point)) (point-max))
 			  )))
-      (if (not
+      (when
+	  (not
 	   (c-propertize-raw-string-opener
 	    (match-string-no-properties 1) ; id
 	    (1- (point))		   ; open quote
 	    (match-end 1)		   ; open paren
 	    macro-end))		     ; bound (end of macro) or nil.
-	  (goto-char (or macro-end (point-max))))
-      t)
-     ((save-excursion
-	(and
-	 (search-backward-regexp ")\\([^ ()\\\n\r\t]\\{0,16\\}\\)\"\\=" nil t)
-	 (setq id (match-string-no-properties 1))
-	 (let* ((quoted-id (regexp-quote id))
-		(quoted-id-depth (regexp-opt-depth quoted-id)))
-	   (while
-	       (and
-		;; Search back for an opening delimiter with identifier `id'.
-		;; A closing delimiter with `id' "blocks" our search.
-		(search-backward-regexp	; This could be slow.
-		 (concat "\\(R\"" quoted-id "(\\)"
-			 "\\|"
-			 "\\()" quoted-id "\"\\)")
-		 nil t)
-		(setq found t)
-		(if (eq (c-in-literal) 'string)
-		    (match-beginning 1)
-		  (match-beginning (+ 2 quoted-id-depth)))))
-	   (and found
-		(null (c-in-literal))
-		(match-beginning 1)))
-	 (setq Rquote (point))))
-      (save-excursion
-	(goto-char Rquote)
-	(setq in-macro (c-beginning-of-macro))
-	(setq macro-end (when in-macro
-			  (c-end-of-macro)
-			  (point))))
-      (if (or (not in-macro)
-	      (<= here macro-end))
-	  (progn
-	    (c-propertize-raw-string-opener
-	     id (1+ (point)) (match-end 1) macro-end)
-	    (goto-char here)
-	    t)
-	(goto-char here)
-	nil))
-
-     (t
-      ;; If the " is in another part of a raw string (whether as part of the
-      ;; identifier, or in the string itself) the `syntax-table' text
-      ;; properties on the raw string will be current.  So, we can use...
-      (c-raw-string-pos)))))
+	(goto-char (or macro-end (point-max))))
+      t)))
 
 
 ;; Handling of small scale constructs like types and names.
@@ -7229,6 +7566,21 @@ comment at the start of cc-engine.el for more info."
       (c-forward-syntactic-ws))
   t)
 
+(defun c-forward-noise-clause-not-macro-decl (maybe-parens)
+  ;; Point is at a noise macro identifier, which, when MAYBE-PARENS is
+  ;; non-nil, optionally takes paren arguments.  Go forward over this name,
+  ;; and when there may be optional parens, any parenthesis expression which
+  ;; follows it, but DO NOT go over any macro declaration which may come
+  ;; between them.  Always return t.
+  (c-end-of-token)
+  (when maybe-parens
+    (let ((here (point)))
+      (c-forward-comments)
+      (if (not (and (eq (char-after) ?\()
+		    (c-go-list-forward)))
+	  (goto-char here))))
+  t)
+
 (defun c-forward-keyword-clause (match)
   ;; Submatch MATCH in the current match data is assumed to surround a
   ;; token.  If it's a keyword, move over it and any immediately
@@ -7436,7 +7788,9 @@ comment at the start of cc-engine.el for more info."
 		(progn
 		  (c-forward-syntactic-ws)
 		  (when (or (and c-record-type-identifiers all-types)
-			    (not (equal c-inside-<>-type-key "\\(a\\`\\)")))
+			    (not (equal c-inside-<>-type-key
+					(concat
+					 "\\(" regexp-unmatchable "\\)"))))
 		    (c-forward-syntactic-ws)
 		    (cond
 		     ((eq (char-after) ??)
@@ -8841,7 +9195,10 @@ This function might do hidden buffer changes."
 	   ((and c-opt-cpp-prefix
 		 (looking-at c-noise-macro-with-parens-name-re))
 	    (setq noise-start (point))
-	    (c-forward-noise-clause)
+	    (while
+		(and
+		  (c-forward-noise-clause)
+		  (looking-at c-noise-macro-with-parens-name-re)))
 	    (setq kwd-clause-end (point))))
 
 	  (when (setq found-type (c-forward-type t)) ; brace-block-too
@@ -9043,7 +9400,7 @@ This function might do hidden buffer changes."
       ;; Skip over type decl prefix operators.  (Note similar code in
       ;; `c-forward-declarator'.)
       (if (and c-recognize-typeless-decls
-	       (equal c-type-decl-prefix-key "a\\`")) ; Regexp which doesn't match
+	       (equal c-type-decl-prefix-key regexp-unmatchable))
 	  (when (eq (char-after) ?\()
 	    (progn
 	      (setq paren-depth (1+ paren-depth))
@@ -10676,7 +11033,7 @@ comment at the start of cc-engine.el for more info."
 	      ;; legal because it's part of a "compound keyword" like
 	      ;; "enum class".	Of course, if c-after-brace-list-key
 	      ;; is nil, we can skip the test.
-	      (or (equal c-after-brace-list-key "a\\`") ; Regexp which doesn't match
+	      (or (equal c-after-brace-list-key regexp-unmatchable)
 		  (save-match-data
 		    (save-excursion
 		      (not
@@ -12734,6 +13091,13 @@ comment at the start of cc-engine.el for more info."
 			(if (eq (char-after) ?<)
 			    (zerop (c-forward-token-2 1 t indent-point))
 			  t)
+			(progn
+			  (while
+			      (and
+			       (< (point) indent-point)
+			       (looking-at c-class-id-suffix-ws-ids-key)
+			       (zerop (c-forward-token-2 1 nil indent-point))))
+			  t)
 			(eq (char-after) ?:))))
 	    (goto-char placeholder)
 	    (c-add-syntax 'inher-cont (c-point 'boi)))
diff --git a/lisp/progmodes/cc-fonts.el b/lisp/progmodes/cc-fonts.el
index e7a3748af4..c3dd8f85bd 100644
--- a/lisp/progmodes/cc-fonts.el
+++ b/lisp/progmodes/cc-fonts.el
@@ -880,48 +880,51 @@ casts and declarations are fontified.  Used on level 2 and higher."
   (when (bobp)
     (c-clear-found-types))
 
-  ;; Clear the c-type char properties which mark the region, to recalculate
-  ;; them properly.  The most interesting properties are those put on the
-  ;; closest token before the region.
-  (save-excursion
-    (let ((pos (point)))
-      (c-backward-syntactic-ws)
-      (c-clear-char-properties
-       (if (and (not (bobp))
-		(memq (c-get-char-property (1- (point)) 'c-type)
-		      '(c-decl-arg-start
-			c-decl-end
-			c-decl-id-start
-			c-decl-type-start)))
-	   (1- (point))
-	 pos)
-       limit 'c-type)))
-
-  ;; Update `c-state-cache' to the beginning of the region.  This will
-  ;; make `c-beginning-of-syntax' go faster when it's used later on,
-  ;; and it's near the point most of the time.
-  (c-parse-state)
-
-  ;; Check if the fontified region starts inside a declarator list so
-  ;; that `c-font-lock-declarators' should be called at the start.
-  ;; The declared identifiers are font-locked correctly as types, if
-  ;; that is what they are.
-  (let ((prop (save-excursion
-		(c-backward-syntactic-ws)
-		(unless (bobp)
-		  (c-get-char-property (1- (point)) 'c-type)))))
-    (when (memq prop '(c-decl-id-start c-decl-type-start))
-      (c-forward-syntactic-ws limit)
-      (c-font-lock-declarators limit t (eq prop 'c-decl-type-start)
-			       (not (c-bs-at-toplevel-p (point))))))
-
-  (setq c-font-lock-context ;; (c-guess-font-lock-context)
-	(save-excursion
-	  (if (and c-cpp-expr-intro-re
-		   (c-beginning-of-macro)
-		   (looking-at c-cpp-expr-intro-re))
-	      'in-cpp-expr)))
-  nil)
+  (c-skip-comments-and-strings limit)
+  (when (< (point) limit)
+
+    ;; Clear the c-type char properties which mark the region, to recalculate
+    ;; them properly.  The most interesting properties are those put on the
+    ;; closest token before the region.
+    (save-excursion
+      (let ((pos (point)))
+	(c-backward-syntactic-ws)
+	(c-clear-char-properties
+	 (if (and (not (bobp))
+		  (memq (c-get-char-property (1- (point)) 'c-type)
+			'(c-decl-arg-start
+			  c-decl-end
+			  c-decl-id-start
+			  c-decl-type-start)))
+	     (1- (point))
+	   pos)
+	 limit 'c-type)))
+
+    ;; Update `c-state-cache' to the beginning of the region.  This will
+    ;; make `c-beginning-of-syntax' go faster when it's used later on,
+    ;; and it's near the point most of the time.
+    (c-parse-state)
+
+    ;; Check if the fontified region starts inside a declarator list so
+    ;; that `c-font-lock-declarators' should be called at the start.
+    ;; The declared identifiers are font-locked correctly as types, if
+    ;; that is what they are.
+    (let ((prop (save-excursion
+		  (c-backward-syntactic-ws)
+		  (unless (bobp)
+		    (c-get-char-property (1- (point)) 'c-type)))))
+      (when (memq prop '(c-decl-id-start c-decl-type-start))
+	(c-forward-syntactic-ws limit)
+	(c-font-lock-declarators limit t (eq prop 'c-decl-type-start)
+				 (not (c-bs-at-toplevel-p (point))))))
+
+    (setq c-font-lock-context ;; (c-guess-font-lock-context)
+	  (save-excursion
+	    (if (and c-cpp-expr-intro-re
+		     (c-beginning-of-macro)
+		     (looking-at c-cpp-expr-intro-re))
+		'in-cpp-expr)))
+    nil))
 
 (defun c-font-lock-<>-arglists (limit)
   ;; This function will be called from font-lock for a region bounded by POINT
@@ -936,73 +939,76 @@ casts and declarations are fontified.  Used on level 2 and higher."
   ;;
   ;; This function might do hidden buffer changes.
 
-  (let (;; The font-lock package in Emacs is known to clobber
-	;; `parse-sexp-lookup-properties' (when it exists).
-	(parse-sexp-lookup-properties
-	 (cc-eval-when-compile
-	   (boundp 'parse-sexp-lookup-properties)))
-	(c-parse-and-markup-<>-arglists t)
-	c-restricted-<>-arglists
-	id-start id-end id-face pos kwd-sym)
+  (c-skip-comments-and-strings limit)
+  (when (< (point) limit)
 
-    (while (and (< (point) limit)
-		(re-search-forward c-opt-<>-arglist-start limit t))
+    (let (;; The font-lock package in Emacs is known to clobber
+	  ;; `parse-sexp-lookup-properties' (when it exists).
+	  (parse-sexp-lookup-properties
+	   (cc-eval-when-compile
+	     (boundp 'parse-sexp-lookup-properties)))
+	  (c-parse-and-markup-<>-arglists t)
+	  c-restricted-<>-arglists
+	  id-start id-end id-face pos kwd-sym)
 
-      (setq id-start (match-beginning 1)
-	    id-end (match-end 1)
-	    pos (point))
+      (while (and (< (point) limit)
+		  (re-search-forward c-opt-<>-arglist-start limit t))
 
-      (goto-char id-start)
-      (unless (c-skip-comments-and-strings limit)
-	(setq kwd-sym nil
-	      c-restricted-<>-arglists nil
-	      id-face (get-text-property id-start 'face))
-
-	(if (cond
-	     ((eq id-face 'font-lock-type-face)
-	      ;; The identifier got the type face so it has already been
-	      ;; handled in `c-font-lock-declarations'.
-	      nil)
-
-	     ((eq id-face 'font-lock-keyword-face)
-	      (when (looking-at c-opt-<>-sexp-key)
-		;; There's a special keyword before the "<" that tells
-		;; that it's an angle bracket arglist.
-		(setq kwd-sym (c-keyword-sym (match-string 1)))))
-
-	     (t
-	      ;; There's a normal identifier before the "<".  If we're not in
-	      ;; a declaration context then we set `c-restricted-<>-arglists'
-	      ;; to avoid recognizing templates in function calls like "foo (a
-	      ;; < b, c > d)".
-	      (c-backward-syntactic-ws)
-	      (when (and (memq (char-before) '(?\( ?,))
-			 (not (eq (get-text-property (1- (point)) 'c-type)
-				  'c-decl-arg-start)))
-		(setq c-restricted-<>-arglists t))
-	      t))
+	(setq id-start (match-beginning 1)
+	      id-end (match-end 1)
+	      pos (point))
 
-	    (progn
-	      (goto-char (1- pos))
-	      ;; Check for comment/string both at the identifier and
-	      ;; at the "<".
-	      (unless (c-skip-comments-and-strings limit)
-
-		(c-fontify-types-and-refs ()
-		  (when (c-forward-<>-arglist (c-keyword-member
-					       kwd-sym 'c-<>-type-kwds))
-		    (when (and c-opt-identifier-concat-key
-			       (not (get-text-property id-start 'face)))
-		      (c-forward-syntactic-ws)
-		      (cond ((looking-at c-opt-identifier-concat-key)
-			     (c-put-font-lock-face id-start id-end
-						c-reference-face-name))
-			    ((eq (char-after) ?\())
-			    (t (c-put-font-lock-face id-start id-end
-					      'font-lock-type-face))))))
-
-		(goto-char pos)))
-	  (goto-char pos)))))
+	(goto-char id-start)
+	(unless (c-skip-comments-and-strings limit)
+	  (setq kwd-sym nil
+		c-restricted-<>-arglists nil
+		id-face (get-text-property id-start 'face))
+
+	  (if (cond
+	       ((eq id-face 'font-lock-type-face)
+		;; The identifier got the type face so it has already been
+		;; handled in `c-font-lock-declarations'.
+		nil)
+
+	       ((eq id-face 'font-lock-keyword-face)
+		(when (looking-at c-opt-<>-sexp-key)
+		  ;; There's a special keyword before the "<" that tells
+		  ;; that it's an angle bracket arglist.
+		  (setq kwd-sym (c-keyword-sym (match-string 1)))))
+
+	       (t
+		;; There's a normal identifier before the "<".  If we're not in
+		;; a declaration context then we set `c-restricted-<>-arglists'
+		;; to avoid recognizing templates in function calls like "foo (a
+		;; < b, c > d)".
+		(c-backward-syntactic-ws)
+		(when (and (memq (char-before) '(?\( ?,))
+			   (not (eq (get-text-property (1- (point)) 'c-type)
+				    'c-decl-arg-start)))
+		  (setq c-restricted-<>-arglists t))
+		t))
+
+	      (progn
+		(goto-char (1- pos))
+		;; Check for comment/string both at the identifier and
+		;; at the "<".
+		(unless (c-skip-comments-and-strings limit)
+
+		  (c-fontify-types-and-refs ()
+		    (when (c-forward-<>-arglist (c-keyword-member
+						 kwd-sym 'c-<>-type-kwds))
+		      (when (and c-opt-identifier-concat-key
+				 (not (get-text-property id-start 'face)))
+			(c-forward-syntactic-ws)
+			(cond ((looking-at c-opt-identifier-concat-key)
+			       (c-put-font-lock-face id-start id-end
+						     c-reference-face-name))
+			      ((eq (char-after) ?\())
+			      (t (c-put-font-lock-face id-start id-end
+						       'font-lock-type-face))))))
+
+		  (goto-char pos)))
+	    (goto-char pos))))))
   nil)
 
 (defun c-font-lock-declarators (limit list types not-top
@@ -1036,7 +1042,7 @@ casts and declarations are fontified.  Used on level 2 and higher."
     (c-do-declarators
      limit list not-top
      (if types 'c-decl-type-start 'c-decl-id-start)
-     (lambda (id-start id-end end-pos not-top is-function init-char)
+     (lambda (id-start _id-end end-pos _not-top is-function init-char)
        (if types
 	   ;; Register and fontify the identifier as a type.
 	   (let ((c-promote-possible-types t))
@@ -1311,227 +1317,229 @@ casts and declarations are fontified.  Used on level 2 and higher."
   ;; This function might do hidden buffer changes.
 
   ;;(message "c-font-lock-declarations search from %s to %s" (point) limit)
+  (c-skip-comments-and-strings limit)
+  (when (< (point) limit)
+
+    (save-restriction
+      (let (;; The position where `c-find-decl-spots' last stopped.
+	    start-pos
+	    ;; o - 'decl if we're in an arglist containing declarations
+	    ;;   (but if `c-recognize-paren-inits' is set it might also be
+	    ;;   an initializer arglist);
+	    ;; o - '<> if the arglist is of angle bracket type;
+	    ;; o - 'arglist if it's some other arglist;
+	    ;; o - nil, if not in an arglist at all.  This includes the
+	    ;;   parenthesized condition which follows "if", "while", etc.
+	    context
+	    ;; A list of starting positions of possible type declarations, or of
+	    ;; the typedef preceding one, if any.
+	    last-cast-end
+	    ;; The result from `c-forward-decl-or-cast-1'.
+	    decl-or-cast
+	    ;; The maximum of the end positions of all the checked type
+	    ;; decl expressions in the successfully identified
+	    ;; declarations.  The position might be either before or
+	    ;; after the syntactic whitespace following the last token
+	    ;; in the type decl expression.
+	    (max-type-decl-end 0)
+	    ;; Same as `max-type-decl-*', but used when we're before
+	    ;; `token-pos'.
+	    (max-type-decl-end-before-token 0)
+	    ;; End of <..> construct which has had c-<>-arg-sep c-type
+	    ;; properties set within it.
+	    (max-<>-end 0)
+	    ;; Set according to the context to direct the heuristics for
+	    ;; recognizing C++ templates.
+	    c-restricted-<>-arglists
+	    ;; Turn on recording of identifier ranges in
+	    ;; `c-forward-decl-or-cast-1' and `c-forward-label' for
+	    ;; later fontification.
+	    (c-record-type-identifiers t)
+	    label-type
+	    c-record-ref-identifiers
+	    ;; Make `c-forward-type' calls mark up template arglists if
+	    ;; it finds any.  That's necessary so that we later will
+	    ;; stop inside them to fontify types there.
+	    (c-parse-and-markup-<>-arglists t)
+	    ;; The font-lock package in Emacs is known to clobber
+	    ;; `parse-sexp-lookup-properties' (when it exists).
+	    (parse-sexp-lookup-properties
+	     (cc-eval-when-compile
+	       (boundp 'parse-sexp-lookup-properties))
+	     ))
+
+	;; Below we fontify a whole declaration even when it crosses the limit,
+	;; to avoid gaps when jit/lazy-lock fontifies the file a block at a
+	;; time.  That is however annoying during editing, e.g. the following is
+	;; a common situation while the first line is being written:
+	;;
+	;;     my_variable
+	;;     some_other_variable = 0;
+	;;
+	;; font-lock will put the limit at the beginning of the second line
+	;; here, and if we go past it we'll fontify "my_variable" as a type and
+	;; "some_other_variable" as an identifier, and the latter will not
+	;; correct itself until the second line is changed.  To avoid that we
+	;; narrow to the limit if the region to fontify is a single line.
+	(if (<= limit (c-point 'bonl))
+	    (narrow-to-region
+	     (point-min)
+	     (save-excursion
+	       ;; Narrow after any operator chars following the limit though,
+	       ;; since those characters can be useful in recognizing a
+	       ;; declaration (in particular the '{' that opens a function body
+	       ;; after the header).
+	       (goto-char limit)
+	       (skip-chars-forward c-nonsymbol-chars)
+	       (point))))
+
+	(c-find-decl-spots
+	 limit
+	 c-decl-start-re
+	 (eval c-maybe-decl-faces)
+
+	 (lambda (match-pos inside-macro &optional toplev)
+	   ;; Note to maintainers: don't use `limit' inside this lambda form;
+	   ;; c-find-decl-spots sometimes narrows to less than `limit'.
+	   (setq start-pos (point))
+	   (when
+	       ;; The result of the form below is true when we don't recognize a
+	       ;; declaration or cast, and we don't recognize a "non-decl",
+	       ;; typically a brace list.
+	       (if (or (and (eq (get-text-property (point) 'face)
+				'font-lock-keyword-face)
+			    (looking-at c-not-decl-init-keywords))
+		       (and c-macro-with-semi-re
+			    (looking-at c-macro-with-semi-re))) ; 2008-11-04
+		   ;; Don't do anything more if we're looking at a keyword that
+		   ;; can't start a declaration.
+		   t
+
+		 ;; Set `context' and `c-restricted-<>-arglists'.  Look for
+		 ;; "<" for the sake of C++-style template arglists.
+		 ;; Ignore "(" when it's part of a control flow construct
+		 ;; (e.g. "for (").
+		 (let ((got-context
+			(c-get-fontification-context
+			 match-pos
+			 (< match-pos (if inside-macro
+					  max-type-decl-end-before-token
+					max-type-decl-end))
+			 toplev)))
+		   (setq context (car got-context)
+			 c-restricted-<>-arglists (cdr got-context)))
+
+		 ;; Check we haven't missed a preceding "typedef".
+		 (when (not (looking-at c-typedef-key))
+		   (c-backward-syntactic-ws)
+		   (c-backward-token-2)
+		   (or (looking-at c-typedef-key)
+		       (goto-char start-pos)))
+
+		 ;; In QT, "more" is an irritating keyword that expands to nothing.
+		 ;; We skip over it to prevent recognition of "more slots: <symbol>"
+		 ;; as a bitfield declaration.
+		 (when (and (c-major-mode-is 'c++-mode)
+			    (looking-at
+			     (concat "\\(more\\)\\([^" c-symbol-chars "]\\|$\\)")))
+		   (goto-char (match-end 1))
+		   (c-forward-syntactic-ws))
 
-  (save-restriction
-    (let (;; The position where `c-find-decl-spots' last stopped.
-	  start-pos
-	  ;; o - 'decl if we're in an arglist containing declarations
-	  ;;   (but if `c-recognize-paren-inits' is set it might also be
-	  ;;   an initializer arglist);
-	  ;; o - '<> if the arglist is of angle bracket type;
-	  ;; o - 'arglist if it's some other arglist;
-	  ;; o - nil, if not in an arglist at all.  This includes the
-	  ;;   parenthesized condition which follows "if", "while", etc.
-	  context
-	  ;; A list of starting positions of possible type declarations, or of
-	  ;; the typedef preceding one, if any.
-	  last-cast-end
-	  ;; The result from `c-forward-decl-or-cast-1'.
-	  decl-or-cast
-	  ;; The maximum of the end positions of all the checked type
-	  ;; decl expressions in the successfully identified
-	  ;; declarations.  The position might be either before or
-	  ;; after the syntactic whitespace following the last token
-	  ;; in the type decl expression.
-	  (max-type-decl-end 0)
-	  ;; Same as `max-type-decl-*', but used when we're before
-	  ;; `token-pos'.
-	  (max-type-decl-end-before-token 0)
-	  ;; End of <..> construct which has had c-<>-arg-sep c-type
-	  ;; properties set within it.
-	  (max-<>-end 0)
-	  ;; Set according to the context to direct the heuristics for
-	  ;; recognizing C++ templates.
-	  c-restricted-<>-arglists
-	  ;; Turn on recording of identifier ranges in
-	  ;; `c-forward-decl-or-cast-1' and `c-forward-label' for
-	  ;; later fontification.
-	  (c-record-type-identifiers t)
-	  label-type
-	  c-record-ref-identifiers
-	  ;; Make `c-forward-type' calls mark up template arglists if
-	  ;; it finds any.  That's necessary so that we later will
-	  ;; stop inside them to fontify types there.
-	  (c-parse-and-markup-<>-arglists t)
-	  ;; The font-lock package in Emacs is known to clobber
-	  ;; `parse-sexp-lookup-properties' (when it exists).
-	  (parse-sexp-lookup-properties
-	   (cc-eval-when-compile
-	     (boundp 'parse-sexp-lookup-properties))
-	   ))
-
-      ;; Below we fontify a whole declaration even when it crosses the limit,
-      ;; to avoid gaps when jit/lazy-lock fontifies the file a block at a
-      ;; time.  That is however annoying during editing, e.g. the following is
-      ;; a common situation while the first line is being written:
-      ;;
-      ;;     my_variable
-      ;;     some_other_variable = 0;
-      ;;
-      ;; font-lock will put the limit at the beginning of the second line
-      ;; here, and if we go past it we'll fontify "my_variable" as a type and
-      ;; "some_other_variable" as an identifier, and the latter will not
-      ;; correct itself until the second line is changed.  To avoid that we
-      ;; narrow to the limit if the region to fontify is a single line.
-      (if (<= limit (c-point 'bonl))
-	  (narrow-to-region
-	   (point-min)
-	   (save-excursion
-	     ;; Narrow after any operator chars following the limit though,
-	     ;; since those characters can be useful in recognizing a
-	     ;; declaration (in particular the '{' that opens a function body
-	     ;; after the header).
-	     (goto-char limit)
-	     (skip-chars-forward c-nonsymbol-chars)
-	     (point))))
-
-      (c-find-decl-spots
-       limit
-       c-decl-start-re
-       (eval c-maybe-decl-faces)
-
-       (lambda (match-pos inside-macro &optional toplev)
-	 ;; Note to maintainers: don't use `limit' inside this lambda form;
-	 ;; c-find-decl-spots sometimes narrows to less than `limit'.
-	 (setq start-pos (point))
-	 (when
-	  ;; The result of the form below is true when we don't recognize a
-	  ;; declaration or cast, and we don't recognize a "non-decl",
-	  ;; typically a brace list.
-	  (if (or (and (eq (get-text-property (point) 'face)
-			   'font-lock-keyword-face)
-		       (looking-at c-not-decl-init-keywords))
-		  (and c-macro-with-semi-re
-		       (looking-at c-macro-with-semi-re))) ; 2008-11-04
-	      ;; Don't do anything more if we're looking at a keyword that
-	      ;; can't start a declaration.
-	      t
-
-	    ;; Set `context' and `c-restricted-<>-arglists'.  Look for
-	    ;; "<" for the sake of C++-style template arglists.
-	    ;; Ignore "(" when it's part of a control flow construct
-	    ;; (e.g. "for (").
-	    (let ((got-context
-		   (c-get-fontification-context
-		    match-pos
-		    (< match-pos (if inside-macro
-				     max-type-decl-end-before-token
-				   max-type-decl-end))
-		    toplev)))
-	      (setq context (car got-context)
-		    c-restricted-<>-arglists (cdr got-context)))
-
-	    ;; Check we haven't missed a preceding "typedef".
-	    (when (not (looking-at c-typedef-key))
-	      (c-backward-syntactic-ws)
-	      (c-backward-token-2)
-	      (or (looking-at c-typedef-key)
-		  (goto-char start-pos)))
-
-	    ;; In QT, "more" is an irritating keyword that expands to nothing.
-	    ;; We skip over it to prevent recognition of "more slots: <symbol>"
-	    ;; as a bitfield declaration.
-	    (when (and (c-major-mode-is 'c++-mode)
-		       (looking-at
-			(concat "\\(more\\)\\([^" c-symbol-chars "]\\|$\\)")))
-	      (goto-char (match-end 1))
-	      (c-forward-syntactic-ws))
-
-	    ;; Now analyze the construct.
-	    (if (eq context 'not-decl)
-		(progn
-		  (setq decl-or-cast nil)
-		  (if (c-syntactic-re-search-forward
-		       "," (min limit (point-max)) 'at-limit t)
-		      (c-put-char-property (1- (point)) 'c-type 'c-not-decl))
-		  nil)
-	      (setq decl-or-cast
-		    (c-forward-decl-or-cast-1
-		     match-pos context last-cast-end))
-
-	      ;; Ensure that c-<>-arg-sep c-type properties are in place on the
-	      ;; commas separating the arguments inside template/generic <..>s.
-	      (when (and (eq (char-before match-pos) ?<)
-			 (> match-pos max-<>-end))
-		(save-excursion
-		  (goto-char match-pos)
-		  (c-backward-token-2)
-		  (if (and
-		       (eq (char-after) ?<)
-		       (let ((c-restricted-<>-arglists
-			      (save-excursion
-				(c-backward-token-2)
-				(and
-				 (not (looking-at c-opt-<>-sexp-key))
-				 (progn (c-backward-syntactic-ws)
-					(memq (char-before) '(?\( ?,)))
-				 (not (eq (c-get-char-property (1- (point))
-							       'c-type)
-					  'c-decl-arg-start))))))
-			 (c-forward-<>-arglist nil)))
-		      (setq max-<>-end (point)))))
-
-	      (cond
-	       ((eq decl-or-cast 'cast)
-		;; Save the position after the previous cast so we can feed
-		;; it to `c-forward-decl-or-cast-1' in the next round.  That
-		;; helps it discover cast chains like "(a) (b) c".
-		(setq last-cast-end (point))
-		(c-fontify-recorded-types-and-refs)
-		nil)
-
-	       (decl-or-cast
-		;; We've found a declaration.
-
-		;; Set `max-type-decl-end' or `max-type-decl-end-before-token'
-		;; under the assumption that we're after the first type decl
-		;; expression in the declaration now.  That's not really true;
-		;; we could also be after a parenthesized initializer
-		;; expression in C++, but this is only used as a last resort
-		;; to slant ambiguous expression/declarations, and overall
-		;; it's worth the risk to occasionally fontify an expression
-		;; as a declaration in an initializer expression compared to
-		;; getting ambiguous things in normal function prototypes
-		;; fontified as expressions.
-		(if inside-macro
-		    (when (> (point) max-type-decl-end-before-token)
-		      (setq max-type-decl-end-before-token (point)))
-		  (when (> (point) max-type-decl-end)
-		    (setq max-type-decl-end (point))))
-		(goto-char start-pos)
-		(c-font-lock-single-decl limit decl-or-cast match-pos
-					 context
-					 (or toplev (nth 4 decl-or-cast))))
-
-	       (t t))))
-
-	  ;; It was a false alarm.  Check if we're in a label (or other
-	  ;; construct with `:' except bitfield) instead.
-	  (goto-char start-pos)
-	  (when (setq label-type (c-forward-label t match-pos nil))
-	    ;; Can't use `c-fontify-types-and-refs' here since we
-	    ;; use the label face at times.
-	    (cond ((eq label-type 'goto-target)
-		   (c-put-font-lock-face (caar c-record-ref-identifiers)
-					 (cdar c-record-ref-identifiers)
-					 c-label-face-name))
-		  ((eq label-type 'qt-1kwd-colon)
-		   (c-put-font-lock-face (caar c-record-ref-identifiers)
-					 (cdar c-record-ref-identifiers)
-					 'font-lock-keyword-face))
-		  ((eq label-type 'qt-2kwds-colon)
-		   (mapc
-		    (lambda (kwd)
-		      (c-put-font-lock-face (car kwd) (cdr kwd)
+		 ;; Now analyze the construct.
+		 (if (eq context 'not-decl)
+		     (progn
+		       (setq decl-or-cast nil)
+		       (if (c-syntactic-re-search-forward
+			    "," (min limit (point-max)) 'at-limit t)
+			   (c-put-char-property (1- (point)) 'c-type 'c-not-decl))
+		       nil)
+		   (setq decl-or-cast
+			 (c-forward-decl-or-cast-1
+			  match-pos context last-cast-end))
+
+		   ;; Ensure that c-<>-arg-sep c-type properties are in place on the
+		   ;; commas separating the arguments inside template/generic <..>s.
+		   (when (and (eq (char-before match-pos) ?<)
+			      (> match-pos max-<>-end))
+		     (save-excursion
+		       (goto-char match-pos)
+		       (c-backward-token-2)
+		       (if (and
+			    (eq (char-after) ?<)
+			    (let ((c-restricted-<>-arglists
+				   (save-excursion
+				     (c-backward-token-2)
+				     (and
+				      (not (looking-at c-opt-<>-sexp-key))
+				      (progn (c-backward-syntactic-ws)
+					     (memq (char-before) '(?\( ?,)))
+				      (not (eq (c-get-char-property (1- (point))
+								    'c-type)
+					       'c-decl-arg-start))))))
+			      (c-forward-<>-arglist nil)))
+			   (setq max-<>-end (point)))))
+
+		   (cond
+		    ((eq decl-or-cast 'cast)
+		     ;; Save the position after the previous cast so we can feed
+		     ;; it to `c-forward-decl-or-cast-1' in the next round.  That
+		     ;; helps it discover cast chains like "(a) (b) c".
+		     (setq last-cast-end (point))
+		     (c-fontify-recorded-types-and-refs)
+		     nil)
+
+		    (decl-or-cast
+		     ;; We've found a declaration.
+
+		     ;; Set `max-type-decl-end' or `max-type-decl-end-before-token'
+		     ;; under the assumption that we're after the first type decl
+		     ;; expression in the declaration now.  That's not really true;
+		     ;; we could also be after a parenthesized initializer
+		     ;; expression in C++, but this is only used as a last resort
+		     ;; to slant ambiguous expression/declarations, and overall
+		     ;; it's worth the risk to occasionally fontify an expression
+		     ;; as a declaration in an initializer expression compared to
+		     ;; getting ambiguous things in normal function prototypes
+		     ;; fontified as expressions.
+		     (if inside-macro
+			 (when (> (point) max-type-decl-end-before-token)
+			   (setq max-type-decl-end-before-token (point)))
+		       (when (> (point) max-type-decl-end)
+			 (setq max-type-decl-end (point))))
+		     (goto-char start-pos)
+		     (c-font-lock-single-decl limit decl-or-cast match-pos
+					      context
+					      (or toplev (nth 4 decl-or-cast))))
+
+		    (t t))))
+
+	     ;; It was a false alarm.  Check if we're in a label (or other
+	     ;; construct with `:' except bitfield) instead.
+	     (goto-char start-pos)
+	     (when (setq label-type (c-forward-label t match-pos nil))
+	       ;; Can't use `c-fontify-types-and-refs' here since we
+	       ;; use the label face at times.
+	       (cond ((eq label-type 'goto-target)
+		      (c-put-font-lock-face (caar c-record-ref-identifiers)
+					    (cdar c-record-ref-identifiers)
+					    c-label-face-name))
+		     ((eq label-type 'qt-1kwd-colon)
+		      (c-put-font-lock-face (caar c-record-ref-identifiers)
+					    (cdar c-record-ref-identifiers)
 					    'font-lock-keyword-face))
-		    c-record-ref-identifiers)))
-	    (setq c-record-ref-identifiers nil)
-	    ;; `c-forward-label' has probably added a `c-decl-end'
-	    ;; marker, so return t to `c-find-decl-spots' to signal
-	    ;; that.
-	    t))))
-
-      nil)))
+		     ((eq label-type 'qt-2kwds-colon)
+		      (mapc
+		       (lambda (kwd)
+			 (c-put-font-lock-face (car kwd) (cdr kwd)
+					       'font-lock-keyword-face))
+		       c-record-ref-identifiers)))
+	       (setq c-record-ref-identifiers nil)
+	       ;; `c-forward-label' has probably added a `c-decl-end'
+	       ;; marker, so return t to `c-find-decl-spots' to signal
+	       ;; that.
+	       t))))
+
+	nil))))
 
 (defun c-font-lock-enum-body (limit)
   ;; Fontify the identifiers of each enum we find by searching forward.
@@ -1541,7 +1549,8 @@ casts and declarations are fontified.  Used on level 2 and higher."
   ;; font-lock-keyword-face.  It always returns NIL to inhibit this and
   ;; prevent a repeat invocation.  See elisp/lispref page "Search-based
   ;; Fontification".
-  (while (search-forward-regexp c-enum-clause-introduction-re limit t)
+  (while (and (< (point) limit)
+	      (search-forward-regexp c-enum-clause-introduction-re limit t))
     (when (save-excursion
 	    (backward-char)
 	    (c-backward-over-enum-header))
@@ -1561,19 +1570,21 @@ casts and declarations are fontified.  Used on level 2 and higher."
   ;;
   ;; Note that this function won't attempt to fontify beyond the end of the
   ;; current enum block, if any.
-  (let* ((paren-state (c-parse-state))
-	 (encl-pos (c-most-enclosing-brace paren-state)))
-    (when (and
-	   encl-pos
-	   (eq (char-after encl-pos) ?\{)
-	   (save-excursion
-	     (goto-char encl-pos)
-	     (c-backward-over-enum-header)))
-      (c-syntactic-skip-backward "^{," nil t)
-      (c-put-char-property (1- (point)) 'c-type 'c-decl-id-start)
+  (c-skip-comments-and-strings limit)
+  (when (< (point) limit)
+    (let* ((paren-state (c-parse-state))
+	   (encl-pos (c-most-enclosing-brace paren-state)))
+      (when (and
+	     encl-pos
+	     (eq (char-after encl-pos) ?\{)
+	     (save-excursion
+	       (goto-char encl-pos)
+	       (c-backward-over-enum-header)))
+	(c-syntactic-skip-backward "^{," nil t)
+	(c-put-char-property (1- (point)) 'c-type 'c-decl-id-start)
 
-      (c-forward-syntactic-ws)
-      (c-font-lock-declarators limit t nil t)))
+	(c-forward-syntactic-ws)
+	(c-font-lock-declarators limit t nil t))))
   nil)
 
 (defun c-font-lock-cut-off-declarators (limit)
@@ -1585,46 +1596,48 @@ casts and declarations are fontified.  Used on level 2 and higher."
   ;; font-lock-keyword-face.  It always returns NIL to inhibit this and
   ;; prevent a repeat invocation.  See elisp/lispref page "Search-based
   ;; fontification".
-  (let ((here (point))
-	(decl-search-lim (c-determine-limit 1000))
-	paren-state encl-pos token-end context decl-or-cast
-	start-pos top-level c-restricted-<>-arglists
-	c-recognize-knr-p)		; Strictly speaking, bogus, but it
+  (c-skip-comments-and-strings limit)
+  (when (< (point) limit)
+    (let ((here (point))
+	  (decl-search-lim (c-determine-limit 1000))
+	  paren-state encl-pos token-end context decl-or-cast
+	  start-pos top-level c-restricted-<>-arglists
+	  c-recognize-knr-p)		; Strictly speaking, bogus, but it
 					; speeds up lisp.h tremendously.
-    (save-excursion
-      (when (not (c-back-over-member-initializers))
-	(unless (or (eobp)
-		    (looking-at "\\s(\\|\\s)"))
-	  (forward-char))
-	(c-syntactic-skip-backward "^;{}" decl-search-lim t)
-	(when (eq (char-before) ?})
-	  (c-go-list-backward)	; brace block of struct, etc.?
-	  (c-syntactic-skip-backward "^;{}" decl-search-lim t))
-	(when (or (bobp)
-		  (memq (char-before) '(?\; ?{ ?})))
-	  (setq token-end (point))
-	  (c-forward-syntactic-ws here)
-	  (when (< (point) here)
-	    ;; We're now putatively at the declaration.
-	    (setq start-pos (point))
-	    (setq paren-state (c-parse-state))
-	    ;; At top level or inside a "{"?
-	    (if (or (not (setq encl-pos
-			       (c-most-enclosing-brace paren-state)))
-		    (eq (char-after encl-pos) ?\{))
-		(progn
-		  (setq top-level (c-at-toplevel-p))
-		  (let ((got-context (c-get-fontification-context
-				      token-end nil top-level)))
-		    (setq context (car got-context)
-			  c-restricted-<>-arglists (cdr got-context)))
-		  (setq decl-or-cast
-			(c-forward-decl-or-cast-1 token-end context nil))
-		  (when (consp decl-or-cast)
-		    (goto-char start-pos)
-		    (c-font-lock-single-decl limit decl-or-cast token-end
-					     context top-level))))))))
-    nil))
+      (save-excursion
+	(when (not (c-back-over-member-initializers))
+	  (unless (or (eobp)
+		      (looking-at "\\s(\\|\\s)"))
+	    (forward-char))
+	  (c-syntactic-skip-backward "^;{}" decl-search-lim t)
+	  (when (eq (char-before) ?})
+	    (c-go-list-backward)	; brace block of struct, etc.?
+	    (c-syntactic-skip-backward "^;{}" decl-search-lim t))
+	  (when (or (bobp)
+		    (memq (char-before) '(?\; ?{ ?})))
+	    (setq token-end (point))
+	    (c-forward-syntactic-ws here)
+	    (when (< (point) here)
+	      ;; We're now putatively at the declaration.
+	      (setq start-pos (point))
+	      (setq paren-state (c-parse-state))
+	      ;; At top level or inside a "{"?
+	      (if (or (not (setq encl-pos
+				 (c-most-enclosing-brace paren-state)))
+		      (eq (char-after encl-pos) ?\{))
+		  (progn
+		    (setq top-level (c-at-toplevel-p))
+		    (let ((got-context (c-get-fontification-context
+					token-end nil top-level)))
+		      (setq context (car got-context)
+			    c-restricted-<>-arglists (cdr got-context)))
+		    (setq decl-or-cast
+			  (c-forward-decl-or-cast-1 token-end context nil))
+		    (when (consp decl-or-cast)
+		      (goto-char start-pos)
+		      (c-font-lock-single-decl limit decl-or-cast token-end
+					       context top-level))))))))
+      nil)))
 
 (defun c-font-lock-enclosing-decls (limit)
   ;; Fontify the declarators of (nested) declarations we're in the middle of.
@@ -1636,27 +1649,29 @@ casts and declarations are fontified.  Used on level 2 and higher."
   ;; font-lock-keyword-face.  It always returns NIL to inhibit this and
   ;; prevent a repeat invocation.  See elisp/lispref page "Search-based
   ;; Fontification".
-  (let* ((paren-state (c-parse-state))
-	 (decl-search-lim (c-determine-limit 1000))
-	 in-typedef ps-elt)
-    ;; Are we in any nested struct/union/class/etc. braces?
-    (while paren-state
-      (setq ps-elt (car paren-state)
-	    paren-state (cdr paren-state))
-      (when (and (atom ps-elt)
-		 (eq (char-after ps-elt) ?\{))
-	(goto-char ps-elt)
-	(c-syntactic-skip-backward "^;{}" decl-search-lim)
-	(c-forward-syntactic-ws)
-	(setq in-typedef (looking-at c-typedef-key))
-	(if in-typedef (c-forward-over-token-and-ws))
-	(when (and c-opt-block-decls-with-vars-key
-		   (looking-at c-opt-block-decls-with-vars-key))
+  (c-skip-comments-and-strings limit)
+  (when (< (point) limit)
+    (let* ((paren-state (c-parse-state))
+	   (decl-search-lim (c-determine-limit 1000))
+	   in-typedef ps-elt)
+      ;; Are we in any nested struct/union/class/etc. braces?
+      (while paren-state
+	(setq ps-elt (car paren-state)
+	      paren-state (cdr paren-state))
+	(when (and (atom ps-elt)
+		   (eq (char-after ps-elt) ?\{))
 	  (goto-char ps-elt)
-	  (when (c-safe (c-forward-sexp))
-	    (c-forward-syntactic-ws)
-	    (c-font-lock-declarators limit t in-typedef
-				     (not (c-bs-at-toplevel-p (point))))))))))
+	  (c-syntactic-skip-backward "^;{}" decl-search-lim)
+	  (c-forward-syntactic-ws)
+	  (setq in-typedef (looking-at c-typedef-key))
+	  (if in-typedef (c-forward-over-token-and-ws))
+	  (when (and c-opt-block-decls-with-vars-key
+		     (looking-at c-opt-block-decls-with-vars-key))
+	    (goto-char ps-elt)
+	    (when (c-safe (c-forward-sexp))
+	      (c-forward-syntactic-ws)
+	      (c-font-lock-declarators limit t in-typedef
+				       (not (c-bs-at-toplevel-p (point)))))))))))
 
 (defun c-font-lock-raw-strings (limit)
   ;; Fontify C++ raw strings.
@@ -1666,15 +1681,12 @@ casts and declarations are fontified.  Used on level 2 and higher."
   ;; font-lock-keyword-face.  It always returns NIL to inhibit this and
   ;; prevent a repeat invocation.  See elisp/lispref page "Search-based
   ;; Fontification".
-  (let* ((state (c-state-semi-pp-to-literal (point)))
+  (let* ((state (c-semi-pp-to-literal (point)))
 	 (string-start (and (eq (cadr state) 'string)
 			    (car (cddr state))))
 	 (raw-id (and string-start
-		      (save-excursion
-			(goto-char string-start)
-			(and (eq (char-before) ?R)
-			     (looking-at "\"\\([^ ()\\\n\r\t]\\{0,16\\}\\)(")
-			     (match-string-no-properties 1)))))
+		      (c-at-c++-raw-string-opener string-start)
+		      (match-string-no-properties 1)))
 	 (content-start (and raw-id (point))))
     ;; We go round the next loop twice per raw string, once for each "end".
     (while (< (point) limit)
@@ -2089,6 +2101,14 @@ higher."
 	    (c-lang-const c-complex-decl-matchers)
 	    (c-lang-const c-basic-matchers-after)))
 
+(defun c-get-doc-comment-style ()
+  ;; Get the symbol (or list of symbols) constituting the document style.
+  ;; Return nil if there is no such, otherwise something like `autodoc'.
+  (if (consp (car-safe c-doc-comment-style))
+      (cdr-safe (or (assq c-buffer-is-cc-mode c-doc-comment-style)
+		    (assq 'other c-doc-comment-style)))
+    c-doc-comment-style))
+
 (defun c-compose-keywords-list (base-list)
   ;; Incorporate the font lock keyword lists according to
   ;; `c-doc-comment-style' on the given keyword list and return it.
@@ -2099,11 +2119,7 @@ higher."
   (unless (memq c-doc-face-name c-literal-faces)
     (setq c-literal-faces (cons c-doc-face-name c-literal-faces)))
 
-  (let* ((doc-keywords
-	  (if (consp (car-safe c-doc-comment-style))
-	      (cdr-safe (or (assq c-buffer-is-cc-mode c-doc-comment-style)
-			    (assq 'other c-doc-comment-style)))
-	    c-doc-comment-style))
+  (let* ((doc-keywords (c-get-doc-comment-style))
 	 (list (nconc (c--mapcan
 		       (lambda (doc-style)
 			 (let ((sym (intern
@@ -2552,15 +2568,88 @@ need for `pike-font-lock-extra-types'.")
   "Default expressions to highlight in Pike mode.")
 
 (defun pike-font-lock-keywords-2 ()
+  (c-set-doc-comment-res)
   (c-compose-keywords-list pike-font-lock-keywords-2))
 (defun pike-font-lock-keywords-3 ()
+  (c-set-doc-comment-res)
   (c-compose-keywords-list pike-font-lock-keywords-3))
 (defun pike-font-lock-keywords ()
+  (c-set-doc-comment-res)
   (c-compose-keywords-list pike-font-lock-keywords))
 
 
 ;;; Doc comments.
 
+(defvar c-doc-line-join-re regexp-unmatchable)
+;; Matches a join of two lines in a doc comment.
+;; This should not be changed directly, but instead set by
+;; `c-setup-doc-comment-style'.  This variable is used in `c-find-decl-spots'
+;; in (e.g.) autodoc style comments to bridge the gap between a "@\n" at an
+;; EOL and the token following "//!" on the next line.
+
+(defvar c-doc-bright-comment-start-re regexp-unmatchable)
+;; Matches the start of a "bright" comment, one whose contents may be
+;; fontified by, e.g., `c-font-lock-declarations'.
+
+(defvar c-doc-line-join-end-ch nil)
+;; A list of characters, each being a last character of a doc comment marker,
+;; e.g. the ! from pike autodoc's "//!".
+
+(defmacro c-set-doc-comment-re-element (suffix)
+  ;; Set the variable `c-doc-line-join-re' to a buffer local value suitable
+  ;; for the current doc comment style, or kill the local value.
+  (let ((var (intern (concat "c-doc" suffix))))
+    `(let* ((styles (c-get-doc-comment-style))
+	    elts)
+       (when (atom styles)
+	 (setq styles (list styles)))
+       (setq elts
+	     (mapcar (lambda (style)
+		       (let ((sym
+			      (intern-soft
+			       (concat (symbol-name style) ,suffix))))
+			 (and sym
+			      (boundp sym)
+			      (symbol-value sym))))
+		     styles))
+       (setq elts (delq nil elts))
+       (setq elts (and elts
+		       (concat "\\("
+			       (mapconcat #'identity elts "\\|")
+			       "\\)")))
+       (if elts
+	   (set (make-local-variable ',var) elts)
+	 (kill-local-variable ',var)))))
+
+(defmacro c-set-doc-comment-char-list (suffix)
+  ;; Set the variable 'c-doc-<suffix>' to the list of *-<suffix>, which must
+  ;; be characters, and * represents the doc comment style.
+  (let ((var (intern (concat "c-doc" suffix))))
+    `(let* ((styles (c-get-doc-comment-style))
+	    elts)
+       (when (atom styles)
+	 (setq styles (list styles)))
+       (setq elts
+	     (mapcar (lambda (style)
+		       (let ((sym
+			      (intern-soft
+			       (concat (symbol-name style) ,suffix))))
+			 (and sym
+			      (boundp sym)
+			      (symbol-value sym))))
+		     styles))
+       (setq elts (delq nil elts))
+       (if elts
+	   (set (make-local-variable ',var) elts)
+	 (kill-local-variable ',var)))))
+
+(defun c-set-doc-comment-res ()
+  ;; Set the variables `c-doc-line-join-re' and
+  ;; `c-doc-bright-comment-start-re' from the current doc comment style(s).
+  (c-set-doc-comment-re-element "-line-join-re")
+  (c-set-doc-comment-re-element "-bright-comment-start-re")
+  (c-set-doc-comment-char-list "-line-join-end-ch"))
+
 (defun c-font-lock-doc-comments (prefix limit keywords)
   ;; Fontify the comments between the point and LIMIT whose start
   ;; matches PREFIX with `c-doc-face-name'.  Assumes comments have been
@@ -2621,17 +2710,20 @@ need for `pike-font-lock-extra-types'.")
 	    (goto-char comment-beg)
 	    (while (and (progn
 			  (c-forward-single-comment)
+			  (c-put-font-lock-face comment-beg (point)
+						c-doc-face-name)
 			  (skip-syntax-forward " ")
+			  (setq comment-beg (point))
 			  (< (point) limit))
 			(looking-at prefix))))
 	(goto-char comment-beg)
-	(c-forward-single-comment))
+	(c-forward-single-comment)
+	(c-put-font-lock-face comment-beg (point) c-doc-face-name))
       (if (> (point) limit) (goto-char limit))
       (setq comment-beg nil)
 
       (let ((region-end (point))
 	    (keylist keywords) keyword matcher highlights)
-	(c-put-font-lock-face region-beg region-end c-doc-face-name)
 	(save-restriction
 	  ;; Narrow to the doc comment.  Among other things, this
 	  ;; helps by making "^" match at the start of the comment.
@@ -2681,7 +2773,7 @@ need for `pike-font-lock-extra-types'.")
 			      (copy-marker (1+ start))))
       t)))
 
-;; GtkDoc patterns contributed by Masatake YAMATO <jet@gyve.org>.
+;; GtkDoc patterns contributed by Masatake YAMATO <yamato@redhat.com>.
 
 (defconst gtkdoc-font-lock-doc-comments
   (let ((symbol "[a-zA-Z0-9_]+")
@@ -2759,7 +2851,8 @@ need for `pike-font-lock-extra-types'.")
 			 "\\)\\)\\s *\\)@[A-Za-z_-]+\\(\\s \\|$\\)"))
 	(markup-faces (list c-doc-markup-face-name c-doc-face-name)))
 
-    (while (re-search-forward line-re limit t)
+    (while (and (< (point) limit)
+		(re-search-forward line-re limit t))
       (goto-char (match-end 1))
 
       (if (looking-at autodoc-decl-keywords)
@@ -2838,6 +2931,13 @@ need for `pike-font-lock-extra-types'.")
      0 'font-lock-warning-face prepend nil)
     ))
 
+(defconst autodoc-line-join-re "@[\n\r][ \t]*/[/*]!")
+;; Matches a line continuation in autodoc comment style.
+(defconst autodoc-bright-comment-start-re "/[/*]!")
+;; Matches an autodoc comment opener.
+(defconst autodoc-line-join-end-ch ?!)
+;; The final character of `autodoc-line-join-re'.
+
 (defun autodoc-font-lock-keywords ()
   ;; Note that we depend on that `c-current-comment-prefix' has got
   ;; its proper value here.
diff --git a/lisp/progmodes/cc-langs.el b/lisp/progmodes/cc-langs.el
index 2dff5cf83c..be921ad42a 100644
--- a/lisp/progmodes/cc-langs.el
+++ b/lisp/progmodes/cc-langs.el
@@ -945,7 +945,7 @@ file name in angle brackets or quotes."
 	 (c-make-keywords-re 'appendable
 	   (c-lang-const c-cpp-include-directives))
 	 "[ \t]*")
-      "a\\`"))				; Doesn't match anything
+      regexp-unmatchable))
 (c-lang-defvar c-cpp-include-key (c-lang-const c-cpp-include-key))
 
 (c-lang-defconst c-opt-cpp-macro-define
@@ -979,6 +979,14 @@ definition, or nil if the language doesn't have any."
 (c-lang-defvar c-opt-cpp-macro-define-id
   (c-lang-const c-opt-cpp-macro-define-id))
 
+(c-lang-defconst c-anchored-hash-define-no-parens
+  ;; Regexp matching everything up to the end of a cpp define which has no
+  ;; argument parentheses.  Or nil in languages which don't have them.
+  t (if (c-lang-const c-opt-cpp-macro-define)
+	(concat (c-lang-const c-anchored-cpp-prefix)
+		(c-lang-const c-opt-cpp-macro-define)
+		"[ \t]+\\(\\sw\\|_\\)+\\([^(a-zA-Z0-9_]\\|$\\)")))
+
 (c-lang-defconst c-cpp-expr-directives
   "List of cpp directives (without the prefix) that are followed by an
 expression."
@@ -1323,7 +1331,7 @@ operators."
 	   (c--set-difference (c-lang-const c-assignment-operators)
 			      '("=")
 			      :test 'string-equal)))
-      "a\\`"))				; Doesn't match anything.
+      regexp-unmatchable))
 (c-lang-defvar c-assignment-op-regexp
   (c-lang-const c-assignment-op-regexp))
 
@@ -1546,10 +1554,19 @@ properly."
   ;; language)
   t (if (c-lang-const c-block-comment-ender)
 	(regexp-quote (c-lang-const c-block-comment-ender))
-      "a\\`"))				; Doesn't match anything.
+      regexp-unmatchable))
 (c-lang-defvar c-block-comment-ender-regexp
 	       (c-lang-const c-block-comment-ender-regexp))
 
+(c-lang-defconst c-block-comment-awkward-chars
+  "List of characters which, inside a block comment, could be the first
+character of a double character construct.  This doesn't include
+backslash."
+  t (when (> (length (c-lang-const c-block-comment-ender)) 1)
+      (list (aref (c-lang-const c-block-comment-ender) 0))))
+(c-lang-defvar c-block-comment-awkward-chars
+	       (c-lang-const c-block-comment-awkward-chars))
+
 (c-lang-defconst c-font-lock-comment-end-skip
   ;; Regexp which matches whitespace followed by the end of a block comment
   ;; (if such exists in the language).  This is used by font lock to determine
@@ -1557,7 +1574,7 @@ properly."
   ;; `font-lock-comment-delimiter-face'.
   t (if (c-lang-const c-block-comment-ender)
 	(concat "[ \t]*" (c-lang-const c-block-comment-ender-regexp))
-      "a\\`"))				; Doesn't match anything.
+      regexp-unmatchable))
 (c-lang-setvar font-lock-comment-end-skip
 	       (c-lang-const c-font-lock-comment-end-skip))
 
@@ -1576,7 +1593,7 @@ properly."
   ;; language)
   t (if (c-lang-const c-block-comment-starter)
 	(regexp-quote (c-lang-const c-block-comment-starter))
-      "a\\`"))				; Doesn't match anything.
+      regexp-unmatchable))
 (c-lang-defvar c-block-comment-start-regexp
   (c-lang-const c-block-comment-start-regexp))
 
@@ -1585,22 +1602,42 @@ properly."
   ;; language; it does in all 7 CC Mode languages).
   t (if (c-lang-const c-line-comment-starter)
 	(regexp-quote (c-lang-const c-line-comment-starter))
-      "a\\`"))				; Doesn't match anything.
+      regexp-unmatchable))
 (c-lang-defvar c-line-comment-start-regexp
 	       (c-lang-const c-line-comment-start-regexp))
 
+(c-lang-defconst c-last-c-comment-end-on-line-re
+  "Regexp which matches the last block comment ender on the
+current line, if any, or nil in those languages without block
+comments.  When a match is found, submatch 1 contains the comment
+ender."
+  t "\\(\\*/\\)\\([^*]\\|\\*[^/]\\)*$"
+  awk nil)
+(c-lang-defvar c-last-c-comment-end-on-line-re
+	       (c-lang-const c-last-c-comment-end-on-line-re))
+
+(c-lang-defconst c-last-open-c-comment-start-on-line-re
+  "Regexp which matches the last block comment start on the
+current ine, if any, or nil in those languages without block
+comments.  When a match is found, submatch 1 contains the comment
+starter."
+  t "\\(/\\*\\)\\([^*]\\|\\*[^/]\\)*$"
+  awk nil)
+(c-lang-defvar c-last-open-c-comment-start-on-line-re
+	       (c-lang-const c-last-open-c-comment-start-on-line-re))
+
 (c-lang-defconst c-literal-start-regexp
   ;; Regexp to match the start of comments and string literals.
   t (concat (c-lang-const c-comment-start-regexp)
 	    "\\|"
 	    (if (memq 'gen-string-delim c-emacs-features)
-		"\"|"
+		"\"\\|\\s|"
 	      "\"")))
 (c-lang-defvar c-literal-start-regexp (c-lang-const c-literal-start-regexp))
 
 (c-lang-defconst c-doc-comment-start-regexp
   "Regexp to match the start of documentation comments."
-  t    "a\\`"	; Doesn't match anything.
+  t    regexp-unmatchable
   ;; From font-lock.el: `doxygen' uses /*! while others use /**.
   (c c++ objc) "/\\*[*!]"
   java "/\\*\\*"
@@ -2049,6 +2086,19 @@ effect in the declaration, but are syntactically like whitespace."
 (c-lang-defvar c-type-decl-suffix-ws-ids-key
   (c-lang-const c-type-decl-suffix-ws-ids-key))
 
+(c-lang-defconst c-class-id-suffix-ws-ids-kwds
+  "\"Identifiers\" that when immediately following the identifier
+of a class declaration have semantic effect in the declaration,
+but are syntactically like whitespace."
+  t    nil
+  c++ '("final"))
+
+(c-lang-defconst c-class-id-suffix-ws-ids-key
+  ;; An adorned regexp matching `c-class-id-suffix-ws-ids-kwds'.
+  t (c-make-keywords-re t (c-lang-const c-class-id-suffix-ws-ids-kwds)))
+(c-lang-defvar c-class-id-suffix-ws-ids-key
+  (c-lang-const c-class-id-suffix-ws-ids-key))
+
 (c-lang-defconst c-class-decl-kwds
   "Keywords introducing declarations where the following block (if any)
 contains another declaration level that should be considered a class.
@@ -3071,7 +3121,7 @@ Note that Java specific rules are currently applied to tell this from
   "Regexp matching a keyword that is followed by a colon, where
   the whole construct can precede a declaration.
   E.g. \"public:\" in C++."
-  t "a\\`"				; Doesn't match anything.
+  t regexp-unmatchable
   c++ (c-make-keywords-re t (c-lang-const c-protection-kwds)))
 (c-lang-defvar c-decl-start-colon-kwd-re
   (c-lang-const c-decl-start-colon-kwd-re))
@@ -3150,24 +3200,40 @@ constructs."
   ;; token that might precede such a construct, e.g. ';', '}' or '{'.
   ;; It's built from `c-decl-prefix-re'.
   ;;
-  ;; If the first submatch did not match, the match of the whole
-  ;; regexp is taken to be at the first token in the declaration.
-  ;; `c-decl-start-re' is not checked in this case.
+  ;; If the first submatch did not match, we have either a #define construct
+  ;; without parentheses or the match of the whole regexp is taken to be at
+  ;; the first token in the declaration.  `c-decl-start-re' is not checked in
+  ;; these cases.
   ;;
   ;; Design note: The reason the same regexp is used to match both
   ;; tokens that precede declarations and start them is to avoid an
   ;; extra regexp search from the previous declaration spot in
   ;; `c-find-decl-spots'.  Users of `c-find-decl-spots' also count on
-  ;; that it finds all declaration/cast/label starts in approximately
+  ;; it finding all declaration/cast/label starts in approximately
   ;; linear order, so we can't do the searches in two separate passes.
-  t (if (c-lang-const c-decl-start-kwds)
-	(concat (c-lang-const c-decl-prefix-re)
-		"\\|"
-		(c-make-keywords-re t (c-lang-const c-decl-start-kwds)))
-      (c-lang-const c-decl-prefix-re)))
+  t (cond
+     ((and (c-lang-const c-decl-start-kwds)
+	   (c-lang-const c-anchored-hash-define-no-parens))
+      (concat (c-lang-const c-decl-prefix-re)
+	      "\\|" (c-lang-const c-anchored-hash-define-no-parens)
+	      "\\|" (c-make-keywords-re t (c-lang-const c-decl-start-kwds))))
+     ((c-lang-const c-decl-start-kwds)
+      (concat (c-lang-const c-decl-prefix-re)
+	      "\\|" (c-make-keywords-re t (c-lang-const c-decl-start-kwds))))
+     ((c-lang-const c-anchored-hash-define-no-parens)
+      (concat (c-lang-const c-decl-prefix-re)
+	      "\\|" (c-lang-const c-anchored-hash-define-no-parens)))
+     (t (c-lang-const c-decl-prefix-re))))
 (c-lang-defvar c-decl-prefix-or-start-re
   (c-lang-const c-decl-prefix-or-start-re))
 
+(c-lang-defconst c-dposr-cpp-macro-depth
+  ;; The match number of `c-anchored-hash-define-no-parens''s first match
+  ;; within `c-decl-prefix-or-start-re', or nil if there is no such component.
+  t (if (c-lang-const c-anchored-hash-define-no-parens)
+	(1+ (regexp-opt-depth (c-lang-const c-decl-prefix-re)))))
+(c-lang-defvar c-dposr-cpp-macro-depth (c-lang-const c-dposr-cpp-macro-depth))
+
 (c-lang-defconst c-cast-parens
   ;; List containing the paren characters that can open a cast, or nil in
   ;; languages without casts.
@@ -3252,7 +3318,7 @@ Identifier syntax is in effect when this is matched \(see
   t (if (c-lang-const c-type-modifier-kwds)
 	(concat (regexp-opt (c-lang-const c-type-modifier-kwds) t) "\\>")
       ;; Default to a regexp that never matches.
-      "a\\`")
+      regexp-unmatchable)
   ;; Check that there's no "=" afterwards to avoid matching tokens
   ;; like "*=".
   (c objc) (concat "\\("
@@ -3290,7 +3356,7 @@ that might precede the identifier in a declaration, e.g. the
 as the end of the operator.  Identifier syntax is in effect when
 this is matched \(see `c-identifier-syntax-table')."
   t ;; Default to a regexp that never matches.
-    "a\\`"
+    regexp-unmatchable
   ;; Check that there's no "=" afterwards to avoid matching tokens
   ;; like "*=".
   (c objc) (concat "\\(\\*\\)"
@@ -3449,7 +3515,7 @@ list."
 (c-lang-defconst c-pre-id-bracelist-key
   "A regexp matching tokens which, preceding an identifier, signify a bracelist.
 "
-  t "a\\`"				; Doesn't match anything.
+  t regexp-unmatchable
   c++ "new\\([^[:alnum:]_$]\\|$\\)\\|&&?\\(\\S.\\|$\\)")
 (c-lang-defvar c-pre-id-bracelist-key (c-lang-const c-pre-id-bracelist-key))
 
@@ -3505,7 +3571,7 @@ the invalidity of the putative template construct."
 	 ;; before the '{' of the enum list, to avoid searching too far.
 	 "[^][{};/#=]*"
 	 "{")
-      "a\\`"))				; Doesn't match anything.
+      regexp-unmatchable))
 (c-lang-defvar c-enum-clause-introduction-re
 	       (c-lang-const c-enum-clause-introduction-re))
 
@@ -3617,11 +3683,36 @@ i.e. before \":\".  Only used if `c-recognize-colon-labels' is set."
   c++ (concat "\\s(\\|\"\\|" (c-lang-const c-nonlabel-token-key)))
 (c-lang-defvar c-nonlabel-token-key (c-lang-const c-nonlabel-token-key))
 
+(c-lang-defconst c-nonlabel-nonparen-token-key
+  "Regexp matching things that can't occur in generic colon labels,
+neither in a statement nor in a declaration context, with the
+exception of an open parenthesis.  The regexp is tested at the
+beginning of every sexp in a suspected label, i.e. before \":\".
+Only used if `c-recognize-colon-labels' is set."
+  ;; This lang const is the same as `c-nonlabel-token-key', except for a
+  ;; slight difference in the c++-mode value.
+  t (concat
+     ;; All keywords except `c-label-kwds' and `c-protection-kwds'.
+     (c-make-keywords-re t
+       (c--set-difference (c-lang-const c-keywords)
+			  (append (c-lang-const c-label-kwds)
+				  (c-lang-const c-protection-kwds))
+			  :test 'string-equal)))
+  ;; Don't allow string literals, except in AWK and Java.  Character constants are OK.
+  (c objc pike idl) (concat "\"\\|"
+			    (c-lang-const c-nonlabel-nonparen-token-key))
+  ;; Also check for open parens in C++, to catch member init lists in
+  ;; constructors.  We normally allow it so that macros with arguments
+  ;; work in labels.
+  c++ (concat "[{[]\\|\"\\|" (c-lang-const c-nonlabel-nonparen-token-key)))
+(c-lang-defvar c-nonlabel-nonparen-token-key
+  (c-lang-const c-nonlabel-nonparen-token-key))
+
 (c-lang-defconst c-nonlabel-token-2-key
   "Regexp matching things that can't occur two symbols before a colon in
 a label construct.  This catches C++'s inheritance construct \"class foo
 : bar\".  Only used if `c-recognize-colon-labels' is set."
-  t "a\\`"				; Doesn't match anything.
+  t regexp-unmatchable
   c++ (c-make-keywords-re t '("class")))
 (c-lang-defvar c-nonlabel-token-2-key (c-lang-const c-nonlabel-token-2-key))
 
diff --git a/lisp/progmodes/cc-mode.el b/lisp/progmodes/cc-mode.el
index 49268c4482..6afcb08a7c 100644
--- a/lisp/progmodes/cc-mode.el
+++ b/lisp/progmodes/cc-mode.el
@@ -559,6 +559,8 @@ that requires a literal mode spec at compile time."
   ;; doesn't work with filladapt but it's better than nothing.
   (set (make-local-variable 'fill-paragraph-function) 'c-fill-paragraph)
 
+  ;; Initialize the three literal sub-caches.
+  (c-truncate-lit-pos-cache 1)
   ;; Initialize the cache of brace pairs, and opening braces/brackets/parens.
   (c-state-cache-init)
   ;; Initialize the "brace stack" cache.
@@ -653,6 +655,9 @@ that requires a literal mode spec at compile time."
     (make-local-hook 'after-change-functions))
   (add-hook 'before-change-functions 'c-before-change nil t)
   (setq c-just-done-before-change nil)
+  ;; FIXME: We should use the new `depth' arg in Emacs-27 (e.g. a depth of -10
+  ;; would do since font-lock uses a(n implicit) depth of 0) so we don't need
+  ;; c-after-font-lock-init.
   (add-hook 'after-change-functions 'c-after-change nil t)
   (when (boundp 'font-lock-extend-after-change-region-function)
     (set (make-local-variable 'font-lock-extend-after-change-region-function)
@@ -1192,8 +1197,6 @@ Note that the style variables are always made local to the buffer."
        (beg-literal-type (and beg-limits
                                       (c-literal-type beg-limits))))
 
-    (when (eq end-literal-type 'string)
-      (setq c-new-END (max c-new-END (cdr end-limits))))
     ;; It is possible the buffer change will include inserting a string quote.
     ;; This could have the effect of flipping the meaning of any following
     ;; quotes up until the next unescaped EOL.  Also guard against the change
@@ -1218,7 +1221,7 @@ Note that the style variables are always made local to the buffer."
 		     (point-max) t t)
 		    (progn
 		      (c-clear-char-property (1- (point)) 'syntax-table)
-		      (c-truncate-semi-nonlit-pos-cache (1- (point)))
+		      (c-truncate-lit-pos-cache (1- (point)))
 		      (not (memq (char-before) c-string-delims)))))
 	       (memq (char-before) c-string-delims))
 	     (progn
@@ -1244,7 +1247,7 @@ Note that the style variables are always made local to the buffer."
       (goto-char (1+ end))	; might be a newline.
       ;; In the following regexp, the initial \n caters for a newline getting
       ;; joined to a preceding \ by the removal of what comes between.
-      (re-search-forward "[\n\r]?\\(\\\\\\(.\\|\n\\|\r\\)\\|[^\\\n\r]\\)*"
+      (re-search-forward "[\n\r]?\\(\\\\\\(.\\|\n\\)\\|[^\\\n\r]\\)*"
 			 nil t)
       ;; We're at an EOLL or point-max.
       (setq c-new-END (max c-new-END (min (1+ (point)) (point-max))))
@@ -1256,14 +1259,15 @@ Note that the style variables are always made local to the buffer."
 		(backward-sexp)
 		(c-clear-char-property eoll-1 'syntax-table)
 		(c-clear-char-property (point) 'syntax-table)
-		(c-truncate-semi-nonlit-pos-cache (point)))
+		(c-truncate-lit-pos-cache (point)))
 	    ;; Opening " at EOB.
 	    (c-clear-char-property (1- (point)) 'syntax-table))
 	(when (and (c-search-backward-char-property 'syntax-table '(15) c-new-BEG)
 		   (memq (char-after) c-string-delims)) ; Ignore an unterminated raw string's (.
 	  ;; Opening " on last line of text (without EOL).
 	  (c-clear-char-property (point) 'syntax-table)
-	  (c-truncate-semi-nonlit-pos-cache (point)))))
+	  (c-truncate-lit-pos-cache (point))
+	  (setq c-new-BEG (min c-new-BEG (point))))))
 
      (t (goto-char end)			; point-max
 	(when
@@ -1271,20 +1275,26 @@ Note that the style variables are always made local to the buffer."
 	     (c-search-backward-char-property 'syntax-table '(15) c-new-BEG)
 	     (memq (char-after) c-string-delims))
 	  (c-clear-char-property (point) 'syntax-table)
-	  (c-truncate-semi-nonlit-pos-cache (point)))))
-
-    (unless (and c-multiline-string-start-char
-		 (not (c-characterp c-multiline-string-start-char)))
+	  (c-truncate-lit-pos-cache (point)))))
+
+    (unless 
+	(or (and
+	     ;; Don't set c-new-BEG/END if we're in a raw string.
+	     (eq beg-literal-type 'string)
+	     (c-at-c++-raw-string-opener (car beg-limits)))
+	    (and c-multiline-string-start-char
+		 (not (c-characterp c-multiline-string-start-char))))
       (when (and (eq end-literal-type 'string)
 		 (not (eq (char-before (cdr end-limits)) ?\()))
 	(c-clear-char-property (1- (cdr end-limits)) 'syntax-table)
-	(c-truncate-semi-nonlit-pos-cache (1- (cdr end-limits))))
+	(c-truncate-lit-pos-cache (1- (cdr end-limits)))
+	(setq c-new-END (max c-new-END (cdr end-limits))))
 
       (when (and (eq beg-literal-type 'string)
 		 (memq (char-after (car beg-limits)) c-string-delims))
-	(setq c-new-BEG (min c-new-BEG (car beg-limits)))
 	(c-clear-char-property (car beg-limits) 'syntax-table)
-	(c-truncate-semi-nonlit-pos-cache (car beg-limits))))))
+	(c-truncate-lit-pos-cache (car beg-limits))
+	(setq c-new-BEG (min c-new-BEG (car beg-limits)))))))
 
 (defun c-after-change-mark-abnormal-strings (beg end _old-len)
   ;; Mark any unbalanced strings in the region (c-new-BEG c-new-END) with
@@ -1355,6 +1365,7 @@ Note that the style variables are always made local to the buffer."
 	      (car beg-limits))
 	     (t				; comment
 	      (cdr beg-limits))))
+      ;; Handle one string each time around the next while loop.
       (while
 	  (and
 	   (< (point) c-new-END)
@@ -1371,15 +1382,20 @@ Note that the style variables are always made local to the buffer."
 	(unless (and (c-major-mode-is 'c++-mode)
 		     (c-maybe-re-mark-raw-string))
 	  (if (c-unescaped-nls-in-string-p (1- (point)))
-	      (looking-at "\\(\\\\\\(.\\|\n\\|\r\\)\\|[^\"]\\)*")
+	      (looking-at "\\(\\\\\\(.\\|\n\\)\\|[^\"]\\)*")
 	    (looking-at (cdr (assq (char-before) c-string-innards-re-alist))))
 	  (cond
 	   ((memq (char-after (match-end 0)) '(?\n ?\r))
 	    (c-put-char-property (1- (point)) 'syntax-table '(15))
-	    (c-put-char-property (match-end 0) 'syntax-table '(15)))
+	    (c-put-char-property (match-end 0) 'syntax-table '(15))
+	    (setq c-new-BEG (min c-new-BEG (point))
+		  c-new-END (max c-new-END (match-end 0))))
 	   ((or (eq (match-end 0) (point-max))
 		(eq (char-after (match-end 0)) ?\\)) ; \ at EOB
-	    (c-put-char-property (1- (point)) 'syntax-table '(15))))
+	    (c-put-char-property (1- (point)) 'syntax-table '(15))
+	    (setq c-new-BEG (min c-new-BEG (point))
+		  c-new-END (max c-new-END (match-end 0))) ; Do we need c-new-END?
+	    ))
 	  (goto-char (min (1+ (match-end 0)) (point-max))))
 	(setq s nil)))))
 
@@ -1518,9 +1534,12 @@ Note that this is a strict tail, so won't match, e.g. \"0x....\".")
 	(goto-char (match-end 0))
 	(if (> (match-end 0) c-new-BEG)
 	    (setq c-new-BEG (1- (match-beginning 0)))))
+       ((looking-at "\\\\'")
+	(setq c-new-BEG (min c-new-BEG (1- (point))))
+	(goto-char (match-end 0)))
        ((save-excursion
 	  (not (search-forward "'" c-new-BEG t)))
-	(setq c-new-BEG (1- (point))))
+	(setq c-new-BEG (min c-new-BEG (1- (point)))))
        (t nil)))
 
     (goto-char c-new-END)
@@ -1544,6 +1563,9 @@ Note that this is a strict tail, so won't match, e.g. \"0x....\".")
 	(goto-char (match-end 0))
 	(if (> (match-end 0) c-new-END)
 	    (setq c-new-END (match-end 0))))
+       ((looking-at "\\\\'")
+	(goto-char (match-end 0))
+	(setq c-new-END (max c-new-END (point))))
        ((equal (c-get-char-property (1- (point)) 'syntax-table) '(1))
 	(when (c-search-forward-char-property-with-value-on-char
 	       'syntax-table '(1) ?\' (c-point 'eoll))
@@ -1567,7 +1589,7 @@ Note that this is a strict tail, so won't match, e.g. \"0x....\".")
     (when (c-search-forward-char-property-with-value-on-char
 	   'syntax-table '(1) ?\' c-new-END)
       (c-invalidate-state-cache (1- (point)))
-      (c-truncate-semi-nonlit-pos-cache (1- (point)))
+      (c-truncate-lit-pos-cache (1- (point)))
       (c-clear-char-property-with-value-on-char
        (1- (point)) c-new-END
        'syntax-table '(1)
@@ -1603,7 +1625,7 @@ Note that this is a strict tail, so won't match, e.g. \"0x....\".")
 	       (setq num-beg (match-beginning 0)
 		     num-end (match-end 0))
 	       (c-invalidate-state-cache num-beg)
-	       (c-truncate-semi-nonlit-pos-cache num-beg)
+	       (c-truncate-lit-pos-cache num-beg)
 	       (c-put-char-properties-on-char num-beg num-end
 					      'syntax-table '(1) ?')
 	       (c-put-char-properties-on-char num-beg num-end
@@ -1613,9 +1635,15 @@ Note that this is a strict tail, so won't match, e.g. \"0x....\".")
 		"\\([^\\']\\|\\\\\\([0-7]\\{1,3\\}\\|[xuU][0-9a-fA-F]+\\|.\\)\
 \\)'") ; balanced quoted expression.
 	       (goto-char (match-end 0)))
+	      ((looking-at "\\\\'")	; Anomalous construct.
+	       (c-invalidate-state-cache (1- (point)))
+	       (c-truncate-lit-pos-cache (1- (point)))
+	       (c-put-char-properties-on-char (1- (point)) (+ (point) 2)
+					      'syntax-table '(1) ?')
+	       (goto-char (match-end 0)))
 	      (t
 	       (c-invalidate-state-cache (1- (point)))
-	       (c-truncate-semi-nonlit-pos-cache (1- (point)))
+	       (c-truncate-lit-pos-cache (1- (point)))
 	       (c-put-char-property (1- (point)) 'syntax-table '(1))))
 	;; Prevent the next `c-quoted-number-straddling-point' getting
 	;; confused by already processed single quotes.
@@ -1797,6 +1825,36 @@ Note that this is a strict tail, so won't match, e.g. \"0x....\".")
 		    (funcall fn beg end old-len))
 		  c-before-font-lock-functions)))))))
 
+(defun c-doc-fl-decl-start (pos)
+  ;; If the line containing POS is in a doc comment continued line (as defined
+  ;; by `c-doc-line-join-re'), return the position of the first line of the
+  ;; sequence.  Otherwise, return nil.  Point has no significance at entry to
+  ;; and exit from this function.
+  (when (not (equal c-doc-line-join-re regexp-unmatchable))
+    (goto-char pos)
+    (back-to-indentation)
+    (and (or (looking-at c-comment-start-regexp)
+	     (memq (c-literal-type (c-literal-limits)) '(c c++)))
+	 (progn
+	   (end-of-line)
+	   (let ((here (point)))
+	     (while (re-search-backward c-doc-line-join-re (c-point 'bopl) t))
+	     (and (not (eq (point) here))
+		  (c-point 'bol)))))))
+
+(defun c-doc-fl-decl-end (pos)
+  ;; If the line containing POS is continued by a doc comment continuation
+  ;; marker (as defined by `c-doc-line-join-re), return the position of
+  ;; the BOL at the end of the sequence.  Otherwise, return nil.  Point has no
+  ;; significance at entry to and exit from this function.
+  (when (not (equal c-doc-line-join-re regexp-unmatchable))
+    (goto-char pos)
+    (back-to-indentation)
+    (let ((here (point)))
+      (while (re-search-forward c-doc-line-join-re (c-point 'eonl) t))
+      (and (not (eq (point) here))
+	   (c-point 'bonl)))))
+
 (defun c-fl-decl-start (pos)
   ;; If the beginning of the line containing POS is in the middle of a "local"
   ;; declaration, return the beginning of that declaration.  Otherwise return
@@ -1804,6 +1862,9 @@ Note that this is a strict tail, so won't match, e.g. \"0x....\".")
   ;; declaration is one which does not start outside of struct braces (and
   ;; similar) enclosing POS.  Brace list braces here are not "similar".
   ;;
+  ;; POS being in a literal does not count as being in a declaration (on
+  ;; pragmatic grounds).
+  ;;
   ;; This function is called indirectly from font locking stuff - either from
   ;; c-after-change (to prepare for after-change font-locking) or from font
   ;; lock context (etc.) fontification.
@@ -1814,92 +1875,89 @@ Note that this is a strict tail, so won't match, e.g. \"0x....\".")
 	capture-opener
 	bod-lim bo-decl)
     (goto-char (c-point 'bol new-pos))
-    (when lit-start			; Comment or string.
-      (goto-char lit-start))
-    (setq bod-lim (c-determine-limit 500))
-
-    ;; In C++ Mode, first check if we are within a (possibly nested) lambda
-    ;; form capture list.
-    (when (c-major-mode-is 'c++-mode)
-      (let ((paren-state (c-parse-state))
-	    opener)
+    (unless lit-start
+      (setq bod-lim (c-determine-limit 500))
+
+      ;; In C++ Mode, first check if we are within a (possibly nested) lambda
+      ;; form capture list.
+      (when (c-major-mode-is 'c++-mode)
 	(save-excursion
-	  (while (setq opener (c-pull-open-brace paren-state))
-	    (goto-char opener)
-	    (if (c-looking-at-c++-lambda-capture-list)
-		(setq capture-opener (point)))))))
-
-    (while
-	;; Go to a less nested declaration each time round this loop.
-	(and
-	 (setq old-pos (point))
-	 (let (pseudo)
-	   (while
-	       (progn
-		 (c-syntactic-skip-backward "^;{}" bod-lim t)
-		 (and (eq (char-before) ?})
-		      (save-excursion
-			(backward-char)
-			(setq pseudo (c-cheap-inside-bracelist-p (c-parse-state))))))
-	     (goto-char pseudo))
-	   t)
-	 (> (point) bod-lim)
-	 (progn (c-forward-syntactic-ws)
-		;; Have we got stuck in a comment at EOB?
-		(not (and (eobp)
-			  (c-literal-start))))
-	 (< (point) old-pos)
-	 (progn (setq bo-decl (point))
-		(or (not (looking-at c-protection-key))
-		    (c-forward-keyword-clause 1)))
-	 (progn
-	   ;; Are we looking at a keyword such as "template" or
-	   ;; "typedef" which can decorate a type, or the type itself?
-	   (when (or (looking-at c-prefix-spec-kwds-re)
-		     (c-forward-type t))
-	     ;; We've found another candidate position.
-	     (setq new-pos (min new-pos bo-decl))
-	     (goto-char bo-decl))
-	   t)
-	 ;; Try and go out a level to search again.
-	 (progn
-	   (c-backward-syntactic-ws bod-lim)
-	   (and (> (point) bod-lim)
-		(or (memq (char-before) '(?\( ?\[))
-		    (and (eq (char-before) ?\<)
-			 (eq (c-get-char-property
-			      (1- (point)) 'syntax-table)
-			     c-<-as-paren-syntax))
-		    (and (eq (char-before) ?{)
-			 (save-excursion
-			   (backward-char)
-			   (consp (c-looking-at-or-maybe-in-bracelist))))
-		    )))
-	 (not (bobp)))
-      (backward-char))			; back over (, [, <.
-    (when (and capture-opener (< capture-opener new-pos))
-      (setq new-pos capture-opener))
-    (and (/= new-pos pos) new-pos)))
+	  (while (and (c-go-up-list-backward nil bod-lim)
+		      (c-looking-at-c++-lambda-capture-list))
+	    (setq capture-opener (point)))))
+
+      (while
+	  ;; Go to a less nested declaration each time round this loop.
+	  (and
+	   (setq old-pos (point))
+	   (let (pseudo)
+	     (while
+		 (progn
+		   (c-syntactic-skip-backward "^;{}" bod-lim t)
+		   (and (eq (char-before) ?})
+			(save-excursion
+			  (backward-char)
+			  (setq pseudo (c-cheap-inside-bracelist-p (c-parse-state))))))
+	       (goto-char pseudo))
+	     t)
+	   (> (point) bod-lim)
+	   (progn (c-forward-syntactic-ws)
+		  ;; Have we got stuck in a comment at EOB?
+		  (not (and (eobp)
+			    (c-literal-start))))
+	   (< (point) old-pos)
+	   (progn (setq bo-decl (point))
+		  (or (not (looking-at c-protection-key))
+		      (c-forward-keyword-clause 1)))
+	   (progn
+	     ;; Are we looking at a keyword such as "template" or
+	     ;; "typedef" which can decorate a type, or the type itself?
+	     (when (or (looking-at c-prefix-spec-kwds-re)
+		       (c-forward-type t))
+	       ;; We've found another candidate position.
+	       (setq new-pos (min new-pos bo-decl))
+	       (goto-char bo-decl))
+	     t)
+	   ;; Try and go out a level to search again.
+	   (progn
+	     (c-backward-syntactic-ws bod-lim)
+	     (and (> (point) bod-lim)
+		  (or (memq (char-before) '(?\( ?\[))
+		      (and (eq (char-before) ?\<)
+			   (eq (c-get-char-property
+				(1- (point)) 'syntax-table)
+			       c-<-as-paren-syntax))
+		      (and (eq (char-before) ?{)
+			   (save-excursion
+			     (backward-char)
+			     (consp (c-looking-at-or-maybe-in-bracelist))))
+		      )))
+	   (not (bobp)))
+	(backward-char))		; back over (, [, <.
+      (when (and capture-opener (< capture-opener new-pos))
+	(setq new-pos capture-opener))
+      (and (/= new-pos pos) new-pos))))
 
 (defun c-fl-decl-end (pos)
   ;; If POS is inside a declarator, return the end of the token that follows
-  ;; the declarator, otherwise return nil.
+  ;; the declarator, otherwise return nil.  POS being in a literal does not
+  ;; count as being in a declarator (on pragmatic grounds).
   (goto-char pos)
   (let ((lit-start (c-literal-start))
 	pos1)
-    (if lit-start (goto-char lit-start))
-    (c-backward-syntactic-ws)
-    (when (setq pos1 (c-on-identifier))
-      (goto-char pos1)
-      (let ((lim (save-excursion
-		   (and (c-beginning-of-macro)
-			(progn (c-end-of-macro) (point))))))
-	(when (and (c-forward-declarator lim)
-		   (or (not (eq (char-after) ?\())
-		       (c-go-list-forward nil lim))
-		   (eq (c-forward-token-2 1 nil lim) 0))
-	  (c-backward-syntactic-ws)
-	  (point))))))
+    (unless lit-start
+      (c-backward-syntactic-ws)
+      (when (setq pos1 (c-on-identifier))
+	(goto-char pos1)
+	(let ((lim (save-excursion
+		     (and (c-beginning-of-macro)
+			  (progn (c-end-of-macro) (point))))))
+	  (when (and (c-forward-declarator lim)
+		     (or (not (eq (char-after) ?\())
+			 (c-go-list-forward nil lim))
+		     (eq (c-forward-token-2 1 nil lim) 0))
+	    (c-backward-syntactic-ws)
+	    (point)))))))
 
 (defun c-change-expand-fl-region (_beg _end _old-len)
   ;; Expand the region (c-new-BEG c-new-END) to an after-change font-lock
@@ -1912,9 +1970,10 @@ Note that this is a strict tail, so won't match, e.g. \"0x....\".")
   ;; and OLD-LEN are not used.
   (if font-lock-mode
       (setq c-new-BEG
-	    (or (c-fl-decl-start c-new-BEG) (c-point 'bol c-new-BEG))
+	    (or (c-fl-decl-start c-new-BEG) (c-doc-fl-decl-start c-new-BEG)
+		(c-point 'bol c-new-BEG))
 	    c-new-END
-	    (or (c-fl-decl-end c-new-END)
+	    (or (c-fl-decl-end c-new-END) (c-doc-fl-decl-end c-new-END)
 		(c-point 'bonl c-new-END)))))
 
 (defun c-context-expand-fl-region (beg end)
@@ -1922,8 +1981,10 @@ Note that this is a strict tail, so won't match, e.g. \"0x....\".")
   ;; "local" declaration containing BEG (see `c-fl-decl-start') or BOL BEG is
   ;; in.  NEW-END is beginning of the line after the one END is in.
   (c-save-buffer-state ()
-    (cons (or (c-fl-decl-start beg) (c-point 'bol beg))
-	  (or (c-fl-decl-end end) (c-point 'bonl (1- end))))))
+    (cons (or (c-fl-decl-start beg) (c-doc-fl-decl-start beg)
+	      (c-point 'bol beg))
+	  (or (c-fl-decl-end end) (c-doc-fl-decl-end end)
+	      (c-point 'bonl (1- end))))))
 
 (defun c-before-context-fl-expand-region (beg end)
   ;; Expand the region (BEG END) as specified by
@@ -2553,6 +2614,7 @@ Key bindings:
 
 ;; reporter-submit-bug-report requires sendmail.
 (declare-function mail-position-on-field "sendmail" (field &optional soft))
+(declare-function mail-text "sendmail" ())
 
 (defun c-submit-bug-report ()
   "Submit via mail a bug report on CC Mode."
@@ -2617,9 +2679,26 @@ Key bindings:
 	vars)
       (lambda ()
 	(run-hooks 'c-prepare-bug-report-hook)
+	(let ((hook (get mail-user-agent 'hookvar)))
+	  (if hook
+	      (add-hook hook
+			(lambda ()
+			  (save-excursion
+			    (mail-text)
+			    (unless (looking-at "Package: ")
+			      (insert "Package: " c-mode-bug-package "\n\n"))))
+			nil t)))
 	(save-excursion
 	  (or (mail-position-on-field "X-Debbugs-Package")
-	      (insert c-mode-bug-package)))
+	      (insert c-mode-bug-package))
+	  ;; For mail clients that do not support X- headers.
+	  ;; Sadly reporter-submit-bug-report unconditionally adds
+	  ;; a blank line before SALUTATION, so we can't use that.
+	  ;; It is also sad that reporter offers no way to leave point
+	  ;; after this line we are now inserting.
+	  (mail-text)
+	  (or (looking-at "Package:")
+	      (insert "Package: " c-mode-bug-package)))
 	(insert (format "Buffer Style: %s\nc-emacs-features: %s\n"
 			style c-features)))))))
 
diff --git a/lisp/progmodes/cc-vars.el b/lisp/progmodes/cc-vars.el
index 6e8acd4c0d..79bd6a9295 100644
--- a/lisp/progmodes/cc-vars.el
+++ b/lisp/progmodes/cc-vars.el
@@ -1210,7 +1210,7 @@ can always override the use of `c-default-style' by making calls to
        (template-args-cont    . (c-lineup-template-args +))
        ;; Anchor pos: Boi at the decl start.  This might be changed;
        ;; the logical position is clearly the opening '<'.
-       (inlambda              . c-lineup-inexpr-block)
+       (inlambda              . 0)
        ;; Anchor pos: None.
        (lambda-intro-cont     . +)
        ;; Anchor pos: Boi at the lambda start.
@@ -1648,9 +1648,9 @@ white space either before or after the operator, but not both."
   :group 'c)
 
 ;; Initialize the next two to a regexp which never matches.
-(defvar c-noise-macro-with-parens-name-re "a\\`")
+(defvar c-noise-macro-with-parens-name-re regexp-unmatchable)
 (make-variable-buffer-local 'c-noise-macro-with-parens-name-re)
-(defvar c-noise-macro-name-re "a\\`")
+(defvar c-noise-macro-name-re regexp-unmatchable)
 (make-variable-buffer-local 'c-noise-macro-name-re)
 
 (defcustom c-noise-macro-names nil
@@ -1682,7 +1682,7 @@ These are recognized by CC Mode only in declarations."
   ;; Convert `c-noise-macro-names' and `c-noise-macro-with-parens-names' into
   ;; `c-noise-macro-name-re' and `c-noise-macro-with-parens-name-re'.
   (setq c-noise-macro-with-parens-name-re
-	(cond ((null c-noise-macro-with-parens-names) "a\\`") ; Never matches.
+	(cond ((null c-noise-macro-with-parens-names) regexp-unmatchable)
 	      ((consp c-noise-macro-with-parens-names)
 	       (concat (regexp-opt c-noise-macro-with-parens-names t)
 		       "\\([^[:alnum:]_$]\\|$\\)"))
@@ -1691,7 +1691,7 @@ These are recognized by CC Mode only in declarations."
 	      (t (error "c-make-noise-macro-regexps: \
 c-noise-macro-with-parens-names is invalid: %s" c-noise-macro-with-parens-names))))
   (setq c-noise-macro-name-re
-	(cond ((null c-noise-macro-names) "a\\`") ; Never matches anything.
+	(cond ((null c-noise-macro-names) regexp-unmatchable)
 	      ((consp c-noise-macro-names)
 	       (concat (regexp-opt c-noise-macro-names t)
 		       "\\([^[:alnum:]_$]\\|$\\)"))
diff --git a/lisp/progmodes/cperl-mode.el b/lisp/progmodes/cperl-mode.el
index 73b55e29a5..ba007d67c0 100644
--- a/lisp/progmodes/cperl-mode.el
+++ b/lisp/progmodes/cperl-mode.el
@@ -7983,7 +7983,7 @@ prototype \\&SUB	Returns prototype of the function given a reference.
 		       "\\|"		; $ ^
 		       "[$^]"
 		       "\\|"		; simple-code simple-code*?
-		       "\\(\\\\.\\|[^][()#|*+?\n]\\)\\([*+{?]\\??\\)?" ; 4 5
+		       "\\(\\\\.\\|[^][()#|*+?$^\n]\\)\\([*+{?]\\??\\)?" ; 4 5
 		       "\\|"		; Class
 		       "\\(\\[\\)"	; 6
 		       "\\|"		; Grouping
diff --git a/lisp/progmodes/ebnf-abn.el b/lisp/progmodes/ebnf-abn.el
index b8441a79d9..53d37b689f 100644
--- a/lisp/progmodes/ebnf-abn.el
+++ b/lisp/progmodes/ebnf-abn.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, ebnf, PostScript
 ;; Old-Version: 1.2
 ;; Package: ebnf2ps
diff --git a/lisp/progmodes/ebnf-bnf.el b/lisp/progmodes/ebnf-bnf.el
index f28f49090d..70dc84519f 100644
--- a/lisp/progmodes/ebnf-bnf.el
+++ b/lisp/progmodes/ebnf-bnf.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, ebnf, PostScript
 ;; Old-Version: 1.10
 ;; Package: ebnf2ps
diff --git a/lisp/progmodes/ebnf-dtd.el b/lisp/progmodes/ebnf-dtd.el
index 98284faf29..94d9643261 100644
--- a/lisp/progmodes/ebnf-dtd.el
+++ b/lisp/progmodes/ebnf-dtd.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, ebnf, PostScript
 ;; Old-Version: 1.1
 ;; Package: ebnf2ps
diff --git a/lisp/progmodes/ebnf-ebx.el b/lisp/progmodes/ebnf-ebx.el
index 5f9f9b2c19..25500f1618 100644
--- a/lisp/progmodes/ebnf-ebx.el
+++ b/lisp/progmodes/ebnf-ebx.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, ebnf, PostScript
 ;; Old-Version: 1.2
 ;; Package: ebnf2ps
diff --git a/lisp/progmodes/ebnf-iso.el b/lisp/progmodes/ebnf-iso.el
index 88644bbe89..dbba87b3ef 100644
--- a/lisp/progmodes/ebnf-iso.el
+++ b/lisp/progmodes/ebnf-iso.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, ebnf, PostScript
 ;; Old-Version: 1.9
 ;; Package: ebnf2ps
diff --git a/lisp/progmodes/ebnf-otz.el b/lisp/progmodes/ebnf-otz.el
index cbc058e476..291d510020 100644
--- a/lisp/progmodes/ebnf-otz.el
+++ b/lisp/progmodes/ebnf-otz.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, ebnf, PostScript
 ;; Old-Version: 1.0
 ;; Package: ebnf2ps
diff --git a/lisp/progmodes/ebnf-yac.el b/lisp/progmodes/ebnf-yac.el
index 9e712353e9..e55e01e3e9 100644
--- a/lisp/progmodes/ebnf-yac.el
+++ b/lisp/progmodes/ebnf-yac.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, ebnf, PostScript
 ;; Old-Version: 1.4
 ;; Package: ebnf2ps
diff --git a/lisp/progmodes/ebnf2ps.el b/lisp/progmodes/ebnf2ps.el
index 7e7efacf1e..f26ad0a6a8 100644
--- a/lisp/progmodes/ebnf2ps.el
+++ b/lisp/progmodes/ebnf2ps.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, ebnf, PostScript
 ;; Version: 4.4
 ;; X-URL: http://www.emacswiki.org/cgi-bin/wiki/ViniciusJoseLatorre
diff --git a/lisp/progmodes/flymake-proc.el b/lisp/progmodes/flymake-proc.el
index dbf7561944..2d5a47a079 100644
--- a/lisp/progmodes/flymake-proc.el
+++ b/lisp/progmodes/flymake-proc.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2003-2019 Free Software Foundation, Inc.
 
-;; Author:  Pavel Kobyakov <pk_at_work@yahoo.com>
+;; Author: Pavel Kobyakov <pk_at_work@yahoo.com>
 ;; Maintainer: João Távora <joaotavora@gmail.com>
 ;; Version: 1.0
 ;; Keywords: c languages tools
diff --git a/lisp/progmodes/flymake.el b/lisp/progmodes/flymake.el
index d6cd370dac..83b5ee33aa 100644
--- a/lisp/progmodes/flymake.el
+++ b/lisp/progmodes/flymake.el
@@ -2,9 +2,9 @@
 
 ;; Copyright (C) 2003-2019 Free Software Foundation, Inc.
 
-;; Author:  Pavel Kobyakov <pk_at_work@yahoo.com>
+;; Author: Pavel Kobyakov <pk_at_work@yahoo.com>
 ;; Maintainer: João Távora <joaotavora@gmail.com>
-;; Version: 1.0.5
+;; Version: 1.0.6
 ;; Package-Requires: ((emacs "26.1"))
 ;; Keywords: c languages tools
 
@@ -38,10 +38,9 @@
 ;; The main interactive entry point is the `flymake-mode' minor mode,
 ;; which periodically and automatically initiates checks as the user
 ;; is editing the buffer.  The variables `flymake-no-changes-timeout',
-;; `flymake-start-syntax-check-on-newline' and
 ;; `flymake-start-on-flymake-mode' give finer control over the events
-;; triggering a check, as does the interactive command
-;; `flymake-start', which immediately starts a check.
+;; triggering a check, as does the interactive command  `flymake-start',
+;; which immediately starts a check.
 ;;
 ;; Shortly after each check, a summary of collected diagnostics should
 ;; appear in the mode-line.  If it doesn't, there might not be a
@@ -178,14 +177,15 @@ See `flymake-error-bitmap' and `flymake-warning-bitmap'."
 		 (const right-fringe)
 		 (const :tag "No fringe indicators" nil)))
 
-(defcustom flymake-start-syntax-check-on-newline t
-  "Start syntax check if newline char was added/removed from the buffer."
-  :type 'boolean)
+(make-obsolete-variable 'flymake-start-syntax-check-on-newline
+		        "can check on newline in post-self-insert-hook"
+                        "27.1")
 
 (defcustom flymake-no-changes-timeout 0.5
   "Time to wait after last change before automatically checking buffer.
 If nil, never start checking buffer automatically like this."
-  :type 'number)
+  :type '(choice (number :tag "Timeout in seconds")
+                 (const :tag "No check on timeout" nil)))
 
 (defcustom flymake-gui-warnings-enabled t
   "Enables/disables GUI warnings."
@@ -203,7 +203,7 @@ Specifically, start it when the buffer is actually displayed."
   :type 'boolean)
 
 (defcustom flymake-start-on-save-buffer t
-  "If non-nil start syntax check when a buffer is saved.
+  "If non-nil, start syntax check when a buffer is saved.
 Specifically, start it when the saved buffer is actually displayed."
   :version "27.1"
   :type 'boolean)
@@ -856,6 +856,7 @@ with a report function."
 
 (defvar-local flymake--recent-changes nil
   "Recent changes collected by `flymake-after-change-function'.")
+(defvar flymake-mode)
 
 (defun flymake-start (&optional deferred force)
   "Start a syntax check for the current buffer.
@@ -900,7 +901,7 @@ Interactively, with a prefix arg, FORCE is t."
              (add-hook 'window-configuration-change-hook
                        #'start-on-display
                        'append 'local))
-            (t
+            (flymake-mode
              (setq flymake-check-start-time (float-time))
              (let ((backend-args
                     (and
@@ -940,12 +941,10 @@ Flymake collects diagnostic information from multiple sources,
 called backends, and visually annotates the buffer with the
 results.
 
-Flymake performs these checks while the user is editing.  The
-customization variables `flymake-start-on-flymake-mode',
-`flymake-no-changes-timeout' and
-`flymake-start-syntax-check-on-newline' determine the exact
-circumstances whereupon Flymake decides to initiate a check of
-the buffer.
+Flymake performs these checks while the user is editing.
+The customization variables `flymake-start-on-flymake-mode',
+`flymake-no-changes-timeout' determine the exact circumstances
+whereupon Flymake decides to initiate a check of the buffer.
 
 The commands `flymake-goto-next-error' and
 `flymake-goto-prev-error' can be used to navigate among Flymake
@@ -1039,9 +1038,6 @@ Do it only if `flymake-no-changes-timeout' is non-nil."
 START and STOP and LEN are as in `after-change-functions'."
   (let((new-text (buffer-substring start stop)))
     (push (list start stop new-text) flymake--recent-changes)
-    (when (and flymake-start-syntax-check-on-newline (equal new-text "\n"))
-      (flymake-log :debug "starting syntax check as new-line has been seen")
-      (flymake-start t))
     (flymake--schedule-timer-maybe)))
 
 (defun flymake-after-save-hook ()
diff --git a/lisp/progmodes/fortran.el b/lisp/progmodes/fortran.el
index 152667040f..f01e866f55 100644
--- a/lisp/progmodes/fortran.el
+++ b/lisp/progmodes/fortran.el
@@ -1275,7 +1275,8 @@ Directive lines are treated as comments."
                      (concat "[ \t]*"
                              (regexp-quote fortran-continuation-string)))
                     (looking-at "[ \t]*$\\| \\{5\\}[^ 0\n]\\|\t[1-9]")
-                    (looking-at (concat "[ \t]*" comment-start-skip)))))
+                    (looking-at (concat "[ \t]*\\(?:"
+                                        comment-start-skip "\\)")))))
     (cond ((and continue-test
                 (not not-first-statement))
            (message "Incomplete continuation statement."))
@@ -1298,7 +1299,8 @@ Directive lines are treated as comments."
                 (or (looking-at fortran-comment-line-start-skip)
                     (looking-at fortran-directive-re)
                     (looking-at "[ \t]*$\\|     [^ 0\n]\\|\t[1-9]")
-                    (looking-at (concat "[ \t]*" comment-start-skip)))))
+                    (looking-at (concat "[ \t]*\\(?:"
+                                        comment-start-skip "\\)")))))
     (if (not not-last-statement)
         'last-statement)))
 
@@ -2146,7 +2148,8 @@ Always returns non-nil (to prevent `fill-paragraph' being called)."
               (or (looking-at "[ \t]*$")
                   (looking-at fortran-comment-line-start-skip)
                   (and comment-start-skip
-                       (looking-at (concat "[ \t]*" comment-start-skip)))))
+                       (looking-at (concat "[ \t]*\\(?:"
+                                           comment-start-skip "\\)")))))
       (save-excursion
         ;; Find beginning of statement.
         (fortran-next-statement)
diff --git a/lisp/progmodes/glasses.el b/lisp/progmodes/glasses.el
index 2bfc256e18..8dcf84a70b 100644
--- a/lisp/progmodes/glasses.el
+++ b/lisp/progmodes/glasses.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Milan Zamazal <pdm@zamazal.org>
-;; Maintainer: Milan Zamazal <pdm@zamazal.org>
 ;; Keywords: tools
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/progmodes/grep.el b/lisp/progmodes/grep.el
index 8c7a58fd8b..79178c4346 100644
--- a/lisp/progmodes/grep.el
+++ b/lisp/progmodes/grep.el
@@ -441,6 +441,15 @@ abbreviated part can also be toggled with
   :version "27.1"
   :group 'grep)
 
+(defcustom grep-search-path '(nil)
+  "Search path for grep results.
+Elements should be directory names, not file names of directories.
+The value nil as an element means to try the default directory."
+  :group 'grep
+  :version "27.1"
+  :type '(repeat (choice (const :tag "Default" nil)
+			 (string :tag "Directory"))))
+
 (defvar grep-find-abbreviate-properties
   (let ((ellipsis (if (char-displayable-p ?…) "[…]" "[...]"))
         (map (make-sparse-keymap)))
@@ -828,7 +837,8 @@ This function is called from `compilation-filter-hook'."
        grep-mode-line-matches)
   ;; compilation-directory-matcher can't be nil, so we set it to a regexp that
   ;; can never match.
-  (set (make-local-variable 'compilation-directory-matcher) '("\\`a\\`"))
+  (set (make-local-variable 'compilation-directory-matcher)
+       (list regexp-unmatchable))
   (set (make-local-variable 'compilation-process-setup-function)
        'grep-process-setup)
   (set (make-local-variable 'compilation-disable-input) t)
diff --git a/lisp/progmodes/hideshow.el b/lisp/progmodes/hideshow.el
index dcce2a6e2a..1d62bb5875 100644
--- a/lisp/progmodes/hideshow.el
+++ b/lisp/progmodes/hideshow.el
@@ -1,4 +1,4 @@
-;;; hideshow.el --- minor mode cmds to selectively display code/comment blocks
+;;; hideshow.el --- minor mode cmds to selectively display code/comment blocks  -*- lexical-binding:t -*-
 
 ;; Copyright (C) 1994-2019 Free Software Foundation, Inc.
 
@@ -37,7 +37,7 @@
 ;;   hs-show-all                        C-c @ C-M-s
 ;;   hs-hide-level                      C-c @ C-l
 ;;   hs-toggle-hiding                   C-c @ C-c
-;;   hs-mouse-toggle-hiding             [(shift mouse-2)]
+;;   hs-toggle-hiding                   [(shift mouse-2)]
 ;;   hs-hide-initial-comment-block
 ;;
 ;; Blocks are defined per mode.  In c-mode, c++-mode and java-mode, they
@@ -55,8 +55,7 @@
 ;; Then, add the following to your init file:
 ;;
 ;; (load-library "hideshow")
-;; (add-hook 'X-mode-hook               ; other modes similarly
-;;           (lambda () (hs-minor-mode 1)))
+;; (add-hook 'X-mode-hook #'hs-minor-mode)           ; other modes similarly
 ;;
 ;; where X = {emacs-lisp,c,c++,perl,...}.  You can also manually toggle
 ;; hideshow minor mode by typing `M-x hs-minor-mode'.  After hideshow is
@@ -181,8 +180,8 @@
 ;; (5) Hideshow interacts badly with Ediff and `vc-diff'.  At the moment, the
 ;;     suggested workaround is to turn off hideshow entirely, for example:
 ;;
-;;     (add-hook 'ediff-prepare-buffer-hook 'turn-off-hideshow)
-;;     (add-hook 'vc-before-checkin-hook 'turn-off-hideshow)
+;;     (add-hook 'ediff-prepare-buffer-hook #'turn-off-hideshow)
+;;     (add-hook 'vc-before-checkin-hook #'turn-off-hideshow)
 ;;
 ;;     In the case of `vc-diff', here is a less invasive workaround:
 ;;
@@ -317,7 +316,7 @@ a block), `hs-hide-all', `hs-hide-block' and `hs-hide-level'.")
 These commands include the toggling commands (when the result is to show
 a block), `hs-show-all' and `hs-show-block'.")
 
-(defvar hs-set-up-overlay nil
+(defvar hs-set-up-overlay #'ignore
   "Function called with one arg, OV, a newly initialized overlay.
 Hideshow puts a unique overlay on each range of text to be hidden
 in the buffer.  Here is a simple example of how to use this variable:
@@ -329,7 +328,7 @@ in the buffer.  Here is a simple example of how to use this variable:
                            (count-lines (overlay-start ov)
                                         (overlay-end ov))))))
 
-  (setq hs-set-up-overlay \\='display-code-line-counts)
+  (setq hs-set-up-overlay #\\='display-code-line-counts)
 
 This example shows how to get information from the overlay as well
 as how to set its `display' property.  See `hs-make-overlay' and
@@ -355,7 +354,7 @@ Use the command `hs-minor-mode' to toggle or set this variable.")
     (define-key map "\C-c@\C-t"       'hs-hide-all)
     (define-key map "\C-c@\C-d"       'hs-hide-block)
     (define-key map "\C-c@\C-e"       'hs-toggle-hiding)
-    (define-key map [(shift mouse-2)] 'hs-mouse-toggle-hiding)
+    (define-key map [(shift mouse-2)] 'hs-toggle-hiding)
     map)
   "Keymap for hideshow minor mode.")
 
@@ -410,7 +409,7 @@ element (using `match-beginning') before calling `hs-forward-sexp-func'.")
 (defvar-local hs-block-end-regexp nil
   "Regexp for end of block.")
 
-(defvar-local hs-forward-sexp-func 'forward-sexp
+(defvar-local hs-forward-sexp-func #'forward-sexp
   "Function used to do a `forward-sexp'.
 Should change for Algol-ish modes.  For single-character block
 delimiters -- ie, the syntax table regexp for the character is
@@ -418,7 +417,7 @@ either `(' or `)' -- `hs-forward-sexp-func' would just be
 `forward-sexp'.  For other modes such as simula, a more specialized
 function is necessary.")
 
-(defvar-local hs-adjust-block-beginning nil
+(defvar-local hs-adjust-block-beginning #'identity
   "Function used to tweak the block beginning.
 The block is hidden from the position returned by this function,
 as opposed to hiding it from the position returned when searching
@@ -575,10 +574,8 @@ and then further adjusted to be at the end of the line."
 	;; `p' is the point at the end of the block beginning, which
 	;; may need to be adjusted
 	(save-excursion
-	  (if hs-adjust-block-beginning
-	      (goto-char (funcall hs-adjust-block-beginning
-				  header-end))
-	    (goto-char header-end))
+	  (goto-char (funcall (or hs-adjust-block-beginning #'identity)
+			      header-end))
 	  (setq p (line-end-position)))
 	;; `q' is the point at the end of the block
 	(hs-forward-sexp mdata 1)
@@ -657,9 +654,8 @@ If `hs-special-modes-alist' has information associated with the
 current buffer's major mode, use that.
 Otherwise, guess start, end and `comment-start' regexps; `forward-sexp'
 function; and adjust-block-beginning function."
-  (if (and (boundp 'comment-start)
-           (boundp 'comment-end)
-           comment-start comment-end)
+  (if (and (bound-and-true-p comment-start)
+           (bound-and-true-p comment-end))
       (let* ((lookup (assoc major-mode hs-special-modes-alist))
              (start-elem (or (nth 1 lookup) "\\s(")))
         (if (listp start-elem)
@@ -677,8 +673,8 @@ function; and adjust-block-beginning function."
                                           (substring c-start-regexp
                                                      0 (1- (match-end 0)))
                                         c-start-regexp)))
-              hs-forward-sexp-func (or (nth 4 lookup) 'forward-sexp)
-              hs-adjust-block-beginning (nth 5 lookup)))
+              hs-forward-sexp-func (or (nth 4 lookup) #'forward-sexp)
+              hs-adjust-block-beginning (or (nth 5 lookup) #'identity)))
     (setq hs-minor-mode nil)
     (error "%s Mode doesn't support Hideshow Minor Mode"
            (format-mode-line mode-name))))
@@ -729,13 +725,12 @@ Return point, or nil if original point was not in a block."
   "Evaluate BODY forms if variable `hs-minor-mode' is non-nil.
 In the dynamic context of this macro, `inhibit-point-motion-hooks'
 and `case-fold-search' are both t."
+  (declare (debug t))
   `(when hs-minor-mode
      (let ((inhibit-point-motion-hooks t)
            (case-fold-search t))
        ,@body)))
 
-(put 'hs-life-goes-on 'edebug-form-spec '(&rest form))
-
 (defun hs-overlay-at (position)
   "Return hideshow overlay at POSITION, or nil if none to be found."
   (let ((overlays (overlays-at position))
@@ -895,24 +890,18 @@ The hook `hs-hide-hook' is run; see `run-hooks'."
      (message "Hiding blocks ... done"))
    (run-hooks 'hs-hide-hook)))
 
-(defun hs-toggle-hiding ()
+(defun hs-toggle-hiding (&optional e)
   "Toggle hiding/showing of a block.
-See `hs-hide-block' and `hs-show-block'."
+See `hs-hide-block' and `hs-show-block'.
+Argument E should be the event that triggered this action."
   (interactive)
   (hs-life-goes-on
+   (posn-set-point (event-end e))
    (if (hs-already-hidden-p)
        (hs-show-block)
      (hs-hide-block))))
 
-(defun hs-mouse-toggle-hiding (e)
-  "Toggle hiding/showing of a block.
-This command should be bound to a mouse key.
-Argument E is a mouse event used by `mouse-set-point'.
-See `hs-hide-block' and `hs-show-block'."
-  (interactive "@e")
-  (hs-life-goes-on
-   (mouse-set-point e)
-   (hs-toggle-hiding)))
+(define-obsolete-function-alias 'hs-mouse-toggle-hiding #'hs-toggle-hiding "27.1")
 
 (defun hs-hide-initial-comment-block ()
   "Hide the first block of comments in a file.
@@ -939,7 +928,7 @@ The value (hs . t) is added to `buffer-invisibility-spec'.
 
 The main commands are: `hs-hide-all', `hs-show-all', `hs-hide-block',
 `hs-show-block', `hs-hide-level' and `hs-toggle-hiding'.  There is also
-`hs-hide-initial-comment-block' and `hs-mouse-toggle-hiding'.
+`hs-hide-initial-comment-block'.
 
 Turning hideshow minor mode off reverts the menu bar and the
 variables to default values and disables the hideshow commands.
@@ -957,7 +946,7 @@ Key bindings:
         (hs-grok-mode-type)
         ;; Turn off this mode if we change major modes.
         (add-hook 'change-major-mode-hook
-                  'turn-off-hideshow
+                  #'turn-off-hideshow
                   nil t)
         (easy-menu-add hs-minor-mode-menu)
         (set (make-local-variable 'line-move-ignore-invisible) t)
diff --git a/lisp/progmodes/idlw-complete-structtag.el b/lisp/progmodes/idlw-complete-structtag.el
index 51c9117cd4..dcb7d0184c 100644
--- a/lisp/progmodes/idlw-complete-structtag.el
+++ b/lisp/progmodes/idlw-complete-structtag.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Carsten Dominik <dominik@astro.uva.nl>
-;; Maintainer: J.D. Smith <jdsmith@as.arizona.edu>
 ;; Old-Version: 1.2
 ;; Keywords: languages
 ;; Package: idlwave
diff --git a/lisp/progmodes/idlw-help.el b/lisp/progmodes/idlw-help.el
index 4588e93dcf..2cf6fa117b 100644
--- a/lisp/progmodes/idlw-help.el
+++ b/lisp/progmodes/idlw-help.el
@@ -2,9 +2,8 @@
 
 ;; Copyright (C) 2000-2019 Free Software Foundation, Inc.
 ;;
-;; Authors: J.D. Smith <jdsmith@as.arizona.edu>
+;; Authors: JD Smith <jd.smith@utoledo.edu>
 ;;          Carsten Dominik <dominik@science.uva.nl>
-;; Maintainer: J.D. Smith <jdsmith@as.arizona.edu>
 ;; Package: idlwave
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/progmodes/idlw-shell.el b/lisp/progmodes/idlw-shell.el
index a3b079830b..58e8be9716 100644
--- a/lisp/progmodes/idlw-shell.el
+++ b/lisp/progmodes/idlw-shell.el
@@ -2,10 +2,9 @@
 
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
-;; Authors: J.D. Smith <jdsmith@as.arizona.edu>
+;; Authors: JD Smith <jd.smith@utoledo.edu>
 ;;          Carsten Dominik <dominik@astro.uva.nl>
 ;;          Chris Chase <chase@att.com>
-;; Maintainer: J.D. Smith <jdsmith@as.arizona.edu>
 ;; Keywords: processes
 ;; Package: idlwave
 
diff --git a/lisp/progmodes/idlw-toolbar.el b/lisp/progmodes/idlw-toolbar.el
index d3b442c056..fe31eeb46c 100644
--- a/lisp/progmodes/idlw-toolbar.el
+++ b/lisp/progmodes/idlw-toolbar.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
 ;; Author: Carsten Dominik <dominik@astro.uva.nl>
-;; Maintainer: J.D. Smith <jdsmith@as.arizona.edu>
 ;; Keywords: processes
 ;; Package: idlwave
 
diff --git a/lisp/progmodes/idlwave.el b/lisp/progmodes/idlwave.el
index 6f56ce052a..0a124b4d1b 100644
--- a/lisp/progmodes/idlwave.el
+++ b/lisp/progmodes/idlwave.el
@@ -2,10 +2,9 @@
 
 ;; Copyright (C) 1999-2019 Free Software Foundation, Inc.
 
-;; Authors: J.D. Smith <jdsmith@as.arizona.edu>
+;; Authors: JD Smith <jd.smith@utoledo.edu>
 ;;          Carsten Dominik <dominik@science.uva.nl>
 ;;          Chris Chase <chase@att.com>
-;; Maintainer: J.D. Smith <jdsmith@as.arizona.edu>
 ;; Version: 6.1.22
 ;; Keywords: languages
 
diff --git a/lisp/progmodes/js.el b/lisp/progmodes/js.el
index a0adaa84ee..161fd5c00b 100644
--- a/lisp/progmodes/js.el
+++ b/lisp/progmodes/js.el
@@ -3,8 +3,8 @@
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
 ;; Author: Karl Landstrom <karl.landstrom@brgeight.se>
-;;         Daniel Colascione <dan.colascione@gmail.com>
-;; Maintainer: Daniel Colascione <dan.colascione@gmail.com>
+;;         Daniel Colascione <dancol@dancol.org>
+;; Maintainer: Daniel Colascione <dancol@dancol.org>
 ;; Version: 9
 ;; Date: 2009-07-25
 ;; Keywords: languages, javascript
@@ -2140,14 +2140,6 @@ JSXElement or a JSXOpeningElement/JSXClosingElement pair."
 ;; `syntax-propertize-rules' loop so the next JSXBoundaryElement can
 ;; be parsed, if any, be it an opening or closing one.
 
-(defun js-jsx--put-syntax-table (start end value)
-  "Set syntax-table text property from START to END as VALUE.
-Redundantly set the value to two properties, syntax-table and
-js-jsx-syntax-table.  Derivative modes that remove syntax-table
-text properties may recover the value from the second property." ; i.e. js2-mode
-  (add-text-properties start end (list 'syntax-table value
-                                       'js-jsx-syntax-table value)))
-
 (defun js-jsx--text-range (beg end)
   "Identify JSXText within a “>/{/}/<” pair."
   (when (> (- end beg) 0)
@@ -2159,7 +2151,7 @@ text properties may recover the value from the second property." ; i.e. js2-mode
         ;; negate those roles.
         (when (or (= (char-after) ?/) ; comment
                   (= (syntax-class (syntax-after (point))) 7)) ; string quote
-          (js-jsx--put-syntax-table (point) (1+ (point)) '(1)))
+          (put-text-property (point) (1+ (point)) 'syntax-table '(1)))
         (forward-char)))
     ;; Mark JSXText so it can be font-locked as non-keywords.
     (put-text-property beg (1+ beg) 'js-jsx-text (list beg end (current-buffer)))
@@ -2228,7 +2220,8 @@ testing for syntax only valid as JSX."
         (cond
          ((= (char-after) ?>)
           ;; Make the closing “>” a close parenthesis.
-          (js-jsx--put-syntax-table (point) (1+ (point)) '(5))
+          (put-text-property (point) (1+ (point)) 'syntax-table
+                             (eval-when-compile (string-to-syntax ")<")))
           (forward-char)
           (setq unambiguous t)
           (throw 'stop nil))
@@ -2314,7 +2307,8 @@ testing for syntax only valid as JSX."
       ;; Save JSXBoundaryElement’s name’s match data for font-locking.
       (if name-beg (put-text-property name-beg (1+ name-beg) 'js-jsx-tag-name name-match-data))
       ;; Make the opening “<” an open parenthesis.
-      (js-jsx--put-syntax-table tag-beg (1+ tag-beg) '(4))
+      (put-text-property tag-beg (1+ tag-beg) 'syntax-table
+                         (eval-when-compile (string-to-syntax "(>")))
       ;; Prevent “out of range” errors when typing at the end of a buffer.
       (setq tag-end (if (eobp) (1- (point)) (point)))
       ;; Mark beginning and end of tag for font-locking.
@@ -2333,8 +2327,7 @@ testing for syntax only valid as JSX."
   (list
    'js-jsx-tag-beg nil 'js-jsx-tag-end nil 'js-jsx-close-tag-pos nil
    'js-jsx-tag-name nil 'js-jsx-attribute-name nil 'js-jsx-string nil
-   'js-jsx-text nil 'js-jsx-expr nil 'js-jsx-expr-attribute nil
-   'js-jsx-syntax-table nil)
+   'js-jsx-text nil 'js-jsx-expr nil 'js-jsx-expr-attribute nil)
   "Plist of text properties added by `js-syntax-propertize'.")
 
 (defun js-syntax-propertize (start end)
diff --git a/lisp/progmodes/ld-script.el b/lisp/progmodes/ld-script.el
index 6dafb64ed5..8cc7f2d7d7 100644
--- a/lisp/progmodes/ld-script.el
+++ b/lisp/progmodes/ld-script.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2001-2019 Free Software Foundation, Inc.
 
-;; Author: Masatake YAMATO<jet@gyve.org>
+;; Author: Masatake YAMATO <yamato@redhat.com>
 ;; Keywords: languages, faces
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/progmodes/octave.el b/lisp/progmodes/octave.el
index 52e5fd477f..8a7e24e5ad 100644
--- a/lisp/progmodes/octave.el
+++ b/lisp/progmodes/octave.el
@@ -1691,7 +1691,7 @@ code line."
   (eval-and-compile (require 'help-mode))
   ;; Don't highlight `EXAMPLE' as elisp symbols by using a regexp that
   ;; can never match.
-  (setq-local help-xref-symbol-regexp "x\\`"))
+  (setq-local help-xref-symbol-regexp regexp-unmatchable))
 
 (defun octave-help (fn)
   "Display the documentation of FN."
diff --git a/lisp/progmodes/project.el b/lisp/progmodes/project.el
index dabc4ab6b4..88ea59b70e 100644
--- a/lisp/progmodes/project.el
+++ b/lisp/progmodes/project.el
@@ -157,19 +157,13 @@ end it with `/'.  DIR must be one of `project-roots' or
     vc-directory-exclusion-list)
    grep-find-ignored-files))
 
-(cl-defgeneric project-file-completion-table (project dirs)
-  "Return a completion table for files in directories DIRS in PROJECT.
-DIRS is a list of absolute directories; it should be some
-subset of the project roots and external roots.
-
-The default implementation delegates to `project-files'."
-  (let ((all-files (project-files project dirs)))
-    (lambda (string pred action)
-      (cond
-       ((eq action 'metadata)
-        '(metadata . ((category . project-file))))
-       (t
-        (complete-with-action action all-files string pred))))))
+(defun project--file-completion-table (all-files)
+  (lambda (string pred action)
+    (cond
+     ((eq action 'metadata)
+      '(metadata . ((category . project-file))))
+     (t
+      (complete-with-action action all-files string pred)))))
 
 (cl-defmethod project-roots ((project (head transient)))
   (list (cdr project)))
@@ -209,7 +203,8 @@ to find the list of ignores for each directory."
                                      (shell-quote-argument ")"))"")
                          )))
     (project--remote-file-names
-     (split-string (shell-command-to-string command) "\0" t))))
+     (sort (split-string (shell-command-to-string command) "\0" t)
+           #'string<))))
 
 (defun project--remote-file-names (local-files)
   "Return LOCAL-FILES as if they were on the system of `default-directory'."
@@ -354,9 +349,11 @@ requires quoting, e.g. `\\[quoted-insert]<space>'."
             (let ((dir (read-directory-name "Base directory: "
                                             nil default-directory t)))
               (project--files-in-directory dir
-                                           (project--dir-ignores pr dir)
+                                           nil
                                            (grep-read-files regexp))))))
-    (project--find-regexp-in-files regexp files)))
+    (xref--show-xrefs
+     (apply-partially #'project--find-regexp-in-files regexp files)
+     nil)))
 
 (defun project--dir-ignores (project dir)
   (let* ((roots (project-roots project))
@@ -381,7 +378,9 @@ pattern to search for."
           (project-files pr (append
                              (project-roots pr)
                              (project-external-roots pr)))))
-    (project--find-regexp-in-files regexp files)))
+    (xref--show-xrefs
+     (apply-partially #'project--find-regexp-in-files regexp files)
+     nil)))
 
 (defun project--find-regexp-in-files (regexp files)
   (pcase-let*
@@ -390,7 +389,7 @@ pattern to search for."
        (status nil)
        (hits nil)
        (xrefs nil)
-       (command (format "xargs -0 grep %s -nHE %s"
+       (command (format "xargs -0 grep %s -nHE -e %s"
                         (if (and case-fold-search
                                  (isearch-no-upper-case-p regexp t))
                             "-i"
@@ -423,7 +422,7 @@ pattern to search for."
     (setq xrefs (xref--convert-hits (nreverse hits) regexp))
     (unless xrefs
       (user-error "No matches for: %s" regexp))
-    (xref--show-xrefs xrefs nil)))
+    xrefs))
 
 (defun project--process-file-region (start end program
                                      &optional buffer display
@@ -469,55 +468,77 @@ recognized."
                 (project-external-roots pr))))
     (project-find-file-in (thing-at-point 'filename) dirs pr)))
 
+(defcustom project-read-file-name-function #'project--read-file-cpd-relative
+  "Function to call to read a file name from a list.
+For the arguments list, see `project--read-file-cpd-relative'."
+  :type '(choice (const :tag "Read with completion from relative names"
+                        project--read-file-cpd-relative)
+                 (const :tag "Read with completion from absolute names"
+                        project--read-file-absolute)
+                 (function :tag "Custom function" nil))
+  :version "27.1")
+
+(defun project--read-file-cpd-relative (prompt
+                                        all-files &optional predicate
+                                        hist default)
+  "Read a file name, prompting with PROMPT.
+ALL-FILES is a list of possible file name completions.
+PREDICATE, HIST, and DEFAULT have the same meaning as in
+`completing-read'."
+  (let* ((common-parent-directory
+          (let ((common-prefix (try-completion "" all-files)))
+            (if (> (length common-prefix) 0)
+                (file-name-directory common-prefix))))
+         (cpd-length (length common-parent-directory))
+         (prompt (if (zerop cpd-length)
+                     prompt
+                   (concat prompt (format " in %s" common-parent-directory))))
+         (substrings (mapcar (lambda (s) (substring s cpd-length)) all-files))
+         (new-collection (project--file-completion-table substrings))
+         (res (project--completing-read-strict prompt
+                                               new-collection
+                                               predicate
+                                               hist default)))
+    (concat common-parent-directory res)))
+
+(defun project--read-file-absolute (prompt
+                                    all-files &optional predicate
+                                    hist default)
+  (project--completing-read-strict prompt
+                                   (project--file-completion-table all-files)
+                                   predicate
+                                   hist default))
+
 (defun project-find-file-in (filename dirs project)
   "Complete FILENAME in DIRS in PROJECT and visit the result."
-  (let* ((table (project-file-completion-table project dirs))
-         (file (project--completing-read-strict
-                "Find file" table nil nil
-                filename)))
+  (let* ((all-files (project-files project dirs))
+         (file (funcall project-read-file-name-function
+                       "Find file" all-files nil nil
+                       filename)))
     (if (string= file "")
         (user-error "You didn't specify the file")
       (find-file file))))
 
 (defun project--completing-read-strict (prompt
                                         collection &optional predicate
-                                        hist default inherit-input-method)
+                                        hist default)
   ;; Tried both expanding the default before showing the prompt, and
   ;; removing it when it has no matches.  Neither seems natural
   ;; enough.  Removal is confusing; early expansion makes the prompt
   ;; too long.
-  (let* ((common-parent-directory
-          (let ((common-prefix (try-completion "" collection)))
-            (if (> (length common-prefix) 0)
-                (file-name-directory common-prefix))))
-         (cpd-length (length common-parent-directory))
-         (prompt (if (zerop cpd-length)
-                     prompt
-                   (concat prompt (format " in %s" common-parent-directory))))
-         ;; XXX: This requires collection to be "flat" as well.
-         (substrings (mapcar (lambda (s) (substring s cpd-length))
-                             (all-completions "" collection)))
-         (new-collection
-          (lambda (string pred action)
-            (cond
-             ((eq action 'metadata)
-              (if (functionp collection) (funcall collection nil nil 'metadata)))
-             (t
-	      (complete-with-action action substrings string pred)))))
-         (new-prompt (if default
+  (let* ((new-prompt (if (and default (not (string-equal default "")))
                          (format "%s (default %s): " prompt default)
                        (format "%s: " prompt)))
          (res (completing-read new-prompt
-                               new-collection predicate t
+                               collection predicate t
                                nil ;; initial-input
-                               hist default inherit-input-method)))
+                               hist default)))
     (when (and (equal res default)
                (not (test-completion res collection predicate)))
       (setq res
             (completing-read (format "%s: " prompt)
-                             new-collection predicate t res hist nil
-                             inherit-input-method)))
-    (concat common-parent-directory res)))
+                             collection predicate t res hist nil)))
+    res))
 
 (declare-function fileloop-continue "fileloop" ())
 
diff --git a/lisp/progmodes/ps-mode.el b/lisp/progmodes/ps-mode.el
index d9406278e9..92824b63e6 100644
--- a/lisp/progmodes/ps-mode.el
+++ b/lisp/progmodes/ps-mode.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1999, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author:     Peter Kleiweg <p.c.j.kleiweg@rug.nl>
-;; Maintainer: Peter Kleiweg <p.c.j.kleiweg@rug.nl>
 ;; Created:    20 Aug 1997
 ;; Version:    1.1i
 ;; Keywords:   PostScript, languages
diff --git a/lisp/progmodes/python.el b/lisp/progmodes/python.el
index b05f9a33e9..188bc973d9 100644
--- a/lisp/progmodes/python.el
+++ b/lisp/progmodes/python.el
@@ -1070,12 +1070,18 @@ possibilities can be narrowed to specific indentation points."
         (`(,(or :after-line
                 :after-comment
                 :inside-string
-                :after-backslash
-                :inside-paren-at-closing-paren
-                :inside-paren-at-closing-nested-paren) . ,start)
+                :after-backslash) . ,start)
          ;; Copy previous indentation.
          (goto-char start)
          (current-indentation))
+        (`(,(or :inside-paren-at-closing-paren
+                :inside-paren-at-closing-nested-paren) . ,start)
+         (goto-char (+ 1 start))
+         (if (looking-at "[ \t]*\\(?:#\\|$\\)")
+             ;; Copy previous indentation.
+             (current-indentation)
+           ;; Align with opening paren.
+           (current-column)))
         (`(:inside-docstring . ,start)
          (let* ((line-indentation (current-indentation))
                 (base-indent (progn
@@ -2003,7 +2009,7 @@ position, else returns nil."
 It should not contain a caret (^) at the beginning."
   :type 'string)
 
-(defcustom python-shell-prompt-block-regexp "\\.\\.\\. "
+(defcustom python-shell-prompt-block-regexp "\\.\\.\\.:? "
   "Regular expression matching block input prompt of Python shell.
 It should not contain a caret (^) at the beginning."
   :type 'string)
@@ -2303,15 +2309,16 @@ detection and just returns nil."
                          ;; carriage returns in unbuffered mode.
                          (let ((inhibit-eol-conversion (getenv "PYTHONUNBUFFERED")))
                            (python-shell--save-temp-file code))))
-                    ;; Use `process-file' as it is remote-host friendly.
-                    (process-file
-                     interpreter
-                     code-file
-                     '(t nil)
-                     nil
-                     interpreter-arg)
-                    ;; Try to cleanup
-                    (delete-file code-file)))
+                    (unwind-protect
+                        ;; Use `process-file' as it is remote-host friendly.
+                        (process-file
+                         interpreter
+                         code-file
+                         '(t nil)
+                         nil
+                         interpreter-arg)
+                      ;; Try to cleanup
+                      (delete-file code-file))))
                 (buffer-string)))
              (prompts
               (catch 'prompts
diff --git a/lisp/progmodes/ruby-mode.el b/lisp/progmodes/ruby-mode.el
index 4fceda8937..80e809b9d6 100644
--- a/lisp/progmodes/ruby-mode.el
+++ b/lisp/progmodes/ruby-mode.el
@@ -155,6 +155,7 @@ This should only be called after matching against `ruby-here-doc-beg-re'."
     (define-key map (kbd "M-C-n") 'ruby-end-of-block)
     (define-key map (kbd "C-c {") 'ruby-toggle-block)
     (define-key map (kbd "C-c '") 'ruby-toggle-string-quotes)
+    (define-key map (kbd "C-c C-f") 'ruby-find-library-file)
     map)
   "Keymap used in Ruby mode.")
 
@@ -1802,6 +1803,28 @@ If the result is do-end block, it will always be multiline."
          (format "%s%s%s" string-quote content string-quote))
         (goto-char orig-point)))))
 
+(defun ruby-find-library-file (&optional feature-name)
+  "Visit a library file denoted by FEATURE-NAME.
+FEATURE-NAME is a relative file name, file extension is optional.
+This commands delegates to 'gem which', which searches both
+installed gems and the standard library.  When called
+interactively, defaults to the feature name in the 'require'
+statement around point."
+  (interactive)
+  (unless feature-name
+    (let ((init (save-excursion
+                  (forward-line 0)
+                  (when (looking-at "require [\"']\\(.?*\\)[\"']")
+                    (match-string 1)))))
+      (setq feature-name (read-string "Feature name: " init))))
+  (let ((out
+         (substring
+          (shell-command-to-string (concat "gem which " feature-name))
+          0 -1)))
+    (if (string-match-p "\\`ERROR" out)
+        (user-error "%s" out)
+      (find-file out))))
+
 (eval-and-compile
   (defconst ruby-percent-literal-beg-re
     "\\(%\\)[qQrswWxIi]?\\([[:punct:]]\\)"
diff --git a/lisp/progmodes/simula.el b/lisp/progmodes/simula.el
index 3bbf4e0aa2..7230d4cfaf 100644
--- a/lisp/progmodes/simula.el
+++ b/lisp/progmodes/simula.el
@@ -4,8 +4,6 @@
 ;; Inc.
 
 ;; Author: Hans Henrik Eriksen <hhe@ifi.uio.no>
-;; Maintainer: simula-mode@ifi.uio.no
-;;   (above email addresses invalid as of April 2008)
 ;; Adapted-By: ESR
 ;; Keywords: languages
 
diff --git a/lisp/progmodes/sql.el b/lisp/progmodes/sql.el
index 4ab174d92b..2d33b3130c 100644
--- a/lisp/progmodes/sql.el
+++ b/lisp/progmodes/sql.el
@@ -223,6 +223,7 @@
 ;; Simen Heggestøyl <simenheg@gmail.com> -- Postgres database completion
 ;; Robert Cochran <robert-emacs@cochranmail.com> -- MariaDB support
 ;; Alex Harsanyi <alexharsanyi@gmail.com> -- sql-indent package and support
+;; Roy Mathew <rmathew8@gmail.com> -- bug in `sql-send-string'
 ;;
 
 
@@ -442,6 +443,7 @@ file.  Since that is a plaintext file, this could be dangerous."
      :sqli-login sql-ms-login-params
      :sqli-comint-func sql-comint-ms
      :prompt-regexp "^[0-9]*>"
+     :prompt-cont-regexp "^[0-9]*>"
      :prompt-length 5
      :syntax-alist ((?@ . "_"))
      :terminator ("^go" . "go"))
@@ -477,7 +479,7 @@ file.  Since that is a plaintext file, this could be dangerous."
      :prompt-cont-regexp "^\\(?:[ ][ ][1-9]\\|[ ][1-9][0-9]\\|[1-9][0-9]\\{2\\}\\)[ ]\\{2\\}"
      :statement sql-oracle-statement-starters
      :syntax-alist ((?$ . "_") (?# . "_"))
-     :terminator ("\\(^/\\|;\\)$" . "/")
+     :terminator ("\\(^/\\|;\\)" . "/")
      :input-filter sql-placeholders-filter)
 
     (postgres
@@ -495,7 +497,7 @@ file.  Since that is a plaintext file, this could be dangerous."
      :prompt-length 5
      :prompt-cont-regexp "^[[:alnum:]_]*[-(][#>] "
      :input-filter sql-remove-tabs-filter
-     :terminator ("\\(^\\s-*\\\\g$\\|;\\)" . "\\g"))
+     :terminator ("\\(^\\s-*\\\\g\\|;\\)" . "\\g"))
 
     (solid
      :name "Solid"
@@ -520,8 +522,7 @@ file.  Since that is a plaintext file, this could be dangerous."
      :completion-object sql-sqlite-completion-object
      :prompt-regexp "^sqlite> "
      :prompt-length 8
-     :prompt-cont-regexp "^   \\.\\.\\.> "
-     :terminator ";")
+     :prompt-cont-regexp "^   \\.\\.\\.> ")
 
     (sybase
      :name "Sybase"
@@ -1219,6 +1220,11 @@ Starts `sql-interactive-mode' after doing some setup."
 
 ;; Customization for Microsoft
 
+;; Microsoft documentation seems to indicate that ISQL and OSQL are
+;; going away and being replaced by SQLCMD.  If anyone has experience
+;; using SQLCMD, modified product configuration and feedback on its
+;; use would be greatly appreciated.
+
 (defcustom sql-ms-program "osql"
   "Command to start osql by Microsoft.
 
@@ -1417,6 +1423,15 @@ specified, it's `sql-product' or `sql-connection' must match."
                     (and (stringp connection)
                          (string= connection sql-connection))))))))
 
+(defun sql-is-sqli-buffer-p (buffer)
+  "Return non-nil if buffer is a SQLi buffer."
+  (when buffer
+    (setq buffer (get-buffer buffer))
+    (and buffer
+         (buffer-live-p buffer)
+         (with-current-buffer buffer
+           (derived-mode-p 'sql-interactive-mode)))))
+
 ;; Keymap for sql-interactive-mode.
 
 (defvar sql-interactive-mode-map
@@ -3544,24 +3559,29 @@ server/database name."
   "Generate a new, unique buffer name for a SQLi buffer.
 
 Append a sequence number until a unique name is found."
-  (let ((base-name (when (stringp base)
-                     (substring-no-properties
-                      (or base
-                          (sql-get-product-feature product :name)
+  (let ((base-name (substring-no-properties
+                    (if base
+                        (if (stringp base)
+                            base
+                          (format "%S" base))
+                      (or (sql-get-product-feature product :name)
                           (symbol-name product)))))
-        buf-fmt-1st buf-fmt-rest)
+        buf-fmt-1st
+        buf-fmt-rest)
 
     ;; Calculate buffer format
-    (if base-name
-        (setq buf-fmt-1st  (format "*SQL: %s*" base-name)
-              buf-fmt-rest (format "*SQL: %s-%%d*" base-name))
-      (setq buf-fmt-1st  "*SQL*"
-            buf-fmt-rest "*SQL-%d*"))
+    (if (string-blank-p base-name)
+        (setq buf-fmt-1st  "*SQL*"
+              buf-fmt-rest "*SQL-%d*")
+      (setq buf-fmt-1st  (format "*SQL: %s*" base-name)
+            buf-fmt-rest (format "*SQL: %s-%%d*" base-name)))
 
     ;; See if we can find an unused buffer
     (let ((buf-name buf-fmt-1st)
           (i 1))
-      (while (sql-buffer-live-p buf-name)
+      (while (if (sql-is-sqli-buffer-p buf-name)
+                 (comint-check-proc buf-name)
+               (buffer-live-p (get-buffer buf-name)))
         ;; Check a sequence number on the BASE
         (setq buf-name (format buf-fmt-rest i)
               i (1+ i)))
@@ -3640,12 +3660,16 @@ Inserts SELECT or commas if appropriate."
 Placeholders are words starting with an ampersand like &this."
 
   (when sql-oracle-scan-on
-    (while (string-match "&?&\\(\\(?:\\sw\\|\\s_\\)+\\)[.]?" string)
-      (setq string (replace-match
-		    (read-from-minibuffer
-		     (format "Enter value for %s: " (match-string 1 string))
-		     nil nil nil 'sql-placeholder-history)
-		    t t string))))
+    (let ((start 0)
+          (replacement ""))
+      (while (string-match "&?&\\(\\(?:\\sw\\|\\s_\\)+\\)[.]?" string start)
+        (setq replacement (read-from-minibuffer
+		           (format "Enter value for %s: "
+                                   (propertize (match-string 1 string)
+                                               'face 'font-lock-variable-name-face))
+		           nil nil nil 'sql-placeholder-history)
+              string (replace-match replacement t t string)
+              start (+ (match-beginning 1) (length replacement))))))
   string)
 
 ;; Using DB2 interactively, newlines must be escaped with " \".
@@ -3742,7 +3766,8 @@ to avoid deleting non-prompt output."
              (or (> (length (or sql-preoutput-hold "")) 0)
                  (> (or sql-output-newline-count 0) 0)
                  (not (or (string-match sql-prompt-regexp oline)
-                          (string-match sql-prompt-cont-regexp oline)))))
+                          (and sql-prompt-cont-regexp
+                               (string-match sql-prompt-cont-regexp oline))))))
 
     (save-match-data
       (let (prompt-found last-nl)
@@ -3794,6 +3819,8 @@ to avoid deleting non-prompt output."
   oline)
 
 ;;; Sending the region to the SQLi buffer.
+(defvar sql-debug-send nil
+  "Display text sent to SQL process pragmatically.")
 
 (defun sql-send-string (str)
   "Send the string STR to the SQL process."
@@ -3807,12 +3834,14 @@ to avoid deleting non-prompt output."
 	  (save-excursion
 	    ;; Set product context
 	    (with-current-buffer sql-buffer
+              (when sql-debug-send
+                (message ">>SQL> %S" s))
+
 	      ;; Send the string (trim the trailing whitespace)
-	      (sql-input-sender (get-buffer-process sql-buffer) s)
+	      (sql-input-sender (get-buffer-process (current-buffer)) s)
 
 	      ;; Send a command terminator if we must
-	      (when sql-send-terminator
-		(sql-send-magic-terminator sql-buffer s sql-send-terminator))
+	      (sql-send-magic-terminator sql-buffer s sql-send-terminator)
 
               (when sql-pop-to-buffer-after-send-region
 	        (message "Sent string to buffer %s" sql-buffer))))
@@ -3874,12 +3903,8 @@ to avoid deleting non-prompt output."
 
     ;; Check to see if the pattern is present in the str already sent
     (unless (and pat term
-		 (string-match (concat pat "\\'") str))
-      (comint-simple-send (get-buffer-process buf) term)
-      (setq sql-output-newline-count
-            (if sql-output-newline-count
-                (1+ sql-output-newline-count)
-              1)))))
+		 (string-match-p (concat pat "\\'") str))
+      (sql-input-sender (get-buffer-process buf) term))))
 
 (defun sql-remove-tabs-filter (str)
   "Replace tab characters with spaces."
@@ -4390,12 +4415,12 @@ you entered, right above the output it created.
   ;; Set comint based on user overrides.
   (setq comint-prompt-regexp
         (if sql-prompt-cont-regexp
-            (concat "\\(" sql-prompt-regexp
-                    "\\|" sql-prompt-cont-regexp "\\)")
+            (concat "\\(?:\\(?:" sql-prompt-regexp "\\)"
+                    "\\|\\(?:" sql-prompt-cont-regexp "\\)\\)")
           sql-prompt-regexp))
   (setq left-margin (or sql-prompt-length 0))
   ;; Install input sender
-  (set (make-local-variable 'comint-input-sender) 'sql-input-sender)
+  (set (make-local-variable 'comint-input-sender) #'sql-input-sender)
   ;; People wanting a different history file for each
   ;; buffer/process/client/whatever can change separator and file-name
   ;; on the sql-interactive-mode-hook.
@@ -4659,13 +4684,13 @@ the call to \\[sql-product-interactive] with
                             (read-string
                              "Buffer name (\"*SQL: XXX*\"; enter `XXX'): "
                              (sql-make-alternate-buffer-name product))))
-                          ((or (string-prefix-p " " new-name)
-                               (string-match-p "\\`[*].*[*]\\'" new-name))
-                           new-name)
                           ((stringp new-name)
-                           (sql-generate-unique-sqli-buffer-name product new-name))
+                           (if (or (string-prefix-p " " new-name)
+                                   (string-match-p "\\`[*].*[*]\\'" new-name))
+                               new-name
+                             (sql-generate-unique-sqli-buffer-name product new-name)))
                           (t
-                           (sql-generate-unique-sqli-buffer-name product nil)))))
+                           (sql-generate-unique-sqli-buffer-name product new-name)))))
 
               ;; Set SQLi mode.
               (let ((sql-interactive-product product))
diff --git a/lisp/progmodes/tcl.el b/lisp/progmodes/tcl.el
index ffb3d41ab6..0fd3d6d1bf 100644
--- a/lisp/progmodes/tcl.el
+++ b/lisp/progmodes/tcl.el
@@ -2,9 +2,9 @@
 
 ;; Copyright (C) 1994, 1998-2019 Free Software Foundation, Inc.
 
-;; Maintainer: emacs-devel@gnu.org
 ;; Author: Tom Tromey <tromey@redhat.com>
 ;;    Chris Lindblad <cjl@lcs.mit.edu>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: languages tcl modes
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/progmodes/vera-mode.el b/lisp/progmodes/vera-mode.el
index a03556ee12..f34b21e4cf 100644
--- a/lisp/progmodes/vera-mode.el
+++ b/lisp/progmodes/vera-mode.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1997-2019 Free Software Foundation, Inc.
 
 ;; Author:      Reto Zimmermann <reto@gnu.org>
-;; Maintainer:  Reto Zimmermann <reto@gnu.org>
 ;; Version:     2.28
 ;; Keywords:    languages vera
 ;; WWW:         http://www.iis.ee.ethz.ch/~zimmi/emacs/vera-mode.html
diff --git a/lisp/progmodes/verilog-mode.el b/lisp/progmodes/verilog-mode.el
index e75e5845ef..eeed4c0d7c 100644
--- a/lisp/progmodes/verilog-mode.el
+++ b/lisp/progmodes/verilog-mode.el
@@ -121,7 +121,7 @@
 ;;
 
 ;; This variable will always hold the version number of the mode
-(defconst verilog-mode-version "2019-04-02-5d62d3f-vpo-GNU"
+(defconst verilog-mode-version "2019-05-06-28bee25-vpo-GNU"
   "Version of this Verilog mode.")
 (defconst verilog-mode-release-emacs t
   "If non-nil, this version of Verilog mode was released with Emacs itself.")
@@ -2760,13 +2760,13 @@ find the errors."
 (defconst verilog-delay-re "#\\s-*\\(\\([0-9_]+\\('s?[hdxbo][0-9a-fA-F_xz]+\\)?\\)\\|\\(([^()]*)\\)\\|\\(\\sw+\\)\\)")
 (defconst verilog-declaration-re-2-no-macro
   (concat "\\s-*" verilog-declaration-re
-	  "\\s-*\\(\\(" verilog-optional-signed-range-re "\\)\\|\\(" verilog-delay-re "\\)"
-	  "\\)"))
+          "\\s-*\\(\\(" verilog-optional-signed-range-re "\\)\\|\\(" verilog-delay-re "\\)"
+          "\\)"))
 (defconst verilog-declaration-re-2-macro
   (concat "\\s-*" verilog-declaration-re
-	  "\\s-*\\(\\(" verilog-optional-signed-range-re "\\)\\|\\(" verilog-delay-re "\\)"
-	  "\\|\\(" verilog-macroexp-re "\\)"
-	  "\\)"))
+          "\\s-*\\(\\(" verilog-optional-signed-range-re "\\)\\|\\(" verilog-delay-re "\\)"
+          "\\|\\(" verilog-macroexp-re "\\)"
+          "\\)"))
 (defconst verilog-declaration-re-1-macro
   (concat "^" verilog-declaration-re-2-macro))
 
@@ -8357,13 +8357,13 @@ Use optional HEADER and PREFIX."
   (when (looking-at ")")
     (verilog-backward-open-paren)
     (verilog-re-search-backward-quick "\\b[a-zA-Z0-9`_$]" nil nil))
-  (skip-chars-backward "a-zA-Z0-9'_$")
+  (skip-chars-backward "a-zA-Z0-9`_$")
   ;; #1 is legal syntax for gate primitives
   (when (save-excursion
-	  (verilog-backward-syntactic-ws-quick)
-	  (eq ?# (char-before)))
+          (verilog-backward-syntactic-ws-quick)
+          (eq ?# (char-before)))
     (verilog-re-search-backward-quick "\\b[a-zA-Z0-9`_$]" nil nil)
-    (skip-chars-backward "a-zA-Z0-9'_$"))
+    (skip-chars-backward "a-zA-Z0-9`_$"))
   (looking-at "[a-zA-Z0-9`_$]+")
   ;; Important: don't use match string, this must work with Emacs 19 font-lock on
   (buffer-substring-no-properties (match-beginning 0) (match-end 0))
@@ -11412,7 +11412,7 @@ If PAR-VALUES replace final strings with these parameter values."
     (when tpl-ass
       ;; Evaluate @"(lispcode)"
       (when (string-match "@\".*[^\\]\"" tpl-net)
-	(while (string-match "@\"\\(\\([^\\\"]\\|\\\\.\\)*\\)\"" tpl-net)
+        (while (string-match "@\"\\(\\([^\\\"]\\|\\\\.\\)*\\)\"" tpl-net)
 	  (setq tpl-net
 		(concat
 		 (substring tpl-net 0 (match-beginning 0))
diff --git a/lisp/progmodes/vhdl-mode.el b/lisp/progmodes/vhdl-mode.el
index 1dc0c61d06..13d0cfa67e 100644
--- a/lisp/progmodes/vhdl-mode.el
+++ b/lisp/progmodes/vhdl-mode.el
@@ -6699,7 +6699,7 @@ search, and an argument indicating an interactive call."
     (if (and interactive
 	     (or (nth 3 state)
 		 (nth 4 state)
-		 (looking-at (concat "[ \t]*" comment-start-skip))))
+		 (looking-at (concat "[ \t]*\\(?:" comment-start-skip "\\)"))))
 	(forward-sentence (- count))
       (while (> count 0)
 	(vhdl-beginning-of-statement-1 lim)
diff --git a/lisp/progmodes/xref.el b/lisp/progmodes/xref.el
index aed92f8db6..fde8464da2 100644
--- a/lisp/progmodes/xref.el
+++ b/lisp/progmodes/xref.el
@@ -448,6 +448,18 @@ If SELECT is non-nil, select the target window."
 (defconst xref-buffer-name "*xref*"
   "The name of the buffer to show xrefs.")
 
+(defface xref-file-header '((t :inherit compilation-info))
+  "Face used to highlight file header in the xref buffer."
+  :version "27.1")
+
+(defface xref-line-number '((t :inherit compilation-line-number))
+  "Face for displaying line numbers in the xref buffer."
+  :version "27.1")
+
+(defface xref-match '((t :inherit highlight))
+  "Face used to highlight matches in the xref buffer."
+  :version "27.1")
+
 (defmacro xref--with-dedicated-window (&rest body)
   `(let* ((xref-w (get-buffer-window xref-buffer-name))
           (xref-w-dedicated (window-dedicated-p xref-w)))
@@ -465,6 +477,9 @@ If SELECT is non-nil, select the target window."
 (defvar-local xref--original-window nil
   "The original window this xref buffer was created from.")
 
+(defvar-local xref--fetcher nil
+  "The original function to call to fetch the list of xrefs.")
+
 (defun xref--show-pos-in-buf (pos buf)
   "Goto and display position POS of buffer BUF in a window.
 Honor `xref--original-window-intent', run `xref-after-jump-hook'
@@ -680,6 +695,7 @@ references displayed in the current *xref* buffer."
     ;; suggested by Johan Claesson "to further reduce finger movement":
     (define-key map (kbd ".") #'xref-next-line)
     (define-key map (kbd ",") #'xref-prev-line)
+    (define-key map (kbd "g") #'xref-revert-buffer)
     map))
 
 (define-derived-mode xref--xref-buffer-mode special-mode "XREF"
@@ -719,7 +735,8 @@ references displayed in the current *xref* buffer."
   (interactive "e")
   (mouse-set-point event)
   (forward-line 0)
-  (xref--search-property 'xref-item)
+  (or (get-text-property (point) 'xref-item)
+      (xref--search-property 'xref-item))
   (xref-show-location-at-point))
 
 (defun xref--insert-xrefs (xref-alist)
@@ -737,18 +754,17 @@ GROUP is a string for decoration purposes and XREF is an
            for line-format = (and max-line-width
                                   (format "%%%dd: " max-line-width))
            do
-           (xref--insert-propertized '(face compilation-info) group "\n")
+           (xref--insert-propertized '(face xref-file-header) group "\n")
            (cl-loop for (xref . more2) on xrefs do
                     (with-slots (summary location) xref
                       (let* ((line (xref-location-line location))
                              (prefix
                               (if line
                                   (propertize (format line-format line)
-                                              'face 'compilation-line-number)
+                                              'face 'xref-line-number)
                                 "  ")))
                         (xref--insert-propertized
                          (list 'xref-item xref
-                               ;; 'face 'font-lock-keyword-face
                                'mouse-face 'highlight
                                'keymap xref--button-map
                                'help-echo
@@ -765,8 +781,13 @@ Return an alist of the form ((FILENAME . (XREF ...)) ...)."
                     (xref-location-group (xref-item-location x)))
                   #'equal))
 
-(defun xref--show-xref-buffer (xrefs alist)
-  (let ((xref-alist (xref--analyze xrefs)))
+(defun xref--show-xref-buffer (fetcher alist)
+  (cl-assert (functionp fetcher))
+  (let* ((xrefs
+          (or
+           (assoc-default 'fetched-xrefs alist)
+           (funcall fetcher)))
+         (xref-alist (xref--analyze xrefs)))
     (with-current-buffer (get-buffer-create xref-buffer-name)
       (setq buffer-undo-list nil)
       (let ((inhibit-read-only t)
@@ -778,35 +799,80 @@ Return an alist of the form ((FILENAME . (XREF ...)) ...)."
         (goto-char (point-min))
         (setq xref--original-window (assoc-default 'window alist)
               xref--original-window-intent (assoc-default 'display-action alist))
+        (setq xref--fetcher fetcher)
         (current-buffer)))))
 
-
-;; This part of the UI seems fairly uncontroversial: it reads the
-;; identifier and deals with the single definition case.
-;; (FIXME: do we really want this case to be handled like that in
-;; "find references" and "find regexp searches"?)
-;;
-;; The controversial multiple definitions case is handed off to
-;; xref-show-xrefs-function.
+(defun xref-revert-buffer ()
+  "Refresh the search results in the current buffer."
+  (interactive)
+  (let ((inhibit-read-only t)
+        (buffer-undo-list t))
+    (save-excursion
+      (erase-buffer)
+      (condition-case err
+          (xref--insert-xrefs
+           (xref--analyze (funcall xref--fetcher)))
+        (user-error
+         (insert
+          (propertize
+           (error-message-string err)
+           'face 'error))))
+      (goto-char (point-min)))))
+
+(defun xref--show-defs-buffer (fetcher alist)
+  (let ((xrefs (funcall fetcher)))
+    (cond
+     ((not (cdr xrefs))
+      (xref--pop-to-location (car xrefs)
+                             (assoc-default 'display-action alist)))
+     (t
+      (xref--show-xref-buffer fetcher
+                              (cons (cons 'fetched-xrefs xrefs)
+                                    alist))))))
 
+
 (defvar xref-show-xrefs-function 'xref--show-xref-buffer
-  "Function to display a list of xrefs.")
+  "Function to display a list of search results.
+
+It should accept two arguments: FETCHER and ALIST.
+
+FETCHER is a function of no arguments that returns a list of xref
+values.  It must not depend on the current buffer or selected
+window.
+
+ALIST can include, but limited to, the following keys:
+
+WINDOW for the window that was selected before the current
+command was called.
+
+DISPLAY-ACTION indicates where the target location should be
+displayed.  The possible values are nil, `window' meaning the
+other window, or `frame' meaning the other frame.")
+
+(defvar xref-show-definitions-function 'xref--show-defs-buffer
+  "Function to display a list of definitions.
+
+Accepts the same arguments as `xref-show-xrefs-function'.")
 
 (defvar xref--read-identifier-history nil)
 
 (defvar xref--read-pattern-history nil)
 
-(defun xref--show-xrefs (xrefs display-action &optional always-show-list)
+(defun xref--show-xrefs (fetcher display-action)
+  (xref--push-markers)
+  (funcall xref-show-xrefs-function fetcher
+           `((window . ,(selected-window))
+             (display-action . ,display-action))))
+
+(defun xref--show-defs (xrefs display-action)
+  (xref--push-markers)
+  (funcall xref-show-definitions-function xrefs
+           `((window . ,(selected-window))
+             (display-action . ,display-action))))
+
+(defun xref--push-markers ()
   (unless (region-active-p) (push-mark nil t))
-  (cond
-   ((and (not (cdr xrefs)) (not always-show-list))
-    (xref-push-marker-stack)
-    (xref--pop-to-location (car xrefs) display-action))
-   (t
-    (xref-push-marker-stack)
-    (funcall xref-show-xrefs-function xrefs
-             `((window . ,(selected-window))
-               (display-action . ,display-action))))))
+  (xref-push-marker-stack))
 
 (defun xref--prompt-p (command)
   (or (eq xref-prompt-for-identifier t)
@@ -817,34 +883,66 @@ Return an alist of the form ((FILENAME . (XREF ...)) ...)."
 (defun xref--read-identifier (prompt)
   "Return the identifier at point or read it from the minibuffer."
   (let* ((backend (xref-find-backend))
-         (id (xref-backend-identifier-at-point backend)))
+         (def (xref-backend-identifier-at-point backend)))
     (cond ((or current-prefix-arg
-               (not id)
+               (not def)
                (xref--prompt-p this-command))
-           (completing-read (if id
-                                (format "%s (default %s): "
-                                        (substring prompt 0 (string-match
-                                                             "[ :]+\\'" prompt))
-                                        id)
-                              prompt)
-                            (xref-backend-identifier-completion-table backend)
-                            nil nil nil
-                            'xref--read-identifier-history id))
-          (t id))))
+           (let ((id
+                  (completing-read
+                   (if def
+                       (format "%s (default %s): "
+                               (substring prompt 0 (string-match
+                                                    "[ :]+\\'" prompt))
+                               def)
+                     prompt)
+                   (xref-backend-identifier-completion-table backend)
+                   nil nil nil
+                   'xref--read-identifier-history def)))
+             (if (equal id "")
+                 (or def (user-error "There is no defailt identifier"))
+               id)))
+          (t def))))
 
 
 ;;; Commands
 
 (defun xref--find-xrefs (input kind arg display-action)
-  (let ((xrefs (funcall (intern (format "xref-backend-%s" kind))
-                        (xref-find-backend)
-                        arg)))
-    (unless xrefs
-      (user-error "No %s found for: %s" (symbol-name kind) input))
-    (xref--show-xrefs xrefs display-action)))
+  (xref--show-xrefs
+   (xref--create-fetcher input kind arg)
+   display-action))
 
 (defun xref--find-definitions (id display-action)
-  (xref--find-xrefs id 'definitions id display-action))
+  (xref--show-defs
+   (xref--create-fetcher id 'definitions id)
+   display-action))
+
+(defun xref--create-fetcher (input kind arg)
+  "Return an xref list fetcher function.
+
+It revisits the saved position and delegates the finding logic to
+the xref backend method indicated by KIND and passes ARG to it."
+  (let* ((orig-buffer (current-buffer))
+         (orig-position (point))
+         (backend (xref-find-backend))
+         (method (intern (format "xref-backend-%s" kind))))
+    (lambda ()
+      (save-excursion
+        ;; Xref methods are generally allowed to depend on the text
+        ;; around point, not just on their explicit arguments.
+        ;;
+        ;; There is only so much we can do, however, to recreate that
+        ;; context, given that the user is free to change the buffer
+        ;; contents freely in the meantime.
+        (when (buffer-live-p orig-buffer)
+          (set-buffer orig-buffer)
+          (ignore-errors (goto-char orig-position)))
+        (let ((xrefs (funcall method backend arg)))
+          (unless xrefs
+            (xref--not-found-error kind input))
+          xrefs)))))
+
+(defun xref--not-found-error (kind input)
+  (user-error "No %s found for: %s" (symbol-name kind) input))
 
 ;;;###autoload
 (defun xref-find-definitions (identifier)
@@ -1047,7 +1145,8 @@ IGNORES is a list of glob patterns."
 IGNORES is a list of glob patterns.  DIR is an absolute
 directory, used as the root of the ignore globs."
   (cl-assert (not (string-match-p "\\`~" dir)))
-  (when ignores
+  (if (not ignores)
+      ""
     (concat
      (shell-quote-argument "(")
      " -path "
@@ -1159,7 +1258,7 @@ Such as the current syntax table and the applied syntax properties."
              (end-column (- (match-end 0) line-beg))
              (loc (xref-make-file-location file line beg-column))
              (summary (buffer-substring line-beg line-end)))
-        (add-face-text-property beg-column end-column 'highlight
+        (add-face-text-property beg-column end-column 'xref-match
                                 t summary)
         (push (xref-make-match summary loc (- end-column beg-column))
               matches)))
diff --git a/lisp/ps-bdf.el b/lisp/ps-bdf.el
index be80b4a15b..2e75e53fc2 100644
--- a/lisp/ps-bdf.el
+++ b/lisp/ps-bdf.el
@@ -9,7 +9,7 @@
 ;;   National Institute of Advanced Industrial Science and Technology (AIST)
 ;;   Registration Number H13PRO009
 
-;; Author: Kenichi Handa <handa@m17n.org>
+;; Author: Kenichi Handa <handa@gnu.org>
 ;; (according to ack.texi)
 ;; Keywords: wp, BDF, font, PostScript
 ;; Package: ps-print
diff --git a/lisp/ps-def.el b/lisp/ps-def.el
index 2063133890..0f3b2f7fee 100644
--- a/lisp/ps-def.el
+++ b/lisp/ps-def.el
@@ -3,9 +3,7 @@
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;;	Kenichi Handa <handa@m17n.org> (multi-byte characters)
-;; Maintainer: Kenichi Handa <handa@m17n.org> (multi-byte characters)
-;;	Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
+;;	Kenichi Handa <handa@gnu.org> (multi-byte characters)
 ;; Keywords: wp, print, PostScript
 ;; X-URL: http://www.emacswiki.org/cgi-bin/wiki/ViniciusJoseLatorre
 ;; Package: ps-print
diff --git a/lisp/ps-mule.el b/lisp/ps-mule.el
index c88d6d2679..24604e9d5c 100644
--- a/lisp/ps-mule.el
+++ b/lisp/ps-mule.el
@@ -3,9 +3,7 @@
 ;; Copyright (C) 1998-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;;	Kenichi Handa <handa@m17n.org> (multi-byte characters)
-;; Maintainer: Kenichi Handa <handa@m17n.org> (multi-byte characters)
-;;	Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
+;;	Kenichi Handa <handa@gnu.org> (multi-byte characters)
 ;; Keywords: wp, print, PostScript, multibyte, mule
 ;; Package: ps-print
 
diff --git a/lisp/ps-print.el b/lisp/ps-print.el
index 647597cefa..994048d2b1 100644
--- a/lisp/ps-print.el
+++ b/lisp/ps-print.el
@@ -5,13 +5,14 @@
 ;; Author: Jim Thompson (was <thompson@wg2.waii.com>)
 ;;	Jacques Duthen (was <duthen@cegelec-red.fr>)
 ;;	Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;;	Kenichi Handa <handa@m17n.org> (multi-byte characters)
-;; Maintainer: Kenichi Handa <handa@m17n.org> (multi-byte characters)
-;;	Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
+;;	Kenichi Handa <handa@gnu.org> (multi-byte characters)
+;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, print, PostScript
 ;; Version: 7.3.5
 ;; X-URL: http://www.emacswiki.org/cgi-bin/wiki/ViniciusJoseLatorre
 
+(eval-when-compile (require 'cl-lib))
+
 (defconst ps-print-version "7.3.5"
   "ps-print.el, v 7.3.5 <2009/12/23 vinicius>
 
@@ -1403,7 +1404,7 @@ Please send all bug fixes and enhancements to
 ;; prologue code suggestion, for odd/even printing suggestion and for
 ;; `ps-prologue-file' enhancement.
 ;;
-;; Thanks to Ken'ichi Handa <handa@m17n.org> for multi-byte buffer handling.
+;; Thanks to Ken'ichi Handa <handa@gnu.org> for multi-byte buffer handling.
 ;;
 ;; Thanks to Matthew O Persico <Matthew.Persico@lazard.com> for line number on
 ;; empty columns.
@@ -4612,7 +4613,9 @@ page-height == ((floor print-height ((th + ls) * zh)) * ((th + ls) * zh)) - th
 (defsubst ps-output-string-prim (string)
   (insert "(")				;insert start-string delimiter
   (save-excursion			;insert string
-    (insert (string-as-unibyte string)))
+    (insert (if (multibyte-string-p string)
+                (encode-coding-string string 'utf-8)
+              string)))
   ;; Find and quote special characters as necessary for PS
   ;; This skips everything except control chars, non-ASCII chars, (, ) and \.
   (while (progn (skip-chars-forward " -'*-[]-~") (not (eobp)))
@@ -5770,9 +5773,9 @@ XSTART YSTART are the relative position for the first page in a sheet.")
 	ps-footer-font-size-internal (ps-get-font-size 'ps-footer-font-size)
 	ps-control-or-escape-regexp
 	(cond ((eq ps-print-control-characters '8-bit)
-	       (string-as-unibyte "[\000-\037\177-\377]"))
+	       "[\000-\037\177-\377]")
 	      ((eq ps-print-control-characters 'control-8-bit)
-	       (string-as-unibyte "[\000-\037\177-\237]"))
+	       "[\000-\037\177-\237]")
 	      ((eq ps-print-control-characters 'control)
 	       "[\000-\037\177]")
 	      (t "[\t\n\f]"))
@@ -5827,6 +5830,7 @@ XSTART YSTART are the relative position for the first page in a sheet.")
 	;; They may be overridden by ps-mule-begin-job.
 	ps-basic-plot-string-function    'ps-basic-plot-string
 	ps-encode-header-string-function nil)
+  (cl-assert (not (multibyte-string-p ps-control-or-escape-regexp)))
   ;; initialize page dimensions
   (ps-get-page-dimensions)
   ;; final check
diff --git a/lisp/ps-samp.el b/lisp/ps-samp.el
index 784b4356b4..1a2f7742d2 100644
--- a/lisp/ps-samp.el
+++ b/lisp/ps-samp.el
@@ -5,9 +5,8 @@
 ;; Author: Jim Thompson (was <thompson@wg2.waii.com>)
 ;;	Jacques Duthen (was <duthen@cegelec-red.fr>)
 ;;	Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;;	Kenichi Handa <handa@m17n.org> (multi-byte characters)
-;; Maintainer: Kenichi Handa <handa@m17n.org> (multi-byte characters)
-;;	Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
+;;	Kenichi Handa <handa@gnu.org> (multi-byte characters)
+;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: wp, print, PostScript
 ;; X-URL: http://www.emacswiki.org/cgi-bin/wiki/ViniciusJoseLatorre
 ;; Package: ps-print
diff --git a/lisp/recentf.el b/lisp/recentf.el
index 9b70017a38..4112b44e48 100644
--- a/lisp/recentf.el
+++ b/lisp/recentf.el
@@ -67,7 +67,8 @@ You should define the options of your own filters in this group."
 A nil value means to save the whole list.
 See the command `recentf-save-list'."
   :group 'recentf
-  :type 'integer)
+  :type '(choice (integer :tag "Entries" :value 1)
+		 (const :tag "No Limit" nil)))
 
 (defcustom recentf-save-file (locate-user-emacs-file "recentf" ".recentf")
   "File to save the recent list into."
diff --git a/lisp/rect.el b/lisp/rect.el
index 17907534ac..ecf6da1381 100644
--- a/lisp/rect.el
+++ b/lisp/rect.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1985, 1999-2019 Free Software Foundation, Inc.
 
-;; Maintainer: Didier Verna <didier@xemacs.org>
+;; Maintainer: Didier Verna <didier@didierverna.net>
 ;; Keywords: internal
 ;; Package: emacs
 
@@ -27,7 +27,7 @@
 ;; in the Emacs manual.
 
 ;; ### NOTE: this file was almost completely rewritten by Didier Verna
-;; <didier@xemacs.org> in July 1999.
+;; in July 1999.
 
 ;;; Code:
 
diff --git a/lisp/ruler-mode.el b/lisp/ruler-mode.el
index c5c88d03e0..093dd497dc 100644
--- a/lisp/ruler-mode.el
+++ b/lisp/ruler-mode.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 24 Mar 2001
 ;; Version: 1.6
 ;; Keywords: convenience
diff --git a/lisp/savehist.el b/lisp/savehist.el
index 1eab18ef76..79ab848386 100644
--- a/lisp/savehist.el
+++ b/lisp/savehist.el
@@ -1,8 +1,8 @@
-;;; savehist.el --- Save minibuffer history
+;;; savehist.el --- Save minibuffer history  -*- lexical-binding:t -*-
 
 ;; Copyright (C) 1997, 2005-2019 Free Software Foundation, Inc.
 
-;; Author: Hrvoje Niksic <hniksic@xemacs.org>
+;; Author: Hrvoje Nikšić <hrvoje.niksic@avl.com>
 ;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: minibuffer
 ;; Version: 24
@@ -62,8 +62,7 @@
   "If non-nil, save all recorded minibuffer histories.
 If you want to save only specific histories, use `savehist-save-hook'
 to modify the value of `savehist-minibuffer-history-variables'."
-  :type 'boolean
-  :group 'savehist)
+  :type 'boolean)
 
 (defcustom savehist-additional-variables ()
   "List of additional variables to save.
@@ -77,13 +76,11 @@ non-nil.
 User options should be saved with the Customize interface.  This
 list is useful for saving automatically updated variables that are not
 minibuffer histories, such as `compile-command' or `kill-ring'."
-  :type '(repeat variable)
-  :group 'savehist)
+  :type '(repeat variable))
 
 (defcustom savehist-ignored-variables nil ;; '(command-history)
   "List of additional variables not to save."
-  :type '(repeat variable)
-  :group 'savehist)
+  :type '(repeat variable))
 
 (defcustom savehist-file
   (locate-user-emacs-file "history" ".emacs-history")
@@ -95,8 +92,7 @@ for more details.
 If you want your minibuffer history shared between Emacs and XEmacs,
 customize this value and make sure that `savehist-coding-system' is
 set to a coding system that exists in both emacsen."
-  :type 'file
-  :group 'savehist)
+  :type 'file)
 
 (defcustom savehist-file-modes #o600
   "Default permissions of the history file.
@@ -104,27 +100,23 @@ This is decimal, not octal.  The default is 384 (0600 in octal).
 Set to nil to use the default permissions that Emacs uses, typically
 mandated by umask.  The default is a bit more restrictive to protect
 the user's privacy."
-  :type 'integer
-  :group 'savehist)
+  :type 'integer)
 
 (defcustom savehist-autosave-interval (* 5 60)
   "The interval between autosaves of minibuffer history.
 If set to nil, disables timer-based autosaving."
   :type '(choice (const :tag "Disabled" nil)
-                 (integer :tag "Seconds"))
-  :group 'savehist)
+                 (integer :tag "Seconds")))
 
 (defcustom savehist-mode-hook nil
   "Hook called when Savehist mode is turned on."
-  :type 'hook
-  :group 'savehist)
+  :type 'hook)
 
 (defcustom savehist-save-hook nil
   "Hook called by `savehist-save' before saving the variables.
 You can use this hook to influence choice and content of variables
 to save."
-  :type 'hook
-  :group 'savehist)
+  :type 'hook)
 
 ;; This should be capable of representing characters used by Emacs.
 ;; We prefer UTF-8 over ISO 2022 because it is well-known outside
@@ -150,12 +142,6 @@ The contents of this variable is built while Emacs is running, and saved
 along with minibuffer history.  You can change its value off
 `savehist-save-hook' to influence which variables are saved.")
 
-(defconst savehist-no-conversion (if (featurep 'xemacs) 'binary 'no-conversion)
-  "Coding system without any conversion.
-This is used for calculating an internal checksum.  Should be as fast
-as possible, ideally simply exposing the internal representation of
-buffer text.")
-
 (defvar savehist-loaded nil
   "Whether the history has already been loaded.
 This prevents toggling Savehist mode from destroying existing
@@ -223,8 +209,8 @@ histories, which is probably undesirable."
 Normally invoked by calling `savehist-mode' to set the minor mode.
 Installs `savehist-autosave' in `kill-emacs-hook' and on a timer.
 To undo this, call `savehist-uninstall'."
-  (add-hook 'minibuffer-setup-hook 'savehist-minibuffer-hook)
-  (add-hook 'kill-emacs-hook 'savehist-autosave)
+  (add-hook 'minibuffer-setup-hook #'savehist-minibuffer-hook)
+  (add-hook 'kill-emacs-hook #'savehist-autosave)
   ;; Install an invocation of savehist-autosave on a timer.  This
   ;; should not cause noticeable delays for users -- savehist-autosave
   ;; executes in under 5 ms on my system.
@@ -233,16 +219,16 @@ To undo this, call `savehist-uninstall'."
     (setq savehist-timer
 	  (if (featurep 'xemacs)
 	      (start-itimer
-	       "savehist" 'savehist-autosave savehist-autosave-interval
+	       "savehist" #'savehist-autosave savehist-autosave-interval
 	       savehist-autosave-interval)
 	    (run-with-timer savehist-autosave-interval
-			    savehist-autosave-interval 'savehist-autosave)))))
+			    savehist-autosave-interval #'savehist-autosave)))))
 
 (defun savehist-uninstall ()
   "Undo installing savehist.
 Normally invoked by calling `savehist-mode' to unset the minor mode."
-  (remove-hook 'minibuffer-setup-hook 'savehist-minibuffer-hook)
-  (remove-hook 'kill-emacs-hook 'savehist-autosave)
+  (remove-hook 'minibuffer-setup-hook #'savehist-minibuffer-hook)
+  (remove-hook 'kill-emacs-hook #'savehist-autosave)
   (when savehist-timer
     (if (featurep 'xemacs)
 	(delete-itimer savehist-timer)
@@ -327,7 +313,7 @@ If AUTO-SAVE is non-nil, compare the saved contents to the one last saved,
 	      (insert ?\n))))))
     ;; If autosaving, avoid writing if nothing has changed since the
     ;; last write.
-    (let ((checksum (md5 (current-buffer) nil nil savehist-no-conversion)))
+    (let ((checksum (md5 (current-buffer) nil nil savehist-coding-system)))
       (unless (and auto-save (equal checksum savehist-last-checksum))
 	;; Set file-precious-flag when saving the buffer because we
 	;; don't want a half-finished write ruining the entire
diff --git a/lisp/select.el b/lisp/select.el
index c79e923b74..af6bf467e4 100644
--- a/lisp/select.el
+++ b/lisp/select.el
@@ -309,6 +309,10 @@ the formats available in the clipboard if TYPE is `CLIPBOARD'."
                           (_ (error "Unknown selection data type: %S"
                                     type))))))
         (setq data (if coding (decode-coding-string data coding)
+                     ;; This is for C_STRING case.
+                     ;; We want to convert each non-ASCII byte to the
+                     ;; corresponding eight-bit character, which has
+                     ;; a codepoint >= #x3FFF00.
                      (string-to-multibyte data))))
       (setq next-selection-coding-system nil)
       (put-text-property 0 (length data) 'foreign-selection data-type data))
@@ -472,6 +476,9 @@ two markers or an overlay.  Otherwise, it is nil."
 	    (setq str (encode-coding-string str coding)))
 
 	   ((eq type 'C_STRING)
+            ;; If STR is unibyte (the normal case), use it; otherwise
+            ;; we assume some of the characters are eight-bit, and
+            ;; take their lower 8 bits.
 	    (setq str (string-make-unibyte str)))
 
 	   (t
diff --git a/lisp/server.el b/lisp/server.el
index c38fdf8483..436a44a7e9 100644
--- a/lisp/server.el
+++ b/lisp/server.el
@@ -96,7 +96,6 @@
              (unless load-in-progress
                (message "Local sockets unsupported, using TCP sockets")))
            (set-default sym val))
-  :group 'server
   :type 'boolean
   :version "22.1")
 
@@ -108,7 +107,6 @@ DO NOT give this a non-nil value unless you know what you are doing!
 On unsecured networks, accepting remote connections is very dangerous,
 because server-client communication (including session authentication)
 is not encrypted."
-  :group 'server
   :type '(choice
           (string :tag "Name or IP address")
           (const :tag "Local" nil))
@@ -121,7 +119,6 @@ is not encrypted."
 This variable only takes effect when the Emacs server is using
 TCP instead of local sockets.  A nil value means to use a random
 port number."
-  :group 'server
   :type '(choice
           (string :tag "Port number")
           (const :tag "Random" nil))
@@ -138,7 +135,6 @@ NOTE: On FAT32 filesystems, directories are not secure;
 files can be read and modified by any user or process.
 It is strongly suggested to set `server-auth-dir' to a
 directory residing in a NTFS partition instead."
-  :group 'server
   :type 'directory
   :version "22.1")
 ;;;###autoload
@@ -166,7 +162,6 @@ communications are unencrypted, still apply.
 The key must consist of 64 ASCII printable characters except for
 space (this means characters from ! to ~; or from code 33 to
 126).  You can use \\[server-generate-key] to get a random key."
-  :group 'server
   :type '(choice
 	  (const :tag "Random" nil)
 	  (string :tag "Password"))
@@ -174,30 +169,25 @@ space (this means characters from ! to ~; or from code 33 to
 
 (defcustom server-raise-frame t
   "If non-nil, raise frame when switching to a buffer."
-  :group 'server
   :type 'boolean
   :version "22.1")
 
 (defcustom server-visit-hook nil
   "Hook run when visiting a file for the Emacs server."
-  :group 'server
   :type 'hook)
 
 (defcustom server-switch-hook nil
   "Hook run when switching to a buffer for the Emacs server."
-  :group 'server
   :type 'hook)
 
 (defcustom server-after-make-frame-hook nil
   "Hook run when the Emacs server creates a client frame.
 The created frame is selected when the hook is called."
-  :group 'server
   :type 'hook
   :version "27.1")
 
 (defcustom server-done-hook nil
   "Hook run when done editing a buffer for the Emacs server."
-  :group 'server
   :type 'hook)
 
 (defvar server-process nil
@@ -223,7 +213,6 @@ If it is a frame, use the frame's selected window.
 
 It is not meaningful to set this to a specific frame or window with Custom.
 Only programs can do so."
-  :group 'server
   :version "22.1"
   :type '(choice (const :tag "Use selected window"
 			:match (lambda (widget value)
@@ -233,11 +222,10 @@ Only programs can do so."
 		 (function-item :tag "Use pop-to-buffer" pop-to-buffer)
 		 (function :tag "Other function")))
 
-(defcustom server-temp-file-regexp "^/tmp/Re\\|/draft$"
+(defcustom server-temp-file-regexp "\\`/tmp/Re\\|/draft\\'"
   "Regexp matching names of temporary files.
 These are deleted and reused after each edit by the programs that
 invoke the Emacs server."
-  :group 'server
   :type 'regexp)
 
 (defcustom server-kill-new-buffers t
@@ -248,7 +236,6 @@ it with the Emacs server.  If nil, kill only buffers as specified by
 Please note that only buffers that still have a client are killed,
 i.e. buffers visited with \"emacsclient --no-wait\" are never killed
 in this way."
-  :group 'server
   :type 'boolean
   :version "21.1")
 
@@ -278,7 +265,6 @@ If this is an absolute file name, it specifies where the socket
 file will be created.  To have emacsclient connect to the same
 socket, use the \"-s\" switch for local non-TCP sockets, and
 the \"-f\" switch otherwise."
-  :group 'server
   :type 'string
   :version "23.1")
 
@@ -381,7 +367,7 @@ Updates `server-clients'."
 
       (server-log "Deleted" proc))))
 
-(defvar server-log-time-function 'current-time-string
+(defvar server-log-time-function #'current-time-string
   "Function to generate timestamps for `server-buffer'.")
 
 (defconst server-buffer " *server*"
@@ -549,6 +535,16 @@ Creates the directory if necessary and makes sure:
       (cl-letf (((default-file-modes) ?\700)) (make-directory dir t))
       (setq attrs (file-attributes dir 'integer)))
 
+    (let ((olddir (or (getenv "TMPDIR") "/tmp")))
+      (when (and (equal dir (format "%s/emacs" (getenv "XDG_RUNTIME_DIR")))
+                 (file-writable-p olddir))
+        (let ((link (format "%s/emacs%d" olddir (user-uid))))
+          (unless (file-directory-p link)
+            ;; We're using the new location, so try and setup a symlink from
+            ;; the old location, in case we want to use an old emacsclient.
+            ;; FIXME: Check that it's safe to use!
+            (make-symbolic-link dir link t)))))
+
     ;; Check that it's safe for use.
     (let* ((uid (file-attribute-user-id attrs))
 	   (w32 (eq system-type 'windows-nt))
@@ -684,16 +680,16 @@ server or call `\\[server-force-delete]' to forcibly disconnect it."))
 	(when server-process
 	  (server-log (message "Restarting server")))
 	(cl-letf (((default-file-modes) ?\700))
-	  (add-hook 'suspend-tty-functions 'server-handle-suspend-tty)
-	  (add-hook 'delete-frame-functions 'server-handle-delete-frame)
+	  (add-hook 'suspend-tty-functions #'server-handle-suspend-tty)
+	  (add-hook 'delete-frame-functions #'server-handle-delete-frame)
 	  (add-hook 'kill-emacs-query-functions
-                    'server-kill-emacs-query-function)
+                    #'server-kill-emacs-query-function)
           ;; We put server's kill-emacs-hook after the others, so that
           ;; frames are not deleted too early, because doing that
           ;; would severely degrade our abilities to communicate with
           ;; the user, while some hooks may wish to ask the user
           ;; questions (e.g., desktop-kill).
-	  (add-hook 'kill-emacs-hook 'server-force-stop t) ;Cleanup upon exit.
+	  (add-hook 'kill-emacs-hook #'server-force-stop t) ;Cleanup upon exit.
 	  (setq server-process
 		(apply #'make-network-process
 		       :name server-name
@@ -792,7 +788,6 @@ Server mode runs a process that accepts commands from the
 `emacsclient' program.  See Info node `Emacs server' and
 `server-start' for details."
   :global t
-  :group 'server
   :version "22.1"
   ;; Fixme: Should this check for an existing server socket and do
   ;; nothing if there is one (for multiple Emacs sessions)?
@@ -807,7 +802,7 @@ Server mode runs a process that accepts commands from the
   ;; intended it to interrupt us rather than interrupt whatever Emacs
   ;; was doing before it started handling the process filter.
   ;; Hence `with-local-quit' (bug#6585).
-  (let ((v (with-local-quit (eval (car (read-from-string expr))))))
+  (let ((v (with-local-quit (eval (car (read-from-string expr)) t))))
     (when proc
       (with-temp-buffer
         (let ((standard-output (current-buffer)))
@@ -1118,7 +1113,7 @@ The following commands are accepted by the client:
 	    ;; Remove this line from STRING.
 	    (setq string (substring string (match-end 0)))
 	    (setq args-left
-		  (mapcar 'server-unquote-arg (split-string request " " t)))
+		  (mapcar #'server-unquote-arg (split-string request " " t)))
 	    (while args-left
               (pcase (pop args-left)
                 ;; -version CLIENT-VERSION: obsolete at birth.
@@ -1329,7 +1324,7 @@ The following commands are accepted by the client:
                                                (find-file-noselect initial-buffer-choice))
                                               ((functionp initial-buffer-choice)
                                                (funcall initial-buffer-choice)))))
-                                   (if (buffer-live-p buf) buf (get-buffer-create "*scratch*")))))
+                                   (if (buffer-live-p buf) buf (startup--get-buffer-create-scratch)))))
                ;; Set current buffer so that newly created tty frames
                ;; show the correct buffer initially.
                (frame (with-current-buffer (or (car buffers)
@@ -1341,7 +1336,7 @@ The following commands are accepted by the client:
                           (when initial-buffer
                             (switch-to-buffer initial-buffer 'norecord))))))
 
-          (mapc 'funcall (nreverse commands))
+          (mapc #'funcall (nreverse commands))
 
           ;; Delete the client if necessary.
           (cond
@@ -1441,7 +1436,7 @@ so don't mark these buffers specially, just visit them normally."
 	  (run-hooks 'post-command-hook))
 	(unless nowait
 	  ;; When the buffer is killed, inform the clients.
-	  (add-hook 'kill-buffer-hook 'server-kill-buffer nil t)
+	  (add-hook 'kill-buffer-hook #'server-kill-buffer nil t)
 	  (push proc server-buffer-clients))
 	(push (current-buffer) client-record)))
     (unless nowait
@@ -1552,8 +1547,8 @@ specifically for the clients and did not exist before their request for it."
   "Ask before exiting Emacs if it has live clients."
   (or (not (let (live-client)
              (dolist (proc server-clients)
-               (when (memq t (mapcar 'buffer-live-p (process-get
-                                                     proc 'buffers)))
+               (when (memq t (mapcar #'buffer-live-p
+                                     (process-get proc 'buffers)))
                  (setq live-client t)))
              live-client))
       (yes-or-no-p "This Emacs session has clients; exit anyway? ")))
@@ -1589,7 +1584,7 @@ starts server process and that is all.  Invoked by \\[server-edit]."
 	(not server-process)
 	(memq (process-status server-process) '(signal exit)))
     (server-mode 1))
-   (server-clients (apply 'server-switch-buffer (server-done)))
+   (server-clients (apply #'server-switch-buffer (server-done)))
    (t (message "No server editing buffers exist"))))
 
 (defun server-switch-buffer (&optional next-buffer killed-one filepos)
@@ -1622,7 +1617,7 @@ be a cons cell (LINENUMBER . COLUMNNUMBER)."
     (if (not (buffer-live-p next-buffer))
 	;; If NEXT-BUFFER is a dead buffer, remove the server records for it
 	;; and try the next surviving server buffer.
-	(apply 'server-switch-buffer (server-buffer-done next-buffer))
+	(apply #'server-switch-buffer (server-buffer-done next-buffer))
       ;; OK, we know next-buffer is live, let's display and select it.
       (if (functionp server-window)
 	  (funcall server-window next-buffer)
@@ -1655,7 +1650,14 @@ be a cons cell (LINENUMBER . COLUMNNUMBER)."
 			      (frame-terminal))))
 		'nomini 'visible (selected-window))))
 	    (condition-case nil
-		(switch-to-buffer next-buffer)
+                ;; If the client specified a new buffer position,
+                ;; treat that as an explicit point-move command, and
+                ;; override switch-to-buffer-preserve-window-point.
+                (let ((switch-to-buffer-preserve-window-point
+                       (if filepos
+                           nil
+                         switch-to-buffer-preserve-window-point)))
+                  (switch-to-buffer next-buffer))
 	      ;; After all the above, we might still have ended up with
 	      ;; a minibuffer/dedicated-window (if there's no other).
 	      (error (pop-to-buffer next-buffer)))))))
@@ -1701,7 +1703,7 @@ only these files will be asked to be saved."
   (save-current-buffer
     (dolist (buffer (buffer-list))
       (set-buffer buffer)
-      (remove-hook 'kill-buffer-hook 'server-kill-buffer t)))
+      (remove-hook 'kill-buffer-hook #'server-kill-buffer t)))
   ;; continue standard unloading
   nil)
 
diff --git a/lisp/ses.el b/lisp/ses.el
index 73157d6f5f..7fdacc77c9 100644
--- a/lisp/ses.el
+++ b/lisp/ses.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 2002-2019 Free Software Foundation, Inc.
 
 ;; Author: Jonathan Yavner <jyavner@member.fsf.org>
-;; Maintainer: Vincent Belaïche  <vincentb1@users.sourceforge.net>
+;; Maintainer: Vincent Belaïche <vincentb1@users.sourceforge.net>
 ;; Keywords: spreadsheet Dijkstra
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/simple.el b/lisp/simple.el
index 37f92540dd..6bc3bc5304 100644
--- a/lisp/simple.el
+++ b/lisp/simple.el
@@ -110,9 +110,9 @@ If non-nil, the value is passed directly to `recenter'."
   :type 'hook
   :group 'next-error)
 
-(defcustom next-error-verbosity nil
-  "If nil, `next-error' always outputs the current error buffer.
-If non-nil, the message is output only when the error buffer
+(defcustom next-error-verbose t
+  "If non-nil, `next-error' always outputs the current error buffer.
+If nil, the message is output only when the error buffer
 changes."
   :group 'next-error
   :type 'boolean
@@ -323,7 +323,7 @@ To control which errors are matched, customize the variable
         (funcall next-error-function (prefix-numeric-value arg) reset)
         (let ((prev next-error-last-buffer))
           (next-error-found buffer (current-buffer))
-          (when (or (not next-error-verbosity)
+          (when (or next-error-verbose
                     (not (eq prev next-error-last-buffer)))
             (message "%s locus from %s"
                      (cond (reset                             "First")
@@ -339,7 +339,7 @@ To control which errors are matched, customize the variable
     (funcall next-error-function 0 nil)
     (let ((prev next-error-last-buffer))
       (next-error-found buffer (current-buffer))
-      (when (or (not next-error-verbosity)
+      (when (or next-error-verbose
                 (not (eq prev next-error-last-buffer)))
         (message "Current locus from %s" next-error-last-buffer)))))
 
@@ -1646,12 +1646,14 @@ this command arranges for all errors to enter the debugger."
          (eval-expression-get-print-arguments current-prefix-arg)))
 
   (if (null eval-expression-debug-on-error)
-      (push (eval (macroexpand-all exp) lexical-binding) values)
+      (push (eval (let ((lexical-binding t)) (macroexpand-all exp)) t)
+            values)
     (let ((old-value (make-symbol "t")) new-value)
       ;; Bind debug-on-error to something unique so that we can
       ;; detect when evalled code changes it.
       (let ((debug-on-error old-value))
-	(push (eval (macroexpand-all exp) lexical-binding) values)
+	(push (eval (let ((lexical-binding t)) (macroexpand-all exp)) t)
+              values)
 	(setq new-value debug-on-error))
       ;; If evalled code has changed the value of debug-on-error,
       ;; propagate that change to the global binding.
@@ -2438,6 +2440,28 @@ Go to the history element by the absolute history position HIST-POS."
   (goto-history-element hist-pos))
 
 
+(add-hook 'minibuffer-setup-hook 'minibuffer-error-initialize)
+
+(defun minibuffer-error-initialize ()
+  "Set up minibuffer error processing."
+  (setq-local command-error-function 'minibuffer-error-function))
+
+(defun minibuffer-error-function (data context caller)
+  "Display error messages in the active minibuffer.
+The same as `command-error-default-function' but display error messages
+at the end of the minibuffer using `minibuffer-message' to not obscure
+the minibuffer contents."
+  (discard-input)
+  (ding)
+  (let ((string (error-message-string data)))
+    ;; If we know from where the error was signaled, show it in
+    ;; *Messages*.
+    (let ((inhibit-message t))
+      (message "%s%s" (if caller (format "%s: " caller) "") string))
+    ;; Display an error message at the end of the minibuffer.
+    (minibuffer-message (concat context string))))
+
+
 ;Put this on C-x u, so we can force that rather than C-_ into startup msg
 (define-obsolete-function-alias 'advertised-undo 'undo "23.2")
 
@@ -3351,6 +3375,16 @@ is output."
   :group 'shell
   :version "26.1")
 
+(defcustom async-shell-command-width nil
+  "Number of display columns available for asynchronous shell command output.
+If nil, use the shell default number (usually 80 columns).
+If a positive integer, tell the shell to use that number of columns for
+command output."
+  :type '(choice (const :tag "Use system limit" nil)
+                 (integer :tag "Fixed width" :value 80))
+  :group 'shell
+  :version "27.1")
+
 (defcustom shell-command-dont-erase-buffer nil
   "If non-nil, output buffer is not erased between shell commands.
 Also, a non-nil value sets the point in the output buffer
@@ -3614,8 +3648,13 @@ impose the use of a shell (with its need to quote arguments)."
 		(with-current-buffer buffer
                   (shell-command--save-pos-or-erase)
 		  (setq default-directory directory)
-                  (setq proc
-                        (start-process-shell-command "Shell" buffer command))
+		  (let ((process-environment
+			 (if (natnump async-shell-command-width)
+			     (cons (format "COLUMNS=%d" async-shell-command-width)
+				   process-environment)
+			   process-environment)))
+		    (setq proc
+			  (start-process-shell-command "Shell" buffer command)))
 		  (setq mode-line-process '(":%s"))
 		  (require 'shell) (shell-mode)
                   (set-process-sentinel proc #'shell-command-sentinel)
@@ -5595,7 +5634,7 @@ see `region-noncontiguous-p' and `extract-rectangle-bounds'."
   "Return non-nil if the region contains several pieces.
 An example is a rectangular region handled as a list of
 separate contiguous regions for each line."
-  (> (length (region-bounds)) 1))
+  (cdr (region-bounds)))
 
 (defvar redisplay-unhighlight-region-function
   (lambda (rol) (when (overlayp rol) (delete-overlay rol))))
diff --git a/lisp/speedbar.el b/lisp/speedbar.el
index 4823e4ba56..451c57fe06 100644
--- a/lisp/speedbar.el
+++ b/lisp/speedbar.el
@@ -341,7 +341,7 @@ attached to and added to this list before the new frame is initialized."
 		       (symbol :tag "Parameter")
 		       (sexp :tag "Value"))))
 
-;; These values by Hrvoje Niksic <hniksic@srce.hr>
+;; These values by Hrvoje Nikšić <hrvoje.niksic@avl.com>
 (defcustom speedbar-frame-plist
   '(minibuffer nil width 20 border-width 0
 	       internal-border-width 0 unsplittable t
diff --git a/lisp/startup.el b/lisp/startup.el
index a9b58c5e01..90046389d1 100644
--- a/lisp/startup.el
+++ b/lisp/startup.el
@@ -1,4 +1,4 @@
-;;; startup.el --- process Emacs shell arguments  -*- lexical-binding: t -*-
+;; startup.el --- process Emacs shell arguments  -*- lexical-binding: t -*-
 
 ;; Copyright (C) 1985-1986, 1992, 1994-2019 Free Software Foundation,
 ;; Inc.
@@ -971,6 +971,15 @@ the `--debug-init' option to view a complete error backtrace."
     (when debug-on-error-should-be-set
       (setq debug-on-error debug-on-error-from-init-file))))
 
+(defun find-init-path (fn)
+  "Look in ~/.config/FOO or ~/.FOO for the dotfile or dot directory FOO.
+It is expected that the output will undergo ~ expansion.  Implements the
+XDG convention for dotfiles."
+  (let* ((xdg-path (concat "~" init-file-user "/.config/" fn))
+        (oldstyle-path (concat "~" init-file-user "/." fn))
+        (found-path (if (file-exists-p xdg-path) xdg-path oldstyle-path)))
+    found-path))
+
 (defun command-line ()
   "A subroutine of `normal-top-level'.
 Amongst another things, it parses the command-line arguments."
@@ -1172,7 +1181,7 @@ please check its value")
       ;; "early-init" without an extension, as it does for ".emacs".
       "early-init.el"
       (file-name-as-directory
-       (concat "~" init-file-user "/.emacs.d")))))
+       (find-init-path "emacs.d")))))
   (setq early-init-file user-init-file)
 
   ;; If any package directory exists, initialize the package system.
@@ -1313,7 +1322,7 @@ please check its value")
         ((eq system-type 'ms-dos)
          (concat "~" init-file-user "/_emacs"))
         ((not (eq system-type 'windows-nt))
-         (concat "~" init-file-user "/.emacs"))
+         (find-init-path "emacs"))
         ;; Else deal with the Windows situation.
         ((directory-files "~" nil "^\\.emacs\\(\\.elc?\\)?$")
          ;; Prefer .emacs on Windows.
@@ -1331,7 +1340,7 @@ please check its value")
        (expand-file-name
         "init"
         (file-name-as-directory
-         (concat "~" init-file-user "/.emacs.d"))))
+         (find-init-path "emacs.d"))))
      (not inhibit-default-init))
 
     (when (and deactivate-mark transient-mark-mode)
@@ -1378,7 +1387,8 @@ please check its value")
   (if (get-buffer "*scratch*")
       (with-current-buffer "*scratch*"
 	(if (eq major-mode 'fundamental-mode)
-	    (funcall initial-major-mode))))
+	    (funcall initial-major-mode))
+        (setq-local lexical-binding t)))
 
   ;; Load library for our terminal type.
   ;; User init file can set term-file-prefix to nil to prevent this.
@@ -2124,7 +2134,7 @@ If you have no Meta key, you may instead type ESC followed by the character.)"))
   (insert "\t\t")
   (insert-button "Open *scratch* buffer"
 		 'action (lambda (_button) (switch-to-buffer
-                                       (get-buffer-create "*scratch*")))
+                                       (startup--get-buffer-create-scratch)))
 		 'follow-link t)
   (insert "\n")
   (insert "\n" (emacs-version) "\n" emacs-copyright "\n")
@@ -2250,6 +2260,13 @@ A fancy display is used on graphic displays, normal otherwise."
 (defalias 'about-emacs 'display-about-screen)
 (defalias 'display-splash-screen 'display-startup-screen)
 
+(defun startup--get-buffer-create-scratch ()
+  (or (get-buffer "*scratch*")
+      (with-current-buffer (get-buffer-create "*scratch*")
+        (set-buffer-major-mode (current-buffer))
+        (setq-local lexical-binding t)
+        (current-buffer))))
+
 (defun command-line-1 (args-left)
   "A subroutine of `command-line'."
   (display-startup-echo-area-message)
@@ -2399,7 +2416,7 @@ nil default-directory" name)
                        (unless (= end (length str-expr))
                          (error "Trailing garbage following expression: %s"
                                 (substring str-expr end)))
-                       (eval expr)))
+                       (eval expr t)))
 
                     ((member argi '("-L" "-directory"))
                      ;; -L :/foo adds /foo to the _end_ of load-path.
@@ -2514,7 +2531,7 @@ nil default-directory" name)
     (when (eq initial-buffer-choice t)
       ;; When `initial-buffer-choice' equals t make sure that *scratch*
       ;; exists.
-      (get-buffer-create "*scratch*"))
+      (startup--get-buffer-create-scratch))
 
     ;; If *scratch* exists and is empty, insert initial-scratch-message.
     ;; Do this before switching to *scratch* below to handle bug#9605.
@@ -2538,7 +2555,7 @@ nil default-directory" name)
 		   ((functionp initial-buffer-choice)
 		    (funcall initial-buffer-choice))
                    ((eq initial-buffer-choice t)
-                    (get-buffer-create "*scratch*"))
+                    (startup--get-buffer-create-scratch))
                    (t
                     (error "`initial-buffer-choice' must be a string, a function, or t")))))
         (unless (buffer-live-p buf)
diff --git a/lisp/strokes.el b/lisp/strokes.el
index 9265b8a52e..0c671c43ac 100644
--- a/lisp/strokes.el
+++ b/lisp/strokes.el
@@ -155,7 +155,7 @@
 ;; Euna Kim for her help in Korean, and massive thanks to the helpful
 ;; guys on the help instance on athena (zeno, jered, amu, gsstark,
 ;; ghudson, etc) Special thanks to Steve Baur, Kyle Jones, and Hrvoje
-;; Niksic for all their help.  And special thanks to Dave Gillespie
+;; Nikšić for all their help.  And special thanks to Dave Gillespie
 ;; for all the elisp help--he is responsible for helping me use the cl
 ;; macros at (near) max speed.
 
diff --git a/lisp/subr.el b/lisp/subr.el
index bf3716bbd3..73031a2a9f 100644
--- a/lisp/subr.el
+++ b/lisp/subr.el
@@ -580,6 +580,7 @@ i.e., subtract 2 * most-negative-fixnum from VALUE before shifting it."
 If LIST is nil, return nil.
 If N is non-nil, return the Nth-to-last link of LIST.
 If N is bigger than the length of LIST, return LIST."
+  (declare (side-effect-free t))
   (if n
       (and (>= n 0)
            (let ((m (safe-length list)))
@@ -591,6 +592,7 @@ If N is bigger than the length of LIST, return LIST."
   "Return a copy of LIST with the last N elements removed.
 If N is omitted or nil, the last element is removed from the
 copy."
+  (declare (side-effect-free t))
   (if (and n (<= n 0)) list
     (nbutlast (copy-sequence list) n)))
 
@@ -726,6 +728,7 @@ If that is non-nil, the element matches; then `assoc-default'
 
 If no element matches, the value is nil.
 If TEST is omitted or nil, `equal' is used."
+  (declare (side-effect-free t))
   (let (found (tail alist) value)
     (while (and tail (not found))
       (let ((elt (car tail)))
@@ -739,6 +742,7 @@ If TEST is omitted or nil, `equal' is used."
 ELT must be a string.  Upper-case and lower-case letters are treated as equal.
 Unibyte strings are converted to multibyte for comparison.
 Non-strings in LIST are ignored."
+  (declare (side-effect-free t))
   (while (and list
 	      (not (and (stringp (car list))
 			(eq t (compare-strings elt 0 nil (car list) 0 nil t)))))
@@ -822,6 +826,7 @@ Example:
 (defun remove (elt seq)
   "Return a copy of SEQ with all occurrences of ELT removed.
 SEQ must be a list, vector, or string.  The comparison is done with `equal'."
+  (declare (side-effect-free t))
   (if (nlistp seq)
       ;; If SEQ isn't a list, there's no need to copy SEQ because
       ;; `delete' will return a new object.
@@ -832,6 +837,7 @@ SEQ must be a list, vector, or string.  The comparison is done with `equal'."
   "Return LIST with all occurrences of ELT removed.
 The comparison is done with `eq'.  Contrary to `delq', this does not use
 side-effects, and the argument LIST is not modified."
+  (declare (side-effect-free t))
   (while (and (eq elt (car list)) (setq list (cdr list))))
   (if (memq elt list)
       (delq elt (copy-sequence list))
@@ -1232,12 +1238,14 @@ The normal global definition of the character C-x indirects to this keymap.")
 			  c)))
 	    key)))
 
-(defun eventp (obj)
-  "True if the argument is an event object."
-  (when obj
-    (or (integerp obj)
-        (and (symbolp obj) obj (not (keywordp obj)))
-        (and (consp obj) (symbolp (car obj))))))
+(defun eventp (object)
+  "Return non-nil if OBJECT is an input event or event object."
+  (or (integerp object)
+      (and (if (consp object)
+               (setq object (car object))
+             object)
+           (symbolp object)
+           (not (keywordp object)))))
 
 (defun event-modifiers (event)
   "Return a list of symbols representing the modifier keys in event EVENT.
@@ -1596,12 +1604,23 @@ be a list of the form returned by `event-start' and `event-end'."
 
 ;;;; Hook manipulation functions.
 
-(defun add-hook (hook function &optional append local)
+(defun add-hook (hook function &optional depth local)
+  ;; Note: the -100..100 depth range is arbitrary and was chosen to match the
+  ;; range used in add-function.
   "Add to the value of HOOK the function FUNCTION.
 FUNCTION is not added if already present.
-FUNCTION is added (if necessary) at the beginning of the hook list
-unless the optional argument APPEND is non-nil, in which case
-FUNCTION is added at the end.
+
+The place where the function is added depends on the DEPTH
+parameter.  DEPTH defaults to 0.  By convention, it should be
+a number between -100 and 100 where 100 means that the function
+should be at the very end of the list, whereas -100 means that
+the function should always come first.
+Since nothing is \"always\" true, don't use 100 nor -100.
+When two functions have the same depth, the new one gets added after the
+old one if depth is strictly positive and before otherwise.
+
+For backward compatibility reasons, a symbol other than nil is
+interpreted as a DEPTH of 90.
 
 The optional fourth argument, LOCAL, if non-nil, says to modify
 the hook's buffer-local value rather than its global value.
@@ -1614,6 +1633,7 @@ HOOK is void, it is first set to nil.  If HOOK's value is a single
 function, it is changed to a list of functions."
   (or (boundp hook) (set hook nil))
   (or (default-boundp hook) (set-default hook nil))
+  (unless (numberp depth) (setq depth (if depth 90 0)))
   (if local (unless (local-variable-if-set-p hook)
 	      (set (make-local-variable hook) (list t)))
     ;; Detect the case where make-local-variable was used on a hook
@@ -1626,12 +1646,25 @@ function, it is changed to a list of functions."
       (setq hook-value (list hook-value)))
     ;; Do the actual addition if necessary
     (unless (member function hook-value)
-      (when (stringp function)
+      (when (stringp function)          ;FIXME: Why?
 	(setq function (purecopy function)))
+      (when (or (get hook 'hook--depth-alist) (not (zerop depth)))
+        ;; Note: The main purpose of the above `when' test is to avoid running
+        ;; this `setf' before `gv' is loaded during bootstrap.
+        (setf (alist-get function (get hook 'hook--depth-alist)
+                         0 'remove #'equal)
+              depth))
       (setq hook-value
-	    (if append
+	    (if (< 0 depth)
 		(append hook-value (list function))
-	      (cons function hook-value))))
+	      (cons function hook-value)))
+      (let ((depth-alist (get hook 'hook--depth-alist)))
+        (when depth-alist
+          (setq hook-value
+                (sort (if (< 0 depth) hook-value (copy-sequence hook-value))
+                      (lambda (f1 f2)
+                        (< (alist-get f1 depth-alist 0 nil #'equal)
+                           (alist-get f2 depth-alist 0 nil #'equal))))))))
     ;; Set the actual variable
     (if local
 	(progn
@@ -3898,6 +3931,7 @@ Zero means the entire text matched by the whole regexp or whole string.
 STRING should be given if the last search was by `string-match' on STRING.
 If STRING is nil, the current buffer should be the same buffer
 the search/match was performed in."
+  (declare (side-effect-free t))
   (if (match-beginning num)
       (if string
 	  (substring string (match-beginning num) (match-end num))
@@ -3911,6 +3945,7 @@ Zero means the entire text matched by the whole regexp or whole string.
 STRING should be given if the last search was by `string-match' on STRING.
 If STRING is nil, the current buffer should be the same buffer
 the search/match was performed in."
+  (declare (side-effect-free t))
   (if (match-beginning num)
       (if string
 	  (substring-no-properties string (match-beginning num)
@@ -5001,7 +5036,8 @@ to deactivate this transient map, regardless of KEEP-PRED."
 ;;			      MAX-VALUE
 ;;			      MESSAGE
 ;;			      MIN-CHANGE
-;;			      MIN-TIME])
+;;                            MIN-TIME
+;;                            MESSAGE-SUFFIX])
 ;;
 ;; This weirdness is for optimization reasons: we want
 ;; `progress-reporter-update' to be as fast as possible, so
@@ -5011,7 +5047,7 @@ to deactivate this transient map, regardless of KEEP-PRED."
 ;; digits of precision, it doesn't really matter here.  On the other
 ;; hand, it greatly simplifies the code.
 
-(defsubst progress-reporter-update (reporter &optional value)
+(defsubst progress-reporter-update (reporter &optional value suffix)
   "Report progress of an operation in the echo area.
 REPORTER should be the result of a call to `make-progress-reporter'.
 
@@ -5020,14 +5056,17 @@ If REPORTER is a numerical progress reporter---i.e. if it was
  `make-progress-reporter'---then VALUE should be a number between
  MIN-VALUE and MAX-VALUE.
 
-If REPORTER is a non-numerical reporter, VALUE should be nil.
+Optional argument SUFFIX is a string to be displayed after
+REPORTER's main message and progress text.  If REPORTER is a
+non-numerical reporter, then VALUE should be nil, or a string to
+use instead of SUFFIX.
 
 This function is relatively inexpensive.  If the change since
 last update is too small or insufficient time has passed, it does
 nothing."
   (when (or (not (numberp value))      ; For pulsing reporter
 	    (>= value (car reporter))) ; For numerical reporter
-    (progress-reporter-do-update reporter value)))
+    (progress-reporter-do-update reporter value suffix)))
 
 (defun make-progress-reporter (message &optional min-value max-value
 				       current-value min-change min-time)
@@ -5071,26 +5110,28 @@ effectively rounded up."
 		       max-value
 		       message
 		       (if min-change (max (min min-change 50) 1) 1)
-		       min-time))))
+                       min-time
+                       ;; SUFFIX
+                       nil))))
     (progress-reporter-update reporter (or current-value min-value))
     reporter))
 
-(defun progress-reporter-force-update (reporter &optional value new-message)
+(defun progress-reporter-force-update (reporter &optional value new-message suffix)
   "Report progress of an operation in the echo area unconditionally.
 
-The first two arguments are the same as in `progress-reporter-update'.
+REPORTER, VALUE, and SUFFIX are the same as in `progress-reporter-update'.
 NEW-MESSAGE, if non-nil, sets a new message for the reporter."
   (let ((parameters (cdr reporter)))
     (when new-message
       (aset parameters 3 new-message))
     (when (aref parameters 0)
       (aset parameters 0 (float-time)))
-    (progress-reporter-do-update reporter value)))
+    (progress-reporter-do-update reporter value suffix)))
 
 (defvar progress-reporter--pulse-characters ["-" "\\" "|" "/"]
   "Characters to use for pulsing progress reporters.")
 
-(defun progress-reporter-do-update (reporter value)
+(defun progress-reporter-do-update (reporter value &optional suffix)
   (let* ((parameters   (cdr reporter))
 	 (update-time  (aref parameters 0))
 	 (min-value    (aref parameters 1))
@@ -5125,18 +5166,25 @@ NEW-MESSAGE, if non-nil, sets a new message for the reporter."
 	       (setcar reporter (ceiling (car reporter))))
 	     ;; Only print message if enough time has passed
 	     (when enough-time-passed
-	       (if (> percentage 0)
-		   (message "%s%d%%" text percentage)
-		 (message "%s" text)))))
+               (if suffix
+                   (aset parameters 6 suffix)
+                 (setq suffix (or (aref parameters 6) "")))
+               (if (> percentage 0)
+                   (message "%s%d%% %s" text percentage suffix)
+                 (message "%s %s" text suffix)))))
 	  ;; Pulsing indicator
 	  (enough-time-passed
-	   (let ((index (mod (1+ (car reporter)) 4))
-		 (message-log-max nil))
+           (when (and value (not suffix))
+             (setq suffix value))
+           (if suffix
+               (aset parameters 6 suffix)
+             (setq suffix (or (aref parameters 6) "")))
+           (let* ((index (mod (1+ (car reporter)) 4))
+                  (message-log-max nil)
+                  (pulse-char (aref progress-reporter--pulse-characters
+                                    index)))
 	     (setcar reporter index)
-	     (message "%s %s"
-		      text
-		      (aref progress-reporter--pulse-characters
-			    index)))))))
+             (message "%s %s %s" text pulse-char suffix))))))
 
 (defun progress-reporter-done (reporter)
   "Print reporter's message followed by word \"done\" in echo area."
@@ -5534,4 +5582,8 @@ returned list are in the same order as in TREE.
 ;; for discoverability:
 (defalias 'flatten-list 'flatten-tree)
 
+;; The initial anchoring is for better performance in searching matches.
+(defconst regexp-unmatchable "\\`a\\`"
+  "Standard regexp guaranteed not to match any string at all.")
+
 ;;; subr.el ends here
diff --git a/lisp/tabify.el b/lisp/tabify.el
index 37cd8fb2fd..e2df8fc405 100644
--- a/lisp/tabify.el
+++ b/lisp/tabify.el
@@ -1,4 +1,4 @@
-;;; tabify.el --- tab conversion commands for Emacs
+;;; tabify.el --- tab conversion commands for Emacs  -*- lexical-binding: t -*-
 
 ;; Copyright (C) 1985, 1994, 2001-2019 Free Software Foundation, Inc.
 
diff --git a/lisp/tar-mode.el b/lisp/tar-mode.el
index 599da9ac80..7ff31ff102 100644
--- a/lisp/tar-mode.el
+++ b/lisp/tar-mode.el
@@ -523,7 +523,8 @@ MODE should be an integer which is a file mode value."
   "Extract all archive members in the tar-file into the current directory."
   (interactive)
   ;; FIXME: make it work even if we're not in tar-mode.
-  (let ((descriptors tar-parse-info))   ;Read the var in its buffer.
+  (let ((descriptors tar-parse-info)    ;Read the var in its buffer.
+        (reporter (make-progress-reporter "Extracting")))
     (with-current-buffer
         (if (tar-data-swapped-p) tar-data-buffer (current-buffer))
       (set-buffer-multibyte nil)          ;Hopefully, a no-op.
@@ -536,17 +537,19 @@ MODE should be an integer which is a file mode value."
                (start (tar-header-data-start descriptor))
                (end (+ start (tar-header-size descriptor))))
           (unless (file-directory-p name)
-            (message "Extracting %s" name)
+            (progress-reporter-update reporter name)
             (if (and dir (not (file-exists-p dir)))
                 (make-directory dir t))
             (unless (file-directory-p name)
-	      (let ((coding-system-for-write 'no-conversion))
+              (let ((coding-system-for-write 'no-conversion)
+                    (write-region-inhibit-fsync t))
                 (when link-desc
                   (lwarn '(tar link) :warning
                          "Extracted `%s', %s, as a normal file"
                          name link-desc))
-		(write-region start end name)))
-            (set-file-modes name (tar-header-mode descriptor))))))))
+                (write-region start end name nil :nomessage)))
+            (set-file-modes name (tar-header-mode descriptor)))))
+      (progress-reporter-done reporter))))
 
 (defun tar-summarize-buffer ()
   "Parse the contents of the tar file in the current buffer."
diff --git a/lisp/tempo.el b/lisp/tempo.el
index 28afbec0f4..e3b9c76a5b 100644
--- a/lisp/tempo.el
+++ b/lisp/tempo.el
@@ -1,11 +1,11 @@
-;;; tempo.el --- Flexible template insertion
+;;; tempo.el --- Flexible template insertion -*- lexical-binding: t; -*-
 
 ;; Copyright (C) 1994-1995, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: David Kågedal <davidk@lysator.liu.se>
 ;; Created: 16 Feb 1994
 ;; Kågedal's last version number: 1.2.4
-;; Keywords: extensions, languages, tools
+;; Keywords: abbrev, extensions, languages, tools
 
 ;; This file is part of GNU Emacs.
 
@@ -152,7 +152,7 @@ setting it to (upcase), for example.")
 (defvar tempo-tags nil
   "An association list with tags and corresponding templates.")
 
-(defvar tempo-local-tags '((tempo-tags . nil))
+(defvar-local tempo-local-tags '((tempo-tags . nil))
   "A list of locally installed tag completion lists.
 It is an association list where the car of every element is a symbol
 whose variable value is a template list.  The cdr part, if non-nil,
@@ -161,16 +161,16 @@ documentation for the function `tempo-complete-tag' for more info.
 
 `tempo-tags' is always in the last position in this list.")
 
-(defvar tempo-collection nil
+(defvar-local tempo-collection nil
   "A collection of all the tags defined for the current buffer.")
 
-(defvar tempo-dirty-collection t
+(defvar-local tempo-dirty-collection t
   "Indicates if the tag collection needs to be rebuilt.")
 
-(defvar tempo-marks nil
+(defvar-local tempo-marks nil
   "A list of marks to jump to with `\\[tempo-forward-mark]' and `\\[tempo-backward-mark]'.")
 
-(defvar tempo-match-finder "\\b\\([[:word:]]+\\)\\="
+(defvar-local tempo-match-finder "\\b\\([[:word:]]+\\)\\="
   "The regexp or function used to find the string to match against tags.
 
 If `tempo-match-finder' is a string, it should contain a regular
@@ -195,23 +195,15 @@ A list of symbols which are bound to functions that take one argument.
 This function should return something to be sent to `tempo-insert' if
 it recognizes the argument, and nil otherwise.")
 
-(defvar tempo-named-insertions nil
+(defvar-local tempo-named-insertions nil
   "Temporary storage for named insertions.")
 
-(defvar tempo-region-start (make-marker)
+(defvar-local tempo-region-start (make-marker)
   "Region start when inserting around the region.")
 
-(defvar tempo-region-stop (make-marker)
+(defvar-local tempo-region-stop (make-marker)
   "Region stop when inserting around the region.")
 
-;; Make some variables local to every buffer
-
-(make-variable-buffer-local 'tempo-marks)
-(make-variable-buffer-local 'tempo-local-tags)
-(make-variable-buffer-local 'tempo-match-finder)
-(make-variable-buffer-local 'tempo-collection)
-(make-variable-buffer-local 'tempo-dirty-collection)
-
 ;;; Functions
 
 ;;
@@ -268,11 +260,14 @@ The elements in ELEMENTS can be of several types:
  - `n>': Inserts a newline and indents line.
  - `o': Like `%' but leaves the point before the newline.
  - nil: It is ignored.
- - Anything else: It is evaluated and the result is treated as an
-   element to be inserted.  One additional tag is useful for these
-   cases.  If an expression returns a list (l foo bar), the elements
-   after `l' will be inserted according to the usual rules.  This makes
-   it possible to return several elements from one expression."
+ - Anything else: Each function in `tempo-user-elements' is called
+   with it as argument until one of them returns non-nil, and the
+   result is inserted.  If all of them return nil, it is evaluated and
+   the result is treated as an element to be inserted.  One additional
+   tag is useful for these cases.  If an expression returns a list (l
+   foo bar), the elements after `l' will be inserted according to the
+   usual rules.  This makes it possible to return several elements
+   from one expression."
   (let* ((template-name (intern (concat "tempo-template-"
 				       name)))
 	 (command-name template-name))
diff --git a/lisp/term.el b/lisp/term.el
index 586a887a29..553c3a1af4 100644
--- a/lisp/term.el
+++ b/lisp/term.el
@@ -390,8 +390,16 @@ This emulates (more or less) the behavior of xterm.")
   "A queue of strings whose echo we want suppressed.")
 (defvar term-terminal-undecoded-bytes nil)
 (defvar term-current-face 'term)
-(defvar term-scroll-start 0 "Top-most line (inclusive) of scrolling region.")
-(defvar term-scroll-end) ; Number of line (zero-based) after scrolling region.
+(defvar-local term-scroll-start 0
+  "Top-most line (inclusive) of the scrolling region.
+`term-scroll-start' must be in the range [0,term-height).  In addition, its
+value has to be smaller than `term-scroll-end', i.e. one line scroll regions are
+not allowed.")
+(defvar-local term-scroll-end nil
+  "Bottom-most line (inclusive) of the scrolling region.
+`term-scroll-end' must be in the range [0,term-height).  In addition, its
+value has to be greater than `term-scroll-start', i.e. one line scroll regions are
+not allowed.")
 (defvar term-pager-count nil
   "Number of lines before we need to page; if nil, paging is disabled.")
 (defvar term-saved-cursor nil)
@@ -1075,9 +1083,6 @@ Entry to this mode runs the hooks on `term-mode-hook'."
   (make-local-variable 'term-current-column)
   (make-local-variable 'term-current-row)
   (make-local-variable 'term-log-buffer)
-  (make-local-variable 'term-scroll-start)
-  (set (make-local-variable 'term-scroll-end) term-height)
-  (make-local-variable 'term-scroll-with-delete)
   (make-local-variable 'term-pager-count)
   (make-local-variable 'term-pager-old-local-map)
   (make-local-variable 'term-old-mode-map)
@@ -1117,6 +1122,8 @@ Entry to this mode runs the hooks on `term-mode-hook'."
 
   (add-hook 'read-only-mode-hook #'term-line-mode-buffer-read-only-update nil t)
 
+  (term--reset-scroll-region)
+
   (easy-menu-add term-terminal-menu)
   (easy-menu-add term-signals-menu)
   (or term-input-ring
@@ -1133,6 +1140,9 @@ Entry to this mode runs the hooks on `term-mode-hook'."
       (let ((inhibit-read-only t))
         (delete-char 1)))))
 
+(defun term--last-line ()
+  (1- term-height))
+
 (defun term--filter-buffer-substring (content)
   (with-temp-buffer
     (insert content)
@@ -1174,7 +1184,7 @@ Entry to this mode runs the hooks on `term-mode-hook'."
       (setq term-start-line-column nil)
       (setq term-current-row nil)
       (setq term-current-column nil)
-      (term-set-scroll-region 0 height)
+      (term--reset-scroll-region)
       ;; `term-set-scroll-region' causes these to be set, we have to
       ;; clear them again since we're changing point (Bug#30544).
       (setq term-start-line-column nil)
@@ -2935,7 +2945,8 @@ See `term-prompt-regexp'."
                       (delete-region (point) (line-end-position))
                       (term-down 1 t)
                       (term-move-columns (- (term-current-column)))
-                      (put-text-property (1- (point)) (point) 'term-line-wrap t)
+                      (add-text-properties (1- (point)) (point)
+                                           '(term-line-wrap t rear-nonsticky t))
                       (setq decoded-substring
                             (substring decoded-substring (- term-width old-column)))
                       (setq old-column 0)))
@@ -3204,7 +3215,7 @@ option is enabled.  See `term-set-goto-process-mark'."
 	(goto-char term-home-marker)
 	(term-vertical-motion (1+ count))
 	(set-marker term-home-marker (point))
-	(setq term-current-row (1- term-height))))))
+	(setq term-current-row (term--last-line))))))
 
 (defun term-reset-terminal ()
   "Reset the terminal, delete all the content and set the face to the default one."
@@ -3212,8 +3223,7 @@ option is enabled.  See `term-set-goto-process-mark'."
   (term-ansi-reset)
   (setq term-current-row 0)
   (setq term-current-column 1)
-  (setq term-scroll-start 0)
-  (setq term-scroll-end term-height)
+  (term--reset-scroll-region)
   (setq term-insert-mode nil)
   ;; FIXME: No idea why this is here, it looks wrong.  --Stef
   (setq term-ansi-face-already-done nil))
@@ -3422,6 +3432,10 @@ option is enabled.  See `term-set-goto-process-mark'."
      (1- (or (nth 1 params) 0))))
    (t)))
 
+(defun term--reset-scroll-region ()
+  "Sets the scroll region to the full height of the terminal."
+  (term-set-scroll-region 0 (term--last-line)))
+
 (defun term-set-scroll-region (top bottom)
   "Set scrolling region.
 TOP is the top-most line (inclusive) of the new scrolling region,
@@ -3432,13 +3446,13 @@ The top-most line is line 0."
 	    0
 	  top))
   (setq term-scroll-end
-	(if (or (<= bottom term-scroll-start) (> bottom term-height))
-	    term-height
+	(if (or (<= bottom term-scroll-start) (> bottom (term--last-line)))
+	    (term--last-line)
 	  bottom))
   (setq term-scroll-with-delete
 	(or (term-using-alternate-sub-buffer)
 	    (not (and (= term-scroll-start 0)
-		      (= term-scroll-end term-height)))))
+                      (= term-scroll-end (term--last-line))))))
   (term-move-columns (- (term-current-column)))
   (term-goto 0 0))
 
@@ -3567,7 +3581,7 @@ The top-most line is line 0."
     (when (> moved lines)
       (backward-char))
     (cond ((<= deficit 0) ;; OK, had enough in the buffer for request.
-	   (recenter (1- term-height)))
+	   (recenter (term--last-line)))
 	  ((term-pager-continue deficit)))))
 
 (defun term-pager-page (arg)
@@ -3581,7 +3595,7 @@ The top-most line is line 0."
   (goto-char (point-min))
   (when (= (vertical-motion term-height) term-height)
     (backward-char))
-  (recenter (1- term-height)))
+  (recenter (term--last-line)))
 
 ;; Pager mode command to go to end of buffer.
 (defun term-pager-eob ()
@@ -3599,7 +3613,7 @@ The top-most line is line 0."
     ;; Move cursor to end of window.
     (vertical-motion term-height)
     (backward-char))
-  (recenter (1- term-height)))
+  (recenter (term--last-line)))
 
 (defun term-pager-back-page (arg)
   (interactive "p")
@@ -3754,7 +3768,8 @@ all pending output has been dealt with."))
   (when (not (bolp))
     (let ((old-point (point)))
       (insert-before-markers ?\n)
-      (put-text-property old-point (point) 'term-line-wrap t))))
+      (add-text-properties old-point (point)
+                           '(term-line-wrap t rear-nonsticky t)))))
 
 (defun term-erase-in-line (kind)
   (when (= kind 1) ;; erase left of point
diff --git a/lisp/textmodes/artist.el b/lisp/textmodes/artist.el
index e9b17795a9..19d1df6d51 100644
--- a/lisp/textmodes/artist.el
+++ b/lisp/textmodes/artist.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2000-2019 Free Software Foundation, Inc.
 
 ;; Author:       Tomas Abrahamsson <tab@lysator.liu.se>
-;; Maintainer:   Tomas Abrahamsson <tab@lysator.liu.se>
 ;; Keywords:     mouse
 ;; Version:	 1.2.6
 ;; Release-date: 6-Aug-2004
diff --git a/lisp/textmodes/css-mode.el b/lisp/textmodes/css-mode.el
index 11a77b5bb7..5d5d787945 100644
--- a/lisp/textmodes/css-mode.el
+++ b/lisp/textmodes/css-mode.el
@@ -844,7 +844,21 @@ cannot be completed sensibly: `custom-ident',
 (defvar css-mode-map
   (let ((map (make-sparse-keymap)))
     (define-key map [remap info-lookup-symbol] 'css-lookup-symbol)
+    ;; `info-complete-symbol' is not used.
+    (define-key map [remap complete-symbol] 'completion-at-point)
     (define-key map "\C-c\C-f" 'css-cycle-color-format)
+    (easy-menu-define css-menu map "CSS mode menu"
+      '("CSS"
+        :help "CSS-specific features"
+        ["Reformat block" fill-paragraph
+         :help "Reformat declaration block or fill comment at point"]
+        ["Cycle color format" css-cycle-color-format
+         :help "Cycle color at point between different formats"]
+        "-"
+        ["Describe symbol" css-lookup-symbol
+         :help "Display documentation for a CSS symbol"]
+        ["Complete symbol" completion-at-point
+         :help "Complete symbol before point"]))
     map)
   "Keymap used in `css-mode'.")
 
@@ -1607,7 +1621,7 @@ rgb()/rgba()."
 This mode provides syntax highlighting, indentation, completion,
 and documentation lookup for CSS.
 
-Use `\\[complete-symbol]' to complete CSS properties, property values,
+Use `\\[completion-at-point]' to complete CSS properties, property values,
 pseudo-elements, pseudo-classes, at-rules, bang-rules, and HTML
 tags, classes and IDs.  Completion candidates for HTML class
 names and IDs are found by looking through open HTML mode
diff --git a/lisp/textmodes/ispell.el b/lisp/textmodes/ispell.el
index 6553a2799b..d488c05418 100644
--- a/lisp/textmodes/ispell.el
+++ b/lisp/textmodes/ispell.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1994-1995, 1997-2019 Free Software Foundation, Inc.
 
-;; Author:           Ken Stevens <k.stevens@ieee.org>
+;; Author: Ken Stevens <k.stevens@ieee.org>
 
 ;; This file is part of GNU Emacs.
 
@@ -4016,7 +4016,7 @@ You can bind this to the key C-c i in GNUS or mail by adding to
 
 (defun ispell-non-empty-string (string)
   (if (or (not string) (string-equal string ""))
-      "\\'\\`" ; An unmatchable string if string is null.
+      regexp-unmatchable
     (regexp-quote string)))
 
 
diff --git a/lisp/textmodes/page.el b/lisp/textmodes/page.el
index 220ef2d7fd..2b0cea4c64 100644
--- a/lisp/textmodes/page.el
+++ b/lisp/textmodes/page.el
@@ -1,4 +1,4 @@
-;;; page.el --- page motion commands for Emacs
+;;; page.el --- page motion commands for Emacs  -*- lexical-binding: t; -*-
 
 ;; Copyright (C) 1985, 2001-2019 Free Software Foundation, Inc.
 
@@ -38,8 +38,7 @@ A page boundary is any line whose beginning matches the regexp
     ;; In case the page-delimiter matches the null string,
     ;; don't find a match without moving.
     (if (bolp) (forward-char 1))
-    (if (re-search-forward page-delimiter nil t)
-	nil
+    (unless (re-search-forward page-delimiter nil t)
       (goto-char (point-max)))
     (setq count (1- count)))
   (while (and (< count 0) (not (bobp)))
diff --git a/lisp/textmodes/paragraphs.el b/lisp/textmodes/paragraphs.el
index 92a6b90785..d0fab36599 100644
--- a/lisp/textmodes/paragraphs.el
+++ b/lisp/textmodes/paragraphs.el
@@ -1,4 +1,4 @@
-;;; paragraphs.el --- paragraph and sentence parsing
+;;; paragraphs.el --- paragraph and sentence parsing  -*- lexical-binding: t -*-
 
 ;; Copyright (C) 1985-1987, 1991, 1994-1997, 1999-2019 Free Software
 ;; Foundation, Inc.
@@ -398,15 +398,15 @@ it marks the next ARG paragraphs after the ones already marked."
 
 (defun kill-paragraph (arg)
   "Kill forward to end of paragraph.
-With arg N, kill forward to Nth end of paragraph;
-negative arg -N means kill backward to Nth start of paragraph."
+With ARG N, kill forward to Nth end of paragraph;
+negative ARG -N means kill backward to Nth start of paragraph."
   (interactive "p")
   (kill-region (point) (progn (forward-paragraph arg) (point))))
 
 (defun backward-kill-paragraph (arg)
   "Kill back to start of paragraph.
-With arg N, kill back to Nth start of paragraph;
-negative arg -N means kill forward to Nth end of paragraph."
+With ARG N, kill back to Nth start of paragraph;
+negative ARG -N means kill forward to Nth end of paragraph."
   (interactive "p")
   (kill-region (point) (progn (backward-paragraph arg) (point))))
 
@@ -421,6 +421,7 @@ the current paragraph with the one containing the mark."
   (transpose-subr 'forward-paragraph arg))
 
 (defun start-of-paragraph-text ()
+  "Move to the start of the current paragraph."
   (let ((opoint (point)) npoint)
     (forward-paragraph -1)
     (setq npoint (point))
@@ -436,6 +437,7 @@ the current paragraph with the one containing the mark."
 	      (start-of-paragraph-text))))))
 
 (defun end-of-paragraph-text ()
+  "Move to the end of the current paragraph."
   (let ((opoint (point)))
     (forward-paragraph 1)
     (if (eq (preceding-char) ?\n) (forward-char -1))
@@ -447,7 +449,7 @@ the current paragraph with the one containing the mark."
 
 (defun forward-sentence (&optional arg)
   "Move forward to next end of sentence.  With argument, repeat.
-With negative argument, move backward repeatedly to start of sentence.
+When ARG is negative, move backward repeatedly to start of sentence.
 
 The variable `sentence-end' is a regular expression that matches ends of
 sentences.  Also, every paragraph boundary terminates sentences as well."
@@ -483,37 +485,46 @@ sentences.  Also, every paragraph boundary terminates sentences as well."
       (setq arg (1- arg)))
     (constrain-to-field nil opoint t)))
 
-(defun repunctuate-sentences ()
+(defun repunctuate-sentences (&optional no-query)
   "Put two spaces at the end of sentences from point to the end of buffer.
-It works using `query-replace-regexp'."
+It works using `query-replace-regexp'.
+If optional argument NO-QUERY is non-nil, make changes without
+asking for confirmation."
   (interactive)
-  (query-replace-regexp "\\([]\"')]?\\)\\([.?!]\\)\\([]\"')]?\\) +"
-			"\\1\\2\\3  "))
+  (let ((regexp "\\([]\"')]?\\)\\([.?!]\\)\\([]\"')]?\\) +")
+        (to-string "\\1\\2\\3  "))
+    (if no-query
+        (while (re-search-forward regexp nil t)
+          (replace-match to-string))
+      (query-replace-regexp regexp to-string))))
 
 
 (defun backward-sentence (&optional arg)
-  "Move backward to start of sentence.  With arg, do it arg times.
-See `forward-sentence' for more information."
+  "Move backward to start of sentence.
+With ARG, do it ARG times.  See `forward-sentence' for more
+information."
   (interactive "^p")
   (or arg (setq arg 1))
   (forward-sentence (- arg)))
 
 (defun kill-sentence (&optional arg)
   "Kill from point to end of sentence.
-With arg, repeat; negative arg -N means kill back to Nth start of sentence."
+With ARG, repeat; negative ARG -N means kill back to Nth start of
+sentence."
   (interactive "p")
   (kill-region (point) (progn (forward-sentence arg) (point))))
 
 (defun backward-kill-sentence (&optional arg)
   "Kill back from point to start of sentence.
-With arg, repeat, or kill forward to Nth end of sentence if negative arg -N."
+With ARG, repeat, or kill forward to Nth end of sentence if
+negative ARG -N."
   (interactive "p")
   (kill-region (point) (progn (backward-sentence arg) (point))))
 
 (defun mark-end-of-sentence (arg)
-  "Put mark at end of sentence.  Arg works as in `forward-sentence'.
-If this command is repeated, it marks the next ARG sentences after the
-ones already marked."
+  "Put mark at end of sentence.
+ARG works as in `forward-sentence'.  If this command is repeated,
+it marks the next ARG sentences after the ones already marked."
   (interactive "p")
   (push-mark
    (save-excursion
diff --git a/lisp/textmodes/picture.el b/lisp/textmodes/picture.el
index b520849467..bc85372de6 100644
--- a/lisp/textmodes/picture.el
+++ b/lisp/textmodes/picture.el
@@ -624,7 +624,6 @@ Leaves the region surrounding the rectangle."
 
 (defvar picture-mode-map
   (let ((map (make-keymap)))
-    (define-key map [remap self-insert-command] 'picture-self-insert)
     (define-key map [remap self-insert-command] 'picture-self-insert)
     (define-key map [remap completion-separator-self-insert-command]
 			  'picture-self-insert)
diff --git a/lisp/textmodes/sgml-mode.el b/lisp/textmodes/sgml-mode.el
index 9e3be99af1..0c5d5e56a6 100644
--- a/lisp/textmodes/sgml-mode.el
+++ b/lisp/textmodes/sgml-mode.el
@@ -96,24 +96,20 @@ a DOCTYPE or an XML declaration."
 `text-mode-hook' is run first."
   :type 'hook)
 
-;; As long as Emacs's syntax can't be complemented with predicates to context
-;; sensitively confirm the syntax of characters, we have to live with this
-;; kludgy kind of tradeoff.
-(defvar sgml-specials '(?\")
+;; The official handling of "--" is complicated in SGML, and
+;; historically not well supported by browser HTML parsers.
+;; Recommendations for writing HTML comments is to use <!--...-->
+;; (where ... doesn't contain "--") to avoid the complications
+;; altogether (XML goes even further by requiring this in the spec).
+;; So there is probably no need to handle it "correctly".
+(defvar sgml-specials '(?\" ?\')
   "List of characters that have a special meaning for SGML mode.
 This list is used when first loading the `sgml-mode' library.
-The supported characters and potential disadvantages are:
+The supported characters are ?\\\", ?\\=', and ?-.
 
-  ?\\\"	Makes \" in text start a string.
-  ?\\='	Makes \\=' in text start a string.
-  ?-	Makes -- in text start a comment.
-
-When only one of ?\\\" or ?\\=' are included, \"\\='\" or \\='\"\\=', as can be found in
-DTDs, start a string.  To partially avoid this problem this also makes these
-self insert as named entities depending on `sgml-quick-keys'.
-
-Including ?- has the problem of affecting dashes that have nothing to do
-with comments, so we normally turn it off.")
+Including ?- makes double dashes into comment delimiters, but
+they are really only supposed to delimit comments within DTD
+definitions.  So we normally turn it off.")
 
 (defvar sgml-quick-keys nil
   "Use <, >, &, /, SPC and `sgml-specials' keys \"electrically\" when non-nil.
@@ -333,6 +329,30 @@ Any terminating `>' or `/' is not matched.")
 (defvar sgml-font-lock-keywords sgml-font-lock-keywords-1
   "Rules for highlighting SGML code.  See also `sgml-tag-face-alist'.")
 
+(defun sgml-font-lock-syntactic-face (state)
+  "`font-lock-syntactic-face-function' for `sgml-mode'."
+  ;; Don't use string face outside of tags.
+  (cond ((and (nth 9 state) (nth 3 state)) font-lock-string-face)
+        ((nth 4 state) font-lock-comment-face)))
+
+(defvar-local sgml--syntax-propertize-ppss nil)
+
+(defun sgml--syntax-propertize-ppss (pos)
+  "Return PPSS at POS, fixing the syntax of any lone `>' along the way."
+  (cl-assert (>= pos (car sgml--syntax-propertize-ppss)))
+  (let ((ppss (parse-partial-sexp (car sgml--syntax-propertize-ppss) pos -1
+                                  nil (cdr sgml--syntax-propertize-ppss))))
+    (while (eq -1 (car ppss))
+      (put-text-property (1- (point)) (point)
+                         'syntax-table (string-to-syntax "."))
+      ;; Hack attack: rather than recompute the ppss from
+      ;; (car sgml--syntax-propertize-ppss), we manually "fix it".
+      (setcar ppss 0)
+      (setq ppss (parse-partial-sexp (point) pos -1 nil ppss)))
+    (setcdr sgml--syntax-propertize-ppss ppss)
+    (setcar sgml--syntax-propertize-ppss pos)
+    ppss))
+
 (eval-and-compile
   (defconst sgml-syntax-propertize-rules
     (syntax-propertize-precompile-rules
@@ -343,29 +363,50 @@ Any terminating `>' or `/' is not matched.")
      ("--[ \t\n]*\\(>\\)" (1 "> b"))
      ("\\(<\\)[?!]" (1 (prog1 "|>"
                          (sgml-syntax-propertize-inside end))))
-     ;; Double quotes outside of tags should not introduce strings which end up
-     ;; hiding tags.  We used to test every double quote and mark it as "."
-     ;; if it's outside of tags, but there are too many double quotes and
+     ;; Quotes outside of tags should not introduce strings which end up
+     ;; hiding tags.  We used to test every quote and mark it as "."
+     ;; if it's outside of tags, but there are too many quotes and
      ;; the resulting number of calls to syntax-ppss made it too slow
      ;; (bug#33887), so we're now careful to leave alone any pair
-     ;; of quotes that doesn't hold a < or > char, which is the vast majority.
-     ("\\(\"\\)[^\"<>]*[<>\"]"
-      (1 (unless (eq ?\" (char-before))
+     ;; of quotes that doesn't hold a < or > char, which is the vast majority:
+     ;; either they're both within a tag (or a comment), in which case it's
+     ;; indeed correct to leave them as is, or they're both outside of tags, in
+     ;; which case they arguably should have punctuation syntax, but it is
+     ;; harmless to let them have string syntax because they won't "hide" any
+     ;; tag or comment from us (and we use the
+     ;; font-lock-syntactic-face-function to make sure those spurious "strings
+     ;; within text" aren't highlighted as strings).
+     ("\\([\"']\\)[^\"'<>]*"
+      (1 (if (eq (char-after) (char-after (match-beginning 0)))
+             ;; Fast-track case.
+             (forward-char 1)
+           ;; Point has moved to the end of the text we matched after the
+           ;; quote, but this risks overlooking a match to one of the other
+           ;; regexp in the rules.  We could just (goto-char (match-end 1))
+           ;; to solve this, but that would be too easy, so instead we
+           ;; only move back enough to avoid skipping comment ender, which
+           ;; happens to be the only one that we could have overlooked.
+           (when (eq (char-after) ?>)
+             (skip-chars-backward "-"))
            ;; Be careful to call `syntax-ppss' on a position before the one
            ;; we're going to change, so as not to need to flush the data we
            ;; just computed.
-           (if (prog1 (zerop (car (syntax-ppss (match-beginning 0))))
-                 (goto-char (1- (match-end 0))))
+           (if (zerop (save-excursion
+                        (car (sgml--syntax-propertize-ppss
+                              (match-beginning 0)))))
                (string-to-syntax ".")))))
      )))
 
 (defun sgml-syntax-propertize (start end)
   "Syntactic keywords for `sgml-mode'."
-  (goto-char start)
+  (setq sgml--syntax-propertize-ppss (cons start (syntax-ppss start)))
+  (cl-assert (>= (cadr sgml--syntax-propertize-ppss) 0))
   (sgml-syntax-propertize-inside end)
   (funcall
    (syntax-propertize-rules sgml-syntax-propertize-rules)
-   start end))
+   start end)
+  ;; Catch any '>' after the last quote.
+  (sgml--syntax-propertize-ppss end))
 
 (defun sgml-syntax-propertize-inside (end)
   (let ((ppss (syntax-ppss)))
@@ -551,7 +592,7 @@ Do \\[describe-key] on the following bindings to discover what they do.
   ;; This is desirable because SGML discards a newline that appears
   ;; immediately after a start tag or immediately before an end tag.
   (setq-local paragraph-start (concat "[ \t]*$\\|\
-[ \t]*</?\\(" sgml-name-re sgml-attrs-re "\\)?>"))
+\[ \t]*</?\\(" sgml-name-re sgml-attrs-re "\\)?>"))
   (setq-local paragraph-separate (concat paragraph-start "$"))
   (setq-local adaptive-fill-regexp "[ \t]*")
   (add-hook 'fill-nobreak-predicate 'sgml-fill-nobreak nil t)
@@ -569,7 +610,9 @@ Do \\[describe-key] on the following bindings to discover what they do.
   (setq font-lock-defaults '((sgml-font-lock-keywords
 			      sgml-font-lock-keywords-1
 			      sgml-font-lock-keywords-2)
-			     nil t))
+                             nil t nil
+                             (font-lock-syntactic-face-function
+                              . sgml-font-lock-syntactic-face)))
   (setq-local syntax-propertize-function #'sgml-syntax-propertize)
   (setq-local facemenu-add-face-function 'sgml-mode-facemenu-add-face-function)
   (setq-local sgml-xml-mode (sgml-xml-guess))
diff --git a/lisp/textmodes/table.el b/lisp/textmodes/table.el
index bed8b2fef2..256fac6342 100644
--- a/lisp/textmodes/table.el
+++ b/lisp/textmodes/table.el
@@ -590,7 +590,7 @@
 ;; attempt of implementing the table feature to Emacs.  This greatly
 ;; motivated me to follow through to its completion.
 ;;
-;; Kenichi Handa <handa@etl.go.jp> kindly guided me through to
+;; Kenichi Handa <handa@gnu.org> kindly guided me through to
 ;; overcome many technical issues while I was struggling with quail
 ;; related internationalization problems.
 ;;
@@ -930,16 +930,16 @@ This is always set to nil at the entry to `table-with-cache-buffer' before execu
 ;; refill the table cache.  If the command were not listed fast
 ;; typing can cause unwanted cache refill.
 (defconst table-cell-bindings
-  '(([(control i)]	. table-forward-cell)
-    ([(control I)]	. table-backward-cell)
+  '(([(control ?i)]	. table-forward-cell)
+    ([(control ?I)]	. table-backward-cell)
     ([tab]		. table-forward-cell)
     ([(shift backtab)]	. table-backward-cell) ; for HPUX console keyboard
     ([(shift iso-lefttab)]    . table-backward-cell) ; shift-tab on a microsoft natural keyboard and redhat linux
     ([(shift tab)]	. table-backward-cell)
     ([backtab]          . table-backward-cell) ; for terminals (e.g., xterm)
     ([return]		. *table--cell-newline)
-    ([(control m)]	. *table--cell-newline)
-    ([(control j)]	. *table--cell-newline-and-indent)
+    ([(control ?m)]	. *table--cell-newline)
+    ([(control ?j)]	. *table--cell-newline-and-indent)
     ([mouse-3]		. *table--present-cell-popup-menu)
     ([(control ?>)]	. table-widen-cell)
     ([(control ?<)]	. table-narrow-cell)
diff --git a/lisp/textmodes/texinfmt.el b/lisp/textmodes/texinfmt.el
index 4bfecb48b6..4110dfb8e8 100644
--- a/lisp/textmodes/texinfmt.el
+++ b/lisp/textmodes/texinfmt.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1985-1986, 1988, 1990-1998, 2000-2019 Free Software
 ;; Foundation, Inc.
 
-;; Maintainer: Robert J. Chassell <bug-texinfo@gnu.org>
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: maint, tex, docs
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/textmodes/texnfo-upd.el b/lisp/textmodes/texnfo-upd.el
index e960e992a8..134f82b14e 100644
--- a/lisp/textmodes/texnfo-upd.el
+++ b/lisp/textmodes/texnfo-upd.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1989-1992, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Robert J. Chassell
-;; Maintainer: bug-texinfo@gnu.org
+;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: maint, tex, docs
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/thingatpt.el b/lisp/thingatpt.el
index 26e084320b..60a20e2d18 100644
--- a/lisp/thingatpt.el
+++ b/lisp/thingatpt.el
@@ -585,13 +585,13 @@ See RFC 4122 for the description of the format.")
 
 ;;  Aliases
 
-(defun word-at-point ()
+(defun word-at-point (&optional no-properties)
   "Return the word at point.  See `thing-at-point'."
-  (thing-at-point 'word))
+  (thing-at-point 'word no-properties))
 
-(defun sentence-at-point ()
+(defun sentence-at-point (&optional no-properties)
   "Return the sentence at point.  See `thing-at-point'."
-  (thing-at-point 'sentence))
+  (thing-at-point 'sentence no-properties))
 
 (defun thing-at-point--read-from-whole-string (str)
   "Read a Lisp expression from STR.
diff --git a/lisp/time-stamp.el b/lisp/time-stamp.el
index 91e02bef51..f423683852 100644
--- a/lisp/time-stamp.el
+++ b/lisp/time-stamp.el
@@ -5,7 +5,7 @@
 
 ;; This file is part of GNU Emacs.
 
-;; Maintainer: Stephen Gildea <gildea@stop.mail-abuse.org>
+;; Maintainer: Stephen Gildea <stepheng+emacs@gildea.com>
 ;; Keywords: tools
 
 ;; GNU Emacs is free software: you can redistribute it and/or modify
diff --git a/lisp/timezone.el b/lisp/timezone.el
index 621f02479f..ff0b266245 100644
--- a/lisp/timezone.el
+++ b/lisp/timezone.el
@@ -1,10 +1,9 @@
-;;; timezone.el --- time zone package for GNU Emacs
+;;; timezone.el --- time zone package for GNU Emacs  -- lexical-binding: t -*-
 
 ;; Copyright (C) 1990-1993, 1996, 1999, 2001-2019 Free Software
 ;; Foundation, Inc.
 
-;; Author: Masanobu Umeda
-;; Maintainer: umerin@mse.kyutech.ac.jp
+;; Author: Masanobu Umeda <umerin@mse.kyutech.ac.jp>
 ;; Keywords: news
 
 ;; This file is part of GNU Emacs.
@@ -73,8 +72,7 @@ if nil, the local time zone is assumed."
     (timezone-make-arpa-date (aref new 0) (aref new 1) (aref new 2)
 			     (timezone-make-time-string
 			      (aref new 3) (aref new 4) (aref new 5))
-			     (aref new 6))
-    ))
+			     (aref new 6))))
 
 (defun timezone-make-date-sortable (date &optional local timezone)
   "Convert DATE to a sortable date string.
@@ -85,8 +83,7 @@ if nil, the local time zone is assumed."
   (let ((new (timezone-fix-time date local timezone)))
     (timezone-make-sortable-date (aref new 0) (aref new 1) (aref new 2)
 				 (timezone-make-time-string
-				  (aref new 3) (aref new 4) (aref new 5)))
-    ))
+				  (aref new 3) (aref new 4) (aref new 5)))))
 
 
 ;;
diff --git a/lisp/tree-widget.el b/lisp/tree-widget.el
index 61bfacd56a..e4da23a387 100644
--- a/lisp/tree-widget.el
+++ b/lisp/tree-widget.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2004-2019 Free Software Foundation, Inc.
 
 ;; Author: David Ponce <david@dponce.com>
-;; Maintainer: David Ponce <david@dponce.com>
 ;; Created: 16 Feb 2001
 ;; Keywords: extensions
 
diff --git a/lisp/type-break.el b/lisp/type-break.el
index 0ad79dd113..52029604af 100644
--- a/lisp/type-break.el
+++ b/lisp/type-break.el
@@ -3,8 +3,7 @@
 ;; Copyright (C) 1994-1995, 1997, 2000-2019 Free Software Foundation,
 ;; Inc.
 
-;; Author: Noah Friedman
-;; Maintainer: Noah Friedman <friedman@splode.com>
+;; Author: Noah Friedman <friedman@splode.com>
 ;; Keywords: extensions, timers
 ;; Created: 1994-07-13
 
diff --git a/lisp/uniquify.el b/lisp/uniquify.el
index 3dd9e34135..cd09ef2af6 100644
--- a/lisp/uniquify.el
+++ b/lisp/uniquify.el
@@ -46,7 +46,7 @@
 ;;; Change Log:
 
 ;; Originally by Dick King <king@reasoning.com> 15 May 86
-;; Converted for Emacs 18 by Stephen Gildea <gildea@stop.mail-abuse.org>
+;; Converted for Emacs 18 by Stephen Gildea <stepheng+emacs@gildea.com>
 ;; Make uniquify-min-dir-content 0 truly non-invasive.  gildea 23 May 89
 ;; Some cleanup.  uniquify-min-dir-content default 0.  gildea 01 Jun 89
 ;; Don't rename to "".  Michael Ernst <mernst@theory.lcs.mit.edu> 15 Jun 94
diff --git a/lisp/url/url-auth.el b/lisp/url/url-auth.el
index 0746cfd96c..beed7c6cb6 100644
--- a/lisp/url/url-auth.el
+++ b/lisp/url/url-auth.el
@@ -86,7 +86,7 @@ instead of the filename inheritance method."
      ((and prompt (not byserv))
       (setq user (or
 		  (url-do-auth-source-search server type :user)
-		  (read-string (url-auth-user-prompt url realm)
+		  (read-string (url-auth-user-prompt href realm)
 			       (or user (user-real-login-name))))
 	    pass (or
 		  (url-do-auth-source-search server type :secret)
@@ -115,7 +115,7 @@ instead of the filename inheritance method."
 	  (progn
 	    (setq user (or
 			(url-do-auth-source-search server type :user)
-			(read-string (url-auth-user-prompt url realm)
+			(read-string (url-auth-user-prompt href realm)
 				     (user-real-login-name)))
 		  pass (or
 			(url-do-auth-source-search server type :secret)
@@ -478,6 +478,8 @@ PROMPT is boolean - specifies whether to ask the user for a username/password
        if one cannot be found in the cache"
   (if (not realm)
       (setq realm (cdr-safe (assoc "realm" args))))
+  (if (equal realm "")
+      (setq realm nil))
   (if (stringp url)
       (setq url (url-generic-parse-url url)))
   (if (or (null type) (eq type 'any))
diff --git a/lisp/url/url-handlers.el b/lisp/url/url-handlers.el
index e35d999e0f..9d7837d8a7 100644
--- a/lisp/url/url-handlers.el
+++ b/lisp/url/url-handlers.el
@@ -23,17 +23,17 @@
 
 ;;; Code:
 
-;; (require 'url)
 (require 'url-parse)
-;; (require 'url-util)
 (eval-when-compile (require 'mm-decode))
-;; (require 'mailcap)
 (eval-when-compile (require 'subr-x))
 ;; The following are autoloaded instead of `require'd to avoid eagerly
 ;; loading all of URL when turning on url-handler-mode in the .emacs.
-(autoload 'url-expand-file-name "url-expand" "Convert url to a fully specified url, and canonicalize it.")
-(autoload 'mm-dissect-buffer "mm-decode" "Dissect the current buffer and return a list of MIME handles.")
-(autoload 'url-scheme-get-property "url-methods" "Get property of a URL SCHEME.")
+(autoload 'url-expand-file-name "url-expand"
+  "Convert URL to a fully specified URL, and canonicalize it.")
+(autoload 'mm-dissect-buffer "mm-decode"
+  "Dissect the current buffer and return a list of MIME handles.")
+(autoload 'url-scheme-get-property "url-methods"
+  "Get PROPERTY of a URL SCHEME.")
 
 ;; Always used after mm-dissect-buffer and defined in the same file.
 (declare-function mm-save-part-to-file "mm-decode" (handle file))
@@ -112,15 +112,16 @@
       (push (cons url-handler-regexp 'url-file-handler)
 	    file-name-handler-alist)))
 
-(defcustom url-handler-regexp "\\`\\(https?\\|ftp\\|file\\|nfs\\|ssh\\|scp\\|rsync\\|telnet\\)://"
+(defcustom url-handler-regexp
+  "\\`\\(?:https?\\|ftp\\|file\\|nfs\\|ssh\\|scp\\|rsync\\|telnet\\)://"
   "Regular expression for URLs handled by `url-handler-mode'.
 When URL Handler mode is enabled, this regular expression is
 added to `file-name-handler-alist'.
 
 Some valid URL protocols just do not make sense to visit
-interactively \(about, data, info, irc, mailto, etc.).  This
+interactively (about, data, info, irc, mailto, etc.).  This
 regular expression avoids conflicts with local files that look
-like URLs \(Gnus is particularly bad at this)."
+like URLs (Gnus is particularly bad at this)."
   :group 'url
   :type 'regexp
   :version "25.1"
@@ -144,8 +145,8 @@ like URLs \(Gnus is particularly bad at this)."
 ;;;###autoload
 (defun url-file-handler (operation &rest args)
   "Function called from the `file-name-handler-alist' routines.
-OPERATION is what needs to be done (`file-exists-p', etc).  ARGS are
-the arguments that would have been passed to OPERATION."
+OPERATION is what needs to be done (`file-exists-p', etc.).
+ARGS are the arguments that would have been passed to OPERATION."
   ;; Avoid recursive load.
   (if (and load-in-progress url-file-handler-load-in-progress)
       (url-run-real-handler operation args)
@@ -153,48 +154,46 @@ the arguments that would have been passed to OPERATION."
       ;; Check, whether there are arguments we want pass to Tramp.
       (if (catch :do
             (dolist (url (cons default-directory args))
-              (and (member
-                    (url-type (url-generic-parse-url (and (stringp url) url)))
-                    url-tramp-protocols)
+              (and (stringp url)
+                   (member (url-type (url-generic-parse-url url))
+                           url-tramp-protocols)
                    (throw :do t))))
-          (apply 'url-tramp-file-handler operation args)
+          (apply #'url-tramp-file-handler operation args)
         ;; Otherwise, let's do the job.
         (let ((fn (get operation 'url-file-handlers))
-              (val nil)
-              (hooked nil))
-          (if (and (not fn) (intern-soft (format "url-%s" operation))
+              val)
+          (if (and (not fn)
                    (fboundp (intern-soft (format "url-%s" operation))))
               (error "Missing URL handler mapping for %s" operation))
-          (if fn
-              (setq hooked t
-                    val (save-match-data (apply fn args)))
-            (setq hooked nil
-                  val (url-run-real-handler operation args)))
-          (url-debug 'handlers "%s %S%S => %S" (if hooked "Hooked" "Real")
+          (setq val (if fn (save-match-data (apply fn args))
+                      (url-run-real-handler operation args)))
+          (url-debug 'handlers "%s %S%S => %S" (if fn "Hooked" "Real")
                      operation args val)
           val)))))
 
-(defun url-file-handler-identity (&rest args)
-  ;; Identity function
-  (car args))
-
-;; These are operations that we can fully support
-(put 'file-readable-p 'url-file-handlers 'url-file-exists-p)
-(put 'substitute-in-file-name 'url-file-handlers 'url-file-handler-identity)
-(put 'file-name-absolute-p 'url-file-handlers (lambda (&rest ignored) t))
-(put 'expand-file-name 'url-file-handlers 'url-handler-expand-file-name)
-(put 'directory-file-name 'url-file-handlers 'url-handler-directory-file-name)
-(put 'file-name-directory 'url-file-handlers 'url-handler-file-name-directory)
-(put 'unhandled-file-name-directory 'url-file-handlers 'url-handler-unhandled-file-name-directory)
-(put 'file-remote-p 'url-file-handlers 'url-handler-file-remote-p)
-;; (put 'file-name-as-directory 'url-file-handlers 'url-handler-file-name-as-directory)
+(defun url-file-handler-identity (arg &rest _ignored)
+  ;; Identity function.
+  arg)
+
+;; These are operations that we can fully support.
+(put 'file-readable-p 'url-file-handlers #'url-file-exists-p)
+(put 'substitute-in-file-name 'url-file-handlers #'url-file-handler-identity)
+(put 'file-name-absolute-p 'url-file-handlers (lambda (&rest _ignored) t))
+(put 'expand-file-name 'url-file-handlers #'url-handler-expand-file-name)
+(put 'directory-file-name 'url-file-handlers #'url-handler-directory-file-name)
+(put 'file-name-directory 'url-file-handlers #'url-handler-file-name-directory)
+(put 'unhandled-file-name-directory 'url-file-handlers
+     #'url-handler-unhandled-file-name-directory)
+(put 'file-remote-p 'url-file-handlers #'url-handler-file-remote-p)
+;; (put 'file-name-as-directory 'url-file-handlers
+;;      #'url-handler-file-name-as-directory)
 
 ;; These are operations that we do not support yet (DAV!!!)
-(put 'file-writable-p 'url-file-handlers 'ignore)
-(put 'file-symlink-p 'url-file-handlers 'ignore)
+(put 'file-writable-p 'url-file-handlers #'ignore)
+(put 'file-symlink-p 'url-file-handlers #'ignore)
 ;; Just like for ange-ftp: let's not waste time trying to look for RCS/foo,v
 ;; files and such since we can't do anything clever with them anyway.
-(put 'vc-registered 'url-file-handlers 'ignore)
+(put 'vc-registered 'url-file-handlers #'ignore)
 
 (defun url-handler-expand-file-name (file &optional base)
   ;; When we see "/foo/bar" in a file whose working dir is "http://bla/bla",
@@ -215,7 +214,7 @@ the arguments that would have been passed to OPERATION."
 ;; reversible:  (f-n-a-d (d-f-n (f-n-a-d X))) == (f-n-a-d X)
 (defun url-handler-directory-file-name (dir)
   ;; When there's more than a single /, just don't touch the slashes at all.
-  (if (string-match "//\\'" dir) dir
+  (if (string-suffix-p "//" dir) dir
     (url-run-real-handler 'directory-file-name (list dir))))
 
 (defun url-handler-unhandled-file-name-directory (filename)
@@ -257,49 +256,48 @@ the arguments that would have been passed to OPERATION."
       ;; `url-handler-unhandled-file-name-directory'.
       nil)))
 
-;; The actual implementation
+;; The actual implementation.
 ;;;###autoload
-(defun url-copy-file (url newname &optional ok-if-already-exists
-                          _keep-time _preserve-uid-gid _preserve-permissions)
-  "Copy URL to NEWNAME.  Both args must be strings.
-Signal a `file-already-exists' error if file NEWNAME already exists,
-unless a third argument OK-IF-ALREADY-EXISTS is supplied and non-nil.
-A number as third arg means request confirmation if NEWNAME already exists.
-This is what happens in interactive use with M-x.
-Fourth arg KEEP-TIME non-nil means give the new file the same
-last-modified time as the old one.  (This works on only some systems.)
-Args PRESERVE-UID-GID and PRESERVE-PERMISSIONS are ignored.
-A prefix arg makes KEEP-TIME non-nil."
-  (if (and (file-exists-p newname)
-	   (not ok-if-already-exists))
-      (signal 'file-already-exists (list "File exists" newname)))
-  (let ((buffer (url-retrieve-synchronously url))
-	(handle nil))
-    (if (not buffer)
-        (signal 'file-missing (list "Opening URL" "No such file or directory"
-                                    url)))
-    (with-current-buffer buffer
-      (setq handle (mm-dissect-buffer t)))
+(defun url-copy-file (url newname &optional ok-if-already-exists &rest _ignored)
+  "Copy URL to NEWNAME.  Both arguments must be strings.
+Signal a `file-already-exists' error if file NEWNAME already
+exists, unless a third argument OK-IF-ALREADY-EXISTS is supplied
+and non-nil.  An integer as third argument means request
+confirmation if NEWNAME already exists."
+  (and (file-exists-p newname)
+       (or (not ok-if-already-exists)
+           (and (integerp ok-if-already-exists)
+                (not (yes-or-no-p
+                      (format "File %s already exists; copy to it anyway? "
+                              newname)))))
+       (signal 'file-already-exists (list "File already exists" newname)))
+  (let* ((buffer (or (url-retrieve-synchronously url)
+                     (signal 'file-missing
+                             (list "Opening URL"
+                                   "No such file or directory" url))))
+         (handle (with-current-buffer buffer
+                   (mm-dissect-buffer t))))
     (let ((mm-attachment-file-modes (default-file-modes)))
       (mm-save-part-to-file handle newname))
     (kill-buffer buffer)
     (mm-destroy-parts handle)))
-(put 'copy-file 'url-file-handlers 'url-copy-file)
+(put 'copy-file 'url-file-handlers #'url-copy-file)
 
 ;;;###autoload
-(defun url-file-local-copy (url &rest ignored)
+(defun url-file-local-copy (url &rest _ignored)
   "Copy URL into a temporary file on this machine.
 Returns the name of the local copy, or nil, if FILE is directly
 accessible."
   (let ((filename (make-temp-file "url")))
     (url-copy-file url filename 'ok-if-already-exists)
     filename))
-(put 'file-local-copy 'url-file-handlers 'url-file-local-copy)
+(put 'file-local-copy 'url-file-handlers #'url-file-local-copy)
 
 (defun url-insert (buffer &optional beg end)
   "Insert the body of a URL object.
 BUFFER should be a complete URL buffer as returned by `url-retrieve'.
-If the headers specify a coding-system, it is applied to the body before it is inserted.
+If the headers specify a coding-system (and current buffer is multibyte),
+it is applied to the body before it is inserted.
 Returns a list of the form (SIZE CHARSET), where SIZE is the size in bytes
 of the inserted text and CHARSET is the charset that was specified in the header,
 or nil if none was found.
@@ -311,12 +309,13 @@ They count bytes from the beginning of the body."
                      (buffer-substring (+ (point-min) beg)
                                        (if end (+ (point-min) end) (point-max)))
 		   (buffer-string))))
-         (charset (mail-content-type-get (mm-handle-type handle)
-                                          'charset)))
+         (charset (if enable-multibyte-characters
+                      (mail-content-type-get (mm-handle-type handle)
+                                             'charset))))
     (mm-destroy-parts handle)
-    (if charset
-        (insert (mm-decode-string data (mm-charset-to-coding-system charset)))
-      (insert data))
+    (insert (if charset
+                (mm-decode-string data (mm-charset-to-coding-system charset))
+              data))
     (list (length data) charset)))
 
 (defvar url-http-codes)
@@ -328,8 +327,8 @@ This is like `url-insert', but also decodes the current buffer as
 if it had been inserted from a file named URL."
   (if visit (setq buffer-file-name url))
   (save-excursion
-    (let* ((start (point))
-           (size-and-charset (url-insert buffer beg end)))
+    (let ((start (point))
+          (size-and-charset (url-insert buffer beg end)))
       (kill-buffer buffer)
       (when replace
         (delete-region (point-min) start)
@@ -340,42 +339,27 @@ if it had been inserted from a file named URL."
         (decode-coding-inserted-region (point-min) (point) url
                                        visit beg end replace))
       (let ((inserted (car size-and-charset)))
-        (when (fboundp 'after-insert-file-set-coding)
-          (let ((insval (after-insert-file-set-coding inserted visit)))
-            (if insval (setq inserted insval))))
-        (list url inserted)))))
+        (list url (or (and (fboundp 'after-insert-file-set-coding)
+                           (after-insert-file-set-coding inserted visit))
+                      inserted))))))
 
 ;;;###autoload
 (defun url-insert-file-contents (url &optional visit beg end replace)
   (let ((buffer (url-retrieve-synchronously url)))
     (unless buffer (signal 'file-error (list url "No Data")))
-    (with-current-buffer buffer
+    (when (fboundp 'url-http--insert-file-helper)
       ;; XXX: This is HTTP/S specific and should be moved to url-http
       ;; instead.  See bug#17549.
-      (when (bound-and-true-p url-http-response-status)
-        ;; Don't signal an error if VISIT is non-nil, because
-        ;; 'insert-file-contents' doesn't.  This is required to
-        ;; support, e.g., 'browse-url-emacs', which is a fancy way of
-        ;; visiting the HTML source of a URL: in that case, we want to
-        ;; display a file buffer even if the URL does not exist and
-        ;; 'url-retrieve-synchronously' returns 404 or whatever.
-        (unless (or visit
-                    (and (>= url-http-response-status 200)
-                         (< url-http-response-status 300)))
-          (let ((desc (nth 2 (assq url-http-response-status url-http-codes))))
-            (kill-buffer buffer)
-            ;; Signal file-error per bug#16733.
-            (signal 'file-error (list url desc))))))
+      (url-http--insert-file-helper buffer url visit))
     (url-insert-buffer-contents buffer url visit beg end replace)))
-
-(put 'insert-file-contents 'url-file-handlers 'url-insert-file-contents)
+(put 'insert-file-contents 'url-file-handlers #'url-insert-file-contents)
 
 (defun url-file-name-completion (url _directory &optional _predicate)
   ;; Even if it's not implemented, it's not an error to ask for completion,
   ;; in case it's available (bug#14806).
   ;; (error "Unimplemented")
   url)
-(put 'file-name-completion 'url-file-handlers 'url-file-name-completion)
+(put 'file-name-completion 'url-file-handlers #'url-file-name-completion)
 
 (defun url-file-name-all-completions (_file _directory)
   ;; Even if it's not implemented, it's not an error to ask for completion,
@@ -383,7 +367,7 @@ if it had been inserted from a file named URL."
   ;; (error "Unimplemented")
   nil)
 (put 'file-name-all-completions
-     'url-file-handlers 'url-file-name-all-completions)
+     'url-file-handlers #'url-file-name-all-completions)
 
 ;; All other handlers map onto their respective backends.
 (defmacro url-handlers-create-wrapper (method args)
@@ -393,10 +377,10 @@ if it had been inserted from a file named URL."
                 (or (documentation method t) "No original documentation."))
        (setq url (url-generic-parse-url url))
        (when (url-type url)
-         (funcall (url-scheme-get-property (url-type url) (quote ,method))
-                  ,@(remove '&rest (remove '&optional args)))))
+         (funcall (url-scheme-get-property (url-type url) ',method)
+                  ,@(remq '&rest (remq '&optional args)))))
      (unless (get ',method 'url-file-handlers)
-       (put ',method 'url-file-handlers ',(intern (format "url-%s" method))))))
+       (put ',method 'url-file-handlers #',(intern (format "url-%s" method))))))
 
 (url-handlers-create-wrapper file-exists-p (url))
 (url-handlers-create-wrapper file-attributes (url &optional id-format))
@@ -407,12 +391,12 @@ if it had been inserted from a file named URL."
 (url-handlers-create-wrapper directory-files (url &optional full match nosort))
 (url-handlers-create-wrapper file-truename (url &optional counter prev-dirs))
 
-(add-hook 'find-file-hook 'url-handlers-set-buffer-mode)
+(add-hook 'find-file-hook #'url-handlers-set-buffer-mode)
 
 (defun url-handlers-set-buffer-mode ()
   "Set correct modes for the current buffer if visiting a remote file."
-  (and (stringp buffer-file-name)
-       (string-match url-handler-regexp buffer-file-name)
+  (and buffer-file-name
+       (string-match-p url-handler-regexp buffer-file-name)
        (auto-save-mode 0)))
 
 (provide 'url-handlers)
diff --git a/lisp/url/url-http.el b/lisp/url/url-http.el
index 662b6664b1..00803a103a 100644
--- a/lisp/url/url-http.el
+++ b/lisp/url/url-http.el
@@ -530,6 +530,23 @@ work correctly."
 (declare-function gnutls-peer-status "gnutls.c" (proc))
 (declare-function gnutls-negotiate "gnutls.el" t t)
 
+(defun url-http--insert-file-helper (buffer url &optional visit)
+  (with-current-buffer buffer
+    (when (bound-and-true-p url-http-response-status)
+      ;; Don't signal an error if VISIT is non-nil, because
+      ;; 'insert-file-contents' doesn't.  This is required to
+      ;; support, e.g., 'browse-url-emacs', which is a fancy way of
+      ;; visiting the HTML source of a URL: in that case, we want to
+      ;; display a file buffer even if the URL does not exist and
+      ;; 'url-retrieve-synchronously' returns 404 or whatever.
+      (unless (or visit
+                  (and (>= url-http-response-status 200)
+                       (< url-http-response-status 300)))
+        (let ((desc (nth 2 (assq url-http-response-status url-http-codes))))
+          (kill-buffer buffer)
+          ;; Signal file-error per bug#16733.
+          (signal 'file-error (list url desc)))))))
+
 (defun url-http-parse-headers ()
  "Parse and handle HTTP specific headers.
 Return t if and only if the current buffer is still active and
@@ -1080,10 +1097,16 @@ the end of the document."
 	  (if no-initial-crlf (skip-chars-forward "\r\n"))
 	  (if (not (looking-at regexp))
 	      (progn
-	   ;; Must not have received the entirety of the chunk header,
+	        ;; Must not have received the entirety of the chunk header,
 		;; need to spin some more.
 		(url-http-debug "Did not see start of chunk @ %d!" (point))
 		(setq read-next-chunk nil))
+            ;; The data we got may have started in the middle of the
+            ;; initial chunk header, so move back to the start of the
+            ;; line and re-compute.
+            (when (= url-http-chunked-counter 0)
+              (beginning-of-line)
+              (looking-at regexp))
  	    (add-text-properties (match-beginning 0) (match-end 0)
 				 (list 'start-open t
 				       'end-open t
@@ -1099,8 +1122,7 @@ the end of the document."
 					  (or url-http-chunked-start
 					      (make-marker))
 					  (match-end 0)))
-;	    (if (not url-http-debug)
-		(delete-region (match-beginning 0) (match-end 0));)
+	    (delete-region (match-beginning 0) (match-end 0))
 	    (url-http-debug "Saw start of chunk %d (length=%d, start=%d"
 			    url-http-chunked-counter url-http-chunked-length
 			    (marker-position url-http-chunked-start))
diff --git a/lisp/url/url-util.el b/lisp/url/url-util.el
index 5b8350642f..a46e7bb385 100644
--- a/lisp/url/url-util.el
+++ b/lisp/url/url-util.el
@@ -543,6 +543,7 @@ This uses `url-current-object', set locally to the buffer."
 (defun url-get-url-at-point (&optional pt)
   "Get the URL closest to point, but don't change position.
 Has a preference for looking backward when not directly on a symbol."
+  (declare (obsolete thing-at-point-url-at-point "27.1"))
   ;; Not at all perfect - point must be right in the name.
   (save-excursion
     (if pt (goto-char pt))
diff --git a/lisp/url/url.el b/lisp/url/url.el
index ed0947795b..5242d42f04 100644
--- a/lisp/url/url.el
+++ b/lisp/url/url.el
@@ -136,9 +136,11 @@ STATUS is a plist representing what happened during the request,
 with most recent events first, or an empty list if no events have
 occurred.  Each pair is one of:
 
-\(:redirect REDIRECTED-TO) - the request was redirected to this URL
-\(:error (ERROR-SYMBOL . DATA)) - an error occurred.  The error can be
-signaled with (signal ERROR-SYMBOL DATA).
+\(:redirect REDIRECTED-TO) - the request was redirected to this URL.
+
+\(:error (error type . DATA)) - an error occurred.  TYPE is a
+symbol that says something about where the error occurred, and
+DATA is a list (possibly nil) that describes the error further.
 
 Return the buffer URL will load into, or nil if the process has
 already completed (i.e. URL was a mailto URL or similar; in this case
diff --git a/lisp/vc/diff-mode.el b/lisp/vc/diff-mode.el
index 1d5a2cf69a..0d5dc0e1c0 100644
--- a/lisp/vc/diff-mode.el
+++ b/lisp/vc/diff-mode.el
@@ -283,6 +283,14 @@ well."
 ;;;; font-lock support
 ;;;;
 
+;; Note: The colors used in a color-rich environments (a GUI or in a
+;; terminal supporting 24 bit colors) doesn't render well in terminal
+;; supporting only 256 colors.  Concretely, both #ffeeee
+;; (diff-removed) and #eeffee (diff-added) are mapped to the same
+;; greyish color.  "min-colors 257" ensures that those colors are not
+;; used terminals supporting only 256 colors.  However, any number
+;; between 257 and 2^24 (16777216) would do.
+
 (defface diff-header
   '((((class color) (min-colors 88) (background light))
      :background "grey85")
@@ -314,8 +322,10 @@ well."
 (defface diff-removed
   '((default
      :inherit diff-changed)
-    (((class color) (min-colors 88) (background light))
+    (((class color) (min-colors 257) (background light))
      :background "#ffeeee")
+    (((class color) (min-colors 88) (background light))
+     :background "#ffdddd")
     (((class color) (min-colors 88) (background dark))
      :background "#553333")
     (((class color))
@@ -325,8 +335,10 @@ well."
 (defface diff-added
   '((default
      :inherit diff-changed)
-    (((class color) (min-colors 88) (background light))
+    (((class color) (min-colors 257) (background light))
      :background "#eeffee")
+    (((class color) (min-colors 88) (background light))
+     :background "#ddffdd")
     (((class color) (min-colors 88) (background dark))
      :background "#335533")
     (((class color))
@@ -2040,8 +2052,10 @@ For use in `add-log-current-defun-function'."
 (defface diff-refine-removed
   '((default
      :inherit diff-refine-changed)
-    (((class color) (min-colors 88) (background light))
+    (((class color) (min-colors 257) (background light))
      :background "#ffcccc")
+    (((class color) (min-colors 88) (background light))
+     :background "#ffbbbb")
     (((class color) (min-colors 88) (background dark))
      :background "#aa2222"))
   "Face used for removed characters shown by `diff-refine-hunk'."
@@ -2050,8 +2064,10 @@ For use in `add-log-current-defun-function'."
 (defface diff-refine-added
   '((default
      :inherit diff-refine-changed)
-    (((class color) (min-colors 88) (background light))
+    (((class color) (min-colors 257) (background light))
      :background "#bbffbb")
+    (((class color) (min-colors 88) (background light))
+     :background "#aaffaa")
     (((class color) (min-colors 88) (background dark))
      :background "#22aa22"))
   "Face used for added characters shown by `diff-refine-hunk'."
@@ -2439,6 +2455,7 @@ When OLD is non-nil, highlight the hunk from the old source."
            (when (and diff-vc-backend
                       (not (eq diff-font-lock-syntax 'hunk-only)))
              (let* ((file (diff-find-file-name old t))
+                    (file (and file (expand-file-name file)))
                     (revision (and file (if (not old) (nth 1 diff-vc-revisions)
                                           (or (nth 0 diff-vc-revisions)
                                               (vc-working-revision file))))))
@@ -2447,7 +2464,7 @@ When OLD is non-nil, highlight the hunk from the old source."
                      ;; Get properties from the current working revision
                      (when (and (not old) (file-readable-p file)
                                 (file-regular-p file))
-                       (let ((buf (get-file-buffer (expand-file-name file))))
+                       (let ((buf (get-file-buffer file)))
                          ;; Try to reuse an existing buffer
                          (if buf
                              (with-current-buffer buf
@@ -2460,13 +2477,13 @@ When OLD is non-nil, highlight the hunk from the old source."
                                    ;; Same file as last-time, unmodified.
                                    ;; Reuse buffer as-is.
                                    (setq file nil)
+                                 (erase-buffer)
                                  (insert-file-contents file)
                                  (setq diff--syntax-file-attributes attrs)))
                              (diff-syntax-fontify-props file text line-nb)))))
                    ;; Get properties from a cached revision
                    (let* ((buffer-name (format " *diff-syntax:%s.~%s~*"
-                                               (expand-file-name file)
-                                               revision))
+                                               file revision))
                           (buffer (get-buffer buffer-name)))
                      (if buffer
                          ;; Don't re-initialize the buffer (which would throw
@@ -2474,7 +2491,7 @@ When OLD is non-nil, highlight the hunk from the old source."
                          (setq file nil)
                        (setq buffer (ignore-errors
                                       (vc-find-revision-no-save
-                                       (expand-file-name file) revision
+                                       file revision
                                        diff-vc-backend
                                        (get-buffer-create buffer-name)))))
                      (when buffer
diff --git a/lisp/vc/ediff-ptch.el b/lisp/vc/ediff-ptch.el
index 4178b5a8c0..70c03b5c01 100644
--- a/lisp/vc/ediff-ptch.el
+++ b/lisp/vc/ediff-ptch.el
@@ -297,11 +297,24 @@ program."
 	      ;; file names. This is a heuristic intended to improve guessing
 	      (let ((default-directory (file-name-directory filename)))
 		(unless (or (file-name-absolute-p base-dir1)
-			    (file-name-absolute-p base-dir2)
-			    (not (file-exists-p base-dir1))
-			    (not (file-exists-p base-dir2)))
-		  (setq base-dir1 ""
-			base-dir2 "")))
+			    (file-name-absolute-p base-dir2))
+		  (if (and (file-exists-p base-dir1)
+			   (file-exists-p base-dir2))
+		      (setq base-dir1 ""
+			    base-dir2 "")
+		    ;; Strip possible source/destination prefixes
+		    ;; such as a/ and b/ from dir names.
+		    (save-match-data
+		      (let ((m1 (when (string-match "^[^/]+/" base-dir1)
+                                  (cons (substring base-dir1 0 (match-end 0))
+                                        (substring base-dir1 (match-end 0)))))
+			    (m2 (when (string-match "^[^/]+/" base-dir2)
+				  (cons (substring base-dir2 0 (match-end 0))
+                                        (substring base-dir2 (match-end 0))))))
+			(when (and (file-exists-p (cdr m1))
+				   (file-exists-p (cdr m2)))
+			  (setq base-dir1 (car m1)
+				base-dir2 (car m2))))))))
 	      (or (string= (car proposed-file-names) "/dev/null")
 		  (setcar proposed-file-names
 			  (ediff-file-name-sans-prefix
@@ -325,8 +338,8 @@ program."
     (mapc (lambda (session-info)
 	    (let ((proposed-file-names
 		   (ediff-get-session-objA-name session-info)))
-	      (if (and (string-match "^/null/" (car proposed-file-names))
-		       (string-match "^/null/" (cdr proposed-file-names)))
+	      (if (and (string-match-p "^/null/" (car proposed-file-names))
+		       (string-match-p "^/null/" (cdr proposed-file-names)))
 		  ;; couldn't intuit the file name to patch, so
 		  ;; something is amiss
 		  (progn
@@ -574,7 +587,7 @@ optional argument, then use it."
 	(ediff-patch-file-internal
 	 patch-buf
 	 (if (and ediff-patch-map
-		  (not (string-match
+		  (not (string-match-p
 			"^/dev/null"
 			;; this is the file to patch
 			(ediff-get-session-objA-name (car ediff-patch-map))))
@@ -677,7 +690,7 @@ optional argument, then use it."
 	 target-buf buf-to-patch file-name-magic-p
 	 patch-return-code ctl-buf backup-style aux-wind)
 
-    (if (string-match "V" ediff-patch-options)
+    (if (string-match-p "V" ediff-patch-options)
 	(error
 	 "Ediff doesn't take the -V option in `ediff-patch-options'--sorry"))
 
diff --git a/lisp/vc/log-edit.el b/lisp/vc/log-edit.el
index 42710dd8dc..91e18c1ec5 100644
--- a/lisp/vc/log-edit.el
+++ b/lisp/vc/log-edit.el
@@ -754,7 +754,9 @@ regardless of user name or time."
 	     (log-edit-insert-changelog-entries (log-edit-files)))))
       (log-edit-set-common-indentation)
       ;; Add an Author: field if appropriate.
-      (when author (log-edit-add-field "Author" (car author)))
+      (when author
+        (log-edit-add-field "Author" (car author))
+        (log-edit-add-field "Summary" ""))
       ;; Add a Fixes: field if applicable.
       (when (consp log-edit-rewrite-fixes)
 	(rfc822-goto-eoh)
@@ -1085,6 +1087,22 @@ line of MSG."
       (if summary (insert summary "\n\n"))
       (cons (buffer-string) res))))
 
+(defun log-edit--toggle-amend (last-msg-fn)
+  (when (log-edit-toggle-header "Amend" "yes")
+    (goto-char (point-max))
+    (unless (bolp) (insert "\n"))
+    (insert (funcall last-msg-fn))
+    (save-excursion
+      (rfc822-goto-eoh)
+      (forward-line 1)
+      (let ((pt (point)))
+        (and (zerop (forward-line 1))
+             (looking-at "\n\\|\\'")
+             (let ((summary (buffer-substring-no-properties pt (1- (point)))))
+               (skip-chars-forward " \n")
+               (delete-region pt (point))
+               (log-edit-set-header "Summary" summary)))))))
+
 (provide 'log-edit)
 
 ;;; log-edit.el ends here
diff --git a/lisp/vc/log-view.el b/lisp/vc/log-view.el
index e47fad8908..0b57e1d508 100644
--- a/lisp/vc/log-view.el
+++ b/lisp/vc/log-view.el
@@ -585,6 +585,13 @@ point, get the diff between the revision at point and its
 previous revision.  Otherwise, get the diff between the revisions
 where the region starts and ends.
 
+When the beginning of the region is on the top line that has no revision,
+use the current working revision as the first revision to compare.
+
+When the end of the region is on the bottom non-revision line after
+the last revision line, use the previous revision of the last
+displayed revision as the second revision to compare.
+
 Unlike `log-view-diff-changeset', this function only shows the
 part of the changeset which affected the currently considered
 file(s)."
@@ -600,6 +607,13 @@ point, get the diff between the revision at point and its
 previous revision.  Otherwise, get the diff between the revisions
 where the region starts and ends.
 
+When the beginning of the region is on the top line that has no revision,
+use the current working revision as the first revision to compare.
+
+When the end of the region is on the bottom non-revision line after
+the last revision line, use the previous revision of the last
+displayed revision as the second revision to compare.
+
 Unlike `log-view-diff' this function shows the whole changeset,
 including changes affecting other files than the currently
 considered file(s)."
@@ -618,10 +632,11 @@ considered file(s)."
     ;; When TO and FR are the same, or when point is on a line after
     ;; the last entry, look at the previous revision.
     (when (or (string-equal fr to)
-              (>= (point)
+              (>= end
                   (save-excursion
-                    (goto-char (car fr-entry))
-                    (forward-line))))
+                    (goto-char end)
+                    (log-view-end-of-defun)
+                    (point))))
       (setq fr (vc-call-backend log-view-vc-backend 'previous-revision nil fr)))
     (vc-diff-internal
      t (list log-view-vc-backend
diff --git a/lisp/vc/vc-annotate.el b/lisp/vc/vc-annotate.el
index 84838135fc..2cc0f3c40a 100644
--- a/lisp/vc/vc-annotate.el
+++ b/lisp/vc/vc-annotate.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1997-1998, 2000-2019 Free Software Foundation, Inc.
 
-;; Author:     Martin Lorentzson  <emwson@emw.ericsson.se>
+;; Author: Martin Lorentzson <emwson@emw.ericsson.se>
 ;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: vc tools
 ;; Package: vc
diff --git a/lisp/vc/vc-bzr.el b/lisp/vc/vc-bzr.el
index ab5a449cd3..ee1646cae5 100644
--- a/lisp/vc/vc-bzr.el
+++ b/lisp/vc/vc-bzr.el
@@ -702,7 +702,7 @@ or a superior directory.")
   (remove-hook 'log-view-mode-hook 'vc-bzr-log-view-mode) ;Deactivate the hack.
   (require 'add-log)
   (set (make-local-variable 'log-view-per-file-logs) nil)
-  (set (make-local-variable 'log-view-file-re) "\\`a\\`")
+  (set (make-local-variable 'log-view-file-re) regexp-unmatchable)
   (set (make-local-variable 'log-view-message-re)
        (if (eq vc-log-view-type 'short)
 	   "^ *\\([0-9.]+\\): \\(.*?\\)[ \t]+\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\)\\( \\[merge\\]\\)?"
@@ -1319,7 +1319,8 @@ stream.  Standard error output is discarded."
      ((string-match "\\`annotate:" string)
       (completion-table-with-context
        (substring string 0 (match-end 0))
-       (apply-partially #'completion-table-with-terminator '(":" . "\\`a\\`")
+       (apply-partially #'completion-table-with-terminator
+                        (cons ":" regexp-unmatchable)
                         #'completion-file-name-table)
        (substring string (match-end 0)) pred action))
 
diff --git a/lisp/vc/vc-cvs.el b/lisp/vc/vc-cvs.el
index 626e190c1e..6fb5fa09c7 100644
--- a/lisp/vc/vc-cvs.el
+++ b/lisp/vc/vc-cvs.el
@@ -2,8 +2,7 @@
 
 ;; Copyright (C) 1995, 1998-2019 Free Software Foundation, Inc.
 
-;; Author:      FSF (see vc.el for full credits)
-;; Maintainer:  emacs-devel@gnu.org
+;; Author: FSF (see vc.el for full credits)
 ;; Package: vc
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/vc/vc-dav.el b/lisp/vc/vc-dav.el
index d0b202cd5f..693056c2b9 100644
--- a/lisp/vc/vc-dav.el
+++ b/lisp/vc/vc-dav.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2001, 2004-2019 Free Software Foundation, Inc.
 
 ;; Author: Bill Perry <wmperry@gnu.org>
-;; Maintainer: Bill Perry <wmperry@gnu.org>
 ;; Keywords: url, vc
 ;; Package: vc
 
diff --git a/lisp/vc/vc-dir.el b/lisp/vc/vc-dir.el
index 75697e389a..6afc599d4c 100644
--- a/lisp/vc/vc-dir.el
+++ b/lisp/vc/vc-dir.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-;; Author:   Dan Nicolaescu <dann@ics.uci.edu>
+;; Author: Dan Nicolaescu <dann@ics.uci.edu>
 ;; Keywords: vc tools
 ;; Package: vc
 
diff --git a/lisp/vc/vc-dispatcher.el b/lisp/vc/vc-dispatcher.el
index edbb83f3df..40c392b21d 100644
--- a/lisp/vc/vc-dispatcher.el
+++ b/lisp/vc/vc-dispatcher.el
@@ -2,8 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author:     FSF (see below for full credits)
-;; Maintainer: emacs-devel@gnu.org
+;; Author: FSF (see below for full credits)
 ;; Keywords: vc tools
 ;; Package: vc
 
@@ -324,7 +323,8 @@ case, and the process object in the asynchronous case."
 		       (apply 'start-file-process command (current-buffer)
                               command squeezed))))
 		(when vc-command-messages
-		  (message "Running in background: %s" full-command))
+		  (let ((inhibit-message (eq (selected-window) (active-minibuffer-window))))
+		    (message "Running in background: %s" full-command)))
                 ;; Get rid of the default message insertion, in case we don't
                 ;; set a sentinel explicitly.
 		(set-process-sentinel proc #'ignore)
@@ -332,11 +332,13 @@ case, and the process object in the asynchronous case."
 		(setq status proc)
 		(when vc-command-messages
 		  (vc-run-delayed
-		    (let ((message-truncate-lines t))
+		    (let ((message-truncate-lines t)
+			  (inhibit-message (eq (selected-window) (active-minibuffer-window))))
 		      (message "Done in background: %s" full-command)))))
 	    ;; Run synchronously
 	    (when vc-command-messages
-	      (message "Running in foreground: %s" full-command))
+	      (let ((inhibit-message (eq (selected-window) (active-minibuffer-window))))
+		(message "Running in foreground: %s" full-command)))
 	    (let ((buffer-undo-list t))
 	      (setq status (apply 'process-file command nil t nil squeezed)))
 	    (when (and (not (eq t okstatus))
@@ -350,7 +352,8 @@ case, and the process object in the asynchronous case."
 		     (if (integerp status) (format "status %d" status) status)
 		     full-command))
 	    (when vc-command-messages
-	      (message "Done (status=%d): %s" status full-command))))
+	      (let ((inhibit-message (eq (selected-window) (active-minibuffer-window))))
+		(message "Done (status=%d): %s" status full-command)))))
 	(vc-run-delayed
 	  (run-hook-with-args 'vc-post-command-functions
 			      command file-or-list flags))
diff --git a/lisp/vc/vc-filewise.el b/lisp/vc/vc-filewise.el
index f05e8efff9..c1cf1c2fea 100644
--- a/lisp/vc/vc-filewise.el
+++ b/lisp/vc/vc-filewise.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1992-1996, 1998-2019 Free Software Foundation, Inc.
 
-;; Author:     FSF (see vc.el for full credits)
+;; Author: FSF (see vc.el for full credits)
 ;; Maintainer: emacs-devel@gnu.org
 ;; Package: vc
 
diff --git a/lisp/vc/vc-git.el b/lisp/vc/vc-git.el
index a921ff1bb8..b6feb3b8d1 100644
--- a/lisp/vc/vc-git.el
+++ b/lisp/vc/vc-git.el
@@ -750,7 +750,7 @@ The car of the list is the current branch."
 (declare-function log-edit-mode "log-edit" ())
 (declare-function log-edit-toggle-header "log-edit" (header value))
 (declare-function log-edit-extract-headers "log-edit" (headers string))
-(declare-function log-edit-set-header "log-edit" (header value &optional toggle))
+(declare-function log-edit--toggle-amend "log-edit" (last-msg-fn))
 
 (defun vc-git-log-edit-toggle-signoff ()
   "Toggle whether to add the \"Signed-off-by\" line at the end of
@@ -767,23 +767,12 @@ the commit message."
   "Toggle whether this will amend the previous commit.
 If toggling on, also insert its message into the buffer."
   (interactive)
-  (when (log-edit-toggle-header "Amend" "yes")
-    (goto-char (point-max))
-    (unless (bolp) (insert "\n"))
-    (insert (with-output-to-string
-              (vc-git-command
-               standard-output 1 nil
-               "log" "--max-count=1" "--pretty=format:%B" "HEAD")))
-    (save-excursion
-      (rfc822-goto-eoh)
-      (forward-line 1)
-      (let ((pt (point)))
-        (and (zerop (forward-line 1))
-             (looking-at "\n\\|\\'")
-             (let ((summary (buffer-substring-no-properties pt (1- (point)))))
-               (skip-chars-forward " \n")
-               (delete-region pt (point))
-               (log-edit-set-header "Summary" summary)))))))
+  (log-edit--toggle-amend
+   (lambda ()
+     (with-output-to-string
+       (vc-git-command
+        standard-output 1 nil
+        "log" "--max-count=1" "--pretty=format:%B" "HEAD")))))
 
 (defvar vc-git-log-edit-mode-map
   (let ((map (make-sparse-keymap "Git-Log-Edit")))
@@ -1028,8 +1017,8 @@ If LIMIT is a revision string, use it as an end-revision."
     ;; If the buffer exists from a previous invocation it might be
     ;; read-only.
     (let ((inhibit-read-only t))
-      (with-current-buffer
-          buffer
+      (with-current-buffer buffer
+	(insert "\n")
 	(apply 'vc-git-command buffer
 	       'async files
 	       (append
@@ -1098,7 +1087,7 @@ If LIMIT is a revision string, use it as an end-revision."
 (define-derived-mode vc-git-log-view-mode log-view-mode "Git-Log-View"
   (require 'add-log) ;; We need the faces add-log.
   ;; Don't have file markers, so use impossible regexp.
-  (set (make-local-variable 'log-view-file-re) "\\`a\\`")
+  (set (make-local-variable 'log-view-file-re) regexp-unmatchable)
   (set (make-local-variable 'log-view-per-file-logs) nil)
   (set (make-local-variable 'log-view-message-re)
        (if (not (eq vc-log-view-type 'long))
diff --git a/lisp/vc/vc-hg.el b/lisp/vc/vc-hg.el
index 6b17e861dd..876d824cea 100644
--- a/lisp/vc/vc-hg.el
+++ b/lisp/vc/vc-hg.el
@@ -444,7 +444,7 @@ If LIMIT is non-nil, show no more than this many entries."
 
 (define-derived-mode vc-hg-log-view-mode log-view-mode "Hg-Log-View"
   (require 'add-log) ;; we need the add-log faces
-  (set (make-local-variable 'log-view-file-re) "\\`a\\`")
+  (set (make-local-variable 'log-view-file-re) regexp-unmatchable)
   (set (make-local-variable 'log-view-per-file-logs) nil)
   (set (make-local-variable 'log-view-message-re)
        (if (eq vc-log-view-type 'short)
@@ -1104,15 +1104,42 @@ hg binary."
   (vc-hg-command nil 0 file "forget"))
 
 (declare-function log-edit-extract-headers "log-edit" (headers string))
+(declare-function log-edit-mode "log-edit" ())
+(declare-function log-edit--toggle-amend "log-edit" (last-msg-fn))
+
+(defun vc-hg-log-edit-toggle-amend ()
+  "Toggle whether this will amend the previous commit.
+If toggling on, also insert its message into the buffer."
+  (interactive)
+  (log-edit--toggle-amend
+   (lambda ()
+     (with-output-to-string
+       (vc-hg-command
+        standard-output 1 nil
+        "log" "--limit=1" "--template" "{desc}")))))
+
+(defvar vc-hg-log-edit-mode-map
+  (let ((map (make-sparse-keymap "Hg-Log-Edit")))
+    (define-key map "\C-c\C-e" 'vc-hg-log-edit-toggle-amend)
+    map))
+
+(define-derived-mode vc-hg-log-edit-mode log-edit-mode "Log-Edit/hg"
+  "Major mode for editing Hg log messages.
+It is based on `log-edit-mode', and has Hg-specific extensions.")
 
 (defun vc-hg-checkin (files comment &optional _rev)
   "Hg-specific version of `vc-backend-checkin'.
 REV is ignored."
-  (apply 'vc-hg-command nil 0 files
-         (nconc (list "commit" "-m")
-                (log-edit-extract-headers '(("Author" . "--user")
-					    ("Date" . "--date"))
-                                          comment))))
+  (let ((amend-extract-fn
+         (lambda (value)
+           (when (equal value "yes")
+             (list "--amend")))))
+    (apply 'vc-hg-command nil 0 files
+           (nconc (list "commit" "-m")
+                  (log-edit-extract-headers `(("Author" . "--user")
+                                              ("Date" . "--date")
+                                              ("Amend" . ,amend-extract-fn))
+                                            comment)))))
 
 (defun vc-hg-find-revision (file rev buffer)
   (let ((coding-system-for-read 'binary)
diff --git a/lisp/vc/vc-hooks.el b/lisp/vc/vc-hooks.el
index 07b3d86b51..2d9187642c 100644
--- a/lisp/vc/vc-hooks.el
+++ b/lisp/vc/vc-hooks.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1992-1996, 1998-2019 Free Software Foundation, Inc.
 
-;; Author:     FSF (see vc.el for full credits)
+;; Author: FSF (see vc.el for full credits)
 ;; Maintainer: emacs-devel@gnu.org
 ;; Package: vc
 
diff --git a/lisp/vc/vc-mtn.el b/lisp/vc/vc-mtn.el
index f0b12489c1..91cc28021c 100644
--- a/lisp/vc/vc-mtn.el
+++ b/lisp/vc/vc-mtn.el
@@ -240,7 +240,7 @@ If LIMIT is non-nil, show no more than this many entries."
 
 (define-derived-mode vc-mtn-log-view-mode log-view-mode "Mtn-Log-View"
   ;; Don't match anything.
-  (set (make-local-variable 'log-view-file-re) "\\`a\\`")
+  (set (make-local-variable 'log-view-file-re) regexp-unmatchable)
   (set (make-local-variable 'log-view-per-file-logs) nil)
   ;; TODO: Use a more precise regexp than "[ |/]+" to avoid false positives
   ;; in the ChangeLog text.
diff --git a/lisp/vc/vc-rcs.el b/lisp/vc/vc-rcs.el
index 598e98250a..d4485d88e4 100644
--- a/lisp/vc/vc-rcs.el
+++ b/lisp/vc/vc-rcs.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1992-2019 Free Software Foundation, Inc.
 
-;; Author:     FSF (see vc.el for full credits)
+;; Author: FSF (see vc.el for full credits)
 ;; Maintainer: emacs-devel@gnu.org
 ;; Package: vc
 
diff --git a/lisp/vc/vc-sccs.el b/lisp/vc/vc-sccs.el
index 4e9f5a025f..805e738f7a 100644
--- a/lisp/vc/vc-sccs.el
+++ b/lisp/vc/vc-sccs.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1992-2019 Free Software Foundation, Inc.
 
-;; Author:     FSF (see vc.el for full credits)
+;; Author: FSF (see vc.el for full credits)
 ;; Maintainer: emacs-devel@gnu.org
 ;; Package: vc
 
diff --git a/lisp/vc/vc-src.el b/lisp/vc/vc-src.el
index f8475925b0..eb97a9aa5e 100644
--- a/lisp/vc/vc-src.el
+++ b/lisp/vc/vc-src.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1992-2019 Free Software Foundation, Inc.
 
-;; Author:     FSF (see vc.el for full credits)
+;; Author: FSF (see vc.el for full credits)
 ;; Maintainer: emacs-devel@gnu.org
 ;; Package: vc
 
diff --git a/lisp/vc/vc.el b/lisp/vc/vc.el
index b992a8ebe0..eb6d6d331f 100644
--- a/lisp/vc/vc.el
+++ b/lisp/vc/vc.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 1992-1998, 2000-2019 Free Software Foundation, Inc.
 
-;; Author:     FSF (see below for full credits)
+;; Author: FSF (see below for full credits)
 ;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: vc tools
 
diff --git a/lisp/vcursor.el b/lisp/vcursor.el
index 3e8b6ee838..9047936f56 100644
--- a/lisp/vcursor.el
+++ b/lisp/vcursor.el
@@ -3,7 +3,7 @@
 ;; Copyright (C) 1994, 1996, 1998, 2001-2019 Free Software Foundation,
 ;; Inc.
 
-;; Author:   Peter Stephenson <pws@ibmth.df.unipi.it>
+;; Author: Peter Stephenson <pws@ibmth.df.unipi.it>
 ;; Maintainer: emacs-devel@gnu.org
 ;; Keywords: virtual cursor, convenience
 
diff --git a/lisp/vt-control.el b/lisp/vt-control.el
index 7175095d40..ee2463475e 100644
--- a/lisp/vt-control.el
+++ b/lisp/vt-control.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 1993-1994, 2001-2019 Free Software Foundation, Inc.
 
 ;; Author: Rob Riepel <riepel@networking.stanford.edu>
-;; Maintainer: Rob Riepel <riepel@networking.stanford.edu>
 ;; Keywords: terminals
 
 ;; This file is part of GNU Emacs.
diff --git a/lisp/w32-fns.el b/lisp/w32-fns.el
index 8762fe772b..443a995cb8 100644
--- a/lisp/w32-fns.el
+++ b/lisp/w32-fns.el
@@ -305,6 +305,9 @@ names."
 
 ;;;; System name and version for emacsbug.el
 
+(declare-function w32-version "w32-win" ())
+(declare-function w32-read-registry "w32fns" (root key name))
+
 (defun w32--os-description ()
   "Return a string describing the underlying OS and its version."
   (let* ((w32ver (car (w32-version)))
diff --git a/lisp/wdired.el b/lisp/wdired.el
index acc62e4e39..d2a298bd25 100644
--- a/lisp/wdired.el
+++ b/lisp/wdired.el
@@ -612,14 +612,23 @@ Optional arguments are ignored."
         (when (re-search-forward
                directory-listing-before-filename-regexp lep t)
           (setq beg (point)
-                ;; If the file is a symlink, put the dired-filename
-                ;; property only on the link name.  (Using
-                ;; (file-symlink-p (dired-get-filename)) fails in
-                ;; wdired-mode, bug#32673.)
-                end (if (and (re-search-backward
-                              dired-permission-flags-regexp nil t)
-                             (looking-at "l")
-                             (search-forward " -> " lep t))
+                end (if (or
+                         ;; If the file is a symlink, put the
+                         ;; dired-filename property only on the link
+                         ;; name.  (Using (file-symlink-p
+                         ;; (dired-get-filename)) fails in
+                         ;; wdired-mode, bug#32673.)
+                         (and (re-search-backward
+                               dired-permission-flags-regexp nil t)
+                              (looking-at "l")
+                              (search-forward " -> " lep t))
+                         ;; When dired-listing-switches includes "F"
+                         ;; or "classify", don't treat appended
+                         ;; indicator characters as part of the file
+                         ;; name (bug#34915).
+                         (and (dired-check-switches dired-actual-switches
+                                                    "F" "classify")
+                              (re-search-forward "[*/@|=>]$" lep t)))
                         (goto-char (match-beginning 0))
                       lep))
           (put-text-property beg end 'dired-filename t))))))
diff --git a/lisp/whitespace.el b/lisp/whitespace.el
index 2463e655b1..d0368b54a8 100644
--- a/lisp/whitespace.el
+++ b/lisp/whitespace.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2000-2019 Free Software Foundation, Inc.
 
 ;; Author: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
-;; Maintainer: Vinicius Jose Latorre <viniciusjl.gnu@gmail.com>
 ;; Keywords: data, wp
 ;; Version: 13.2.2
 ;; X-URL: http://www.emacswiki.org/cgi-bin/wiki/ViniciusJoseLatorre
diff --git a/lisp/wid-edit.el b/lisp/wid-edit.el
index b9f98cdc4c..382eeb8925 100644
--- a/lisp/wid-edit.el
+++ b/lisp/wid-edit.el
@@ -252,7 +252,10 @@ minibuffer."
 	   (define-key map [?\M--] 'negative-argument)
 	   (save-window-excursion
 	     (let ((buf (get-buffer " widget-choose")))
-	       (fit-window-to-buffer (display-buffer buf))
+	       (display-buffer buf
+			       '(display-buffer-in-direction
+				 (direction . bottom)
+				 (window-height . fit-window-to-buffer)))
 	       (let ((cursor-in-echo-area t)
 		     (arg 1))
                  (while (not value)
diff --git a/lisp/windmove.el b/lisp/windmove.el
index 0853f7ec7f..ab47565dfa 100644
--- a/lisp/windmove.el
+++ b/lisp/windmove.el
@@ -596,12 +596,25 @@ When `switch-to-buffer-obey-display-actions' is non-nil,
          (old-window (or (minibuffer-selected-window) (selected-window)))
          (new-window)
          (minibuffer-depth (minibuffer-depth))
-         (action display-buffer-overriding-action)
+         (action (lambda (buffer alist)
+                   (unless (> (minibuffer-depth) minibuffer-depth)
+                     (let ((window (if (eq dir 'same-window)
+                                       (selected-window)
+                                     (window-in-direction
+                                      dir nil nil
+                                      (and arg (prefix-numeric-value arg))
+                                      windmove-wrap-around)))
+                           (type 'reuse))
+                       (unless window
+                         (setq window (split-window nil nil dir) type 'window))
+                       (setq new-window (window--display-buffer buffer window
+                                                                type alist))))))
          (command this-command)
          (clearfun (make-symbol "clear-display-buffer-overriding-action"))
          (exitfun
           (lambda ()
-            (setq display-buffer-overriding-action action)
+            (setq display-buffer-overriding-action
+                  (delq action display-buffer-overriding-action))
             (when (window-live-p (if no-select old-window new-window))
               (select-window (if no-select old-window new-window)))
             (remove-hook 'post-command-hook clearfun))))
@@ -616,19 +629,7 @@ When `switch-to-buffer-obey-display-actions' is non-nil,
 		     (eq this-command command))
               (funcall exitfun))))
     (add-hook 'post-command-hook clearfun)
-    (push (lambda (buffer alist)
-	    (unless (> (minibuffer-depth) minibuffer-depth)
-	      (let ((window (if (eq dir 'same-window)
-			        (selected-window)
-                              (window-in-direction
-                               dir nil nil
-                               (and arg (prefix-numeric-value arg))
-                               windmove-wrap-around)))
-                    (type 'reuse))
-                (unless window
-                  (setq window (split-window nil nil dir) type 'window))
-		(setq new-window (window--display-buffer buffer window type alist)))))
-          display-buffer-overriding-action)
+    (push action display-buffer-overriding-action)
     (message "[display-%s]" dir)))
 
 ;;;###autoload
diff --git a/lisp/window.el b/lisp/window.el
index b4f5ac5cc4..2c9d177d0a 100644
--- a/lisp/window.el
+++ b/lisp/window.el
@@ -7534,6 +7534,152 @@ be added to ALIST."
       (unless (cdr (assq 'inhibit-switch-frame alist))
 	(window--maybe-raise-frame frame)))))
 
+(defun windows-sharing-edge (&optional window edge within)
+  "Return list of live windows sharing the same edge with WINDOW.
+WINDOW must be a valid window and defaults to the selected one.
+EDGE stands for the edge to share and must be either 'left',
+'above', 'right' or 'below'.  Omitted or nil, EDGE defaults to
+'left'.
+
+WITHIN nil means to find a live window that shares the opposite
+EDGE with WINDOW.  For example, if EDGE equals 'left', WINDOW has
+to share (part of) the right edge of any window returned.  WITHIN
+non-nil means to find all live windows that share the same EDGE
+with WINDOW (Window must be internal in this case).  So if EDGE
+equals 'left', WINDOW's left edge has to fully encompass the left
+edge of any window returned."
+  (setq window (window-normalize-window window))
+  (setq edge (or edge 'left))
+  (when (and within (window-live-p window))
+    (error "Cannot share edge from within live window %s" window))
+  (let ((window-edges (window-edges window nil nil t))
+	(horizontal (memq edge '(left right)))
+	(n (pcase edge
+	     ('left 0) ('above 1) ('right 2) ('below 3))))
+    (unless (numberp n)
+      (error "Invalid EDGE %s" edge))
+    (let ((o (mod (+ 2 n) 4))
+	  (p (if horizontal 1 0))
+	  (q (if horizontal 3 2))
+	  windows)
+      (walk-window-tree
+       (lambda (other)
+	 (let ((other-edges (window-edges other nil nil t)))
+	   (when (and (not (eq window other))
+		      (= (nth n window-edges)
+			 (nth (if within n o) other-edges))
+		      (cond
+		       ((= (nth p window-edges) (nth p other-edges)))
+		       ((< (nth p window-edges) (nth p other-edges))
+			(< (nth p other-edges) (nth q window-edges)))
+		       (t
+			(< (nth p window-edges) (nth q other-edges)))))
+	     (setq windows (cons other windows)))))
+       (window-frame window) nil 'nomini)
+      (reverse windows))))
+
+(defun window--try-to-split-window-in-direction (window direction alist)
+  "Try to split WINDOW in DIRECTION.
+DIRECTION is passed as SIDE argument to `split-window-no-error'.
+ALIST is a buffer display alist."
+  (and (not (frame-parameter (window-frame window) 'unsplittable))
+       (let* ((window-combination-limit
+	       ;; When `window-combination-limit' equals
+	       ;; `display-buffer' or equals `resize-window' and a
+	       ;; `window-height' or `window-width' alist entry are
+	       ;; present, bind it to t so resizing steals space
+	       ;; preferably from the window that was split.
+	       (if (or (eq window-combination-limit 'display-buffer)
+		       (and (eq window-combination-limit 'window-size)
+			    (or (cdr (assq 'window-height alist))
+				(cdr (assq 'window-width alist)))))
+		   t
+		 window-combination-limit))
+	      (new-window (split-window-no-error window nil direction)))
+	 (and (window-live-p new-window) new-window))))
+
+(defun display-buffer-in-direction (buffer alist)
+  "Try to display BUFFER in a direction specified by ALIST.
+ALIST has to contain a 'direction' entry whose value should be
+one of 'left', 'above' (or 'up'), 'right', and 'below' (or
+'down').  Other values are usually interpreted as 'below'.
+
+If ALIST also contains a 'window' entry, its value specifies a
+reference window.  That value can be a special symbol like
+'main' (which stands for the selected frame's main window) or
+'root' (standings for the selected frame's root window) or an
+arbitrary valid window.  Any other value (or omitting the
+'window' entry) means to use the selected window as reference
+window.
+
+This function tries to reuse or split a window such that the
+window produced this way is on the side of the reference window
+specified by the 'direction' entry.
+
+Four special values for 'direction' entries allow to implicitly
+specify the selected frame's main window as reference window:
+'leftmost', 'top', 'rightmost' and 'bottom'.  Hence, instead of
+'(direction . left) (window . main)' one can simply write
+'(direction . leftmost)'."
+  (let ((direction (cdr (assq 'direction alist))))
+    (when direction
+      (let ((window (cdr (assq 'window alist)))
+	    within windows other-window-shows-buffer other-window)
+	;; Sanitize WINDOW.
+	(cond
+	 ((or (eq window 'main)
+              (memq direction '(top bottom leftmost rightmost)))
+	  (setq window (window-main-window)))
+	 ((eq window 'root)
+	  (setq window (frame-root-window)))
+	 ((window-valid-p window))
+	 (t
+	  (setq window (selected-window))))
+	(setq within (not (window-live-p window)))
+	;; Sanitize DIRECTION
+	(cond
+	 ((memq direction '(left above right below)))
+	 ((eq direction 'leftmost)
+	  (setq direction 'left))
+	 ((memq direction '(top up))
+	  (setq direction 'above))
+	 ((eq direction 'rightmost)
+	  (setq direction 'right))
+	 ((memq direction '(bottom down))
+	  (setq direction 'below))
+	 (t
+	  (setq direction 'below)))
+
+	(setq alist
+	      (append alist
+		      `(,(if temp-buffer-resize-mode
+		             '(window-height . resize-temp-buffer-window)
+	                   '(window-height . fit-window-to-buffer))
+	                ,(when temp-buffer-resize-mode
+	                   '(preserve-size . (nil . t))))))
+
+	(setq windows (windows-sharing-edge window direction within))
+	(dolist (other windows)
+	  (cond
+	   ((and (not other-window-shows-buffer)
+		 (eq buffer (window-buffer other)))
+	    (setq other-window-shows-buffer t)
+	    (setq other-window other))
+	   ((not other-window)
+	    (setq other-window other))))
+	(or (and other-window-shows-buffer
+		 (window--display-buffer buffer other-window 'reuse alist))
+	    (and (setq other-window
+		       (window--try-to-split-window-in-direction
+			window direction alist))
+		 (window--display-buffer buffer other-window 'window alist))
+	    (and (setq window other-window)
+		 (not (window-dedicated-p other-window))
+		 (not (window-minibuffer-p other-window))
+		 (window--display-buffer buffer other-window 'reuse alist)))))))
+
+;; This should be rewritten as
+;; (display-buffer-in-direction buffer (cons '(direction . below) alist))
 (defun display-buffer-below-selected (buffer alist)
   "Try displaying BUFFER in a window below the selected window.
 If there is a window below the selected one and that window
@@ -7589,6 +7735,8 @@ must also contain a 'window-height' entry with the same value."
         (display-buffer--maybe-pop-up-frame buffer alist)
         (display-buffer-at-bottom buffer alist))))
 
+;; This should be rewritten as
+;; (display-buffer-in-direction buffer (cons '(direction . bottom) alist))
 (defun display-buffer-at-bottom (buffer alist)
   "Try displaying BUFFER in a window at the bottom of the selected frame.
 This either reuses such a window provided it shows BUFFER
diff --git a/lisp/xml.el b/lisp/xml.el
index b5b923f863..09ec72f792 100644
--- a/lisp/xml.el
+++ b/lisp/xml.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2000-2019 Free Software Foundation, Inc.
 
-;; Author: Emmanuel Briot  <briot@gnat.com>
+;; Author: Emmanuel Briot <briot@gnat.com>
 ;; Maintainer: Mark A. Hershberger <mah@everybody.org>
 ;; Keywords: xml, data
 
@@ -245,7 +245,6 @@ See also `xml-get-attribute-or-nil'."
 ;; [54] AttType    ::= StringType | TokenizedType | EnumeratedType
 ;; [55] StringType ::= 'CDATA'
 (defconst xml-att-type-re (concat "\\(?:CDATA\\|" xml-tokenized-type-re
-				  "\\|" xml-notation-type-re
 				  "\\|" xml-enumerated-type-re "\\)"))
 
 ;; [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue)
diff --git a/lwlib/lwlib-Xaw.c b/lwlib/lwlib-Xaw.c
index 24b31fc295..0801c94400 100644
--- a/lwlib/lwlib-Xaw.c
+++ b/lwlib/lwlib-Xaw.c
@@ -50,8 +50,13 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include <X11/Xatom.h>
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
+#ifdef USE_CAIRO
+#include <stdlib.h>
+#include "lwlib-utils.h"
+#else  /* HAVE_XFT */
 #include <X11/Xft/Xft.h>
+#endif
 
 struct widget_xft_data
 {
@@ -79,7 +84,7 @@ lw_xaw_widget_p (Widget widget)
 }
 
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 static void
 fill_xft_data (struct widget_xft_data *data, Widget widget, XftFont *font)
 {
@@ -113,6 +118,23 @@ fill_xft_data (struct widget_xft_data *data, Widget widget, XftFont *font)
   data->p_width = data->p_height = 0;
 }
 
+static void
+destroy_xft_data (Widget widget, XtPointer closure, XtPointer call_data)
+{
+  struct widget_xft_data *xft_data = closure;
+
+  for (int i = 0; xft_data[i].widget; ++i)
+    {
+      if (xft_data[i].xft_draw)
+	XftDrawDestroy (xft_data[i].xft_draw);
+      if (xft_data[i].p != None)
+	XFreePixmap (XtDisplay (widget), xft_data[i].p);
+    }
+  if (xft_data[0].xft_font)
+    XftFontClose (XtDisplay (widget), xft_data[0].xft_font);
+  xfree (xft_data);
+}
+
 static XftFont*
 openFont (Widget widget, char *name)
 {
@@ -154,7 +176,7 @@ get_text_width_and_height (Widget widget, char *text,
                           &gi);
       bp = cp ? cp + 1 : NULL;
       h += xft_font->height;
-      if (w < gi.width) w = gi.width;
+      if (w < gi.xOff) w = gi.xOff;
     }
 
   *height = h;
@@ -170,11 +192,12 @@ draw_text (struct widget_xft_data *data, char *lbl, int inverse)
   int x = inverse ? 0 : 2;
   char *bp = lbl;
 
-  data->xft_draw = XftDrawCreate (XtDisplay (data->widget),
-                                  data->p,
-                                  DefaultVisual (XtDisplay (data->widget),
-                                                 screen),
-                                  DefaultColormapOfScreen (sc));
+  if (!data->xft_draw)
+    data->xft_draw = XftDrawCreate (XtDisplay (data->widget),
+				    data->p,
+				    DefaultVisual (XtDisplay (data->widget),
+						   screen),
+				    DefaultColormapOfScreen (sc));
   XftDrawRect (data->xft_draw,
                inverse ? &data->xft_fg : &data->xft_bg,
                0, 0, data->p_width, data->p_height);
@@ -192,6 +215,9 @@ draw_text (struct widget_xft_data *data, char *lbl, int inverse)
       /* 1.2 gives reasonable line spacing.  */
       y += data->xft_font->height * 1.2;
     }
+#ifdef USE_CAIRO
+  cairo_surface_flush (cairo_get_target (data->xft_draw));
+#endif
 
 }
 
@@ -229,7 +255,7 @@ find_xft_data (Widget widget)
     }
   if (!inst || !inst->xft_data || !inst->xft_data[0].xft_font) return 0;
 
-  for (nr = 0; data == NULL && nr < inst->nr_xft_data; ++nr)
+  for (nr = 0; data == NULL && inst->xft_data[nr].widget; ++nr)
     {
       if (inst->xft_data[nr].widget == widget)
         data = &inst->xft_data[nr];
@@ -289,7 +315,7 @@ xaw_update_one_widget (widget_instance *instance,
   if (XtIsSubclass (widget, dialogWidgetClass))
     {
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
       if (instance->xft_data && instance->xft_data[0].xft_font)
         {
           set_text (&instance->xft_data[0], instance->parent,
@@ -321,15 +347,15 @@ xaw_update_one_widget (widget_instance *instance,
       XtSetArg (al[ac], XtNlabel, val->value);ac++;
       /* Force centered button text.  Se above. */
       XtSetArg (al[ac], XtNjustify, XtJustifyCenter);ac++;
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
       if (instance->xft_data && instance->xft_data[0].xft_font)
         {
           int th;
           int nr;
-          for (nr = 0; nr < instance->nr_xft_data; ++nr)
+          for (nr = 0; instance->xft_data[nr].widget; ++nr)
             if (instance->xft_data[nr].widget == widget)
               break;
-          if (nr < instance->nr_xft_data)
+          if (instance->xft_data[nr].widget)
             {
               set_text (&instance->xft_data[nr], instance->parent,
                         val->value, 6);
@@ -360,28 +386,6 @@ xaw_update_one_value (widget_instance *instance,
 void
 xaw_destroy_instance (widget_instance *instance)
 {
-#ifdef HAVE_XFT
-  if (instance->xft_data)
-    {
-      int i;
-      for (i = 0; i < instance->nr_xft_data; ++i)
-        {
-          if (instance->xft_data[i].xft_draw)
-            XftDrawDestroy (instance->xft_data[i].xft_draw);
-          if (instance->xft_data[i].p != None)
-            {
-              XtVaSetValues (instance->xft_data[i].widget, XtNbitmap, None,
-                             NULL);
-              XFreePixmap (XtDisplay (instance->widget),
-                           instance->xft_data[i].p);
-            }
-        }
-      if (instance->xft_data[0].xft_font)
-        XftFontClose (XtDisplay (instance->widget),
-                      instance->xft_data[0].xft_font);
-      xfree (instance->xft_data);
-    }
-#endif
   if (XtIsSubclass (instance->widget, dialogWidgetClass))
     /* Need to destroy the Shell too. */
     XtDestroyWidget (XtParent (instance->widget));
@@ -477,7 +481,7 @@ static XtActionsRec xaw_actions [] = {
 };
 static Boolean actions_initted = False;
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 static XtActionsRec button_actions[] =
   {
     { "my_reset", command_reset },
@@ -510,7 +514,7 @@ make_dialog (char* name,
   Widget dialog;
   Widget button;
   XtTranslations override;
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   XftFont *xft_font = 0;
   XtTranslations button_override;
 #endif
@@ -525,7 +529,7 @@ make_dialog (char* name,
       XtAppContext app = XtWidgetToApplicationContext (parent);
       XtAppAddActions (app, xaw_actions,
 		       sizeof (xaw_actions) / sizeof (xaw_actions[0]));
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
       XtAppAddActions (app, button_actions,
 		       sizeof (button_actions) / sizeof (button_actions[0]));
 #endif
@@ -550,7 +554,7 @@ make_dialog (char* name,
   override = XtParseTranslationTable (dialogOverride);
   XtOverrideTranslations (dialog, override);
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   {
     int num;
     Widget *ch = NULL;
@@ -568,7 +572,6 @@ make_dialog (char* name,
           }
       }
     instance->xft_data = 0;
-    instance->nr_xft_data = 0;
     if (w)
       {
         XtResource rec[] =
@@ -588,11 +591,13 @@ make_dialog (char* name,
 
         if (xft_font)
           {
-            instance->nr_xft_data = left_buttons + right_buttons + 1;
-            instance->xft_data = calloc (instance->nr_xft_data,
+            int nr_xft_data = left_buttons + right_buttons + 1;
+            instance->xft_data = calloc (nr_xft_data + 1,
                                          sizeof(*instance->xft_data));
 
             fill_xft_data (&instance->xft_data[0], w, xft_font);
+	    XtAddCallback (dialog, XtNdestroyCallback, destroy_xft_data,
+			   instance->xft_data);
           }
       }
 
@@ -621,7 +626,7 @@ make_dialog (char* name,
       sprintf (button_name, "button%d", ++bc);
       button = XtCreateManagedWidget (button_name, commandWidgetClass,
 				      dialog, av, ac);
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
       if (xft_font)
         {
           fill_xft_data (&instance->xft_data[bc], button, xft_font);
@@ -654,7 +659,7 @@ make_dialog (char* name,
       sprintf (button_name, "button%d", ++bc);
       button = XtCreateManagedWidget (button_name, commandWidgetClass,
 				      dialog, av, ac);
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
       if (xft_font)
         {
           fill_xft_data (&instance->xft_data[bc], button, xft_font);
diff --git a/lwlib/lwlib-int.h b/lwlib/lwlib-int.h
index e21fa1f171..9f788e7c0c 100644
--- a/lwlib/lwlib-int.h
+++ b/lwlib/lwlib-int.h
@@ -30,9 +30,8 @@ typedef struct _widget_instance
   Widget		widget;
   Widget		parent;
   Boolean		pop_up_p;
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   struct widget_xft_data *xft_data;
-  int                   nr_xft_data;
 #endif
   struct _widget_info*		info;
   struct _widget_instance*	next;
diff --git a/lwlib/lwlib-utils.c b/lwlib/lwlib-utils.c
index 7c60bdb056..2c0a931f9c 100644
--- a/lwlib/lwlib-utils.c
+++ b/lwlib/lwlib-utils.c
@@ -137,3 +137,143 @@ XtWidgetBeingDestroyedP (Widget widget)
 {
   return widget->core.being_destroyed;
 }
+
+#ifdef USE_CAIRO
+/* Xft emulation on cairo.  */
+#include <math.h>
+#include <cairo-ft.h>
+#include <cairo-xlib.h>
+
+XftFont *
+crxft_font_open_name (Display *dpy, int screen, const char *name)
+{
+  XftFont *pub = NULL;
+  FcPattern *pattern = FcNameParse ((FcChar8 *) name);
+  if (pattern)
+    {
+      FcConfigSubstitute (NULL, pattern, FcMatchPattern);
+      double dpi;
+      if (FcPatternGetDouble (pattern, FC_DPI, 0, &dpi) == FcResultNoMatch)
+	{
+	  char *v = XGetDefault (dpy, "Xft", FC_DPI);
+	  if (v == NULL || sscanf (v, "%lf", &dpi) != 1)
+	    dpi = ((DisplayHeight (dpy, screen) * 25.4)
+		   / DisplayHeightMM (dpy, screen));
+	  FcPatternAddDouble (pattern, FC_DPI, dpi);
+	}
+      FcDefaultSubstitute (pattern);
+      cairo_font_face_t *font_face
+	= cairo_ft_font_face_create_for_pattern (pattern);
+      if (font_face)
+	{
+	  double pixel_size;
+	  if ((FcPatternGetDouble (pattern, FC_PIXEL_SIZE, 0, &pixel_size)
+	       != FcResultMatch)
+	      || pixel_size < 1)
+	    pixel_size = 10;
+
+	  pub = xmalloc (sizeof (*pub));
+	  cairo_matrix_t font_matrix, ctm;
+	  cairo_matrix_init_scale (&font_matrix, pixel_size, pixel_size);
+	  cairo_matrix_init_identity (&ctm);
+	  cairo_font_options_t *options = cairo_font_options_create ();
+	  cairo_ft_font_options_substitute (options, pattern);
+	  pub->scaled_font = cairo_scaled_font_create (font_face, &font_matrix,
+						       &ctm, options);
+	  cairo_font_face_destroy (font_face);
+	  cairo_font_options_destroy (options);
+
+	  cairo_font_extents_t extents;
+	  cairo_scaled_font_extents (pub->scaled_font, &extents);
+	  pub->ascent = lround (extents.ascent);
+	  pub->descent = lround (extents.descent);
+	  pub->height = lround (extents.height);
+	  pub->max_advance_width = lround (extents.max_x_advance);
+	}
+      FcPatternDestroy (pattern);
+    }
+  return pub;
+}
+
+void
+crxft_font_close (XftFont *pub)
+{
+  cairo_scaled_font_destroy (pub->scaled_font);
+  xfree (pub);
+}
+
+cairo_t *
+crxft_draw_create (Display *dpy, Drawable drawable, Visual *visual)
+{
+  cairo_t *cr = NULL;
+  Window root;
+  int x, y;
+  unsigned int width, height, border_width, depth;
+
+  if (!XGetGeometry (dpy, drawable, &root, &x, &y, &width, &height,
+		     &border_width, &depth))
+    return NULL;
+
+  cairo_surface_t *surface = cairo_xlib_surface_create (dpy, drawable, visual,
+							width, height);
+  if (surface)
+    {
+      cr = cairo_create (surface);
+      cairo_surface_destroy (surface);
+    }
+
+  return cr;
+}
+
+static void
+crxft_set_source_color (cairo_t *cr, const XftColor *color)
+{
+  cairo_set_source_rgba (cr, color->color.red / 65535.0,
+			 color->color.green / 65535.0,
+			 color->color.blue / 65535.0,
+			 color->color.alpha / 65535.0);
+}
+
+void
+crxft_draw_rect (cairo_t *cr, const XftColor *color, int x, int y,
+		 unsigned int width, unsigned int height)
+{
+  crxft_set_source_color (cr, color);
+  cairo_rectangle (cr, x, y, width, height);
+  cairo_fill (cr);
+}
+
+void
+crxft_draw_string (cairo_t *cr, const XftColor *color, XftFont *pub,
+		   int x, int y, const FcChar8 *string, int len)
+{
+  char *buf = xmalloc (len + 1);
+  memcpy (buf, string, len);
+  buf[len] = '\0';
+  crxft_set_source_color (cr, color);
+  cairo_set_scaled_font (cr, pub->scaled_font);
+  cairo_move_to (cr, x, y);
+  cairo_show_text (cr, buf);
+  xfree (buf);
+}
+
+void
+crxft_text_extents (XftFont *pub, const FcChar8 *string, int len,
+		    XGlyphInfo *extents)
+{
+  char *buf = xmalloc (len + 1);
+  memcpy (buf, string, len);
+  buf[len] = '\0';
+  cairo_text_extents_t text_extents;
+  cairo_scaled_font_text_extents (pub->scaled_font, buf, &text_extents);
+  xfree (buf);
+  extents->x = ceil (- text_extents.x_bearing);
+  extents->y = ceil (- text_extents.y_bearing);
+  extents->width = (ceil (text_extents.x_bearing + text_extents.width)
+		    + extents->x);
+  extents->height = (ceil (text_extents.y_bearing + text_extents.height)
+		     + extents->y);
+  extents->xOff = lround (text_extents.x_advance);
+  extents->yOff = lround (text_extents.y_advance);
+}
+#endif	/* USE_CAIRO */
diff --git a/lwlib/lwlib-utils.h b/lwlib/lwlib-utils.h
index ec3daab94e..64372f19ad 100644
--- a/lwlib/lwlib-utils.h
+++ b/lwlib/lwlib-utils.h
@@ -15,4 +15,49 @@ Widget *XtCompositeChildren (Widget, unsigned int *);
 Boolean
 XtWidgetBeingDestroyedP (Widget widget);
 
+#ifdef USE_CAIRO
+
+#include <cairo.h>
+#include <fontconfig/fontconfig.h>
+
+typedef struct {
+  cairo_scaled_font_t *scaled_font;
+  int ascent, descent, height, max_advance_width;
+} XftFont;
+
+typedef cairo_t XftDraw;
+
+typedef struct {
+  unsigned long pixel;
+  struct {unsigned short red, green, blue, alpha;} color;
+} XftColor;
+
+#ifdef HAVE_XRENDER
+#include <X11/extensions/Xrender.h>
+#else
+typedef struct {
+  unsigned short width, height;
+  short x, y, xOff, yOff;
+} XGlyphInfo;
+#endif
+
+#define XftFontOpenName crxft_font_open_name
+extern XftFont *crxft_font_open_name (Display *, int, const char *);
+#define XftFontClose(dpy, pub) crxft_font_close (pub)
+extern void crxft_font_close (XftFont *);
+#define XftDrawCreate(dpy, drawable, visual, colormap) \
+  crxft_draw_create (dpy, drawable, visual)
+extern cairo_t *crxft_draw_create (Display *, Drawable, Visual *);
+#define XftDrawDestroy cairo_destroy
+#define XftDrawRect crxft_draw_rect
+extern void crxft_draw_rect (cairo_t *, const XftColor *, int, int,
+			     unsigned int, unsigned int);
+#define XftDrawStringUtf8 crxft_draw_string
+extern void crxft_draw_string (cairo_t *, const XftColor *, XftFont *,
+			       int, int, const FcChar8 *, int);
+#define XftTextExtentsUtf8(dpy, pub, string, len, extents) \
+  crxft_text_extents (pub, string, len, extents)
+extern void crxft_text_extents (XftFont *, const FcChar8 *, int, XGlyphInfo *);
+
+#endif	/* USE_CAIRO */
 #endif /* _LWLIB_UTILS_H_ */
diff --git a/lwlib/xlwmenu.c b/lwlib/xlwmenu.c
index 07ad29e107..6292c840f5 100644
--- a/lwlib/xlwmenu.c
+++ b/lwlib/xlwmenu.c
@@ -107,7 +107,7 @@ xlwMenuResources[] =
   {XtNfontSet,  XtCFontSet, XtRFontSet, sizeof(XFontSet),
      offset(menu.fontSet), XtRFontSet, NULL},
 #endif
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 #define DEFAULT_FONTNAME "Sans-10"
 #else
 #define DEFAULT_FONTNAME "XtDefaultFont"
@@ -325,14 +325,14 @@ string_width (XlwMenuWidget mw, char *s)
 {
   XCharStruct xcs;
   int drop;
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   if (mw->menu.xft_font)
     {
       XGlyphInfo gi;
       XftTextExtentsUtf8 (XtDisplay (mw), mw->menu.xft_font,
                           (FcChar8 *) s,
                           strlen (s), &gi);
-      return gi.width;
+      return gi.xOff;
     }
 #endif
 #ifdef HAVE_X_I18N
@@ -349,7 +349,7 @@ string_width (XlwMenuWidget mw, char *s)
 
 }
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 #define MENU_FONT_HEIGHT(mw)                                    \
   ((mw)->menu.xft_font != NULL                                  \
    ? (mw)->menu.xft_font->height                                \
@@ -965,7 +965,7 @@ display_menu_item (XlwMenuWidget mw,
   int width;
   enum menu_separator separator;
   int separator_p = lw_separator_p (val->name, &separator, 0);
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   XftColor *xftfg;
 #endif
 
@@ -1005,7 +1005,7 @@ display_menu_item (XlwMenuWidget mw,
       else
 	text_gc = mw->menu.disabled_gc;
       deco_gc = mw->menu.foreground_gc;
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
       xftfg = val->enabled ? &mw->menu.xft_fg : &mw->menu.xft_disabled_fg;
 #endif
 
@@ -1032,10 +1032,13 @@ display_menu_item (XlwMenuWidget mw,
 	    x_offset += ws->button_width;
 
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
           if (ws->xft_draw)
             {
               int draw_y = y + v_spacing + shadow;
+#ifdef USE_CAIRO
+	      cairo_surface_mark_dirty (cairo_get_target (ws->xft_draw));
+#endif
               XftDrawStringUtf8 (ws->xft_draw, xftfg,
                                  mw->menu.xft_font,
                                  x_offset, draw_y + font_ascent,
@@ -1078,7 +1081,7 @@ display_menu_item (XlwMenuWidget mw,
 		}
 	      else if (val->key)
 		{
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
                   if (ws->xft_draw)
                     {
                       int draw_x = ws->width - ws->max_rest_width
@@ -1119,6 +1122,10 @@ display_menu_item (XlwMenuWidget mw,
 	      draw_shadow_rectangle (mw, ws->pixmap, x, y, width, height,
 				     True, False);
 	    }
+#ifdef USE_CAIRO
+	  if (ws->xft_draw)
+	    cairo_surface_flush (cairo_get_target (ws->xft_draw));
+#endif
 
 	  if (highlighted_p)
 	    draw_shadow_rectangle (mw, ws->pixmap, x, y, width, height, False,
@@ -1320,7 +1327,7 @@ make_windows_if_needed (XlwMenuWidget mw, int n)
      XtAddEventHandler (windows [i].w, ExposureMask, False, expose_cb, mw);
      windows [i].window = XtWindow (windows [i].w);
      windows [i].pixmap = None;
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
      windows [i].xft_draw = 0;
 #endif
      set_window_type (windows [i].w, mw);
@@ -1411,7 +1418,7 @@ create_pixmap_for_menu (window_state* ws, XlwMenuWidget mw)
   ws->pixmap = XCreatePixmap (XtDisplay (ws->w), ws->window,
                               ws->width, ws->height,
                               DefaultDepthOfScreen (XtScreen (ws->w)));
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   if (ws->xft_draw)
     XftDrawDestroy (ws->xft_draw);
   if (mw->menu.xft_font)
@@ -1831,7 +1838,7 @@ release_shadow_gcs (XlwMenuWidget mw)
   XtReleaseGC ((Widget) mw, mw->menu.shadow_bottom_gc);
 }
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 static XftFont *
 getDefaultXftFont (XlwMenuWidget mw)
 {
@@ -1887,7 +1894,7 @@ XlwMenuInitialize (Widget request, Widget w, ArgList args, Cardinal *num_args)
 				   gray_width, gray_height,
 				   (unsigned long)1, (unsigned long)0, 1);
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   if (openXftFont (mw))
     ;
   else
@@ -1933,7 +1940,7 @@ XlwMenuInitialize (Widget request, Widget w, ArgList args, Cardinal *num_args)
   mw->menu.windows [0].height = 0;
   mw->menu.windows [0].max_rest_width = 0;
   mw->menu.windows [0].pixmap = None;
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   mw->menu.windows [0].xft_draw = 0;
 #endif
   size_menu (mw, 0);
@@ -1981,7 +1988,7 @@ XlwMenuRealize (Widget w, Mask *valueMask, XSetWindowAttributes *attributes)
   set_window_type (mw->menu.windows [0].w, mw);
   create_pixmap_for_menu (&mw->menu.windows [0], mw);
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   if (mw->menu.xft_font)
     {
       XColor colors[3];
@@ -2078,7 +2085,7 @@ XlwMenuDestroy (Widget w)
   if (mw->menu.font)
     XFreeFont (XtDisplay (mw), mw->menu.font);
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   if (mw->menu.windows [0].xft_draw)
     XftDrawDestroy (mw->menu.windows [0].xft_draw);
   if (mw->menu.xft_font)
@@ -2092,7 +2099,7 @@ XlwMenuDestroy (Widget w)
     {
       if (mw->menu.windows [i].pixmap != None)
         XFreePixmap (XtDisplay (mw), mw->menu.windows [i].pixmap);
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
       if (mw->menu.windows [i].xft_draw)
         XftDrawDestroy (mw->menu.windows [i].xft_draw);
 #endif
@@ -2102,7 +2109,7 @@ XlwMenuDestroy (Widget w)
     XtFree ((char *) mw->menu.windows);
 }
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 static int
 fontname_changed (XlwMenuWidget newmw,
                   XlwMenuWidget oldmw)
@@ -2134,7 +2141,7 @@ XlwMenuSetValues (Widget current, Widget request, Widget new,
 
   if (newmw->core.background_pixel != oldmw->core.background_pixel
       || newmw->menu.foreground != oldmw->menu.foreground
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
       || fontname_changed (newmw, oldmw)
 #endif
 #ifdef HAVE_X_I18N
@@ -2170,7 +2177,7 @@ XlwMenuSetValues (Widget current, Widget request, Widget new,
 	  }
     }
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   if (fontname_changed (newmw, oldmw))
     {
       int i;
diff --git a/lwlib/xlwmenuP.h b/lwlib/xlwmenuP.h
index 610f83afe4..2a05d99354 100644
--- a/lwlib/xlwmenuP.h
+++ b/lwlib/xlwmenuP.h
@@ -23,9 +23,13 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include "xlwmenu.h"
 #include <X11/CoreP.h>
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
+#ifdef USE_CAIRO
+#include "lwlib-utils.h"
+#else  /* HAVE_XFT */
 #include <X11/Xft/Xft.h>
 #endif
+#endif
 
 /* Elements in the stack arrays. */
 typedef struct _window_state
@@ -42,7 +46,7 @@ typedef struct _window_state
 
   /* Width of toggle buttons or radio buttons.  */
   Dimension     button_width;
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   XftDraw*      xft_draw;
 #endif
 } window_state;
@@ -56,7 +60,7 @@ typedef struct _XlwMenu_part
   XFontSet	fontSet;
   XFontSetExtents *font_extents;
 #endif
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   int           default_face;
   XftFont*      xft_font;
   XftColor      xft_fg, xft_bg, xft_disabled_fg;
diff --git a/m4/flexmember.m4 b/m4/flexmember.m4
index 1347068fe3..c245ab025f 100644
--- a/m4/flexmember.m4
+++ b/m4/flexmember.m4
@@ -34,12 +34,10 @@ AC_DEFUN([AC_C_FLEXIBLE_ARRAY_MEMBER],
     AC_DEFINE([FLEXIBLE_ARRAY_MEMBER], [],
       [Define to nothing if C supports flexible array members, and to
        1 if it does not.  That way, with a declaration like 'struct s
-       { int n; double d@<:@FLEXIBLE_ARRAY_MEMBER@:>@; };', the struct hack
+       { int n; short d@<:@FLEXIBLE_ARRAY_MEMBER@:>@; };', the struct hack
        can be used with pre-C99 compilers.
-       When computing the size of such an object, don't use 'sizeof (struct s)'
-       as it overestimates the size.  Use 'offsetof (struct s, d)' instead.
-       Don't use 'offsetof (struct s, d@<:@0@:>@)', as this doesn't work with
-       MSVC and with C++ compilers.])
+       Use 'FLEXSIZEOF (struct s, d, N * sizeof (short))' to calculate
+       the size in bytes of such a struct containing an N-element array.])
   else
     AC_DEFINE([FLEXIBLE_ARRAY_MEMBER], [1])
   fi
diff --git a/m4/gnulib-comp.m4 b/m4/gnulib-comp.m4
index f25a0e4081..0a7a30e5ae 100644
--- a/m4/gnulib-comp.m4
+++ b/m4/gnulib-comp.m4
@@ -113,6 +113,7 @@ AC_DEFUN([gl_EARLY],
   # Code from module localtime-buffer:
   # Code from module lstat:
   # Code from module manywarnings:
+  # Code from module memmem-simple:
   # Code from module memrchr:
   # Code from module minmax:
   # Code from module mkostemp:
@@ -195,10 +196,10 @@ AC_DEFUN([gl_INIT],
   gl_source_base='lib'
   gl_FUNC_ACL
   gl_FUNC_ALLOCA
+  gl___BUILTIN_EXPECT
   gl_BYTESWAP
   AC_CHECK_FUNCS_ONCE([readlinkat])
   gl_CLOCK_TIME
-  gl_CLOSE_STREAM
   gl_MODULE_INDICATOR([close-stream])
   gl_COUNT_LEADING_ZEROS
   gl_COUNT_ONE_BITS
@@ -302,6 +303,11 @@ AC_DEFUN([gl_INIT],
     gl_PREREQ_LSTAT
   fi
   gl_SYS_STAT_MODULE_INDICATOR([lstat])
+  gl_FUNC_MEMMEM_SIMPLE
+  if test $HAVE_MEMMEM = 0 || test $REPLACE_MEMMEM = 1; then
+    AC_LIBOBJ([memmem])
+  fi
+  gl_STRING_MODULE_INDICATOR([memmem])
   gl_FUNC_MEMRCHR
   if test $ac_cv_func_memrchr = no; then
     AC_LIBOBJ([memrchr])
@@ -426,7 +432,6 @@ AC_DEFUN([gl_INIT],
   gl_UTIMENS
   AC_C_VARARRAYS
   gl_gnulib_enabled_260941c0e5dc67ec9e87d1fb321c300b=false
-  gl_gnulib_enabled_37f71b604aa9c54446783d80f42fe547=false
   gl_gnulib_enabled_cloexec=false
   gl_gnulib_enabled_dirfd=false
   gl_gnulib_enabled_euidaccess=false
@@ -450,13 +455,6 @@ AC_DEFUN([gl_INIT],
       func_gl_gnulib_m4code_open
     fi
   }
-  func_gl_gnulib_m4code_37f71b604aa9c54446783d80f42fe547 ()
-  {
-    if ! $gl_gnulib_enabled_37f71b604aa9c54446783d80f42fe547; then
-      gl___BUILTIN_EXPECT
-      gl_gnulib_enabled_37f71b604aa9c54446783d80f42fe547=true
-    fi
-  }
   func_gl_gnulib_m4code_cloexec ()
   {
     if ! $gl_gnulib_enabled_cloexec; then
@@ -652,9 +650,6 @@ AC_DEFUN([gl_INIT],
   if test $HAVE_READLINKAT = 0; then
     func_gl_gnulib_m4code_03e0aaad4cb89ca757653bd367a6ccb7
   fi
-  if test $ac_use_included_regex = yes; then
-    func_gl_gnulib_m4code_37f71b604aa9c54446783d80f42fe547
-  fi
   if test $ac_use_included_regex = yes; then
     func_gl_gnulib_m4code_21ee726a3540c09237a8e70c0baf7467
   fi
@@ -666,7 +661,6 @@ AC_DEFUN([gl_INIT],
   fi
   m4_pattern_allow([^gl_GNULIB_ENABLED_])
   AM_CONDITIONAL([gl_GNULIB_ENABLED_260941c0e5dc67ec9e87d1fb321c300b], [$gl_gnulib_enabled_260941c0e5dc67ec9e87d1fb321c300b])
-  AM_CONDITIONAL([gl_GNULIB_ENABLED_37f71b604aa9c54446783d80f42fe547], [$gl_gnulib_enabled_37f71b604aa9c54446783d80f42fe547])
   AM_CONDITIONAL([gl_GNULIB_ENABLED_cloexec], [$gl_gnulib_enabled_cloexec])
   AM_CONDITIONAL([gl_GNULIB_ENABLED_dirfd], [$gl_gnulib_enabled_dirfd])
   AM_CONDITIONAL([gl_GNULIB_ENABLED_euidaccess], [$gl_gnulib_enabled_euidaccess])
@@ -916,6 +910,7 @@ AC_DEFUN([gl_FILE_LIST], [
   lib/lstat.c
   lib/md5.c
   lib/md5.h
+  lib/memmem.c
   lib/memrchr.c
   lib/minmax.h
   lib/mkostemp.c
@@ -959,6 +954,7 @@ AC_DEFUN([gl_FILE_LIST], [
   lib/stdio.in.h
   lib/stdlib.in.h
   lib/stpcpy.c
+  lib/str-two-way.h
   lib/strftime.h
   lib/string.in.h
   lib/strtoimax.c
@@ -999,7 +995,6 @@ AC_DEFUN([gl_FILE_LIST], [
   m4/builtin-expect.m4
   m4/byteswap.m4
   m4/clock_time.m4
-  m4/close-stream.m4
   m4/count-leading-zeros.m4
   m4/count-one-bits.m4
   m4/count-trailing-zeros.m4
@@ -1049,6 +1044,7 @@ AC_DEFUN([gl_FILE_LIST], [
   m4/manywarnings.m4
   m4/mbstate_t.m4
   m4/md5.m4
+  m4/memmem.m4
   m4/memrchr.m4
   m4/minmax.m4
   m4/mkostemp.m4
diff --git a/m4/manywarnings.m4 b/m4/manywarnings.m4
index e0488a5cb3..6bb9f8f84e 100644
--- a/m4/manywarnings.m4
+++ b/m4/manywarnings.m4
@@ -1,4 +1,4 @@
-# manywarnings.m4 serial 17
+# manywarnings.m4 serial 18
 dnl Copyright (C) 2008-2019 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
@@ -112,16 +112,19 @@ m4_defun([gl_MANYWARN_ALL_GCC(C)],
   gl_manywarn_set=
   for gl_manywarn_item in -fno-common \
     -W \
+    -Wabsolute-value \
     -Waddress \
+    -Waddress-of-packed-member \
     -Waggressive-loop-optimizations \
     -Wall \
-    -Wattribute-alias \
+    -Wattribute-warning \
     -Wattributes \
     -Wbad-function-cast \
     -Wbool-compare \
     -Wbool-operation \
     -Wbuiltin-declaration-mismatch \
     -Wbuiltin-macro-redefined \
+    -Wcannot-profile \
     -Wcast-align \
     -Wcast-align=strict \
     -Wcast-function-type \
@@ -186,6 +189,7 @@ m4_defun([gl_MANYWARN_ALL_GCC(C)],
     -Wmissing-field-initializers \
     -Wmissing-include-dirs \
     -Wmissing-parameter-type \
+    -Wmissing-profile \
     -Wmissing-prototypes \
     -Wmultichar \
     -Wmultistatement-macros \
@@ -292,6 +296,7 @@ m4_defun([gl_MANYWARN_ALL_GCC(C)],
   AC_MSG_RESULT([$gl_alloc_max])
   gl_manywarn_set="$gl_manywarn_set -Walloc-size-larger-than=$gl_alloc_max"
   gl_manywarn_set="$gl_manywarn_set -Warray-bounds=2"
+  gl_manywarn_set="$gl_manywarn_set -Wattribute-alias=2"
   gl_manywarn_set="$gl_manywarn_set -Wformat-overflow=2"
   gl_manywarn_set="$gl_manywarn_set -Wformat-truncation=2"
   gl_manywarn_set="$gl_manywarn_set -Wimplicit-fallthrough=5"
diff --git a/m4/memmem.m4 b/m4/memmem.m4
new file mode 100644
index 0000000000..af2d5bbcf5
--- /dev/null
+++ b/m4/memmem.m4
@@ -0,0 +1,154 @@
+# memmem.m4 serial 25
+dnl Copyright (C) 2002-2004, 2007-2019 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Check that memmem is present and functional.
+AC_DEFUN([gl_FUNC_MEMMEM_SIMPLE],
+[
+  dnl Persuade glibc <string.h> to declare memmem().
+  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])
+
+  AC_REQUIRE([gl_HEADER_STRING_H_DEFAULTS])
+  AC_CHECK_FUNCS([memmem])
+  if test $ac_cv_func_memmem = yes; then
+    HAVE_MEMMEM=1
+  else
+    HAVE_MEMMEM=0
+  fi
+  AC_CHECK_DECLS_ONCE([memmem])
+  if test $ac_cv_have_decl_memmem = no; then
+    HAVE_DECL_MEMMEM=0
+  else
+    dnl Detect https://sourceware.org/bugzilla/show_bug.cgi?id=12092.
+    dnl Also check that we handle empty needles correctly.
+    AC_CACHE_CHECK([whether memmem works],
+      [gl_cv_func_memmem_works_always],
+      [AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+#include <string.h> /* for memmem */
+#define P "_EF_BF_BD"
+#define HAYSTACK "F_BD_CE_BD" P P P P "_C3_88_20" P P P "_C3_A7_20" P
+#define NEEDLE P P P P P
+]], [[
+    int result = 0;
+    if (memmem (HAYSTACK, strlen (HAYSTACK), NEEDLE, strlen (NEEDLE)))
+      result |= 1;
+    /* Check for empty needle behavior.  */
+    {
+      const char *haystack = "AAA";
+      if (memmem (haystack, 3, NULL, 0) != haystack)
+        result |= 2;
+    }
+    return result;
+    ]])],
+        [gl_cv_func_memmem_works_always=yes],
+        [gl_cv_func_memmem_works_always=no],
+        [dnl glibc 2.9..2.12 and cygwin 1.7.7 have issue #12092 above.
+         dnl Also empty needles work on glibc >= 2.1 and cygwin >= 1.7.0.
+         dnl uClibc is not affected, since it uses different source code.
+         dnl Assume that it works on all other platforms (even if not linear).
+         AC_EGREP_CPP([Lucky user],
+           [
+#ifdef __GNU_LIBRARY__
+ #include <features.h>
+ #if ((__GLIBC__ == 2 && ((__GLIBC_MINOR > 0 && __GLIBC_MINOR__ < 9) \
+                          || __GLIBC_MINOR__ > 12)) \
+      || (__GLIBC__ > 2)) \
+     || defined __UCLIBC__
+  Lucky user
+ #endif
+#elif defined __CYGWIN__
+ #include <cygwin/version.h>
+ #if CYGWIN_VERSION_DLL_COMBINED > CYGWIN_VERSION_DLL_MAKE_COMBINED (1007, 7)
+  Lucky user
+ #endif
+#else
+  Lucky user
+#endif
+           ],
+           [gl_cv_func_memmem_works_always="guessing yes"],
+           [gl_cv_func_memmem_works_always="guessing no"])
+        ])
+      ])
+    case "$gl_cv_func_memmem_works_always" in
+      *yes) ;;
+      *)
+        REPLACE_MEMMEM=1
+        ;;
+    esac
+  fi
+  gl_PREREQ_MEMMEM
+]) # gl_FUNC_MEMMEM_SIMPLE
+
+dnl Additionally, check that memmem has linear performance characteristics
+AC_DEFUN([gl_FUNC_MEMMEM],
+[
+  AC_REQUIRE([gl_FUNC_MEMMEM_SIMPLE])
+  if test $HAVE_DECL_MEMMEM = 1 && test $REPLACE_MEMMEM = 0; then
+    AC_CACHE_CHECK([whether memmem works in linear time],
+      [gl_cv_func_memmem_works_fast],
+      [AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+#include <signal.h> /* for signal */
+#include <string.h> /* for memmem */
+#include <stdlib.h> /* for malloc */
+#include <unistd.h> /* for alarm */
+static void quit (int sig) { _exit (sig + 128); }
+]], [[
+    int result = 0;
+    size_t m = 1000000;
+    char *haystack = (char *) malloc (2 * m + 1);
+    char *needle = (char *) malloc (m + 1);
+    /* Failure to compile this test due to missing alarm is okay,
+       since all such platforms (mingw) also lack memmem.  */
+    signal (SIGALRM, quit);
+    alarm (5);
+    /* Check for quadratic performance.  */
+    if (haystack && needle)
+      {
+        memset (haystack, 'A', 2 * m);
+        haystack[2 * m] = 'B';
+        memset (needle, 'A', m);
+        needle[m] = 'B';
+        if (!memmem (haystack, 2 * m + 1, needle, m + 1))
+          result |= 1;
+      }
+    /* Free allocated memory, in case some sanitizer is watching.  */
+    free (haystack);
+    free (needle);
+    return result;
+    ]])],
+        [gl_cv_func_memmem_works_fast=yes], [gl_cv_func_memmem_works_fast=no],
+        [dnl Only glibc >= 2.9 and cygwin > 1.7.0 are known to have a
+         dnl memmem that works in linear time.
+         AC_EGREP_CPP([Lucky user],
+           [
+#include <features.h>
+#ifdef __GNU_LIBRARY__
+ #if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 9) || (__GLIBC__ > 2)) \
+     && !defined __UCLIBC__
+  Lucky user
+ #endif
+#endif
+#ifdef __CYGWIN__
+ #include <cygwin/version.h>
+ #if CYGWIN_VERSION_DLL_COMBINED > CYGWIN_VERSION_DLL_MAKE_COMBINED (1007, 0)
+  Lucky user
+ #endif
+#endif
+           ],
+           [gl_cv_func_memmem_works_fast="guessing yes"],
+           [gl_cv_func_memmem_works_fast="guessing no"])
+        ])
+      ])
+    case "$gl_cv_func_memmem_works_fast" in
+      *yes) ;;
+      *)
+        REPLACE_MEMMEM=1
+        ;;
+    esac
+  fi
+]) # gl_FUNC_MEMMEM
+
+# Prerequisites of lib/memmem.c.
+AC_DEFUN([gl_PREREQ_MEMMEM], [:])
diff --git a/m4/pthread_sigmask.m4 b/m4/pthread_sigmask.m4
index cadc239a3c..648edf911f 100644
--- a/m4/pthread_sigmask.m4
+++ b/m4/pthread_sigmask.m4
@@ -1,4 +1,4 @@
-# pthread_sigmask.m4 serial 16
+# pthread_sigmask.m4 serial 17
 dnl Copyright (C) 2011-2019 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
@@ -9,103 +9,101 @@ AC_DEFUN([gl_FUNC_PTHREAD_SIGMASK],
   AC_REQUIRE([gl_SIGNAL_H_DEFAULTS])
 
   AC_CHECK_FUNCS_ONCE([pthread_sigmask])
+
+  dnl On MinGW pthread_sigmask is just a macro which always returns 0.
+  dnl It does not exist as a real function, which is required by POSIX.
+  AC_CACHE_CHECK([whether pthread_sigmask is a macro],
+    [gl_cv_func_pthread_sigmask_macro],
+    [AC_EGREP_CPP([headers_define_pthread_sigmask], [
+#include <pthread.h>
+#include <signal.h>
+#ifdef pthread_sigmask
+ headers_define_pthread_sigmask
+#endif],
+       [gl_cv_func_pthread_sigmask_macro=yes],
+       [gl_cv_func_pthread_sigmask_macro=no])
+    ])
+
   LIB_PTHREAD_SIGMASK=
 
-  dnl Test whether the gnulib module 'threadlib' is in use.
-  dnl Some packages like Emacs use --avoid=threadlib.
-  dnl Write the symbol in such a way that it does not cause 'aclocal' to pick
-  dnl the threadlib.m4 file that is installed in $PREFIX/share/aclocal/.
-  m4_ifdef([gl_][THREADLIB], [
-    AC_REQUIRE([gl_][THREADLIB])
+  if test $gl_cv_func_pthread_sigmask_macro = yes; then
+    dnl pthread_sigmask is a dummy macro.
+    HAVE_PTHREAD_SIGMASK=0
+    dnl Make sure to '#undef pthread_sigmask' before defining it.
+    REPLACE_PTHREAD_SIGMASK=1
+  else
+    dnl Test whether the gnulib module 'threadlib' is in use.
+    dnl Some packages like Emacs use --avoid=threadlib.
+    dnl Write the symbol in such a way that it does not cause 'aclocal' to pick
+    dnl the threadlib.m4 file that is installed in $PREFIX/share/aclocal/.
+    m4_ifdef([gl_][THREADLIB], [
+      AC_REQUIRE([gl_][THREADLIB])
 
-    if test "$gl_threads_api" = posix; then
-      if test $ac_cv_func_pthread_sigmask = yes; then
-        dnl pthread_sigmask is available without -lpthread.
-        :
-      else
-        if test -n "$LIBMULTITHREAD"; then
-          AC_CACHE_CHECK([for pthread_sigmask in $LIBMULTITHREAD],
-            [gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD],
-            [gl_save_LIBS="$LIBS"
-             LIBS="$LIBS $LIBMULTITHREAD"
-             AC_LINK_IFELSE(
-               [AC_LANG_PROGRAM(
-                  [[#include <pthread.h>
-                    #include <signal.h>
-                  ]],
-                  [[return pthread_sigmask (0, (sigset_t *) 0, (sigset_t *) 0);]])
-               ],
-               [gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD=yes],
-               [gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD=no])
-             LIBS="$gl_save_LIBS"
-            ])
-          if test $gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD = yes; then
-            AC_CACHE_CHECK([whether pthread_sigmask is only a macro],
-              [gl_cv_func_pthread_sigmask_is_macro],
+      if test "$gl_threads_api" = posix; then
+        if test $ac_cv_func_pthread_sigmask = yes; then
+          dnl pthread_sigmask is available without -lpthread.
+          :
+        else
+          if test -n "$LIBMULTITHREAD"; then
+            AC_CACHE_CHECK([for pthread_sigmask in $LIBMULTITHREAD],
+              [gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD],
               [gl_save_LIBS="$LIBS"
                LIBS="$LIBS $LIBMULTITHREAD"
                AC_LINK_IFELSE(
                  [AC_LANG_PROGRAM(
                     [[#include <pthread.h>
                       #include <signal.h>
-                      #undef pthread_sigmask
                     ]],
                     [[return pthread_sigmask (0, (sigset_t *) 0, (sigset_t *) 0);]])
                  ],
-                 [gl_cv_func_pthread_sigmask_is_macro=no],
-                 [gl_cv_func_pthread_sigmask_is_macro=yes])
+                 [gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD=yes],
+                 [gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD=no])
                LIBS="$gl_save_LIBS"
               ])
-            if test $gl_cv_func_pthread_sigmask_is_macro = yes; then
-              dnl On MinGW pthread_sigmask is just a macro which always returns 0.
-              dnl It does not exist as a real function, which is required by POSIX.
-              REPLACE_PTHREAD_SIGMASK=1
-              gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD=no
+            if test $gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD = yes; then
+              dnl pthread_sigmask is available with -pthread or -lpthread.
+              LIB_PTHREAD_SIGMASK="$LIBMULTITHREAD"
+            else
+              dnl pthread_sigmask is not available at all.
+              HAVE_PTHREAD_SIGMASK=0
             fi
-          fi
-          if test $gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD = yes; then
-            dnl pthread_sigmask is available with -pthread or -lpthread.
-            LIB_PTHREAD_SIGMASK="$LIBMULTITHREAD"
           else
             dnl pthread_sigmask is not available at all.
             HAVE_PTHREAD_SIGMASK=0
           fi
+        fi
+      else
+        dnl pthread_sigmask may exist but does not interoperate with the chosen
+        dnl multithreading facility.
+        dnl If "$gl_threads_api" = pth, we could use the function pth_sigmask,
+        dnl but it is equivalent to sigprocmask, so we choose to emulate
+        dnl pthread_sigmask with sigprocmask also in this case. This yields
+        dnl fewer link dependencies.
+        if test $ac_cv_func_pthread_sigmask = yes; then
+          REPLACE_PTHREAD_SIGMASK=1
         else
-          dnl pthread_sigmask is not available at all.
           HAVE_PTHREAD_SIGMASK=0
         fi
       fi
-    else
-      dnl pthread_sigmask may exist but does not interoperate with the chosen
-      dnl multithreading facility.
-      dnl If "$gl_threads_api" = pth, we could use the function pth_sigmask,
-      dnl but it is equivalent to sigprocmask, so we choose to emulate
-      dnl pthread_sigmask with sigprocmask also in this case. This yields fewer
-      dnl link dependencies.
+    ], [
+      dnl The module 'threadlib' is not in use, due to --avoid=threadlib being
+      dnl specified.
+      dnl The package either has prepared CPPFLAGS and LIBS for use of
+      dnl POSIX:2008 threads, or wants to build single-threaded programs.
       if test $ac_cv_func_pthread_sigmask = yes; then
-        REPLACE_PTHREAD_SIGMASK=1
+        dnl pthread_sigmask exists and does not require extra libraries.
+        dnl Assume that it is declared.
+        :
       else
+        dnl pthread_sigmask either does not exist or needs extra libraries.
         HAVE_PTHREAD_SIGMASK=0
+        dnl Define the symbol rpl_pthread_sigmask, not pthread_sigmask,
+        dnl so as to not accidentally override the system's pthread_sigmask
+        dnl symbol from libpthread. This is necessary on IRIX 6.5.
+        REPLACE_PTHREAD_SIGMASK=1
       fi
-    fi
-  ], [
-    dnl The module 'threadlib' is not in use, due to --avoid=threadlib being
-    dnl specified.
-    dnl The package either has prepared CPPFLAGS and LIBS for use of POSIX:2008
-    dnl threads, or wants to build single-threaded programs.
-    if test $ac_cv_func_pthread_sigmask = yes; then
-      dnl pthread_sigmask exists and does not require extra libraries.
-      dnl Assume that it is declared.
-      :
-    else
-      dnl pthread_sigmask either does not exist or needs extra libraries.
-      HAVE_PTHREAD_SIGMASK=0
-      dnl Define the symbol rpl_pthread_sigmask, not pthread_sigmask,
-      dnl so as to not accidentally override the system's pthread_sigmask
-      dnl symbol from libpthread. This is necessary on IRIX 6.5.
-      REPLACE_PTHREAD_SIGMASK=1
-    fi
-  ])
+    ])
+  fi
 
   AC_SUBST([LIB_PTHREAD_SIGMASK])
   dnl We don't need a variable LTLIB_PTHREAD_SIGMASK, because when
diff --git a/m4/utimbuf.m4 b/m4/utimbuf.m4
deleted file mode 100644
index a950aa9f0e..0000000000
--- a/m4/utimbuf.m4
+++ /dev/null
@@ -1,39 +0,0 @@
-# serial 9
-
-# Copyright (C) 1998-2001, 2003-2004, 2007, 2009-2019 Free Software
-# Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-dnl From Jim Meyering
-
-dnl Define HAVE_STRUCT_UTIMBUF if 'struct utimbuf' is declared --
-dnl usually in <utime.h>.
-dnl Some systems have utime.h but don't declare the struct anywhere.
-
-AC_DEFUN([gl_CHECK_TYPE_STRUCT_UTIMBUF],
-[
-  AC_CHECK_HEADERS_ONCE([sys/time.h utime.h])
-  AC_CACHE_CHECK([for struct utimbuf], [gl_cv_sys_struct_utimbuf],
-    [AC_COMPILE_IFELSE(
-       [AC_LANG_PROGRAM(
-          [[#if HAVE_SYS_TIME_H
-             #include <sys/time.h>
-            #endif
-            #include <time.h>
-            #ifdef HAVE_UTIME_H
-             #include <utime.h>
-            #endif
-          ]],
-          [[static struct utimbuf x; x.actime = x.modtime;]])],
-       [gl_cv_sys_struct_utimbuf=yes],
-       [gl_cv_sys_struct_utimbuf=no])])
-
-  if test $gl_cv_sys_struct_utimbuf = yes; then
-    AC_DEFINE([HAVE_STRUCT_UTIMBUF], [1],
-      [Define if struct utimbuf is declared -- usually in <utime.h>.
-       Some systems have utime.h but don't declare the struct anywhere. ])
-  fi
-])
diff --git a/make-dist b/make-dist
index 821895a005..e4e6d40d98 100755
--- a/make-dist
+++ b/make-dist
@@ -52,7 +52,7 @@ make_tar=no
 default_gzip=gzip
 newer=""
 with_info=yes
-with_tests=no
+with_tests=yes
 changelog=yes
 verbose=no
 
@@ -110,11 +110,16 @@ while [ $# -gt 0 ]; do
      ;;
 
     ## Include the test/ directory.
-    ## This option is mainly for the hydra build server.
+    ## This is for backward compability to when --no-tests was the default.
     "--tests")
       with_tests=yes
      ;;
 
+    ## Exclude the test/ directory.
+    "--no-tests")
+      with_tests=no
+     ;;
+
     "--verbose")
       verbose=yes
      ;;
@@ -131,9 +136,9 @@ while [ $# -gt 0 ]; do
       echo "  --no-update	don't recompile or do analogous things"
       echo "  --no-changelog	don't generate the top-level ChangeLog"
       echo "  --no-info		don't include info files"
+      echo "  --no-tests	don't include the test/ directory"
       echo "  --snapshot	same as --clean-up --no-update --tar --no-check"
       echo "  --tar		make a tar file"
-      echo "  --tests	include the test/ directory"
       echo "  --verbose		noisier output"
       echo ""
       exit 0
@@ -367,7 +372,6 @@ possibly_non_vc_files="
   MANIFEST aclocal.m4 configure
   admin/charsets/jisx2131-filter
   src/config.in src/emacs-module.h
-  src/fingerprint.c
 "$(
   find admin doc etc lisp \
     \( -name '*.el' -o -name '*.elc' -o -name '*.map' -o -name '*.stamp' \
diff --git a/nt/INSTALL.W64 b/nt/INSTALL.W64
index 994c567c34..4583aed83b 100644
--- a/nt/INSTALL.W64
+++ b/nt/INSTALL.W64
@@ -139,10 +139,10 @@ which 'make install' will use - in this example we set it to C:\emacs\emacs-26.
 If a prefix is not specified the files will be put in the standard Unix
 directories located in your C:\msys64 directory, but this is not recommended.
 
-Note also that we need to disable Imagemagick and D-Bus because Emacs
-does not yet support them on Windows.
+Note also that we need to disable D-Bus because Emacs does not yet
+support them on Windows.
 
-  ./configure --prefix=/c/emacs/emacs-26 --without-imagemagick --without-dbus
+  ./configure --prefix=/c/emacs/emacs-26 --without-dbus
 
 ** Run make
 
diff --git a/nt/README.W32 b/nt/README.W32
index 0fac1c3298..c04f1a6d64 100644
--- a/nt/README.W32
+++ b/nt/README.W32
@@ -24,7 +24,7 @@ See the end of the file for license conditions.
 * Preliminaries
 
   There are two binary distributions named
-  emacs-VER-x86_64-w64-mingw32.zip and emacs-VER-i686-w64-mingw32.zip,
+  emacs-VER-x86_64.zip and emacs-VER-i686.zip,
   where VER is the Emacs version.  These are 64-bit and 32-bit builds,
   respectively.  If you are running a 32-bit version of MS-Windows,
   you need to install the 32-bit build; users of 64-bit Windows can
@@ -45,29 +45,14 @@ See the end of the file for license conditions.
   action, by default this will be in a top-level directory with the
   same name as the zip file.
 
-  We also provide a set of optional dependencies, in
-  emacs-MVER-x86_64-deps.zip or emacs-MVER-i686-deps.zip respectively,
-  where MVER is the major Emacs version that should use these
-  libraries.  These provide Emacs with a number of additional optional
-  capabilities, described in detail below.  To use these, unpack them
-  directly over the emacs directory structure.  Note that, if
-  extracting with the Windows Explorer, you will have to override the
-  directory where it wants to put the file with the same directory
-  where you extracted the Emacs binary package.
-
-  Finally, and also optionally, you can run the program addpm.exe in
-  the bin subdirectory which will place an icon for Emacs on the start
-  page.  (This is no longer needed in latest versions of Emacs, so we
-  recommend you not do that, as running addpm.exe will insert entries
-  into the Registry which might get in the way if you upgrade to later
-  versions without updating those entries, or would like to uninstall
-  Emacs.)
-
   Emacs is completely portable.  You can create your own shortcut to
   runemacs.exe and place this wherever you find it convenient (the
   desktop and/or the Taskbar), or run it from a USB or network drive
   without copying or installing anything on the machine itself.
 
+  It is also possible, although not recommended to use the program
+  bin/addpm.exe which will place an icon for Emacs on the start page.
+
 * Prerequisites for Windows 9X
 
   The 32-bit build supports MS-Windows 9X (Windows 95/98/Me).  To run
@@ -151,48 +136,41 @@ See the end of the file for license conditions.
   + update-game-score.exe - A utility for updating the score files of
     Emacs games.
 
-* Optional dependency libraries
+* Emacs without optional dependencies
 
-  Emacs has built in support for XBM and PPM/PGM/PBM images, and the
-  libXpm library is bundled, providing XPM support (required for color
-  toolbar icons and splash screen).  Source for libXpm should be
-  available from the same place from which you got this binary
-  distribution.
+  The files emacs-VER-x86_64.zip and emacs-VER-i686.zip contain a
+  large number of optional dependencies for Emacs.
 
-  Emacs has a number of optional features which need additional
-  libraries.  These are provided in a separate bundle of dependencies,
-  as described above, and enable support for the following:
+  Emacs has a number of optional features which use these additional
+  dependencies.  They enable support for the following:
 
   - displaying inline images of many types (PNG, JPEG, GIF, TIFF, SVG)
   - SSL/TLS secure network communications (HTTPS, IMAPS, etc.)
   - HTML and XML parsing (necessary for the built-in EWW browser)
   - built-in decompression of compressed text
 
-  The optional dependency libraries are in emacs-MVER-x86_64-deps.zip
-  (64-bit) and emacs-MVER-i686-deps.zip (32-bit), and their sources
-  are in emacs-MVER-deps-mingw-w64-src.zip, where MVER is the major
-  version of Emacs that should use these dependencies.  Note that a
-  64-bit Emacs will only work with the 64-bit dependencies, and the
-  32-bit Emacs only with the 32-bit dependencies.
-
-  Newer/updated builds for these optional libraries are available at
-  http://msys2.github.io/ and
-  http://sourceforge.net/projects/ezwinports/files/ (but you shouldn't
-  need these except in emergencies).
+  If you do not want these files (if you have them already for
+  instance, or you want the smallest possible Emacs), then you may use
+  the files emacs-VER-x86_64-no-deps.zip or
+  emacs-VER-i686-no-deps.zip. The dependency files are also available
+  as emacs-MVER-x86_64-no-deps.zip and emacs-MVER-i686-deps.zip. Source
+  code for these dependencies is available as
+  emacs-26-deps-mingw-w64-src.zip.
 
-  If you install the libraries in a directory different from where you
-  have the Emacs executable programs, we recommend to add the
-  directory with DLLs to your Path, so that Emacs will be able to find
-  those DLLs when needed.
+  All distributions of Emacs have built in support for XBM and
+  PPM/PGM/PBM images, and the libXpm library is bundled, providing XPM
+  support (required for color toolbar icons and splash screen).
+  Source for libXpm should be available from the same place from which
+  you got this binary distribution.
 
 * Installing Emacs with an existing MSYS2 installation
 
-  You may also use Emacs with an existing MSYS2 installation by simply
-  unpacking the Emacs distribution over MSYS2.  You can then use the
-  'pacman' utility to install dependencies.  You should not use the
-  optional dependencies bundle from this site, as this will overwrite
-  MSYS2 files (the dependency bundle derives from MSYS2, but may be a
-  different version).
+  You may also use Emacs with an existing MSYS2 installation by
+  unpacking the emacs-VER-x86_64-no-deps.zip over the MSYS2
+  distribution. You should not use the emacs-VER-x86_64.zip from this
+  site, as this will overwrite MSYS2 files (the dependency bundle
+  derives from MSYS2, but will be from a different version). You can
+  then use the 'pacman' utility to install dependencies.
 
   Some of the optional libraries need to be of certain versions to
   work with your Emacs binary.  Make sure you install those versions
@@ -218,6 +196,7 @@ See the end of the file for license conditions.
     mingw-w64-x86_64-libtiff
     mingw-w64-x86_64-libxml2
     mingw-w64-x86_64-xpm-nox
+    mingw-w64-x86_64-lcms2
 
   You can type any subset of this list.  When asked whether to proceed
   with installation, answer Y.
diff --git a/nt/mingw-cfg.site b/nt/mingw-cfg.site
index 4df2049492..498cd6798e 100644
--- a/nt/mingw-cfg.site
+++ b/nt/mingw-cfg.site
@@ -107,6 +107,7 @@ ac_cv_func_pthread_sigmask=yes
 gl_threads_api=posix
 gl_cv_func_pthread_sigmask_return_works=yes
 gl_cv_func_pthread_sigmask_unblock_works="not relevant"
+gl_cv_func_pthread_sigmask_macro=no
 # Implemented in w32proc.c
 emacs_cv_langinfo_codeset=yes
 emacs_cv_langinfo__nl_paper_width=yes
diff --git a/oldXMenu/Create.c b/oldXMenu/Create.c
index 2ea84e921a..58d1782662 100644
--- a/oldXMenu/Create.c
+++ b/oldXMenu/Create.c
@@ -87,7 +87,7 @@ along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #define XASSOC_TABLE_SIZE	64
 
-char *x_get_resource_string (char const *, char const *);
+const char *x_get_resource_string (char const *, char const *);
 
 
 
@@ -107,7 +107,7 @@ XMenuCreate(Display *display, Window parent, register char const *def_env)
                   		/* Window ID of the menu's parent window. */
                            	/* X Defaults program environment name. */
 {
-  register char *def_val;	/* X Default value temp variable. */
+  register const char *def_val;	/* X Default value temp variable. */
 
   register XMenu *menu;		/* Pointer to the new menu. */
   XMStyle menu_style;		/* Menu display style. */
diff --git a/src/.gdbinit b/src/.gdbinit
index b8b303104f..c0cf639359 100644
--- a/src/.gdbinit
+++ b/src/.gdbinit
@@ -1059,8 +1059,10 @@ end
 define xprintsym
   xsymname $arg0
   xgetptr $symname
-  set $sym_name = (struct Lisp_String *) $ptr
-  xprintstr $sym_name
+  if $ptr != 0
+    set $sym_name = (struct Lisp_String *) $ptr
+    xprintstr $sym_name
+  end
 end
 document xprintsym
   Print argument as a symbol.
@@ -1314,7 +1316,7 @@ if hasattr(gdb, 'printing'):
       itype = ival >> (0 if USE_LSB_TAG else VALBITS)
       itype = itype & ((1 << GCTYPEBITS) - 1)
 
-      # For a Lisp integer N, yield "make_number(N)".
+      # For a Lisp fixnum N, yield "make_fixnum(N)".
       if itype == Lisp_Int0 or itype == Lisp_Int1:
         if USE_LSB_TAG:
           ival = ival >> (GCTYPEBITS - 1)
@@ -1322,7 +1324,7 @@ if hasattr(gdb, 'printing'):
           ival = ival | (-1 << VALBITS)
         else:
           ival = ival & ((1 << VALBITS) - 1)
-        return "make_number(%d)" % ival
+        return "make_fixnum(%d)" % ival
 
       # For non-integers other than nil yield "XIL(N)", where N is a C integer.
       # This helps humans distinguish Lisp_Object values from ordinary
diff --git a/src/ChangeLog.10 b/src/ChangeLog.10
index cab6101860..40edccb502 100644
--- a/src/ChangeLog.10
+++ b/src/ChangeLog.10
@@ -1607,7 +1607,7 @@
 	command line option and `initial-frame-alist' which is superfluous
 	after the last change to `w32_createwindow'.
 
-2006-11-04  Slawomir Nowaczyk  <slawek@cs.lth.se>  (tiny change)
+2006-11-04  Sławomir Nowaczyk  <slawek@cs.lth.se>  (tiny change)
 
 	* w32proc.c (sys_wait): Only wait for processes with fd<0.
 	Others should be handled by sys_select instead.  Fixes problems
diff --git a/src/ChangeLog.7 b/src/ChangeLog.7
index 50c748083e..b19cf9d5ca 100644
--- a/src/ChangeLog.7
+++ b/src/ChangeLog.7
@@ -1581,7 +1581,7 @@
 
 	* editfns.c (Finsert_char): Doc fix.
 
-1998-05-02  Hrvoje Niksic  <hniksic@srce.hr>
+1998-05-02  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* fileio.c (Fmake_temp_name): Improve randomness of generated file
 	names.
@@ -1736,7 +1736,7 @@
 
 	* blockinput.h (reinvoke_input_signal): Don't use prototype decl.
 
-1998-04-27  Hrvoje Niksic  <hniksic@srce.hr>
+1998-04-27  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* fns.c (Fload_average): New arg USE_FLOATS.
 
@@ -1985,7 +1985,7 @@
 	(read_process_output): If the process buffer isn't dead, call
 	after-insert-file-set-buffer-file-coding-system.
 
-1998-04-18  Hrvoje Niksic  <hniksic@srce.hr>
+1998-04-18  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* fileio.c (Fmake_temp_name): Complete rewrite.
 
@@ -5329,7 +5329,7 @@
 	* s/aix4-1.h [! HAVE_LIBXMU] (LIBXMU): Define as empty.
 	[! HAVE_LIBXMU] (NO_EDITRES): Defined.
 
-1997-09-30  Hrvoje Niksic  <hniksic@srce.hr>
+1997-09-30  Hrvoje Nikšić  <hniksic@srce.hr>
 
 	* fns.c (Qwidget_type): New variable.
 	(widget-plist-member, widget-put, widget-get, widget-apply): Move
diff --git a/src/ChangeLog.8 b/src/ChangeLog.8
index e1a45b0b8e..3676258040 100644
--- a/src/ChangeLog.8
+++ b/src/ChangeLog.8
@@ -746,7 +746,7 @@
 
 	* xfaces.c (set_lface_from_font_name): Fix incomplete merge.
 
-1999-12-04  Hrvoje Niksic  <hniksic@iskon.hr>
+1999-12-04  Hrvoje Nikšić  <hniksic@iskon.hr>
 
 	* lread.c (Fintern_soft): Accept a symbol argument.
 
diff --git a/src/Makefile.in b/src/Makefile.in
index 0f0d1d8d34..77200440af 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -332,6 +332,7 @@ UNEXEC_OBJ = @UNEXEC_OBJ@
 
 DUMPING=@DUMPING@
 CHECK_STRUCTS = @CHECK_STRUCTS@
+HAVE_PDUMPER = @HAVE_PDUMPER@
 
 # 'make' verbosity.
 AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
@@ -628,19 +629,25 @@ LIBEGNU_ARCHIVE = $(lib)/lib$(if $(HYBRID_MALLOC),e)gnu.a
 $(LIBEGNU_ARCHIVE): $(config_h)
 	$(MAKE) -C $(dir $@) all
 
-FINGERPRINTED = $(LIBXMENU) $(ALLOBJS) $(LIBEGNU_ARCHIVE) $(EMACSRES)
-fingerprint.c: $(FINGERPRINTED) $(libsrc)/make-fingerprint$(EXEEXT)
-	$(AM_V_GEN)$(libsrc)/make-fingerprint$(EXEEXT) $(FINGERPRINTED) >$@.tmp
-	$(AM_V_at)mv $@.tmp $@
+ifeq ($(HAVE_PDUMPER),yes)
+  MAKE_PDUMPER_FINGERPRINT = $(libsrc)/make-fingerprint$(EXEEXT)
+else
+  MAKE_PDUMPER_FINGERPRINT =
+endif
 
 ## We have to create $(etc) here because init_cmdargs tests its
 ## existence when setting Vinstallation_directory (FIXME?).
 ## This goes on to affect various things, and the emacs binary fails
 ## to start if Vinstallation_directory has the wrong value.
-temacs$(EXEEXT): fingerprint.o $(charsets) $(charscript)
-	$(AM_V_CCLD)$(CC) -o $@ $(ALL_CFLAGS) $(TEMACS_LDFLAGS) $(LDFLAGS) \
-	  $(ALLOBJS) fingerprint.o \
-	  $(LIBEGNU_ARCHIVE) $(W32_RES_LINK) $(LIBES)
+temacs$(EXEEXT): $(LIBXMENU) $(ALLOBJS) $(LIBEGNU_ARCHIVE) $(EMACSRES) \
+  $(charsets) $(charscript) $(MAKE_PDUMPER_FINGERPRINT)
+	$(AM_V_CCLD)$(CC) -o $@.tmp \
+	  $(ALL_CFLAGS) $(TEMACS_LDFLAGS) $(LDFLAGS) \
+	  $(ALLOBJS) $(LIBEGNU_ARCHIVE) $(W32_RES_LINK) $(LIBES)
+ifeq ($(HAVE_PDUMPER),yes)
+	$(AM_V_at)$(MAKE_PDUMPER_FINGERPRINT) $@.tmp
+endif
+	$(AM_V_at)mv $@.tmp $@
 	$(MKDIR_P) $(etc)
 ifeq ($(DUMPING),unexec)
   ifneq ($(PAXCTL_notdumped),)
@@ -677,7 +684,7 @@ ns-app: emacs$(EXEEXT) $(pdmp)
 
 mostlyclean:
 	rm -f temacs$(EXEEXT) core ./*.core \#* ./*.o
-	rm -f dmpstruct.h fingerprint.c
+	rm -f dmpstruct.h
 	rm -f emacs.pdmp
 	rm -f ../etc/DOC
 	rm -f bootstrap-emacs$(EXEEXT) $(bootstrap_pdmp)
@@ -717,10 +724,9 @@ ETAGS = ../lib-src/etags${EXEEXT}
 ${ETAGS}: FORCE
 	$(MAKE) -C $(dir $@) $(notdir $@)
 
-# Remove macuvs.h and fingerprint.c since they'd cause `src/emacs`
+# Remove macuvs.h since it'd cause `src/emacs`
 # to be built before we can get TAGS.
-ctagsfiles1 = $(filter-out ${srcdir}/macuvs.h ${srcdir}/fingerprint.c, \
-                           $(wildcard ${srcdir}/*.[hc]))
+ctagsfiles1 = $(filter-out ${srcdir}/macuvs.h, $(wildcard ${srcdir}/*.[hc]))
 ctagsfiles2 = $(wildcard ${srcdir}/*.m)
 
 ## In out-of-tree builds, TAGS are generated in the build dir, like
diff --git a/src/alloc.c b/src/alloc.c
index dd783863be..64aaa8acdf 100644
--- a/src/alloc.c
+++ b/src/alloc.c
@@ -21,6 +21,7 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <config.h>
 
 #include <errno.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <limits.h>		/* For CHAR_BIT.  */
@@ -151,9 +152,7 @@ malloc_initialize_hook (void)
 
       if (malloc_set_state (malloc_state_ptr) != 0)
 	emacs_abort ();
-# ifndef XMALLOC_OVERRUN_CHECK
       alloc_unexec_post ();
-# endif
     }
 }
 
@@ -528,46 +527,16 @@ pointer_align (void *ptr, int alignment)
   return (void *) ROUNDUP ((uintptr_t) ptr, alignment);
 }
 
-/* Define PNTR_ADD and XPNTR as functions, which are cleaner and can
-   be used in debuggers.  Also, define them as macros if
-   DEFINE_KEY_OPS_AS_MACROS, for performance in that case.
-   The macro_* macros are private to this section of code.  */
-
-/* Add a pointer P to an integer I without gcc -fsanitize complaining
-   about the result being out of range of the underlying array.  */
-
-#define macro_PNTR_ADD(p, i) ((p) + (i))
-
-static ATTRIBUTE_NO_SANITIZE_UNDEFINED ATTRIBUTE_UNUSED char *
-PNTR_ADD (char *p, EMACS_UINT i)
-{
-  return macro_PNTR_ADD (p, i);
-}
-
-#if DEFINE_KEY_OPS_AS_MACROS
-# define PNTR_ADD(p, i) macro_PNTR_ADD (p, i)
-#endif
-
 /* Extract the pointer hidden within O.  */
 
-#define macro_XPNTR(o)                                                 \
-  ((void *) \
-   (SYMBOLP (o)							       \
-    ? PNTR_ADD ((char *) lispsym,				       \
-		(XLI (o)						\
-		 - ((EMACS_UINT) Lisp_Symbol << (USE_LSB_TAG ? 0 : VALBITS)))) \
-    : (char *) XLP (o) - (XLI (o) & ~VALMASK)))
-
-static ATTRIBUTE_UNUSED void *
+static ATTRIBUTE_NO_SANITIZE_UNDEFINED void *
 XPNTR (Lisp_Object a)
 {
-  return macro_XPNTR (a);
+  return (SYMBOLP (a)
+	  ? (char *) lispsym + (XLI (a) - LISP_WORD_TAG (Lisp_Symbol))
+	  : (char *) XLP (a) - (XLI (a) & ~VALMASK));
 }
 
-#if DEFINE_KEY_OPS_AS_MACROS
-# define XPNTR(a) macro_XPNTR (a)
-#endif
-
 static void
 XFLOAT_INIT (Lisp_Object f, double n)
 {
@@ -681,171 +650,6 @@ verify (LISP_ALIGNMENT % GCALIGNMENT == 0);
    it never does anything that requires an alignment of 16.  */
 enum { MALLOC_IS_LISP_ALIGNED = alignof (max_align_t) % LISP_ALIGNMENT == 0 };
 
-#ifndef XMALLOC_OVERRUN_CHECK
-#define XMALLOC_OVERRUN_CHECK_OVERHEAD 0
-#else
-
-/* Check for overrun in malloc'ed buffers by wrapping a header and trailer
-   around each block.
-
-   The header consists of XMALLOC_OVERRUN_CHECK_SIZE fixed bytes
-   followed by XMALLOC_OVERRUN_SIZE_SIZE bytes containing the original
-   block size in little-endian order.  The trailer consists of
-   XMALLOC_OVERRUN_CHECK_SIZE fixed bytes.
-
-   The header is used to detect whether this block has been allocated
-   through these functions, as some low-level libc functions may
-   bypass the malloc hooks.  */
-
-#define XMALLOC_OVERRUN_CHECK_SIZE 16
-#define XMALLOC_OVERRUN_CHECK_OVERHEAD \
-  (2 * XMALLOC_OVERRUN_CHECK_SIZE + XMALLOC_OVERRUN_SIZE_SIZE)
-
-/* Define XMALLOC_OVERRUN_SIZE_SIZE so that (1) it's large enough to
-   hold a size_t value and (2) the header size is a multiple of the
-   alignment that Emacs needs for C types and for USE_LSB_TAG.  */
-#define XMALLOC_OVERRUN_SIZE_SIZE				\
-   (((XMALLOC_OVERRUN_CHECK_SIZE + sizeof (size_t)		\
-      + LISP_ALIGNMENT - 1)					\
-     / LISP_ALIGNMENT * LISP_ALIGNMENT)				\
-    - XMALLOC_OVERRUN_CHECK_SIZE)
-
-static char const xmalloc_overrun_check_header[XMALLOC_OVERRUN_CHECK_SIZE] =
-  { '\x9a', '\x9b', '\xae', '\xaf',
-    '\xbf', '\xbe', '\xce', '\xcf',
-    '\xea', '\xeb', '\xec', '\xed',
-    '\xdf', '\xde', '\x9c', '\x9d' };
-
-static char const xmalloc_overrun_check_trailer[XMALLOC_OVERRUN_CHECK_SIZE] =
-  { '\xaa', '\xab', '\xac', '\xad',
-    '\xba', '\xbb', '\xbc', '\xbd',
-    '\xca', '\xcb', '\xcc', '\xcd',
-    '\xda', '\xdb', '\xdc', '\xdd' };
-
-/* Insert and extract the block size in the header.  */
-
-static void
-xmalloc_put_size (unsigned char *ptr, size_t size)
-{
-  int i;
-  for (i = 0; i < XMALLOC_OVERRUN_SIZE_SIZE; i++)
-    {
-      *--ptr = size & ((1 << CHAR_BIT) - 1);
-      size >>= CHAR_BIT;
-    }
-}
-
-static size_t
-xmalloc_get_size (unsigned char *ptr)
-{
-  size_t size = 0;
-  int i;
-  ptr -= XMALLOC_OVERRUN_SIZE_SIZE;
-  for (i = 0; i < XMALLOC_OVERRUN_SIZE_SIZE; i++)
-    {
-      size <<= CHAR_BIT;
-      size += *ptr++;
-    }
-  return size;
-}
-
-
-/* Like malloc, but wraps allocated block with header and trailer.  */
-
-static void *
-overrun_check_malloc (size_t size)
-{
-  register unsigned char *val;
-  if (SIZE_MAX - XMALLOC_OVERRUN_CHECK_OVERHEAD < size)
-    emacs_abort ();
-
-  val = malloc (size + XMALLOC_OVERRUN_CHECK_OVERHEAD);
-  if (val)
-    {
-      memcpy (val, xmalloc_overrun_check_header, XMALLOC_OVERRUN_CHECK_SIZE);
-      val += XMALLOC_OVERRUN_CHECK_SIZE + XMALLOC_OVERRUN_SIZE_SIZE;
-      xmalloc_put_size (val, size);
-      memcpy (val + size, xmalloc_overrun_check_trailer,
-	      XMALLOC_OVERRUN_CHECK_SIZE);
-    }
-  return val;
-}
-
-
-/* Like realloc, but checks old block for overrun, and wraps new block
-   with header and trailer.  */
-
-static void *
-overrun_check_realloc (void *block, size_t size)
-{
-  register unsigned char *val = (unsigned char *) block;
-  if (SIZE_MAX - XMALLOC_OVERRUN_CHECK_OVERHEAD < size)
-    emacs_abort ();
-
-  if (val
-      && memcmp (xmalloc_overrun_check_header,
-		 val - XMALLOC_OVERRUN_CHECK_SIZE - XMALLOC_OVERRUN_SIZE_SIZE,
-		 XMALLOC_OVERRUN_CHECK_SIZE) == 0)
-    {
-      size_t osize = xmalloc_get_size (val);
-      if (memcmp (xmalloc_overrun_check_trailer, val + osize,
-		  XMALLOC_OVERRUN_CHECK_SIZE))
-	emacs_abort ();
-      memset (val + osize, 0, XMALLOC_OVERRUN_CHECK_SIZE);
-      val -= XMALLOC_OVERRUN_CHECK_SIZE + XMALLOC_OVERRUN_SIZE_SIZE;
-      memset (val, 0, XMALLOC_OVERRUN_CHECK_SIZE + XMALLOC_OVERRUN_SIZE_SIZE);
-    }
-
-  val = realloc (val, size + XMALLOC_OVERRUN_CHECK_OVERHEAD);
-
-  if (val)
-    {
-      memcpy (val, xmalloc_overrun_check_header, XMALLOC_OVERRUN_CHECK_SIZE);
-      val += XMALLOC_OVERRUN_CHECK_SIZE + XMALLOC_OVERRUN_SIZE_SIZE;
-      xmalloc_put_size (val, size);
-      memcpy (val + size, xmalloc_overrun_check_trailer,
-	      XMALLOC_OVERRUN_CHECK_SIZE);
-    }
-  return val;
-}
-
-/* Like free, but checks block for overrun.  */
-
-static void
-overrun_check_free (void *block)
-{
-  unsigned char *val = (unsigned char *) block;
-
-  if (val
-      && memcmp (xmalloc_overrun_check_header,
-		 val - XMALLOC_OVERRUN_CHECK_SIZE - XMALLOC_OVERRUN_SIZE_SIZE,
-		 XMALLOC_OVERRUN_CHECK_SIZE) == 0)
-    {
-      size_t osize = xmalloc_get_size (val);
-      if (memcmp (xmalloc_overrun_check_trailer, val + osize,
-		  XMALLOC_OVERRUN_CHECK_SIZE))
-	emacs_abort ();
-#ifdef XMALLOC_CLEAR_FREE_MEMORY
-      val -= XMALLOC_OVERRUN_CHECK_SIZE + XMALLOC_OVERRUN_SIZE_SIZE;
-      memset (val, 0xff, osize + XMALLOC_OVERRUN_CHECK_OVERHEAD);
-#else
-      memset (val + osize, 0, XMALLOC_OVERRUN_CHECK_SIZE);
-      val -= XMALLOC_OVERRUN_CHECK_SIZE + XMALLOC_OVERRUN_SIZE_SIZE;
-      memset (val, 0, XMALLOC_OVERRUN_CHECK_SIZE + XMALLOC_OVERRUN_SIZE_SIZE);
-#endif
-    }
-
-  free (val);
-}
-
-#undef malloc
-#undef realloc
-#undef free
-#define malloc overrun_check_malloc
-#define realloc overrun_check_realloc
-#define free overrun_check_free
-#endif
-
 /* If compiled with XMALLOC_BLOCK_INPUT_CHECK, define a symbol
    BLOCK_INPUT_IN_MEMORY_ALLOCATORS that is visible to the debugger.
    If that variable is set, block input while in one of Emacs's memory
@@ -919,7 +723,7 @@ xzalloc (size_t size)
   return val;
 }
 
-/* Like realloc but check for no memory and block interrupt input..  */
+/* Like realloc but check for no memory and block interrupt input.  */
 
 void *
 xrealloc (void *block, size_t size)
@@ -1643,9 +1447,7 @@ mark_interval_tree (INTERVAL i)
 
 #define LARGE_STRING_BYTES 1024
 
-/* The SDATA typedef is a struct or union describing string memory
-   sub-allocated from an sblock.  This is where the contents of Lisp
-   strings are stored.  */
+/* The layout of a nonnull string.  */
 
 struct sdata
 {
@@ -1664,13 +1466,8 @@ struct sdata
   unsigned char data[FLEXIBLE_ARRAY_MEMBER];
 };
 
-#ifdef GC_CHECK_STRING_BYTES
-
-typedef struct sdata sdata;
-#define SDATA_NBYTES(S)	(S)->nbytes
-#define SDATA_DATA(S)	(S)->data
-
-#else
+/* A union describing string memory sub-allocated from an sblock.
+   This is where the contents of Lisp strings are stored.  */
 
 typedef union
 {
@@ -1698,8 +1495,6 @@ typedef union
 #define SDATA_NBYTES(S)	(S)->n.nbytes
 #define SDATA_DATA(S)	((struct sdata *) (S))->data
 
-#endif /* not GC_CHECK_STRING_BYTES */
-
 enum { SDATA_DATA_OFFSET = offsetof (struct sdata, data) };
 
 /* Structure describing a block of memory which is sub-allocated to
@@ -1771,47 +1566,34 @@ static struct Lisp_String *string_free_list;
 
 #ifdef GC_CHECK_STRING_OVERRUN
 
-/* We check for overrun in string data blocks by appending a small
+/* Check for overrun in string data blocks by appending a small
    "cookie" after each allocated string data block, and check for the
    presence of this cookie during GC.  */
-
-#define GC_STRING_OVERRUN_COOKIE_SIZE	4
+# define GC_STRING_OVERRUN_COOKIE_SIZE ROUNDUP (4, alignof (sdata))
 static char const string_overrun_cookie[GC_STRING_OVERRUN_COOKIE_SIZE] =
-  { '\xde', '\xad', '\xbe', '\xef' };
+  { '\xde', '\xad', '\xbe', '\xef', /* Perhaps some zeros here.  */ };
 
 #else
-#define GC_STRING_OVERRUN_COOKIE_SIZE 0
+# define GC_STRING_OVERRUN_COOKIE_SIZE 0
 #endif
 
-/* Value is the size of an sdata structure large enough to hold NBYTES
-   bytes of string data.  The value returned includes a terminating
-   NUL byte, the size of the sdata structure, and padding.  */
-
-#ifdef GC_CHECK_STRING_BYTES
-
-#define SDATA_SIZE(NBYTES) FLEXSIZEOF (struct sdata, data, (NBYTES) + 1)
-
-#else /* not GC_CHECK_STRING_BYTES */
-
-/* The 'max' reserves space for the nbytes union member even when NBYTES + 1 is
-   less than the size of that member.  The 'max' is not needed when
-   SDATA_DATA_OFFSET is a multiple of FLEXALIGNOF (struct sdata),
-   because then the alignment code reserves enough space.  */
+/* Return the size of an sdata structure large enough to hold N bytes
+   of string data.  This counts the sdata structure, the N bytes, a
+   terminating NUL byte, and alignment padding.  */
 
-#define SDATA_SIZE(NBYTES)				      \
-     ((SDATA_DATA_OFFSET				      \
-       + (SDATA_DATA_OFFSET % FLEXALIGNOF (struct sdata) == 0 \
-	  ? NBYTES					      \
-	  : max (NBYTES, FLEXALIGNOF (struct sdata) - 1))     \
-       + 1						      \
-       + FLEXALIGNOF (struct sdata) - 1)		      \
-      & ~(FLEXALIGNOF (struct sdata) - 1))
-
-#endif /* not GC_CHECK_STRING_BYTES */
+static ptrdiff_t
+sdata_size (ptrdiff_t n)
+{
+  /* Reserve space for the nbytes union member even when N + 1 is less
+     than the size of that member.  */
+  ptrdiff_t unaligned_size = max (SDATA_DATA_OFFSET + n + 1,
+				  sizeof (sdata));
+  int sdata_align = max (FLEXALIGNOF (struct sdata), alignof (sdata));
+  return (unaligned_size + sdata_align - 1) & ~(sdata_align - 1);
+}
 
 /* Extra bytes to allocate for each string.  */
-
-#define GC_STRING_EXTRA (GC_STRING_OVERRUN_COOKIE_SIZE)
+#define GC_STRING_EXTRA GC_STRING_OVERRUN_COOKIE_SIZE
 
 /* Exact bound on the number of bytes in a string, not counting the
    terminating NUL.  A string cannot contain more bytes than
@@ -1820,7 +1602,7 @@ static char const string_overrun_cookie[GC_STRING_OVERRUN_COOKIE_SIZE] =
    calculating a value to be passed to malloc.  */
 static ptrdiff_t const STRING_BYTES_MAX =
   min (STRING_BYTES_BOUND,
-       ((SIZE_MAX - XMALLOC_OVERRUN_CHECK_OVERHEAD
+       ((SIZE_MAX
 	 - GC_STRING_EXTRA
 	 - offsetof (struct sblock, data)
 	 - SDATA_DATA_OFFSET)
@@ -1851,7 +1633,7 @@ string_bytes (struct Lisp_String *s)
   ptrdiff_t nbytes =
     (s->u.s.size_byte < 0 ? s->u.s.size & ~ARRAY_MARK_FLAG : s->u.s.size_byte);
 
-  if (!PURE_P (s) && s->u.s.data
+  if (!PURE_P (s) && !pdumper_object_p (s) && s->u.s.data
       && nbytes != SDATA_NBYTES (SDATA_OF_STRING (s)))
     emacs_abort ();
   return nbytes;
@@ -1862,21 +1644,14 @@ string_bytes (struct Lisp_String *s)
 static void
 check_sblock (struct sblock *b)
 {
-  sdata *from, *end, *from_end;
+  sdata *end = b->next_free;
 
-  end = b->next_free;
-
-  for (from = b->data; from < end; from = from_end)
+  for (sdata *from = b->data; from < end; )
     {
-      /* Compute the next FROM here because copying below may
-	 overwrite data we need to compute it.  */
-      ptrdiff_t nbytes;
-
-      /* Check that the string size recorded in the string is the
-	 same as the one recorded in the sdata structure.  */
-      nbytes = SDATA_SIZE (from->string ? string_bytes (from->string)
-			   : SDATA_NBYTES (from));
-      from_end = (sdata *) ((char *) from + nbytes + GC_STRING_EXTRA);
+      ptrdiff_t nbytes = sdata_size (from->string
+				     ? string_bytes (from->string)
+				     : SDATA_NBYTES (from));
+      from = (sdata *) ((char *) from + nbytes + GC_STRING_EXTRA);
     }
 }
 
@@ -2008,14 +1783,14 @@ allocate_string_data (struct Lisp_String *s,
 {
   sdata *data, *old_data;
   struct sblock *b;
-  ptrdiff_t needed, old_nbytes;
+  ptrdiff_t old_nbytes;
 
   if (STRING_BYTES_MAX < nbytes)
     string_overflow ();
 
   /* Determine the number of bytes needed to store NBYTES bytes
      of string data.  */
-  needed = SDATA_SIZE (nbytes);
+  ptrdiff_t needed = sdata_size (nbytes);
   if (s->u.s.data)
     {
       old_data = SDATA_OF_STRING (s);
@@ -2072,6 +1847,7 @@ allocate_string_data (struct Lisp_String *s,
 
   data->string = s;
   b->next_free = (sdata *) ((char *) data + needed + GC_STRING_EXTRA);
+  eassert ((uintptr_t) b->next_free % alignof (sdata) == 0);
 
   MALLOC_UNBLOCK_INPUT;
 
@@ -2265,7 +2041,7 @@ compact_small_strings (void)
 	      nbytes = s ? STRING_BYTES (s) : SDATA_NBYTES (from);
 	      eassert (nbytes <= LARGE_STRING_BYTES);
 
-	      ptrdiff_t size = SDATA_SIZE (nbytes);
+	      ptrdiff_t size = sdata_size (nbytes);
 	      sdata *from_end = (sdata *) ((char *) from
 					   + size + GC_STRING_EXTRA);
 
@@ -2831,18 +2607,6 @@ DEFUN ("cons", Fcons, Scons, 2, 2, 0,
   return val;
 }
 
-#ifdef GC_CHECK_CONS_LIST
-/* Get an error now if there's any junk in the cons free list.  */
-void
-check_cons_list (void)
-{
-  struct Lisp_Cons *tail = cons_free_list;
-
-  while (tail)
-    tail = tail->u.s.u.chain;
-}
-#endif
-
 /* Make a list of 1, 2, 3, 4 or 5 specified objects.  */
 
 Lisp_Object
@@ -3270,14 +3034,12 @@ cleanup_vector (struct Lisp_Vector *vector)
       /* sweep_buffer should already have unchained this from its buffer.  */
       eassert (! PSEUDOVEC_STRUCT (vector, Lisp_Marker)->buffer);
     }
-#ifdef HAVE_MODULES
   else if (PSEUDOVECTOR_TYPEP (&vector->header, PVEC_USER_PTR))
     {
       struct Lisp_User_Ptr *uptr = PSEUDOVEC_STRUCT (vector, Lisp_User_Ptr);
       if (uptr->finalizer)
 	uptr->finalizer (uptr->p);
     }
-#endif
 }
 
 /* Reclaim space used by unmarked vectors.  */
@@ -4847,10 +4609,6 @@ maybe_lisp_pointer (void *p)
   return (uintptr_t) p % LISP_ALIGNMENT == 0;
 }
 
-#ifndef HAVE_MODULES
-enum { HAVE_MODULES = false };
-#endif
-
 /* If P points to Lisp data, mark that as live if it isn't already
    marked.  */
 
@@ -4863,17 +4621,8 @@ mark_maybe_pointer (void *p)
   VALGRIND_MAKE_MEM_DEFINED (&p, sizeof (p));
 #endif
 
-  if (sizeof (Lisp_Object) == sizeof (void *) || !HAVE_MODULES)
-    {
-      if (!maybe_lisp_pointer (p))
-        return;
-    }
-  else
-    {
-      /* For the wide-int case, also mark emacs_value tagged pointers,
-	 which can be generated by emacs-module.c's value_to_lisp.  */
-      p = (void *) ((uintptr_t) p & ~((1 << GCTYPEBITS) - 1));
-    }
+  if (!maybe_lisp_pointer (p))
+    return;
 
   if (pdumper_object_p (p))
     {
@@ -6048,8 +5797,6 @@ garbage_collect_1 (struct gcstat *gcst)
   /* Record this function, so it appears on the profiler's backtraces.  */
   record_in_backtrace (QAutomatic_GC, 0, 0);
 
-  check_cons_list ();
-
   /* Don't keep undo information around forever.
      Do this early on, so it is no problem if the user quits.  */
   FOR_EACH_BUFFER (nextb)
@@ -6169,8 +5916,6 @@ garbage_collect_1 (struct gcstat *gcst)
 
   unmark_main_thread ();
 
-  check_cons_list ();
-
   gc_in_progress = 0;
 
   unblock_input ();
@@ -6517,7 +6262,7 @@ mark_frame (struct Lisp_Vector *ptr)
   mark_vectorlike (&ptr->header);
   mark_face_cache (f->face_cache);
 #ifdef HAVE_WINDOW_SYSTEM
-  if (FRAME_WINDOW_P (f) && FRAME_X_OUTPUT (f))
+  if (FRAME_WINDOW_P (f) && FRAME_OUTPUT_DATA (f))
     {
       struct font *font = FRAME_FONT (f);
 
@@ -6639,7 +6384,7 @@ mark_object (Lisp_Object arg)
   do {						\
     CHECK_ALLOCATED ();				\
     CHECK_LIVE (LIVEP);				\
-  } while (0)					\
+  } while (false)
 
   /* Check both of the above conditions, for symbols.  */
 #define CHECK_ALLOCATED_AND_LIVE_SYMBOL()	\
@@ -6649,7 +6394,7 @@ mark_object (Lisp_Object arg)
 	CHECK_ALLOCATED ();			\
 	CHECK_LIVE (live_symbol_p);		\
       }						\
-  } while (0)					\
+  } while (false)
 
 #else /* not GC_CHECK_MARKED_OBJECTS */
 
@@ -7624,9 +7369,9 @@ The time is in seconds as a floating point value.  */);
               doc: /* Accumulated number of garbage collections done.  */);
 
   DEFVAR_INT ("integer-width", integer_width,
-	      doc: /* Maximum number of bits in bignums.
-Integers outside the fixnum range are limited to absolute values less
-than 2**N, where N is this variable's value.  N should be nonnegative.  */);
+	      doc: /* Maximum number N of bits in safely-calculated integers.
+Integers with absolute values less than 2**N do not signal a range error.
+N should be nonnegative.  */);
 
   defsubr (&Scons);
   defsubr (&Slist);
diff --git a/src/bignum.c b/src/bignum.c
index 009d73118c..3883d3a394 100644
--- a/src/bignum.c
+++ b/src/bignum.c
@@ -82,8 +82,11 @@ static Lisp_Object
 make_bignum_bits (size_t bits)
 {
   /* The documentation says integer-width should be nonnegative, so
-     a single comparison suffices even though 'bits' is unsigned.  */
-  if (integer_width < bits)
+     comparing it to BITS works even though BITS is unsigned.  Treat
+     integer-width as if it were at least twice the machine integer width,
+     so that timefns.c can safely use bignums for double-precision
+     timestamps.  */
+  if (integer_width < bits && 2 * max (INTMAX_WIDTH, UINTMAX_WIDTH) < bits)
     overflow_error ();
 
   struct Lisp_Bignum *b = ALLOCATE_PLAIN_PSEUDOVECTOR (struct Lisp_Bignum,
diff --git a/src/bignum.h b/src/bignum.h
index 4c670bd906..743a18fc0f 100644
--- a/src/bignum.h
+++ b/src/bignum.h
@@ -94,6 +94,18 @@ bignum_integer (mpz_t *tmp, Lisp_Object i)
   return &XBIGNUM (i)->value;
 }
 
+/* Set RESULT to the value stored in the Lisp integer I.  If I is a
+   big integer, copy it to RESULT.  RESULT must already be
+   initialized.  */
+INLINE void
+mpz_set_integer (mpz_t result, Lisp_Object i)
+{
+  if (FIXNUMP (i))
+    mpz_set_intmax (result, XFIXNUM (i));
+  else
+    mpz_set (result, XBIGNUM (i)->value);
+}
+
 INLINE_HEADER_END
 
 #endif /* BIGNUM_H */
diff --git a/src/buffer.c b/src/buffer.c
index ab47748191..209e29f0f1 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -2264,7 +2264,7 @@ validate_region (register Lisp_Object *b, register Lisp_Object *e)
 /* Advance BYTE_POS up to a character boundary
    and return the adjusted position.  */
 
-static ptrdiff_t
+ptrdiff_t
 advance_to_char_boundary (ptrdiff_t byte_pos)
 {
   int c;
@@ -2702,6 +2702,9 @@ current buffer is cleared.  */)
 
       /* Do this last, so it can calculate the new correspondences
 	 between chars and bytes.  */
+      /* FIXME: Is it worth the trouble, really?  Couldn't we just throw
+         away all the text-properties instead of trying to guess how
+         to adjust them?  AFAICT the result is not reliable anyway.  */
       set_intervals_multibyte (1);
     }
 
@@ -5600,17 +5603,17 @@ Use the command `abbrev-mode' to change this variable.  */);
 		     doc: /* Non-nil if searches and matches should ignore case.  */);
 
   DEFVAR_PER_BUFFER ("fill-column", &BVAR (current_buffer, fill_column),
-		     Qfixnump,
+		     Qintegerp,
 		     doc: /* Column beyond which automatic line-wrapping should happen.
 Interactively, you can set the buffer local value using \\[set-fill-column].  */);
 
   DEFVAR_PER_BUFFER ("left-margin", &BVAR (current_buffer, left_margin),
-		     Qfixnump,
+		     Qintegerp,
 		     doc: /* Column for the default `indent-line-function' to indent to.
 Linefeed indents to this column in Fundamental mode.  */);
 
   DEFVAR_PER_BUFFER ("tab-width", &BVAR (current_buffer, tab_width),
-		     Qfixnump,
+		     Qintegerp,
 		     doc: /* Distance between tab stops (for display of tab characters), in columns.
 NOTE: This controls the display width of a TAB character, and not
 the size of an indentation step.
@@ -5781,7 +5784,7 @@ If it is nil, that means don't auto-save this buffer.  */);
 Backing up is done before the first time the file is saved.  */);
 
   DEFVAR_PER_BUFFER ("buffer-saved-size", &BVAR (current_buffer, save_length),
-		     Qfixnump,
+		     Qintegerp,
 		     doc: /* Length of current buffer when last read in, saved or auto-saved.
 0 initially.
 -1 means auto-saving turned off until next real save.
@@ -5855,7 +5858,7 @@ In addition, a char-table has six extra slots to control the display of:
 See also the functions `display-table-slot' and `set-display-table-slot'.  */);
 
   DEFVAR_PER_BUFFER ("left-margin-width", &BVAR (current_buffer, left_margin_cols),
-		     Qfixnump,
+		     Qintegerp,
 		     doc: /* Width in columns of left marginal area for display of a buffer.
 A value of nil means no marginal area.
 
@@ -5863,7 +5866,7 @@ Setting this variable does not take effect until a new buffer is displayed
 in a window.  To make the change take effect, call `set-window-buffer'.  */);
 
   DEFVAR_PER_BUFFER ("right-margin-width", &BVAR (current_buffer, right_margin_cols),
-		     Qfixnump,
+		     Qintegerp,
 		     doc: /* Width in columns of right marginal area for display of a buffer.
 A value of nil means no marginal area.
 
@@ -5871,7 +5874,7 @@ Setting this variable does not take effect until a new buffer is displayed
 in a window.  To make the change take effect, call `set-window-buffer'.  */);
 
   DEFVAR_PER_BUFFER ("left-fringe-width", &BVAR (current_buffer, left_fringe_width),
-		     Qfixnump,
+		     Qintegerp,
 		     doc: /* Width of this buffer's left fringe (in pixels).
 A value of 0 means no left fringe is shown in this buffer's window.
 A value of nil means to use the left fringe width from the window's frame.
@@ -5880,7 +5883,7 @@ Setting this variable does not take effect until a new buffer is displayed
 in a window.  To make the change take effect, call `set-window-buffer'.  */);
 
   DEFVAR_PER_BUFFER ("right-fringe-width", &BVAR (current_buffer, right_fringe_width),
-		     Qfixnump,
+		     Qintegerp,
 		     doc: /* Width of this buffer's right fringe (in pixels).
 A value of 0 means no right fringe is shown in this buffer's window.
 A value of nil means to use the right fringe width from the window's frame.
@@ -5897,12 +5900,12 @@ Setting this variable does not take effect until a new buffer is displayed
 in a window.  To make the change take effect, call `set-window-buffer'.  */);
 
   DEFVAR_PER_BUFFER ("scroll-bar-width", &BVAR (current_buffer, scroll_bar_width),
-		     Qfixnump,
+		     Qintegerp,
 		     doc: /* Width of this buffer's vertical scroll bars in pixels.
 A value of nil means to use the scroll bar width from the window's frame.  */);
 
   DEFVAR_PER_BUFFER ("scroll-bar-height", &BVAR (current_buffer, scroll_bar_height),
-		     Qfixnump,
+		     Qintegerp,
 		     doc: /* Height of this buffer's horizontal scroll bars in pixels.
 A value of nil means to use the scroll bar height from the window's frame.  */);
 
@@ -6172,7 +6175,7 @@ Setting this variable is very fast, much faster than scanning all the text in
 the buffer looking for properties to change.  */);
 
   DEFVAR_PER_BUFFER ("buffer-display-count",
-		     &BVAR (current_buffer, display_count), Qfixnump,
+		     &BVAR (current_buffer, display_count), Qintegerp,
 		     doc: /* A number incremented each time this buffer is displayed in a window.
 The function `set-window-buffer' increments it.  */);
 
diff --git a/src/buffer.h b/src/buffer.h
index f42c3e97b9..2080a6f40b 100644
--- a/src/buffer.h
+++ b/src/buffer.h
@@ -327,6 +327,10 @@ extern void enlarge_buffer_text (struct buffer *, ptrdiff_t);
 #define BYTE_TO_CHAR(bytepos)			\
   (buf_bytepos_to_charpos (current_buffer, bytepos))
 
+/* For those very rare cases where you may have a "random" pointer into
+   the middle of a multibyte char, this moves to the next boundary.  */
+extern ptrdiff_t advance_to_char_boundary (ptrdiff_t byte_pos);
+
 /* Convert PTR, the address of a byte in the buffer, into a byte position.  */
 
 #define PTR_BYTE_POS(ptr) \
diff --git a/src/bytecode.c b/src/bytecode.c
index 40977799bf..6f601cf0cd 100644
--- a/src/bytecode.c
+++ b/src/bytecode.c
@@ -562,7 +562,7 @@ exec_byte_code (Lisp_Object bytestr, Lisp_Object vector, Lisp_Object maxdepth,
 	    /* Inline the most common case.  */
 	    if (SYMBOLP (sym)
 		&& !EQ (val, Qunbound)
-		&& !XSYMBOL (sym)->u.s.redirect
+		&& XSYMBOL (sym)->u.s.redirect == SYMBOL_PLAINVAL
 		&& !SYMBOL_TRAPPED_WRITE_P (sym))
 	      SET_SYMBOL_VAL (XSYMBOL (sym), val);
 	    else
diff --git a/src/callproc.c b/src/callproc.c
index a3d09609d7..98c67312b4 100644
--- a/src/callproc.c
+++ b/src/callproc.c
@@ -681,7 +681,7 @@ call_process (ptrdiff_t nargs, Lisp_Object *args, int filefd,
   unblock_input ();
 
   if (pid < 0)
-    report_file_errno ("Doing vfork", Qnil, child_errno);
+    report_file_errno (CHILD_SETUP_ERROR_DESC, Qnil, child_errno);
 
   /* Close our file descriptors, except for callproc_fd[CALLPROC_PIPEREAD]
      since we will use that to read input from.  */
@@ -1135,7 +1135,7 @@ add_env (char **env, char **new_env, char *string)
    mess up the allocator's data structures in the parent.
    Report the error and exit the child.  */
 
-static _Noreturn void
+static AVOID
 exec_failed (char const *name, int err)
 {
   /* Avoid deadlock if the child's perror writes to a full pipe; the
@@ -1174,7 +1174,7 @@ exec_failed (char const *name, int err)
    executable directory by the parent.
 
    On GNUish hosts, either exec or return an error number.
-   On MS-Windows, either return a pid or signal an error.
+   On MS-Windows, either return a pid or return -1 and set errno.
    On MS-DOS, either return an exit status or signal an error.  */
 
 CHILD_SETUP_TYPE
@@ -1319,9 +1319,6 @@ child_setup (int in, int out, int err, char **new_argv, bool set_pgrp,
   /* Spawn the child.  (See w32proc.c:sys_spawnve).  */
   cpid = spawnve (_P_NOWAIT, new_argv[0], new_argv, env);
   reset_standard_handles (in, out, err, handles);
-  if (cpid == -1)
-    /* An error occurred while trying to spawn the process.  */
-    report_file_error ("Spawning child process", Qnil);
   return cpid;
 
 #else  /* not WINDOWSNT */
diff --git a/src/character.h b/src/character.h
index 5dff85aed4..cc57a2a7d5 100644
--- a/src/character.h
+++ b/src/character.h
@@ -558,12 +558,13 @@ enum
 
 /* Return a non-outlandish value for the tab width.  */
 
-#define SANE_TAB_WIDTH(buf) \
-  sanitize_tab_width (XFIXNAT (BVAR (buf, tab_width)))
+#define SANE_TAB_WIDTH(buf) sanitize_tab_width (BVAR (buf, tab_width))
+
 INLINE int
-sanitize_tab_width (EMACS_INT width)
+sanitize_tab_width (Lisp_Object width)
 {
-  return 0 < width && width <= 1000 ? width : 8;
+  return (FIXNUMP (width) && 0 < XFIXNUM (width) && XFIXNUM (width) <= 1000
+	  ? XFIXNUM (width) : 8);
 }
 
 /* Return the width of ASCII character C.  The width is measured by
diff --git a/src/coding.c b/src/coding.c
index e351cc72fa..5b9bfa17dd 100644
--- a/src/coding.c
+++ b/src/coding.c
@@ -302,12 +302,6 @@ encode_coding_XXX (struct coding_system *coding)
 
 Lisp_Object Vcoding_system_hash_table;
 
-/* Format of end-of-line decided by system.  This is Qunix on
-   Unix and Mac, Qdos on DOS/Windows.
-   This has an effect only for external encoding (i.e. for output to
-   file and process), not for in-buffer or Lisp string encoding.  */
-static Lisp_Object system_eol_type;
-
 /* Coding-systems are handed between Emacs Lisp programs and C internal
    routines by the following three variables.  */
 /* Coding system to be used to encode text for terminal display when
@@ -5972,8 +5966,7 @@ raw_text_coding_system_p (struct coding_system *coding)
 
 /* If CODING_SYSTEM doesn't specify end-of-line format, return one of
    the subsidiary that has the same eol-spec as PARENT (if it is not
-   nil and specifies end-of-line format) or the system's setting
-   (system_eol_type).  */
+   nil and specifies end-of-line format) or the system's setting.  */
 
 Lisp_Object
 coding_inherit_eol_type (Lisp_Object coding_system, Lisp_Object parent)
@@ -5988,20 +5981,24 @@ coding_inherit_eol_type (Lisp_Object coding_system, Lisp_Object parent)
   eol_type = AREF (spec, 2);
   if (VECTORP (eol_type))
     {
-      Lisp_Object parent_eol_type;
+      /* Format of end-of-line decided by system.
+	 This is Qunix on Unix and Mac, Qdos on DOS/Windows.
+	 This has an effect only for external encoding (i.e., for output to
+	 file and process), not for in-buffer or Lisp string encoding.  */
+      Lisp_Object system_eol_type = Qunix;
+      #ifdef DOS_NT
+       system_eol_type = Qdos;
+      #endif
 
+      Lisp_Object parent_eol_type = system_eol_type;
       if (! NILP (parent))
 	{
-	  Lisp_Object parent_spec;
-
 	  CHECK_CODING_SYSTEM (parent);
-	  parent_spec = CODING_SYSTEM_SPEC (parent);
-	  parent_eol_type = AREF (parent_spec, 2);
-	  if (VECTORP (parent_eol_type))
-	    parent_eol_type = system_eol_type;
+	  Lisp_Object parent_spec = CODING_SYSTEM_SPEC (parent);
+	  Lisp_Object pspec_type = AREF (parent_spec, 2);
+	  if (!VECTORP (pspec_type))
+	    parent_eol_type = pspec_type;
 	}
-      else
-	parent_eol_type = system_eol_type;
       if (EQ (parent_eol_type, Qunix))
 	coding_system = AREF (eol_type, 0);
       else if (EQ (parent_eol_type, Qdos))
@@ -6356,6 +6353,29 @@ utf8_string_p (Lisp_Object string)
   return check_utf_8 (&coding) != -1;
 }
 
+/* Like make_string, but always returns a multibyte Lisp string, and
+   avoids decoding if TEXT encoded in UTF-8.  */
+
+Lisp_Object
+make_string_from_utf8 (const char *text, ptrdiff_t nbytes)
+{
+  ptrdiff_t chars, bytes;
+  parse_str_as_multibyte ((const unsigned char *) text, nbytes,
+			  &chars, &bytes);
+  /* If TEXT is a valid UTF-8 string, we can convert it to a Lisp
+     string directly.  Otherwise, we need to decode it.  */
+  if (chars == nbytes || bytes == nbytes)
+    return make_specified_string (text, chars, nbytes, true);
+  else
+    {
+      struct coding_system coding;
+      setup_coding_system (Qutf_8_unix, &coding);
+      coding.mode |= CODING_MODE_LAST_BLOCK;
+      coding.source = (const unsigned char *) text;
+      decode_coding_object (&coding, Qnil, 0, 0, nbytes, nbytes, Qt);
+      return coding.dst_object;
+    }
+}
 
 /* Detect how end-of-line of a text of length SRC_BYTES pointed by
    SOURCE is encoded.  If CATEGORY is one of
@@ -7783,15 +7803,22 @@ encode_coding (struct coding_system *coding)
   SAFE_FREE ();
 }
 
-
-/* Name (or base name) of work buffer for code conversion.  */
+/* Code-conversion operations use internal buffers.  There's a single
+   reusable buffer, which is created the first time it is needed, and
+   then never killed.  When this reusable buffer is being used, the
+   reused_workbuf_in_use flag is set.  If we need another conversion
+   buffer while the reusable one is in use (e.g., if code-conversion
+   is reentered when another code-conversion is in progress), we
+   create temporary buffers using the name of the reusable buffer as
+   the base name, see code_conversion_save below.  These temporary
+   buffers are killed when the code-conversion operations that use
+   them return, see code_conversion_restore below.  */
+
+/* A string that serves as name of the reusable work buffer, and as base
+   name of temporary work buffers used for code-conversion operations.  */
 Lisp_Object Vcode_conversion_workbuf_name;
 
-/* A working buffer used by the top level conversion.  Once it is
-   created, it is never destroyed.  It has the name
-   Vcode_conversion_workbuf_name.  The other working buffers are
-   destroyed after the use is finished, and their names are modified
-   versions of Vcode_conversion_workbuf_name.  */
+/* The reusable working buffer, created once and never killed.  */
 static Lisp_Object Vcode_conversion_reused_workbuf;
 
 /* True iff Vcode_conversion_reused_workbuf is already in use.  */
@@ -9382,7 +9409,8 @@ START and END are buffer positions.
 Optional 4th arguments DESTINATION specifies where the decoded text goes.
 If nil, the region between START and END is replaced by the decoded text.
 If buffer, the decoded text is inserted in that buffer after point (point
-does not move).
+does not move).  If that buffer is unibyte, it receives the individual
+bytes of the internal representation of the decoded text.
 In those cases, the length of the decoded text is returned.
 If DESTINATION is t, the decoded text is returned.
 
@@ -9540,7 +9568,9 @@ if the decoding operation is trivial.
 
 Optional fourth arg BUFFER non-nil means that the decoded text is
 inserted in that buffer after point (point does not move).  In this
-case, the return value is the length of the decoded text.
+case, the return value is the length of the decoded text.  If that
+buffer is unibyte, it receives the individual bytes of the internal
+representation of the decoded text.
 
 This function sets `last-coding-system-used' to the precise coding system
 used (which may be different from CODING-SYSTEM if CODING-SYSTEM is
@@ -11306,13 +11336,6 @@ internal character representation.  */);
   for (int i = 0; i < coding_category_max; i++)
     Fset (AREF (Vcoding_category_table, i), Qno_conversion);
 
-#if defined (DOS_NT)
-  system_eol_type = Qdos;
-#else
-  system_eol_type = Qunix;
-#endif
-  staticpro (&system_eol_type);
-
   pdumper_do_now_and_after_load (reset_coding_after_pdumper_load);
 }
 
diff --git a/src/coding.h b/src/coding.h
index 0c03d1a44e..619ca29c8e 100644
--- a/src/coding.h
+++ b/src/coding.h
@@ -695,6 +695,7 @@ extern Lisp_Object raw_text_coding_system (Lisp_Object);
 extern bool raw_text_coding_system_p (struct coding_system *);
 extern Lisp_Object coding_inherit_eol_type (Lisp_Object, Lisp_Object);
 extern Lisp_Object complement_process_encoding_system (Lisp_Object);
+extern Lisp_Object make_string_from_utf8 (const char *, ptrdiff_t);
 
 extern void decode_coding_gap (struct coding_system *,
 			       ptrdiff_t, ptrdiff_t);
@@ -762,6 +763,16 @@ surrogates_to_codepoint (int low, int high)
   return 0x10000 + (low - 0xDC00) + ((high - 0xD800) * 0x400);
 }
 
+/* Like build_string, but always returns a multibyte string, and is
+   optimized for speed when STR is a UTF-8 encoded text string.  */
+
+INLINE Lisp_Object
+build_string_from_utf8 (const char *str)
+{
+  return make_string_from_utf8 (str, strlen (str));
+}
+
+
 extern Lisp_Object preferred_coding_system (void);
 
 /* Coding system to be used to encode text for terminal display when
diff --git a/src/composite.c b/src/composite.c
index 88f1235f11..7d7ed3f4a6 100644
--- a/src/composite.c
+++ b/src/composite.c
@@ -176,7 +176,7 @@ get_composition_id (ptrdiff_t charpos, ptrdiff_t bytepos, ptrdiff_t nchars,
 
   /* Maximum length of a string of glyphs.  XftGlyphExtents limits
      this to INT_MAX, and Emacs limits it further.  Divide INT_MAX - 1
-     by 2 because x_produce_glyphs computes glyph_len * 2 + 1.  Divide
+     by 2 because gui_produce_glyphs computes glyph_len * 2 + 1.  Divide
      the size by MAX_MULTIBYTE_LENGTH because encode_terminal_code
      multiplies glyph_len by MAX_MULTIBYTE_LENGTH.  */
   enum {
diff --git a/src/conf_post.h b/src/conf_post.h
index f8254cfa9d..4af1ba9331 100644
--- a/src/conf_post.h
+++ b/src/conf_post.h
@@ -59,7 +59,7 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
    into the same 1-, 2-, or 4-byte allocation unit in the MinGW
    builds.  It was also needed to port to pre-C99 compilers, although
    we don't care about that any more.  */
-#if NS_IMPL_GNUSTEP || defined(__MINGW32__)
+#if NS_IMPL_GNUSTEP || defined __MINGW32__
 typedef unsigned int bool_bf;
 #else
 typedef bool bool_bf;
@@ -73,10 +73,12 @@ typedef bool bool_bf;
 # define __has_attribute(a) __has_attribute_##a
 # define __has_attribute_alloc_size GNUC_PREREQ (4, 3, 0)
 # define __has_attribute_cleanup GNUC_PREREQ (3, 4, 0)
+# define __has_attribute_cold GNUC_PREREQ (4, 3, 0)
 # define __has_attribute_externally_visible GNUC_PREREQ (4, 1, 0)
 # define __has_attribute_no_address_safety_analysis false
 # define __has_attribute_no_sanitize_address GNUC_PREREQ (4, 8, 0)
 # define __has_attribute_no_sanitize_undefined GNUC_PREREQ (4, 9, 0)
+# define __has_attribute_warn_unused_result GNUC_PREREQ (3, 4, 0)
 #endif
 
 /* Simulate __has_feature on compilers that lack it.  It is used only
@@ -223,6 +225,14 @@ extern void _DebPrint (const char *fmt, ...);
 extern char *emacs_getenv_TZ (void);
 extern int emacs_setenv_TZ (char const *);
 
+/* Avoid __attribute__ ((cold)) on MinGW; see thread starting at
+   <https://lists.gnu.org/r/emacs-devel/2019-04/msg01152.html>. */
+#if __has_attribute (cold) && !defined __MINGW32__
+# define ATTRIBUTE_COLD __attribute__ ((cold))
+#else
+# define ATTRIBUTE_COLD
+#endif
+
 #if __GNUC__ >= 3  /* On GCC 3.0 we might get a warning.  */
 #define NO_INLINE __attribute__((noinline))
 #else
diff --git a/src/data.c b/src/data.c
index 11cd598ed8..c1699aeae7 100644
--- a/src/data.c
+++ b/src/data.c
@@ -130,7 +130,7 @@ set_blv_valcell (struct Lisp_Buffer_Local_Value *blv, Lisp_Object val)
   blv->valcell = val;
 }
 
-static _Noreturn void
+static AVOID
 wrong_length_argument (Lisp_Object a1, Lisp_Object a2, Lisp_Object a3)
 {
   Lisp_Object size1 = make_fixnum (bool_vector_size (a1));
@@ -142,7 +142,7 @@ wrong_length_argument (Lisp_Object a1, Lisp_Object a2, Lisp_Object a3)
 	      make_fixnum (bool_vector_size (a3)));
 }
 
-_Noreturn void
+AVOID
 wrong_type_argument (register Lisp_Object predicate, register Lisp_Object value)
 {
   /* If VALUE is not even a valid Lisp object, we'd want to abort here
@@ -230,9 +230,7 @@ for example, (type-of 1) returns `integer'.  */)
 	case PVEC_MARKER: return Qmarker;
 	case PVEC_OVERLAY: return Qoverlay;
 	case PVEC_FINALIZER: return Qfinalizer;
-#ifdef HAVE_MODULES
 	case PVEC_USER_PTR: return Quser_ptr;
-#endif
         case PVEC_WINDOW_CONFIGURATION: return Qwindow_configuration;
         case PVEC_PROCESS: return Qprocess;
         case PVEC_WINDOW: return Qwindow;
@@ -1124,20 +1122,21 @@ store_symval_forwarding (lispfwd valcontents, Lisp_Object newval,
 	int offset = XBUFFER_OBJFWD (valcontents)->offset;
 	Lisp_Object predicate = XBUFFER_OBJFWD (valcontents)->predicate;
 
-	if (!NILP (newval))
+	if (!NILP (newval) && !NILP (predicate))
 	  {
-	    if (SYMBOLP (predicate))
+	    eassert (SYMBOLP (predicate));
+	    Lisp_Object choiceprop = Fget (predicate, Qchoice);
+	    if (!NILP (choiceprop))
 	      {
-		Lisp_Object prop;
-
-		if ((prop = Fget (predicate, Qchoice), !NILP (prop)))
-		  {
-		    if (NILP (Fmemq (newval, prop)))
-		      wrong_choice (prop, newval);
-		  }
-		else if ((prop = Fget (predicate, Qrange), !NILP (prop)))
+		if (NILP (Fmemq (newval, choiceprop)))
+		  wrong_choice (choiceprop, newval);
+	      }
+	    else
+	      {
+		Lisp_Object rangeprop = Fget (predicate, Qrange);
+		if (CONSP (rangeprop))
 		  {
-		    Lisp_Object min = XCAR (prop), max = XCDR (prop);
+		    Lisp_Object min = XCAR (rangeprop), max = XCDR (rangeprop);
 		    if (! NUMBERP (newval)
 			|| NILP (CALLN (Fleq, min, newval, max)))
 		      wrong_range (min, max, newval);
@@ -1303,15 +1302,13 @@ set_internal (Lisp_Object symbol, Lisp_Object newval, Lisp_Object where,
               enum Set_Internal_Bind bindflag)
 {
   bool voide = EQ (newval, Qunbound);
-  struct Lisp_Symbol *sym;
-  Lisp_Object tem1;
 
   /* If restoring in a dead buffer, do nothing.  */
   /* if (BUFFERP (where) && NILP (XBUFFER (where)->name))
       return; */
 
   CHECK_SYMBOL (symbol);
-  sym = XSYMBOL (symbol);
+  struct Lisp_Symbol *sym = XSYMBOL (symbol);
   switch (sym->u.s.trapped_write)
     {
     case SYMBOL_NOWRITE:
@@ -1330,9 +1327,10 @@ set_internal (Lisp_Object symbol, Lisp_Object newval, Lisp_Object where,
                                    bindflag == SET_INTERNAL_UNBIND? Qunlet :
                                    voide? Qmakunbound : Qset),
                                   where);
-      /* FALLTHROUGH!  */
+      break;
+
     case SYMBOL_UNTRAPPED_WRITE:
-        break;
+      break;
 
     default: emacs_abort ();
     }
@@ -1365,8 +1363,9 @@ set_internal (Lisp_Object symbol, Lisp_Object newval, Lisp_Object where,
 
 	    /* Find the new binding.  */
 	    XSETSYMBOL (symbol, sym); /* May have changed via aliasing.  */
-	    tem1 = assq_no_quit (symbol,
-				 BVAR (XBUFFER (where), local_var_alist));
+	    Lisp_Object tem1
+	      = assq_no_quit (symbol,
+			      BVAR (XBUFFER (where), local_var_alist));
 	    set_blv_where (blv, where);
 	    blv->found = true;
 
@@ -1651,10 +1650,8 @@ void
 set_default_internal (Lisp_Object symbol, Lisp_Object value,
                       enum Set_Internal_Bind bindflag)
 {
-  struct Lisp_Symbol *sym;
-
   CHECK_SYMBOL (symbol);
-  sym = XSYMBOL (symbol);
+  struct Lisp_Symbol *sym = XSYMBOL (symbol);
   switch (sym->u.s.trapped_write)
     {
     case SYMBOL_NOWRITE:
@@ -1671,9 +1668,10 @@ set_default_internal (Lisp_Object symbol, Lisp_Object value,
           /* Setting due to thread switching doesn't count.  */
           && bindflag != SET_INTERNAL_THREAD_SWITCH)
         notify_variable_watchers (symbol, value, Qset_default, Qnil);
-      /* FALLTHROUGH!  */
+      break;
+
     case SYMBOL_UNTRAPPED_WRITE:
-        break;
+      break;
 
     default: emacs_abort ();
     }
@@ -3838,9 +3836,7 @@ syms_of_data (void)
   DEFSYM (Qbool_vector_p, "bool-vector-p");
   DEFSYM (Qchar_or_string_p, "char-or-string-p");
   DEFSYM (Qmarkerp, "markerp");
-#ifdef HAVE_MODULES
   DEFSYM (Quser_ptrp, "user-ptrp");
-#endif
   DEFSYM (Qbuffer_or_string_p, "buffer-or-string-p");
   DEFSYM (Qinteger_or_marker_p, "integer-or-marker-p");
   DEFSYM (Qfboundp, "fboundp");
@@ -3935,9 +3931,7 @@ syms_of_data (void)
   DEFSYM (Qoverlay, "overlay");
   DEFSYM (Qfinalizer, "finalizer");
   DEFSYM (Qmodule_function, "module-function");
-#ifdef HAVE_MODULES
   DEFSYM (Quser_ptr, "user-ptr");
-#endif
   DEFSYM (Qfloat, "float");
   DEFSYM (Qwindow_configuration, "window-configuration");
   DEFSYM (Qprocess, "process");
diff --git a/src/dbusbind.c b/src/dbusbind.c
index 0afae6b05a..850d176c08 100644
--- a/src/dbusbind.c
+++ b/src/dbusbind.c
@@ -346,7 +346,6 @@ xd_signature (char *signature, int dtype, int parent_type, Lisp_Object object)
   int subtype;
   Lisp_Object elt;
   char const *subsig;
-  int subsiglen;
   char x[DBUS_MAXIMUM_SIGNATURE_LENGTH];
 
   elt = object;
@@ -430,10 +429,9 @@ xd_signature (char *signature, int dtype, int parent_type, Lisp_Object object)
 	  elt = CDR_SAFE (XD_NEXT_VALUE (elt));
 	}
 
-      subsiglen = snprintf (signature, DBUS_MAXIMUM_SIGNATURE_LENGTH,
-			    "%c%s", dtype, subsig);
-      if (! (0 <= subsiglen && subsiglen < DBUS_MAXIMUM_SIGNATURE_LENGTH))
-	string_overflow ();
+      signature[0] = dtype;
+      signature[1] = '\0';
+      xd_signature_cat (signature, subsig);
       break;
 
     case DBUS_TYPE_VARIANT:
diff --git a/src/dispextern.h b/src/dispextern.h
index 1a53656353..a21edd818f 100644
--- a/src/dispextern.h
+++ b/src/dispextern.h
@@ -34,16 +34,47 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #ifdef HAVE_XRENDER
 # include <X11/extensions/Xrender.h>
 #endif
+
+typedef XColor Emacs_Color;
+typedef Cursor Emacs_Cursor;
+#define No_Cursor (None)
+#ifndef USE_CAIRO
+typedef Pixmap Emacs_Pixmap;
+#endif
+typedef XRectangle Emacs_Rectangle;
+typedef XGCValues Emacs_GC;
 #else /* !HAVE_X_WINDOWS */
 
-/* X-related stuff used by non-X gui code.  */
+/* XColor-like struct used by non-X code.  */
 
-typedef struct {
+typedef struct
+{
   unsigned long pixel;
   unsigned short red, green, blue;
-  char flags;
-  char pad;
-} XColor;
+} Emacs_Color;
+
+/* Accommodate X's usage of None as a null resource ID.  */
+#define No_Cursor (NULL)
+
+/* XRectangle-like struct used by non-X GUI code.  */
+typedef struct
+{
+  int x, y;
+  unsigned width, height;
+} Emacs_Rectangle;
+
+/* XGCValues-like struct used by non-X GUI code.  */
+typedef struct
+{
+  unsigned long foreground;
+  unsigned long background;
+} Emacs_GC;
+
+/* Mask values to select foreground/background.  */
+/* FIXME: The GC handling in w32 really should be redesigned as to not
+   need these.  */
+#define GCForeground 0x01
+#define GCBackground 0x02
 
 #endif /* HAVE_X_WINDOWS */
 
@@ -63,16 +94,31 @@ xstrcasecmp (char const *a, char const *b)
 #ifdef HAVE_X_WINDOWS
 #include <X11/Xresource.h> /* for XrmDatabase */
 typedef struct x_display_info Display_Info;
-typedef XImage * XImagePtr;
-typedef XImagePtr XImagePtr_or_DC;
+#ifndef USE_CAIRO
+typedef XImage *Emacs_Pix_Container;
+typedef XImage *Emacs_Pix_Context;
+#endif	/* !USE_CAIRO */
 #define NativeRectangle XRectangle
 #endif
 
+#ifdef USE_CAIRO
+/* Mininal version of XImage.  */
+typedef struct
+{
+  int width, height;		/* size of image */
+  char *data;			/* pointer to image data */
+  int bytes_per_line;		/* accelarator to next line */
+  int bits_per_pixel;		/* bits per pixel (ZPixmap) */
+} *Emacs_Pix_Container;
+typedef Emacs_Pix_Container Emacs_Pixmap;
+typedef Emacs_Pix_Container Emacs_Pix_Context;
+#endif
+
 #ifdef HAVE_NTGUI
 #include "w32gui.h"
 typedef struct w32_display_info Display_Info;
-typedef XImage *XImagePtr;
-typedef HDC XImagePtr_or_DC;
+typedef XImage *Emacs_Pix_Container;
+typedef HDC Emacs_Pix_Context;
 #endif
 
 #ifdef HAVE_NS
@@ -80,8 +126,8 @@ typedef HDC XImagePtr_or_DC;
 #define FACE_COLOR_TO_PIXEL(face_color, frame) ns_color_index_to_rgba(face_color, frame)
 /* Following typedef needed to accommodate the MSDOS port, believe it or not.  */
 typedef struct ns_display_info Display_Info;
-typedef Pixmap XImagePtr;
-typedef XImagePtr XImagePtr_or_DC;
+typedef Emacs_Pixmap Emacs_Pix_Container;
+typedef Emacs_Pixmap Emacs_Pix_Context;
 #else
 #define FACE_COLOR_TO_PIXEL(face_color, frame) face_color
 #endif
@@ -92,8 +138,7 @@ typedef XImagePtr XImagePtr_or_DC;
 #endif
 
 #ifndef HAVE_WINDOW_SYSTEM
-typedef int Cursor;
-#define No_Cursor (0)
+typedef void *Emacs_Cursor;
 #endif
 
 #ifndef NativeRectangle
@@ -1040,7 +1085,7 @@ struct glyph_row
 #ifdef HAVE_WINDOW_SYSTEM
   /* Non-NULL means the current clipping area.  This is temporarily
      set while exposing a region.  Coordinates are frame-relative.  */
-  XRectangle *clip;
+  const Emacs_Rectangle *clip;
 #endif
 };
 
@@ -1281,9 +1326,6 @@ struct glyph_string
   /* The window on which the glyph string is drawn.  */
   struct window *w;
 
-  /* X display and window for convenience.  */
-  Display *display;
-
   /* The glyph row for which this string was built.  It determines the
      y-origin and height of the string.  */
   struct glyph_row *row;
@@ -1292,7 +1334,7 @@ struct glyph_string
   enum glyph_row_area area;
 
   /* Characters to be drawn, and number of characters.  */
-  XChar2b *char2b;
+  unsigned *char2b;
   int nchars;
 
   /* A face-override for drawing cursors, mouse face and similar.  */
@@ -1353,7 +1395,7 @@ struct glyph_string
   GC gc;
 #endif
 #if defined (HAVE_NTGUI)
-  XGCValues *gc;
+  Emacs_GC *gc;
   HDC hdc;
 #endif
 
@@ -1595,8 +1637,11 @@ struct face
 
   /* If non-zero, this is a GC that we can use without modification for
      drawing the characters in this face.  */
+# ifdef HAVE_X_WINDOWS
   GC gc;
-
+# else
+  Emacs_GC *gc;
+# endif
   /* Background stipple or bitmap used for this face.  This is
      an id as returned from load_pixmap.  */
   ptrdiff_t stipple;
@@ -1680,7 +1725,7 @@ struct face
 
   /* True means that colors of this face may not be freed because they
      have been copied bitwise from a base face (see
-     realize_x_face).  */
+     realize_gui_face).  */
   bool_bf colors_copied_bitwise_p : 1;
 
   /* If non-zero, use overstrike (to simulate bold-face).  */
@@ -2891,12 +2936,17 @@ struct redisplay_interface
   void (*draw_glyph_string) (struct glyph_string *s);
 
   /* Define cursor CURSOR on frame F.  */
-  void (*define_frame_cursor) (struct frame *f, Cursor cursor);
+  void (*define_frame_cursor) (struct frame *f, Emacs_Cursor cursor);
 
   /* Clear the area at (X,Y,WIDTH,HEIGHT) of frame F.  */
   void (*clear_frame_area) (struct frame *f, int x, int y,
                             int width, int height);
 
+ /* Clear area of frame F's internal border.  If the internal border
+    face of F has been specified (is not null), fill the area with
+    that face.  */
+  void (*clear_under_internal_border) (struct frame *f);
+
   /* Draw specified cursor CURSOR_TYPE of width CURSOR_WIDTH
      at row GLYPH_ROW on window W if ON_P is true.  If ON_P is
      false, don't draw cursor.  If ACTIVE_P is true, system caret
@@ -2939,7 +2989,25 @@ struct redisplay_interface
 #ifdef HAVE_WINDOW_SYSTEM
 
 # if defined USE_CAIRO || defined HAVE_XRENDER || defined HAVE_NS || defined HAVE_NTGUI
-#  define HAVE_NATIVE_SCALING
+#  define HAVE_NATIVE_TRANSFORMS
+
+#  define INIT_MATRIX(m)                          \
+  for (int i = 0 ; i < 3 ; i++)                   \
+    for (int j = 0 ; j < 3 ; j++)                 \
+      m[i][j] = (i == j) ? 1 : 0;
+
+#  define COPY_MATRIX(a, b)                       \
+  for (int i = 0 ; i < 3 ; i++)                   \
+    for (int j = 0 ; j < 3 ; j++)                 \
+      b[i][j] = a[i][j];
+
+#  define MULT_MATRICES(a, b, result)             \
+  for (int i = 0 ; i < 3 ; i++)                   \
+    for (int j = 0 ; j < 3 ; j++) {               \
+      double sum = 0;                             \
+      for (int k = 0 ; k < 3 ; k++)               \
+        sum += a[k][j] * b[i][k];                 \
+      result[i][j] = sum;}
 # endif
 
 /* Structure describing an image.  Specific image formats like XBM are
@@ -2953,7 +3021,7 @@ struct image
   struct timespec timestamp;
 
   /* Pixmaps of the image.  */
-  Pixmap pixmap, mask;
+  Emacs_Pixmap pixmap, mask;
 
 #ifdef USE_CAIRO
   void *cr_data;
@@ -2963,9 +3031,9 @@ struct image
      Non-NULL means it and its Pixmap counterpart may be out of sync
      and the latter is outdated.  NULL means the X image has been
      synchronized to Pixmap.  */
-  XImagePtr ximg, mask_img;
+  XImage *ximg, *mask_img;
 
-# ifdef HAVE_NATIVE_SCALING
+# ifdef HAVE_NATIVE_TRANSFORMS
   /* Picture versions of pixmap and mask for compositing.  */
   Picture picture, mask_picture;
 # endif
@@ -3034,7 +3102,7 @@ struct image
   int hmargin, vmargin;
 
   /* Reference to the type of the image.  */
-  struct image_type *type;
+  struct image_type const *type;
 
   /* True means that loading the image failed.  Don't try again.  */
   bool load_failed_p;
@@ -3274,19 +3342,19 @@ extern void get_font_ascent_descent (struct font *, int *, int *);
 extern void dump_glyph_string (struct glyph_string *) EXTERNALLY_VISIBLE;
 #endif
 
-extern void x_get_glyph_overhangs (struct glyph *, struct frame *,
-                                   int *, int *);
+extern void gui_get_glyph_overhangs (struct glyph *, struct frame *,
+                                     int *, int *);
 extern struct font *font_for_underline_metrics (struct glyph_string *);
-extern void x_produce_glyphs (struct it *);
-
-extern void x_write_glyphs (struct window *, struct glyph_row *,
-			    struct glyph *, enum glyph_row_area, int);
-extern void x_insert_glyphs (struct window *, struct glyph_row *,
-			     struct glyph *, enum glyph_row_area, int);
-extern void x_clear_end_of_line (struct window *, struct glyph_row *,
-				 enum glyph_row_area, int);
-extern void x_fix_overlapping_area (struct window *, struct glyph_row *,
-                                    enum glyph_row_area, int);
+extern void gui_produce_glyphs (struct it *);
+
+extern void gui_write_glyphs (struct window *, struct glyph_row *,
+                              struct glyph *, enum glyph_row_area, int);
+extern void gui_insert_glyphs (struct window *, struct glyph_row *,
+                               struct glyph *, enum glyph_row_area, int);
+extern void gui_clear_end_of_line (struct window *, struct glyph_row *,
+                                   enum glyph_row_area, int);
+extern void gui_fix_overlapping_area (struct window *, struct glyph_row *,
+                                      enum glyph_row_area, int);
 extern void draw_phys_cursor_glyph (struct window *,
                                     struct glyph_row *,
                                     enum draw_glyphs_face);
@@ -3294,10 +3362,10 @@ extern void get_phys_cursor_geometry (struct window *, struct glyph_row *,
                                       struct glyph *, int *, int *, int *);
 extern void erase_phys_cursor (struct window *);
 extern void display_and_set_cursor (struct window *, bool, int, int, int, int);
-extern void x_update_cursor (struct frame *, bool);
-extern void x_clear_cursor (struct window *);
-extern void x_draw_vertical_border (struct window *w);
-extern void x_draw_right_divider (struct window *w);
+extern void gui_update_cursor (struct frame *, bool);
+extern void gui_clear_cursor (struct window *);
+extern void gui_draw_vertical_border (struct window *w);
+extern void gui_draw_right_divider (struct window *w);
 
 extern int get_glyph_string_clip_rects (struct glyph_string *,
                                         NativeRectangle *, int);
@@ -3309,11 +3377,13 @@ extern void handle_tool_bar_click (struct frame *,
                                    int, int, bool, int);
 
 extern void expose_frame (struct frame *, int, int, int, int);
-extern bool x_intersect_rectangles (XRectangle *, XRectangle *, XRectangle *);
+extern bool gui_intersect_rectangles (const Emacs_Rectangle *,
+                                      const Emacs_Rectangle *,
+                                      Emacs_Rectangle *);
 #endif	/* HAVE_WINDOW_SYSTEM */
 
 extern void note_mouse_highlight (struct frame *, int, int);
-extern void x_clear_window_mouse_face (struct window *);
+extern void gui_clear_window_mouse_face (struct window *);
 extern void cancel_mouse_face (struct frame *);
 extern bool clear_mouse_face (Mouse_HLInfo *);
 extern bool cursor_in_mouse_face_p (struct window *w);
@@ -3347,22 +3417,26 @@ extern bool buffer_flipping_blocked_p (void);
 
 #ifdef HAVE_WINDOW_SYSTEM
 
-extern ptrdiff_t x_bitmap_pixmap (struct frame *, ptrdiff_t);
-extern void x_reference_bitmap (struct frame *, ptrdiff_t);
-extern ptrdiff_t x_create_bitmap_from_data (struct frame *, char *,
-					    unsigned int, unsigned int);
-extern ptrdiff_t x_create_bitmap_from_file (struct frame *, Lisp_Object);
+extern ptrdiff_t image_bitmap_pixmap (struct frame *, ptrdiff_t);
+extern void image_reference_bitmap (struct frame *, ptrdiff_t);
+extern ptrdiff_t image_create_bitmap_from_data (struct frame *, char *,
+                                                unsigned int, unsigned int);
+extern ptrdiff_t image_create_bitmap_from_file (struct frame *, Lisp_Object);
 #if defined HAVE_XPM && defined HAVE_X_WINDOWS && !defined USE_GTK
 extern ptrdiff_t x_create_bitmap_from_xpm_data (struct frame *, const char **);
 #endif
-#ifndef x_destroy_bitmap
-extern void x_destroy_bitmap (struct frame *, ptrdiff_t);
+#ifndef image_destroy_bitmap
+extern void image_destroy_bitmap (struct frame *, ptrdiff_t);
 #endif
-extern void x_destroy_all_bitmaps (Display_Info *);
+extern void image_destroy_all_bitmaps (Display_Info *);
+#ifdef HAVE_X_WINDOWS
 extern void x_create_bitmap_mask (struct frame *, ptrdiff_t);
-extern Lisp_Object x_find_image_file (Lisp_Object);
+#ifndef USE_CAIRO
+extern void x_kill_gs_process (Pixmap, struct frame *);
+#endif	/* !USE_CAIRO */
+#endif
+extern Lisp_Object image_find_image_file (Lisp_Object);
 
-void x_kill_gs_process (Pixmap, struct frame *);
 struct image_cache *make_image_cache (void);
 void free_image_cache (struct frame *);
 void clear_image_caches (Lisp_Object);
@@ -3371,7 +3445,7 @@ bool valid_image_p (Lisp_Object);
 void prepare_image_for_display (struct frame *, struct image *);
 ptrdiff_t lookup_image (struct frame *, Lisp_Object);
 
-#if defined (HAVE_X_WINDOWS) ||  defined (HAVE_NS)
+#if defined HAVE_X_WINDOWS || defined USE_CAIRO || defined HAVE_NS
 #define RGB_PIXEL_COLOR unsigned long
 #endif
 
@@ -3380,9 +3454,9 @@ ptrdiff_t lookup_image (struct frame *, Lisp_Object);
 #endif
 
 RGB_PIXEL_COLOR image_background (struct image *, struct frame *,
-                                XImagePtr_or_DC ximg);
+                                  Emacs_Pix_Context img);
 int image_background_transparent (struct image *, struct frame *,
-                                  XImagePtr_or_DC mask);
+                                  Emacs_Pix_Context mask);
 
 int image_ascent (struct image *, struct face *, struct glyph_slice *);
 
@@ -3406,6 +3480,9 @@ void x_free_colors (struct frame *, unsigned long *, int);
 
 void update_face_from_frame_parameter (struct frame *, Lisp_Object,
                                        Lisp_Object);
+extern bool tty_defined_color (struct frame *, const char *, Emacs_Color *,
+                               bool, bool);
+
 Lisp_Object tty_color_name (struct frame *, int);
 void clear_face_cache (bool);
 unsigned long load_color (struct frame *, struct face *, Lisp_Object,
@@ -3446,11 +3523,6 @@ void gamma_correct (struct frame *, COLORREF *);
 
 #ifdef HAVE_WINDOW_SYSTEM
 
-void x_implicitly_set_name (struct frame *, Lisp_Object, Lisp_Object);
-void x_change_tool_bar_height (struct frame *f, int);
-
-extern frame_parm_handler x_frame_parm_handlers[];
-
 extern void start_hourglass (void);
 extern void cancel_hourglass (void);
 
@@ -3516,6 +3588,10 @@ void clear_glyph_matrix_rows (struct glyph_matrix *, int, int);
 void clear_glyph_row (struct glyph_row *);
 void prepare_desired_row (struct window *, struct glyph_row *, bool);
 void update_single_window (struct window *);
+#ifdef HAVE_WINDOW_SYSTEM
+extern void gui_update_window_begin (struct window *);
+extern void gui_update_window_end (struct window *, bool, bool);
+#endif
 void do_pending_window_change (bool);
 void change_frame_size (struct frame *, int, int, bool, bool, bool, bool);
 void init_display (void);
@@ -3586,23 +3662,21 @@ enum resource_types
 };
 
 extern Display_Info *check_x_display_info (Lisp_Object);
-extern Lisp_Object x_get_arg (Display_Info *, Lisp_Object,
-                              Lisp_Object, const char *, const char *class,
-                              enum resource_types);
-extern Lisp_Object x_frame_get_and_record_arg (struct frame *, Lisp_Object,
-                                               Lisp_Object,
-					       const char *, const char *,
-                                               enum resource_types);
-extern Lisp_Object x_default_parameter (struct frame *, Lisp_Object,
-                                        Lisp_Object, Lisp_Object,
-                                        const char *, const char *,
+extern Lisp_Object gui_display_get_arg (Display_Info *, Lisp_Object,
+                                        Lisp_Object, const char *, const char *,
                                         enum resource_types);
-extern char *x_get_string_resource (XrmDatabase, const char *,
-				    const char *);
+extern Lisp_Object gui_frame_get_and_record_arg (struct frame *, Lisp_Object,
+                                                 Lisp_Object,
+                                                 const char *, const char *,
+                                                 enum resource_types);
+extern Lisp_Object gui_default_parameter (struct frame *, Lisp_Object,
+                                          Lisp_Object, Lisp_Object,
+                                          const char *, const char *,
+                                          enum resource_types);
 
 #ifndef HAVE_NS /* These both used on W32 and X only.  */
-extern bool x_mouse_grabbed (Display_Info *);
-extern void x_redo_mouse_highlight (Display_Info *);
+extern bool gui_mouse_grabbed (Display_Info *);
+extern void gui_redo_mouse_highlight (Display_Info *);
 #endif /* HAVE_NS */
 
 #endif /* HAVE_WINDOW_SYSTEM */
diff --git a/src/dispnew.c b/src/dispnew.c
index ccb08ec1b9..52a7b6d6ee 100644
--- a/src/dispnew.c
+++ b/src/dispnew.c
@@ -3390,7 +3390,9 @@ update_window (struct window *w, bool force_p)
   struct glyph_matrix *desired_matrix = w->desired_matrix;
   bool paused_p;
   int preempt_count = clip_to_bounds (1, baud_rate / 2400 + 1, INT_MAX);
+#ifdef HAVE_WINDOW_SYSTEM
   struct redisplay_interface *rif = FRAME_RIF (XFRAME (WINDOW_FRAME (w)));
+#endif
 #ifdef GLYPH_DEBUG
   /* Check that W's frame doesn't have glyph matrices.  */
   eassert (FRAME_WINDOW_P (XFRAME (WINDOW_FRAME (w))));
@@ -3411,7 +3413,9 @@ update_window (struct window *w, bool force_p)
       bool changed_p = 0, mouse_face_overwritten_p = 0;
       int n_updated = 0;
 
-      rif->update_window_begin_hook (w);
+#ifdef HAVE_WINDOW_SYSTEM
+      gui_update_window_begin (w);
+#endif
       yb = window_text_bottom_y (w);
       row = MATRIX_ROW (desired_matrix, 0);
       end = MATRIX_MODE_LINE_ROW (desired_matrix);
@@ -3533,13 +3537,13 @@ update_window (struct window *w, bool force_p)
 
 #ifdef HAVE_WINDOW_SYSTEM
       update_window_fringes (w, 0);
-#endif
 
       /* End the update of window W.  Don't set the cursor if we
          paused updating the display because in this case,
          set_window_cursor_after_update hasn't been called, and
          W->output_cursor doesn't contain the cursor location.  */
-      rif->update_window_end_hook (w, !paused_p, mouse_face_overwritten_p);
+      gui_update_window_end (w, !paused_p, mouse_face_overwritten_p);
+#endif
     }
   else
     paused_p = 1;
@@ -3555,6 +3559,90 @@ update_window (struct window *w, bool force_p)
   return paused_p;
 }
 
+#ifdef HAVE_WINDOW_SYSTEM
+
+/* Start update of window W.  */
+
+void
+gui_update_window_begin (struct window *w)
+{
+  struct frame *f = XFRAME (WINDOW_FRAME (w));
+  Mouse_HLInfo *hlinfo = MOUSE_HL_INFO (f);
+
+  block_input ();
+
+  if (FRAME_RIF (f)->update_window_begin_hook)
+    FRAME_RIF (f)->update_window_begin_hook (w);
+
+  w->output_cursor = w->cursor;
+
+  if (f == hlinfo->mouse_face_mouse_frame)
+    {
+      /* Don't do highlighting for mouse motion during the update.  */
+      hlinfo->mouse_face_defer = true;
+
+      /* If the frame needs to be redrawn, simply forget about any
+	 prior mouse highlighting.  */
+      if (FRAME_GARBAGED_P (f))
+	hlinfo->mouse_face_window = Qnil;
+    }
+
+  unblock_input ();
+}
+
+/* End update of window W.
+
+   Draw vertical borders between horizontally adjacent windows, and
+   display W's cursor if CURSOR_ON_P is non-zero.
+
+   MOUSE_FACE_OVERWRITTEN_P non-zero means that some row containing
+   glyphs in mouse-face were overwritten.  In that case we have to
+   make sure that the mouse-highlight is properly redrawn.  */
+void
+gui_update_window_end (struct window *w, bool cursor_on_p,
+                       bool mouse_face_overwritten_p)
+{
+  struct frame *f = XFRAME (WINDOW_FRAME (w));
+
+  block_input ();
+
+  /* Pseudo windows don't have cursors, so don't display them here.  */
+  if (!w->pseudo_window_p)
+    {
+
+      if (cursor_on_p)
+	display_and_set_cursor (w, true,
+				w->output_cursor.hpos, w->output_cursor.vpos,
+				w->output_cursor.x, w->output_cursor.y);
+
+      if (draw_window_fringes (w, true))
+	{
+	  if (WINDOW_RIGHT_DIVIDER_WIDTH (w))
+	    gui_draw_right_divider (w);
+	  else
+	    gui_draw_vertical_border (w);
+	}
+    }
+
+  /* If a row with mouse-face was overwritten, arrange for
+     frame_up_to_date_hook to redisplay the mouse highlight.  */
+  if (mouse_face_overwritten_p)
+    {
+      Mouse_HLInfo *hlinfo = MOUSE_HL_INFO (f);
+
+      hlinfo->mouse_face_beg_row = hlinfo->mouse_face_beg_col = -1;
+      hlinfo->mouse_face_end_row = hlinfo->mouse_face_end_col = -1;
+      hlinfo->mouse_face_window = Qnil;
+    }
+
+  if (FRAME_RIF (f)->update_window_end_hook)
+    FRAME_RIF (f)->update_window_end_hook (w,
+                                           cursor_on_p,
+                                           mouse_face_overwritten_p);
+  unblock_input ();
+}
+
+#endif /* HAVE_WINDOW_SYSTEM  */
 
 /* Update the display of area AREA in window W, row number VPOS.
    AREA can be either LEFT_MARGIN_AREA or RIGHT_MARGIN_AREA.  */
@@ -5551,7 +5639,7 @@ change_frame_size_1 (struct frame *f, int new_width, int new_height,
 			* FRAME_LINE_HEIGHT (f));
 	}
 
-      /* Adjust frame size but make sure x_set_window_size does not
+      /* Adjust frame size but make sure set_window_size_hook does not
 	 get called.  */
       adjust_frame_size (f, new_width, new_height, 5, pretend,
 			 Qchange_frame_size);
@@ -6142,6 +6230,7 @@ init_display_interactive (void)
 
     t->reference_count++;
 #ifdef MSDOS
+    f->output_data.tty = &the_only_tty_output;
     f->output_data.tty->display_info = &the_only_display_info;
 #else
     if (f->output_method == output_termcap)
diff --git a/src/doc.c b/src/doc.c
index 372e376c62..3fa0eaac20 100644
--- a/src/doc.c
+++ b/src/doc.c
@@ -337,8 +337,10 @@ string is passed through `substitute-command-keys'.  */)
     fun = XCDR (fun);
   if (SUBRP (fun))
     doc = make_fixnum (XSUBR (fun)->doc);
+#ifdef HAVE_MODULES
   else if (MODULE_FUNCTIONP (fun))
-    doc = XMODULE_FUNCTION (fun)->documentation;
+    doc = module_function_documentation (XMODULE_FUNCTION (fun));
+#endif
   else if (COMPILEDP (fun))
     {
       if (PVSIZE (fun) <= COMPILED_DOC_STRING)
diff --git a/src/dynlib.c b/src/dynlib.c
index 878044558a..8c25b75537 100644
--- a/src/dynlib.c
+++ b/src/dynlib.c
@@ -123,7 +123,7 @@ dynlib_sym (dynlib_handle_ptr h, const char *sym)
 }
 
 void
-dynlib_addr (void *addr, const char **fname, const char **symname)
+dynlib_addr (void (*funcptr) (void), const char **fname, const char **symname)
 {
   static char dll_filename[MAX_UTF8_PATH];
   static GetModuleHandleExA_Proc s_pfn_Get_Module_HandleExA = NULL;
@@ -132,6 +132,7 @@ dynlib_addr (void *addr, const char **fname, const char **symname)
   HMODULE hm_dll = NULL;
   wchar_t mfn_w[MAX_PATH];
   char mfn_a[MAX_PATH];
+  void *addr = (void *) funcptr;
 
   /* Step 1: Find the handle of the module where ADDR lives.  */
   if (os_subtype == OS_9X
@@ -279,11 +280,12 @@ dynlib_sym (dynlib_handle_ptr h, const char *sym)
 }
 
 void
-dynlib_addr (void *ptr, const char **path, const char **sym)
+dynlib_addr (void (*funcptr) (void), const char **path, const char **sym)
 {
   *path = NULL;
   *sym = NULL;
 #ifdef HAVE_DLADDR
+  void *ptr = (void *) funcptr;
   Dl_info info;
   if (dladdr (ptr, &info) && info.dli_fname && info.dli_sname)
     {
diff --git a/src/dynlib.h b/src/dynlib.h
index 168ddbc32c..43a0e045f5 100644
--- a/src/dynlib.h
+++ b/src/dynlib.h
@@ -29,12 +29,12 @@ const char *dynlib_error (void);
 
 ATTRIBUTE_MAY_ALIAS void *dynlib_sym (dynlib_handle_ptr h, const char *sym);
 
-typedef struct dynlib_function_ptr_nonce *(ATTRIBUTE_MAY_ALIAS *dynlib_function_ptr) (void);
+typedef void (ATTRIBUTE_MAY_ALIAS *dynlib_function_ptr) (void);
 dynlib_function_ptr dynlib_func (dynlib_handle_ptr h, const char *sym);
 
 /* Sets *FILE to the file name from which PTR was loaded, and *SYM to
    its symbol name.  If the file or symbol name could not be
    determined, set the corresponding argument to NULL.  */
-void dynlib_addr (void *ptr, const char **file, const char **sym);
+void dynlib_addr (void (*ptr) (void), const char **file, const char **sym);
 
 #endif /* DYNLIB_H */
diff --git a/src/emacs-module.c b/src/emacs-module.c
index 47ca3368c0..907a5d8225 100644
--- a/src/emacs-module.c
+++ b/src/emacs-module.c
@@ -17,8 +17,65 @@ GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
+/*
+The public module API is defined in the header emacs-module.h.  The
+configure script generates emacs-module.h from emacs-module.h.in and
+the version-specific environment fragments in module-env-*.h.
+
+If you want to change the module API, please abide to the following
+rules:
+
+- Don't remove publicly documented declarations from the headers.
+
+- Don't remove, reorder, or rename structure fields, as such changes
+  break ABI compatibility.
+
+- Don't change the types of structure fields.
+
+- Likewise, the presence, order, and type of structure fields may not
+  depend on preprocessor macros.
+
+- Add structure fields only at the end of structures.
+
+- For every Emacs major version there is a new fragment file
+  module-env-VER.h.  Add functions solely at the end of the fragment
+  file for the next (not yet released) major version of Emacs.  For
+  example, if the current Emacs release is 26.2, add functions only to
+  emacs-env-27.h.
+
+- emacs-module.h should only depend on standard C headers.  In
+  particular, don't include config.h or lisp.h from emacs-module.h.
+
+- Prefix all names in emacs-module.h with "emacs_" or "EMACS_".
+
+To add a new module function, proceed as follows:
+
+1. Add a new function pointer field at the end of the emacs-env-*.h
+   file for the next major version of Emacs.
+
+2. Run config.status or configure to regenerate emacs-module.h.
+
+3. Create a corresponding implementation function in this file.  See
+   "Implementation of runtime and environment functions" below for
+   further rules.
+
+4. Assign the new field in the initialize_environment function.
+
+5. Add a test function that calls your new function to
+   test/data/emacs-module/mod-test.c.  Add a unit test that invokes
+   your new test function to test/src/emacs-module-tests.el.
+
+6. Document your new function in the manual and in etc/NEWS.
+*/
+
 #include <config.h>
 
+#ifndef HAVE_GMP
+#include "mini-gmp.h"
+#define EMACS_MODULE_HAVE_MPZ_T
+#endif
+
+#define EMACS_MODULE_GMP
 #include "emacs-module.h"
 
 #include <stdarg.h>
@@ -26,8 +83,10 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <time.h>
 
 #include "lisp.h"
+#include "bignum.h"
 #include "dynlib.h"
 #include "coding.h"
 #include "keyboard.h"
@@ -42,11 +101,6 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 # pragma GCC diagnostic ignored "-Wclobbered"
 #endif
 
-/* This module is lackadaisical about function casts.  */
-#if GNUC_PREREQ (8, 0, 0)
-# pragma GCC diagnostic ignored "-Wcast-function-type"
-#endif
-
 /* We use different strategies for allocating the user-visible objects
    (struct emacs_runtime, emacs_env, emacs_value), depending on
    whether the user supplied the -module-assertions flag.  If
@@ -147,21 +201,23 @@ static enum emacs_funcall_exit module_non_local_exit_check (emacs_env *);
 static void module_assert_thread (void);
 static void module_assert_runtime (struct emacs_runtime *);
 static void module_assert_env (emacs_env *);
-static _Noreturn void module_abort (const char *format, ...)
-  ATTRIBUTE_FORMAT_PRINTF(1, 2);
+static AVOID module_abort (const char *, ...) ATTRIBUTE_FORMAT_PRINTF (1, 2);
 static emacs_env *initialize_environment (emacs_env *,
 					  struct emacs_env_private *);
 static void finalize_environment (emacs_env *);
 static void finalize_environment_unwind (void *);
 static void finalize_runtime_unwind (void *);
-static void module_handle_signal (emacs_env *, Lisp_Object);
-static void module_handle_throw (emacs_env *, Lisp_Object);
+static void module_handle_nonlocal_exit (emacs_env *, enum nonlocal_exit,
+                                         Lisp_Object);
 static void module_non_local_exit_signal_1 (emacs_env *,
 					    Lisp_Object, Lisp_Object);
 static void module_non_local_exit_throw_1 (emacs_env *,
 					   Lisp_Object, Lisp_Object);
 static void module_out_of_memory (emacs_env *);
 static void module_reset_handlerlist (struct handler **);
+static bool value_storage_contains_p (const struct emacs_value_storage *,
+                                      emacs_value, ptrdiff_t *);
+static Lisp_Object module_encode (Lisp_Object);
 
 static bool module_assertions = false;
 
@@ -175,29 +231,19 @@ static bool module_assertions = false;
    not prepared for long jumps (e.g., the behavior in C++ is undefined
    if objects with nontrivial destructors would be skipped).
    Therefore, catch all non-local exits.  There are two kinds of
-   non-local exits: `signal' and `throw'.  The macros in this section
-   can be used to catch both.  Use macros to avoid additional variants
+   non-local exits: `signal' and `throw'.  The macro in this section
+   can be used to catch both.  Use a macro to avoid additional variants
    of `internal_condition_case' etc., and to avoid worrying about
    passing information to the handler functions.  */
 
+#if !__has_attribute (cleanup)
+ #error "__attribute__ ((cleanup)) not supported by this compiler; try GCC"
+#endif
+
 /* Place this macro at the beginning of a function returning a number
    or a pointer to handle non-local exits.  The function must have an
    ENV parameter.  The function will return the specified value if a
    signal or throw is caught.  */
-/* TODO: Have Fsignal check for CATCHER_ALL so we only have to install
-   one handler.  */
-#define MODULE_HANDLE_NONLOCAL_EXIT(retval)                     \
-  MODULE_SETJMP (CONDITION_CASE, module_handle_signal, retval); \
-  MODULE_SETJMP (CATCHER_ALL, module_handle_throw, retval)
-
-#define MODULE_SETJMP(handlertype, handlerfunc, retval)			       \
-  MODULE_SETJMP_1 (handlertype, handlerfunc, retval,			       \
-		   internal_handler_##handlertype,			       \
-		   internal_cleanup_##handlertype)
-
-#if !__has_attribute (cleanup)
- #error "__attribute__ ((cleanup)) not supported by this compiler; try GCC"
-#endif
 
 /* It is very important that pushing the handler doesn't itself raise
    a signal.  Install the cleanup only after the handler has been
@@ -207,24 +253,28 @@ static bool module_assertions = false;
    The do-while forces uses of the macro to be followed by a semicolon.
    This macro cannot enclose its entire body inside a do-while, as the
    code after the macro may longjmp back into the macro, which means
-   its local variable C must stay live in later code.  */
+   its local variable INTERNAL_CLEANUP must stay live in later code.  */
 
-/* TODO: Make backtraces work if this macros is used.  */
+/* TODO: Make backtraces work if this macro is used.  */
 
-#define MODULE_SETJMP_1(handlertype, handlerfunc, retval, c0, c)	\
+#define MODULE_HANDLE_NONLOCAL_EXIT(retval)                             \
   if (module_non_local_exit_check (env) != emacs_funcall_exit_return)	\
     return retval;							\
-  struct handler *c0 = push_handler_nosignal (Qt, handlertype);		\
-  if (!c0)								\
+  struct handler *internal_handler =                                    \
+    push_handler_nosignal (Qt, CATCHER_ALL);                            \
+  if (!internal_handler)                                                \
     {									\
       module_out_of_memory (env);					\
       return retval;							\
     }									\
-  struct handler *c __attribute__ ((cleanup (module_reset_handlerlist))) \
-    = c0;								\
-  if (sys_setjmp (c->jmp))						\
+  struct handler *internal_cleanup                                      \
+    __attribute__ ((cleanup (module_reset_handlerlist)))                \
+    = internal_handler;                                                 \
+  if (sys_setjmp (internal_cleanup->jmp))                               \
     {									\
-      (handlerfunc) (env, c->val);					\
+      module_handle_nonlocal_exit (env,                                 \
+                                   internal_cleanup->nonlocal_exit,     \
+                                   internal_cleanup->val);              \
       return retval;							\
     }									\
   do { } while (false)
@@ -305,6 +355,8 @@ module_get_environment (struct emacs_runtime *ert)
 /* To make global refs (GC-protected global values) keep a hash that
    maps global Lisp objects to reference counts.  */
 
+static Lisp_Object Vmodule_refs_hash;
+
 static emacs_value
 module_make_global_ref (emacs_env *env, emacs_value ref)
 {
@@ -357,16 +409,8 @@ module_free_global_ref (emacs_env *env, emacs_value ref)
   if (module_assertions)
     {
       ptrdiff_t count = 0;
-      for (struct emacs_value_frame *frame = &global_storage.initial;
-           frame != NULL; frame = frame->next)
-        {
-          for (int i = 0; i < frame->offset; ++i)
-            {
-              if (&frame->objects[i] == ref)
-                return;
-              ++count;
-            }
-        }
+      if (value_storage_contains_p (&global_storage, ref, &count))
+        return;
       module_abort ("Global value was not found in list of %"pD"d globals",
                     count);
     }
@@ -423,6 +467,30 @@ module_non_local_exit_throw (emacs_env *env, emacs_value tag, emacs_value value)
 				   value_to_lisp (value));
 }
 
+/* Function prototype for the module Lisp functions.  */
+typedef emacs_value (*emacs_subr) (emacs_env *, ptrdiff_t,
+				   emacs_value [], void *);
+
+/* Module function.  */
+
+/* A function environment is an auxiliary structure returned by
+   `module_make_function' to store information about a module
+   function.  It is stored in a pseudovector.  Its members correspond
+   to the arguments given to `module_make_function'.  */
+
+struct Lisp_Module_Function
+{
+  union vectorlike_header header;
+
+  /* Fields traced by GC; these must come first.  */
+  Lisp_Object documentation;
+
+  /* Fields ignored by GC.  */
+  ptrdiff_t min_arity, max_arity;
+  emacs_subr subr;
+  void *data;
+} GCALIGNED_STRUCT;
+
 static struct Lisp_Module_Function *
 allocate_module_function (void)
 {
@@ -457,11 +525,7 @@ module_make_function (emacs_env *env, ptrdiff_t min_arity, ptrdiff_t max_arity,
   function->data = data;
 
   if (documentation)
-    {
-      AUTO_STRING (unibyte_doc, documentation);
-      function->documentation =
-        code_convert_string_norecord (unibyte_doc, Qutf_8, false);
-    }
+    function->documentation = build_string_from_utf8 (documentation);
 
   Lisp_Object result;
   XSET_MODULE_FUNCTION (result, function);
@@ -563,7 +627,7 @@ module_copy_string_contents (emacs_env *env, emacs_value value, char *buffer,
   Lisp_Object lisp_str = value_to_lisp (value);
   CHECK_STRING (lisp_str);
 
-  Lisp_Object lisp_str_utf8 = ENCODE_UTF_8 (lisp_str);
+  Lisp_Object lisp_str_utf8 = module_encode (lisp_str);
   ptrdiff_t raw_size = SBYTES (lisp_str_utf8);
   ptrdiff_t required_buf_size = raw_size + 1;
 
@@ -575,8 +639,11 @@ module_copy_string_contents (emacs_env *env, emacs_value value, char *buffer,
 
   if (*length < required_buf_size)
     {
+      ptrdiff_t actual = *length;
       *length = required_buf_size;
-      xsignal0 (Qargs_out_of_range);
+      args_out_of_range_3 (INT_TO_INTEGER (actual),
+                           INT_TO_INTEGER (required_buf_size),
+                           INT_TO_INTEGER (PTRDIFF_MAX));
     }
 
   *length = required_buf_size;
@@ -591,11 +658,8 @@ module_make_string (emacs_env *env, const char *str, ptrdiff_t length)
   MODULE_FUNCTION_BEGIN (NULL);
   if (! (0 <= length && length <= STRING_BYTES_BOUND))
     overflow_error ();
-  /* FIXME: AUTO_STRING_WITH_LEN requires STR to be NUL-terminated,
-     but we shouldn't require that.  */
-  AUTO_STRING_WITH_LEN (lstr, str, length);
-  return lisp_to_value (env,
-                        code_convert_string_norecord (lstr, Qutf_8, false));
+  Lisp_Object lstr = make_string_from_utf8 (str, length);
+  return lisp_to_value (env, lstr);
 }
 
 static emacs_value
@@ -695,6 +759,38 @@ module_process_input (emacs_env *env)
   return emacs_process_input_continue;
 }
 
+static struct timespec
+module_extract_time (emacs_env *env, emacs_value value)
+{
+  MODULE_FUNCTION_BEGIN ((struct timespec) {0});
+  return lisp_time_argument (value_to_lisp (value));
+}
+
+static emacs_value
+module_make_time (emacs_env *env, struct timespec time)
+{
+  MODULE_FUNCTION_BEGIN (NULL);
+  return lisp_to_value (env, timespec_to_lisp (time));
+}
+
+static void
+module_extract_big_integer (emacs_env *env, emacs_value value,
+                            struct emacs_mpz *result)
+{
+  MODULE_FUNCTION_BEGIN ();
+  Lisp_Object o = value_to_lisp (value);
+  CHECK_INTEGER (o);
+  mpz_set_integer (result->value, o);
+}
+
+static emacs_value
+module_make_big_integer (emacs_env *env, const struct emacs_mpz *value)
+{
+  MODULE_FUNCTION_BEGIN (NULL);
+  mpz_set (mpz[0], value->value);
+  return lisp_to_value (env, make_integer_mpz ());
+}
+
 
 /* Subroutines.  */
 
@@ -716,6 +812,10 @@ module_signal_or_throw (struct emacs_env_private *env)
     }
 }
 
+/* Live runtime and environment objects, for assertions.  */
+static Lisp_Object Vmodule_runtimes;
+static Lisp_Object Vmodule_environments;
+
 DEFUN ("module-load", Fmodule_load, Smodule_load, 1, 1, 0,
        doc: /* Load module FILE.  */)
   (Lisp_Object file)
@@ -794,6 +894,11 @@ funcall_module (Lisp_Object function, ptrdiff_t nargs, Lisp_Object *arglist)
 	memory_full (sizeof *args[i]);
     }
 
+  /* The only possibility of getting an error until here is failure to
+     allocate memory for the arguments, but then we already should
+     have signaled an error before.  */
+  eassert (priv.pending_non_local_exit == emacs_funcall_exit_return);
+
   emacs_value ret = func->subr (env, nargs, args, func->data);
 
   eassert (&priv == env->private_members);
@@ -815,6 +920,18 @@ module_function_arity (const struct Lisp_Module_Function *const function)
 		maxargs == MANY ? Qmany : make_fixnum (maxargs));
 }
 
+Lisp_Object
+module_function_documentation (const struct Lisp_Module_Function *function)
+{
+  return function->documentation;
+}
+
+module_funcptr
+module_function_address (const struct Lisp_Module_Function *function)
+{
+  return (module_funcptr) function->subr;
+}
+
 
 /* Helper functions.  */
 
@@ -899,6 +1016,12 @@ module_out_of_memory (emacs_env *env)
 				  XCDR (Vmemory_signal_data));
 }
 
+static Lisp_Object
+module_encode (Lisp_Object string)
+{
+  return code_convert_string (string, Qutf_8_unix, Qt, true, true, true);
+}
+
 
 /* Value conversion.  */
 
@@ -928,29 +1051,13 @@ value_to_lisp (emacs_value v)
           if (&priv->non_local_exit_symbol == v
               || &priv->non_local_exit_data == v)
             goto ok;
-          for (struct emacs_value_frame *frame = &priv->storage.initial;
-               frame != NULL; frame = frame->next)
-            {
-              for (int i = 0; i < frame->offset; ++i)
-                {
-                  if (&frame->objects[i] == v)
-                    goto ok;
-                  ++num_values;
-                }
-            }
+          if (value_storage_contains_p (&priv->storage, v, &num_values))
+            goto ok;
           ++num_environments;
         }
       /* Also check global values.  */
-      for (struct emacs_value_frame *frame = &global_storage.initial;
-           frame != NULL; frame = frame->next)
-        {
-          for (int i = 0; i < frame->offset; ++i)
-            {
-              if (&frame->objects[i] == v)
-                goto ok;
-              ++num_values;
-            }
-        }
+      if (value_storage_contains_p (&global_storage, v, &num_values))
+        goto ok;
       module_abort (("Emacs value not found in %"pD"d values "
 		     "of %"pD"d environments"),
                     num_values, num_environments);
@@ -1092,6 +1199,10 @@ initialize_environment (emacs_env *env, struct emacs_env_private *priv)
   env->vec_size = module_vec_size;
   env->should_quit = module_should_quit;
   env->process_input = module_process_input;
+  env->extract_time = module_extract_time;
+  env->make_time = module_make_time;
+  env->extract_big_integer = module_extract_big_integer;
+  env->make_big_integer = module_make_big_integer;
   Vmodule_environments = Fcons (make_mint_ptr (env), Vmodule_environments);
   return env;
 }
@@ -1136,20 +1247,22 @@ module_reset_handlerlist (struct handler **phandlerlist)
   handlerlist = handlerlist->next;
 }
 
-/* Called on `signal'.  ERR is a pair (SYMBOL . DATA), which gets
-   stored in the environment.  Set the pending non-local exit flag.  */
+/* Called on `signal' and `throw'.  DATA is a pair
+   (ERROR-SYMBOL . ERROR-DATA) or (TAG . VALUE), which gets stored in
+   the environment.  Set the pending non-local exit flag.  */
 static void
-module_handle_signal (emacs_env *env, Lisp_Object err)
+module_handle_nonlocal_exit (emacs_env *env, enum nonlocal_exit type,
+                             Lisp_Object data)
 {
-  module_non_local_exit_signal_1 (env, XCAR (err), XCDR (err));
-}
-
-/* Called on `throw'.  TAG_VAL is a pair (TAG . VALUE), which gets
-   stored in the environment.  Set the pending non-local exit flag.  */
-static void
-module_handle_throw (emacs_env *env, Lisp_Object tag_val)
-{
-  module_non_local_exit_throw_1 (env, XCAR (tag_val), XCDR (tag_val));
+  switch (type)
+    {
+    case NONLOCAL_EXIT_SIGNAL:
+      module_non_local_exit_signal_1 (env, XCAR (data), XCDR (data));
+      break;
+    case NONLOCAL_EXIT_THROW:
+      module_non_local_exit_throw_1 (env, XCAR (data), XCDR (data));
+      break;
+    }
 }
 
 
@@ -1163,8 +1276,27 @@ init_module_assertions (bool enable)
   initialize_storage (&global_storage);
 }
 
-static _Noreturn void
-ATTRIBUTE_FORMAT_PRINTF(1, 2)
+/* Return whether STORAGE contains VALUE.  Used to check module
+   assertions.  Increment *COUNT by the number of values searched.  */
+
+static bool
+value_storage_contains_p (const struct emacs_value_storage *storage,
+                          emacs_value value, ptrdiff_t *count)
+{
+  for (const struct emacs_value_frame *frame = &storage->initial; frame != NULL;
+       frame = frame->next)
+    {
+      for (int i = 0; i < frame->offset; ++i)
+        {
+          if (&frame->objects[i] == value)
+            return true;
+          ++*count;
+        }
+    }
+  return false;
+}
+
+static AVOID ATTRIBUTE_FORMAT_PRINTF (1, 2)
 module_abort (const char *format, ...)
 {
   fputs ("Emacs module assertion: ", stderr);
@@ -1183,31 +1315,17 @@ module_abort (const char *format, ...)
 void
 syms_of_module (void)
 {
-  DEFSYM (Qmodule_refs_hash, "module-refs-hash");
-  DEFVAR_LISP ("module-refs-hash", Vmodule_refs_hash,
-	       doc: /* Module global reference table.  */);
-
+  staticpro (&Vmodule_refs_hash);
   Vmodule_refs_hash
     = make_hash_table (hashtest_eq, DEFAULT_HASH_SIZE,
 		       DEFAULT_REHASH_SIZE, DEFAULT_REHASH_THRESHOLD,
 		       Qnil, false);
-  Funintern (Qmodule_refs_hash, Qnil);
 
-  DEFSYM (Qmodule_runtimes, "module-runtimes");
-  DEFVAR_LISP ("module-runtimes", Vmodule_runtimes,
-               doc: /* List of active module runtimes.  */);
+  staticpro (&Vmodule_runtimes);
   Vmodule_runtimes = Qnil;
-  /* Unintern `module-runtimes' because it is only used
-     internally.  */
-  Funintern (Qmodule_runtimes, Qnil);
 
-  DEFSYM (Qmodule_environments, "module-environments");
-  DEFVAR_LISP ("module-environments", Vmodule_environments,
-               doc: /* List of active module environments.  */);
+  staticpro (&Vmodule_environments);
   Vmodule_environments = Qnil;
-  /* Unintern `module-environments' because it is only used
-     internally.  */
-  Funintern (Qmodule_environments, Qnil);
 
   DEFSYM (Qmodule_load_failed, "module-load-failed");
   Fput (Qmodule_load_failed, Qerror_conditions,
@@ -1246,10 +1364,6 @@ syms_of_module (void)
   Fput (Qinvalid_arity, Qerror_message,
         build_pure_c_string ("Invalid function arity"));
 
-  /* Unintern `module-refs-hash' because it is internal-only and Lisp
-     code or modules should not access it.  */
-  Funintern (Qmodule_refs_hash, Qnil);
-
   DEFSYM (Qmodule_function_p, "module-function-p");
 
   defsubr (&Smodule_load);
diff --git a/src/emacs-module.h.in b/src/emacs-module.h.in
index 009d1583fe..9955e30eb7 100644
--- a/src/emacs-module.h.in
+++ b/src/emacs-module.h.in
@@ -22,11 +22,18 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include <stdint.h>
 #include <stddef.h>
+#include <time.h>
 
 #ifndef __cplusplus
 #include <stdbool.h>
 #endif
 
+#if defined EMACS_MODULE_GMP && !defined EMACS_MODULE_HAVE_MPZ_T
+#include <gmp.h>
+#endif
+
+#define EMACS_MAJOR_VERSION @emacs_major_version@
+
 #if defined __cplusplus && __cplusplus >= 201103L
 # define EMACS_NOEXCEPT noexcept
 #else
@@ -93,6 +100,12 @@ enum emacs_process_input_result
   emacs_process_input_quit = 1
 };
 
+#ifdef EMACS_MODULE_GMP
+struct emacs_mpz { mpz_t value; };
+#else
+struct emacs_mpz;  /* no definition */
+#endif
+
 struct emacs_env_25
 {
 @module_env_snippet_25@
diff --git a/src/emacs.c b/src/emacs.c
index 402d04a667..4b6d3c2a41 100644
--- a/src/emacs.c
+++ b/src/emacs.c
@@ -342,7 +342,7 @@ section of the Emacs manual or the file BUGS.\n"
 bool fatal_error_in_progress;
 
 #ifdef HAVE_NS
-/* NS autrelease pool, for memory management.  */
+/* NS autorelease pool, for memory management.  */
 static void *ns_pool;
 #endif
 
@@ -370,7 +370,7 @@ using_utf8 (void)
 
 /* Report a fatal error due to signal SIG, output a backtrace of at
    most BACKTRACE_LIMIT lines, and exit.  */
-_Noreturn void
+AVOID
 terminate_due_to_signal (int sig, int backtrace_limit)
 {
   signal (sig, SIG_DFL);
@@ -1436,7 +1436,6 @@ Using an Emacs configured with --with-x-toolkit=lucid does not have this problem
   if (!initialized)
     {
       init_alloc_once ();
-      init_threads_once ();
       init_obarray_once ();
       init_eval_once ();
       init_charset_once ();
@@ -2498,9 +2497,6 @@ You must run Emacs in batch mode in order to dump it.  */)
 # ifdef WINDOWSNT
   Vlibrary_cache = Qnil;
 # endif
-# ifdef HAVE_WINDOW_SYSTEM
-  reset_image_types ();
-# endif
 
   Vpurify_flag = tem;
 
diff --git a/src/eval.c b/src/eval.c
index e9f118c5cb..5bba876637 100644
--- a/src/eval.c
+++ b/src/eval.c
@@ -52,15 +52,6 @@ Lisp_Object Vautoload_queue;
    is shutting down.  */
 Lisp_Object Vrun_hooks;
 
-/* The value of num_nonmacro_input_events as of the last time we
-   started to enter the debugger.  If we decide to enter the debugger
-   again when this is still equal to num_nonmacro_input_events, then we
-   know that the debugger itself has an error, and we should just
-   signal the error instead of entering an infinite loop of debugger
-   invocations.  */
-
-static intmax_t when_entered_debugger;
-
 /* The function from which the last `signal' was called.  Set in
    Fsignal.  */
 /* FIXME: We should probably get rid of this!  */
@@ -510,7 +501,7 @@ usage: (setq [SYM VAL]...)  */)
 
   for (EMACS_INT nargs = 0; CONSP (tail); nargs += 2)
     {
-      Lisp_Object sym = XCAR (tail), lex_binding;
+      Lisp_Object sym = XCAR (tail);
       tail = XCDR (tail);
       if (!CONSP (tail))
 	xsignal2 (Qwrong_number_of_arguments, Qsetq, make_fixnum (nargs + 1));
@@ -519,10 +510,12 @@ usage: (setq [SYM VAL]...)  */)
       val = eval_sub (arg);
       /* Like for eval_sub, we do not check declared_special here since
 	 it's been done when let-binding.  */
-      if (!NILP (Vinternal_interpreter_environment) /* Mere optimization!  */
-	  && SYMBOLP (sym)
-	  && !NILP (lex_binding
-		    = Fassq (sym, Vinternal_interpreter_environment)))
+      Lisp_Object lex_binding
+	= ((!NILP (Vinternal_interpreter_environment) /* Mere optimization!  */
+	    && SYMBOLP (sym))
+	   ? Fassq (sym, Vinternal_interpreter_environment)
+	   : Qnil);
+      if (!NILP (lex_binding))
 	XSETCDR (lex_binding, val); /* SYM is lexically bound.  */
       else
 	Fset (sym, val);	/* SYM is dynamically bound.  */
@@ -551,8 +544,8 @@ usage: (quote ARG)  */)
 
 DEFUN ("function", Ffunction, Sfunction, 1, UNEVALLED, 0,
        doc: /* Like `quote', but preferred for objects which are functions.
-In byte compilation, `function' causes its argument to be compiled.
-`quote' cannot do that.
+In byte compilation, `function' causes its argument to be handled by
+the byte compiler.  `quote' cannot do that.
 usage: (function ARG)  */)
   (Lisp_Object args)
 {
@@ -722,6 +715,25 @@ DEFUN ("set-default-toplevel-value", Fset_default_toplevel_value,
   return Qnil;
 }
 
+DEFUN ("internal--define-uninitialized-variable",
+       Finternal__define_uninitialized_variable,
+       Sinternal__define_uninitialized_variable, 1, 2, 0,
+       doc: /* Define SYMBOL as a variable, with DOC as its docstring.
+This is like `defvar' and `defconst' but without affecting the variable's
+value.  */)
+  (Lisp_Object symbol, Lisp_Object doc)
+{
+  XSYMBOL (symbol)->u.s.declared_special = true;
+  if (!NILP (doc))
+    {
+      if (!NILP (Vpurify_flag))
+	doc = Fpurecopy (doc);
+      Fput (symbol, Qvariable_documentation, doc);
+    }
+  LOADHIST_ATTACH (symbol);
+  return Qnil;
+}
+
 DEFUN ("defvar", Fdefvar, Sdefvar, 1, UNEVALLED, 0,
        doc: /* Define SYMBOL as a variable, and return SYMBOL.
 You are not required to define a variable in order to use it, but
@@ -761,32 +773,25 @@ usage: (defvar SYMBOL &optional INITVALUE DOCSTRING)  */)
     {
       if (!NILP (XCDR (tail)) && !NILP (XCDR (XCDR (tail))))
 	error ("Too many arguments");
+      Lisp_Object exp = XCAR (tail);
 
       tem = Fdefault_boundp (sym);
+      tail = XCDR (tail);
 
       /* Do it before evaluating the initial value, for self-references.  */
-      XSYMBOL (sym)->u.s.declared_special = true;
+      Finternal__define_uninitialized_variable (sym, CAR (tail));
 
       if (NILP (tem))
-	Fset_default (sym, eval_sub (XCAR (tail)));
+	Fset_default (sym, eval_sub (exp));
       else
 	{ /* Check if there is really a global binding rather than just a let
 	     binding that shadows the global unboundness of the var.  */
 	  union specbinding *binding = default_toplevel_binding (sym);
 	  if (binding && EQ (specpdl_old_value (binding), Qunbound))
 	    {
-	      set_specpdl_old_value (binding, eval_sub (XCAR (tail)));
+	      set_specpdl_old_value (binding, eval_sub (exp));
 	    }
 	}
-      tail = XCDR (tail);
-      tem = Fcar (tail);
-      if (!NILP (tem))
-	{
-	  if (!NILP (Vpurify_flag))
-	    tem = Fpurecopy (tem);
-	  Fput (sym, Qvariable_documentation, tem);
-	}
-      LOADHIST_ATTACH (sym);
     }
   else if (!NILP (Vinternal_interpreter_environment)
 	   && (SYMBOLP (sym) && !XSYMBOL (sym)->u.s.declared_special))
@@ -834,19 +839,12 @@ usage: (defconst SYMBOL INITVALUE [DOCSTRING])  */)
       docstring = XCAR (XCDR (XCDR (args)));
     }
 
+  Finternal__define_uninitialized_variable (sym, docstring);
   tem = eval_sub (XCAR (XCDR (args)));
   if (!NILP (Vpurify_flag))
     tem = Fpurecopy (tem);
-  Fset_default (sym, tem);
-  XSYMBOL (sym)->u.s.declared_special = true;
-  if (!NILP (docstring))
-    {
-      if (!NILP (Vpurify_flag))
-	docstring = Fpurecopy (docstring);
-      Fput (sym, Qvariable_documentation, docstring);
-    }
-  Fput (sym, Qrisky_local_variable, Qt);
-  LOADHIST_ATTACH (sym);
+  Fset_default (sym, tem);      /* FIXME: set-default-toplevel-value? */
+  Fput (sym, Qrisky_local_variable, Qt); /* FIXME: Why?  */
   return sym;
 }
 
@@ -1142,14 +1140,16 @@ internal_catch (Lisp_Object tag,
 
    This is used for correct unwinding in Fthrow and Fsignal.  */
 
-static _Noreturn void
-unwind_to_catch (struct handler *catch, Lisp_Object value)
+static AVOID
+unwind_to_catch (struct handler *catch, enum nonlocal_exit type,
+                 Lisp_Object value)
 {
   bool last_time;
 
   eassert (catch->next);
 
   /* Save the value in the tag.  */
+  catch->nonlocal_exit = type;
   catch->val = value;
 
   /* Restore certain special C variables.  */
@@ -1186,9 +1186,9 @@ Both TAG and VALUE are evalled.  */
     for (c = handlerlist; c; c = c->next)
       {
 	if (c->type == CATCHER_ALL)
-          unwind_to_catch (c, Fcons (tag, value));
-	if (c->type == CATCHER && EQ (c->tag_or_ch, tag))
-	  unwind_to_catch (c, value);
+          unwind_to_catch (c, NONLOCAL_EXIT_THROW, Fcons (tag, value));
+        if (c->type == CATCHER && EQ (c->tag_or_ch, tag))
+	  unwind_to_catch (c, NONLOCAL_EXIT_THROW, value);
       }
   xsignal2 (Qno_catch, tag, value);
 }
@@ -1436,28 +1436,7 @@ internal_condition_case_n (Lisp_Object (*bfun) (ptrdiff_t, Lisp_Object *),
     }
 }
 
-static Lisp_Object
-internal_catch_all_1 (Lisp_Object (*function) (void *), void *argument)
-{
-  struct handler *c = push_handler_nosignal (Qt, CATCHER_ALL);
-  if (c == NULL)
-    return Qcatch_all_memory_full;
-
-  if (sys_setjmp (c->jmp) == 0)
-    {
-      Lisp_Object val = function (argument);
-      eassert (handlerlist == c);
-      handlerlist = c->next;
-      return val;
-    }
-  else
-    {
-      eassert (handlerlist == c);
-      Lisp_Object val = c->val;
-      handlerlist = c->next;
-      Fsignal (Qno_catch, val);
-    }
-}
+static Lisp_Object Qcatch_all_memory_full;
 
 /* Like a combination of internal_condition_case_1 and internal_catch.
    Catches all signals and throws.  Never exits nonlocally; returns
@@ -1465,15 +1444,15 @@ internal_catch_all_1 (Lisp_Object (*function) (void *), void *argument)
 
 Lisp_Object
 internal_catch_all (Lisp_Object (*function) (void *), void *argument,
-                    Lisp_Object (*handler) (Lisp_Object))
+                    Lisp_Object (*handler) (enum nonlocal_exit, Lisp_Object))
 {
-  struct handler *c = push_handler_nosignal (Qt, CONDITION_CASE);
+  struct handler *c = push_handler_nosignal (Qt, CATCHER_ALL);
   if (c == NULL)
     return Qcatch_all_memory_full;
 
   if (sys_setjmp (c->jmp) == 0)
     {
-      Lisp_Object val = internal_catch_all_1 (function, argument);
+      Lisp_Object val = function (argument);
       eassert (handlerlist == c);
       handlerlist = c->next;
       return val;
@@ -1481,9 +1460,10 @@ internal_catch_all (Lisp_Object (*function) (void *), void *argument,
   else
     {
       eassert (handlerlist == c);
+      enum nonlocal_exit type = c->nonlocal_exit;
       Lisp_Object val = c->val;
       handlerlist = c->next;
-      return handler (val);
+      return handler (type, val);
     }
 }
 
@@ -1654,6 +1634,11 @@ signal_or_quit (Lisp_Object error_symbol, Lisp_Object data, bool keyboard_quit)
 
   for (h = handlerlist; h; h = h->next)
     {
+      if (h->type == CATCHER_ALL)
+        {
+          clause = Qt;
+          break;
+        }
       if (h->type != CONDITION_CASE)
 	continue;
       clause = find_handler_clause (h->tag_or_ch, conditions);
@@ -1687,7 +1672,7 @@ signal_or_quit (Lisp_Object error_symbol, Lisp_Object data, bool keyboard_quit)
       Lisp_Object unwind_data
 	= (NILP (error_symbol) ? data : Fcons (error_symbol, data));
 
-      unwind_to_catch (h, unwind_data);
+      unwind_to_catch (h, NONLOCAL_EXIT_SIGNAL, unwind_data);
     }
   else
     {
@@ -1835,7 +1820,8 @@ maybe_call_debugger (Lisp_Object conditions, Lisp_Object sig, Lisp_Object data)
 	  ? debug_on_quit
 	  : wants_debugger (Vdebug_on_error, conditions))
       && ! skip_debugger (conditions, combined_data)
-      /* RMS: What's this for?  */
+      /* See commentary on definition of
+         `internal-when-entered-debugger'.  */
       && when_entered_debugger < num_nonmacro_input_events)
     {
       call_debugger (list2 (Qerror, combined_data));
@@ -2174,27 +2160,16 @@ record_in_backtrace (Lisp_Object function, Lisp_Object *args, ptrdiff_t nargs)
 Lisp_Object
 eval_sub (Lisp_Object form)
 {
-  Lisp_Object fun, val, original_fun, original_args;
-  Lisp_Object funcar;
-  ptrdiff_t count;
-
-  /* Declare here, as this array may be accessed by call_debugger near
-     the end of this function.  See Bug#21245.  */
-  Lisp_Object argvals[8];
-
   if (SYMBOLP (form))
     {
       /* Look up its binding in the lexical environment.
 	 We do not pay attention to the declared_special flag here, since we
 	 already did that when let-binding the variable.  */
       Lisp_Object lex_binding
-	= !NILP (Vinternal_interpreter_environment) /* Mere optimization!  */
-	? Fassq (form, Vinternal_interpreter_environment)
-	: Qnil;
-      if (CONSP (lex_binding))
-	return XCDR (lex_binding);
-      else
-	return Fsymbol_value (form);
+	= (!NILP (Vinternal_interpreter_environment) /* Mere optimization!  */
+	   ? Fassq (form, Vinternal_interpreter_environment)
+	   : Qnil);
+      return !NILP (lex_binding) ? XCDR (lex_binding) : Fsymbol_value (form);
     }
 
   if (!CONSP (form))
@@ -2212,18 +2187,22 @@ eval_sub (Lisp_Object form)
 	error ("Lisp nesting exceeds `max-lisp-eval-depth'");
     }
 
-  original_fun = XCAR (form);
-  original_args = XCDR (form);
+  Lisp_Object original_fun = XCAR (form);
+  Lisp_Object original_args = XCDR (form);
   CHECK_LIST (original_args);
 
   /* This also protects them from gc.  */
-  count = record_in_backtrace (original_fun, &original_args, UNEVALLED);
+  ptrdiff_t count
+    = record_in_backtrace (original_fun, &original_args, UNEVALLED);
 
   if (debug_on_next_call)
     do_debug_on_call (Qt, count);
 
-  /* At this point, only original_fun and original_args
-     have values that will be used below.  */
+  Lisp_Object fun, val, funcar;
+  /* Declare here, as this array may be accessed by call_debugger near
+     the end of this function.  See Bug#21245.  */
+  Lisp_Object argvals[8];
+
  retry:
 
   /* Optimize for no indirection.  */
@@ -2238,8 +2217,6 @@ eval_sub (Lisp_Object form)
       Lisp_Object args_left = original_args;
       ptrdiff_t numargs = list_length (args_left);
 
-      check_cons_list ();
-
       if (numargs < XSUBR (fun)->min_args
 	  || (XSUBR (fun)->max_args >= 0
 	      && XSUBR (fun)->max_args < numargs))
@@ -2268,7 +2245,6 @@ eval_sub (Lisp_Object form)
 
 	  val = XSUBR (fun)->function.aMANY (argnum, vals);
 
-	  check_cons_list ();
 	  lisp_eval_depth--;
 	  /* Do the debug-on-exit now, while VALS still exists.  */
 	  if (backtrace_debug_on_exit (specpdl + count))
@@ -2374,7 +2350,6 @@ eval_sub (Lisp_Object form)
       else
 	xsignal1 (Qinvalid_function, original_fun);
     }
-  check_cons_list ();
 
   lisp_eval_depth--;
   if (backtrace_debug_on_exit (specpdl + count))
@@ -2814,8 +2789,6 @@ usage: (funcall FUNCTION &rest ARGUMENTS)  */)
   if (debug_on_next_call)
     do_debug_on_call (Qlambda, count);
 
-  check_cons_list ();
-
   original_fun = args[0];
 
  retry:
@@ -2845,13 +2818,11 @@ usage: (funcall FUNCTION &rest ARGUMENTS)  */)
       else if (EQ (funcar, Qautoload))
 	{
 	  Fautoload_do_load (fun, original_fun, Qnil);
-	  check_cons_list ();
 	  goto retry;
 	}
       else
 	xsignal1 (Qinvalid_function, original_fun);
     }
-  check_cons_list ();
   lisp_eval_depth--;
   if (backtrace_debug_on_exit (specpdl + count))
     val = call_debugger (list2 (Qexit, val));
@@ -2963,7 +2934,6 @@ apply_lambda (Lisp_Object fun, Lisp_Object args, ptrdiff_t count)
   set_backtrace_args (specpdl + count, arg_vector, numargs);
   tem = funcall_lambda (fun, numargs, arg_vector);
 
-  check_cons_list ();
   lisp_eval_depth--;
   /* Do the debug-on-exit now, while arg_vector still exists.  */
   if (backtrace_debug_on_exit (specpdl + count))
@@ -4170,6 +4140,18 @@ Note that `debug-on-error', `debug-on-quit' and friends
 still determine whether to handle the particular condition.  */);
   Vdebug_on_signal = Qnil;
 
+  /* The value of num_nonmacro_input_events as of the last time we
+   started to enter the debugger.  If we decide to enter the debugger
+   again when this is still equal to num_nonmacro_input_events, then we
+   know that the debugger itself has an error, and we should just
+   signal the error instead of entering an infinite loop of debugger
+   invocations.  */
+  DEFSYM (Qinternal_when_entered_debugger, "internal-when-entered-debugger");
+  DEFVAR_INT ("internal-when-entered-debugger", when_entered_debugger,
+              doc: /* The number of keyboard events as of last time `debugger' was called.
+Used to avoid infinite loops if the debugger itself has an error.
+Don't set this unless you're sure that can't happen.  */);
+
   /* When lexical binding is being used,
    Vinternal_interpreter_environment is non-nil, and contains an alist
    of lexically-bound variable, or (t), indicating an empty
@@ -4199,8 +4181,12 @@ alist of active lexical bindings.  */);
   staticpro (&Vsignaling_function);
   Vsignaling_function = Qnil;
 
-  DEFSYM (Qcatch_all_memory_full, "catch-all-memory-full");
-  Funintern (Qcatch_all_memory_full, Qnil);
+  staticpro (&Qcatch_all_memory_full);
+  /* Make sure Qcatch_all_memory_full is a unique object.  We could
+     also use something like Fcons (Qnil, Qnil), but json.c treats any
+     cons cell as error data, so use an uninterned symbol instead.  */
+  Qcatch_all_memory_full
+    = Fmake_symbol (build_pure_c_string ("catch-all-memory-full"));
 
   defsubr (&Sor);
   defsubr (&Sand);
@@ -4217,6 +4203,7 @@ alist of active lexical bindings.  */);
   defsubr (&Sdefvaralias);
   DEFSYM (Qdefvaralias, "defvaralias");
   defsubr (&Sdefconst);
+  defsubr (&Sinternal__define_uninitialized_variable);
   defsubr (&Smake_var_non_special);
   defsubr (&Slet);
   defsubr (&SletX);
diff --git a/src/fileio.c b/src/fileio.c
index 4ee125d7de..9e9779967d 100644
--- a/src/fileio.c
+++ b/src/fileio.c
@@ -5802,6 +5802,7 @@ A non-nil CURRENT-ONLY argument means save only current buffer.  */)
 	    && BUF_SAVE_MODIFF (b) < BUF_MODIFF (b)
 	    && BUF_AUTOSAVE_MODIFF (b) < BUF_MODIFF (b)
 	    /* -1 means we've turned off autosaving for a while--see below.  */
+	    && FIXNUMP (BVAR (b, save_length))
 	    && XFIXNUM (BVAR (b, save_length)) >= 0
 	    && (do_handled_files
 		|| NILP (Ffind_file_name_handler (BVAR (b, auto_save_file_name),
@@ -5815,13 +5816,17 @@ A non-nil CURRENT-ONLY argument means save only current buffer.  */)
 		&& before_time.tv_sec - b->auto_save_failure_time < 1200)
 	      continue;
 
+	    enum { growth_factor = 4 };
+	    verify (BUF_BYTES_MAX <= EMACS_INT_MAX / growth_factor);
+
 	    set_buffer_internal (b);
 	    if (NILP (Vauto_save_include_big_deletions)
-		&& (XFIXNAT (BVAR (b, save_length)) * 10
-		    > (BUF_Z (b) - BUF_BEG (b)) * 13)
+		&& FIXNUMP (BVAR (b, save_length))
 		/* A short file is likely to change a large fraction;
 		   spare the user annoying messages.  */
 		&& XFIXNAT (BVAR (b, save_length)) > 5000
+		&& (growth_factor * (BUF_Z (b) - BUF_BEG (b))
+		    < (growth_factor - 1) * XFIXNAT (BVAR (b, save_length)))
 		/* These messages are frequent and annoying for `*mail*'.  */
 		&& !NILP (BVAR (b, filename))
 		&& NILP (no_message))
diff --git a/src/fns.c b/src/fns.c
index c3202495da..cb47b818f1 100644
--- a/src/fns.c
+++ b/src/fns.c
@@ -1131,10 +1131,8 @@ string the same way whether it is unibyte or multibyte.)  */)
 DEFUN ("string-make-unibyte", Fstring_make_unibyte, Sstring_make_unibyte,
        1, 1, 0,
        doc: /* Return the unibyte equivalent of STRING.
-Multibyte character codes are converted to unibyte according to
-`nonascii-translation-table' or, if that is nil, `nonascii-insert-offset'.
-If the lookup in the translation table fails, this function takes just
-the low 8 bits of each character.  */)
+Multibyte character codes above 255 are converted to unibyte
+by taking just the low 8 bits of each character's code.  */)
   (Lisp_Object string)
 {
   CHECK_STRING (string);
@@ -1523,7 +1521,7 @@ union double_and_words
   EMACS_UINT word[WORDS_PER_DOUBLE];
 };
 
-/* Return true if X and Y are the same floating-point value.
+/* Return true if the floats X and Y have the same value.
    This looks at X's and Y's representation, since (unlike '==')
    it returns true if X and Y are the same NaN.  */
 static bool
@@ -1569,16 +1567,30 @@ DEFUN ("memql", Fmemql, Smemql, 2, 2, 0,
 The value is actually the tail of LIST whose car is ELT.  */)
   (Lisp_Object elt, Lisp_Object list)
 {
-  if (!FLOATP (elt))
-    return Fmemq (elt, list);
-
   Lisp_Object tail = list;
-  FOR_EACH_TAIL (tail)
+
+  if (FLOATP (elt))
     {
-      Lisp_Object tem = XCAR (tail);
-      if (FLOATP (tem) && same_float (elt, tem))
-	return tail;
+      FOR_EACH_TAIL (tail)
+        {
+          Lisp_Object tem = XCAR (tail);
+          if (FLOATP (tem) && same_float (elt, tem))
+            return tail;
+        }
     }
+  else if (BIGNUMP (elt))
+    {
+      FOR_EACH_TAIL (tail)
+        {
+          Lisp_Object tem = XCAR (tail);
+          if (BIGNUMP (tem)
+	      && mpz_cmp (XBIGNUM (elt)->value, XBIGNUM (tem)->value) == 0)
+            return tail;
+        }
+    }
+  else
+    return Fmemq (elt, list);
+
   CHECK_LIST_END (tail, list);
   return Qnil;
 }
@@ -2289,7 +2301,9 @@ This differs from numeric comparison: (eql 0.0 -0.0) returns nil and
   if (FLOATP (obj1))
     return FLOATP (obj2) && same_float (obj1, obj2) ? Qt : Qnil;
   else if (BIGNUMP (obj1))
-    return equal_no_quit (obj1, obj2) ? Qt : Qnil;
+    return ((BIGNUMP (obj2)
+	     && mpz_cmp (XBIGNUM (obj1)->value, XBIGNUM (obj2)->value) == 0)
+	    ? Qt : Qnil);
   else
     return EQ (obj1, obj2) ? Qt : Qnil;
 }
diff --git a/src/font.h b/src/font.h
index 3720650a2e..9ca0c97dc5 100644
--- a/src/font.h
+++ b/src/font.h
@@ -647,7 +647,7 @@ struct font_driver
      the font FONT and the sequence of glyph codes CODE, and store the
      result in METRICS.  */
   void (*text_extents) (struct font *font,
-			unsigned *code, int nglyphs,
+			const unsigned *code, int nglyphs,
 			struct font_metrics *metrics);
 
 #ifdef HAVE_WINDOW_SYSTEM
@@ -894,7 +894,7 @@ extern Lisp_Object ftfont_shape (Lisp_Object);
 extern unsigned ftfont_encode_char (struct font *, int);
 extern void ftfont_close (struct font *);
 extern void ftfont_filter_properties (Lisp_Object, Lisp_Object);
-extern void ftfont_text_extents (struct font *, unsigned *, int,
+extern void ftfont_text_extents (struct font *, const unsigned *, int,
 				 struct font_metrics *);
 extern void syms_of_ftfont (void);
 #endif	/* HAVE_FREETYPE */
diff --git a/src/fontset.c b/src/fontset.c
index eec1e0da4c..2c45c95c3a 100644
--- a/src/fontset.c
+++ b/src/fontset.c
@@ -1061,7 +1061,7 @@ font_for_char (struct face *face, int c, ptrdiff_t pos, Lisp_Object object)
 /* Make a realized fontset for ASCII face FACE on frame F from the
    base fontset BASE_FONTSET_ID.  If BASE_FONTSET_ID is -1, use the
    default fontset as the base.  Value is the id of the new fontset.
-   Called from realize_x_face.  */
+   Called from realize_gui_face.  */
 
 int
 make_fontset_for_ascii_face (struct frame *f, int base_fontset_id, struct face *face)
@@ -1743,13 +1743,14 @@ static Lisp_Object auto_fontset_alist;
 static ptrdiff_t num_auto_fontsets;
 
 /* Return a fontset synthesized from FONT-OBJECT.  This is called from
-   x_new_font when FONT-OBJECT is used for the default ASCII font of a
-   frame, and the returned fontset is used for the default fontset of
-   that frame.  The fontset specifies a font of the same registry as
-   FONT-OBJECT for all characters in the repertory of the registry
-   (see Vfont_encoding_alist).  If the repertory is not known, the
-   fontset specifies the font for all Latin characters assuming that a
-   user intends to use FONT-OBJECT for Latin characters.  */
+   the terminal hook set_new_font_hook when FONT-OBJECT is used for
+   the default ASCII font of a frame, and the returned fontset is used
+   for the default fontset of that frame.  The fontset specifies a
+   font of the same registry as FONT-OBJECT for all characters in the
+   repertory of the registry (see Vfont_encoding_alist).  If the
+   repertory is not known, the fontset specifies the font for all
+   Latin characters assuming that a user intends to use FONT-OBJECT
+   for Latin characters.  */
 
 int
 fontset_from_font (Lisp_Object font_object)
diff --git a/src/frame.c b/src/frame.c
index 192ef4244f..03bbbfb4da 100644
--- a/src/frame.c
+++ b/src/frame.c
@@ -77,7 +77,7 @@ int frame_default_tool_bar_height;
 #endif
 
 #ifdef HAVE_WINDOW_SYSTEM
-static void x_report_frame_params (struct frame *, Lisp_Object *);
+static void gui_report_frame_params (struct frame *, Lisp_Object *);
 #endif
 
 /* These setters are used only in this file, so they can be private.  */
@@ -482,7 +482,8 @@ keep_ratio (struct frame *f, struct frame *p, int old_width, int old_height,
 	      f->top_pos = pos_y;
 	    }
 
-	  x_set_offset (f, pos_x, pos_y, -1);
+          if (FRAME_TERMINAL (f)->set_frame_offset_hook)
+            FRAME_TERMINAL (f)->set_frame_offset_hook (f, pos_x, pos_y, -1);
 	}
 
       if (!CONSP (keep_ratio) || !NILP (Fcar (keep_ratio)))
@@ -518,36 +519,37 @@ keep_ratio (struct frame *f, struct frame *p, int old_width, int old_height,
  * text size of F in pixels.  A value of -1 means no change is requested
  * for that direction (but the frame may still have to be resized to
  * accommodate windows with their minimum sizes).  This can either issue
- * a request to resize the frame externally (via x_set_window_size), to
+ * a request to resize the frame externally (via set_window_size_hook), to
  * resize the frame internally (via resize_frame_windows) or do nothing
  * at all.
  *
  * The argument INHIBIT can assume the following values:
  *
- * 0 means to unconditionally call x_set_window_size even if sizes
+ * 0 means to unconditionally call set_window_size_hook even if sizes
  *   apparently do not change.  Fx_create_frame uses this to pass the
  *   initial size to the window manager.
  *
- * 1 means to call x_set_window_size if the native frame size really
+ * 1 means to call set_window_size_hook if the native frame size really
  *   changes.  Fset_frame_size, Fset_frame_height, ... use this.
  *
- * 2 means to call x_set_window_size provided frame_inhibit_resize
+ * 2 means to call set_window_size_hook provided frame_inhibit_resize
  *   allows it.  The menu and tool bar code use this ("3" won't work
  *   here in general because menu and tool bar are often not counted in
  *   the frame's text height).
  *
- * 3 means call x_set_window_size if window minimum sizes must be
- *   preserved or frame_inhibit_resize allows it.  x_set_left_fringe,
- *   x_set_scroll_bar_width, x_new_font ... use (or should use) this.
+ * 3 means call set_window_size_hook if window minimum sizes must be
+ *   preserved or frame_inhibit_resize allows it.
+ *   gui_set_left_fringe, gui_set_scroll_bar_width, gui_new_font
+ *   ... use (or should use) this.
  *
- * 4 means call x_set_window_size only if window minimum sizes must be
- *   preserved.  x_set_right_divider_width, x_set_border_width and the
- *   code responsible for wrapping the tool bar use this.
+ * 4 means call set_window_size_hook only if window minimum sizes must
+ *   be preserved.  x_set_right_divider_width, x_set_border_width and
+ *   the code responsible for wrapping the tool bar use this.
  *
- * 5 means to never call x_set_window_size.  change_frame_size uses
+ * 5 means to never call set_window_size_hook.  change_frame_size uses
  *   this.
  *
- * Note that even when x_set_window_size is not called, individual
+ * Note that even when set_window_size_hook is not called, individual
  * windows may have to be resized (via `window--sanitize-window-sizes')
  * in order to support minimum size constraints.
  *
@@ -570,7 +572,7 @@ adjust_frame_size (struct frame *f, int new_width, int new_height, int inhibit,
   /* The following two values are calculated from the old frame pixel
      sizes and any "new" settings for tool bar, menu bar and internal
      borders.  We do it this way to detect whether we have to call
-     x_set_window_size as consequence of the new settings.  */
+     set_window_size_hook as consequence of the new settings.  */
   int windows_width = FRAME_WINDOWS_WIDTH (f);
   int windows_height = FRAME_WINDOWS_HEIGHT (f);
   int min_windows_width, min_windows_height;
@@ -645,7 +647,7 @@ adjust_frame_size (struct frame *f, int new_width, int new_height, int inhibit,
 
 #ifdef HAVE_WINDOW_SYSTEM
   if (FRAME_WINDOW_P (f)
-      && f->can_x_set_window_size
+      && f->can_set_window_size
       && ((!inhibit_horizontal
 	   && (new_pixel_width != old_pixel_width
 	       || inhibit == 0 || inhibit == 2))
@@ -668,7 +670,12 @@ adjust_frame_size (struct frame *f, int new_width, int new_height, int inhibit,
 	 list2 (inhibit_horizontal ? Qt : Qnil,
 		inhibit_vertical ? Qt : Qnil));
 
-      x_set_window_size (f, 0, new_text_width, new_text_height, 1);
+      if (FRAME_TERMINAL (f)->set_window_size_hook)
+        FRAME_TERMINAL (f)->set_window_size_hook (f,
+                                                  0,
+                                                  new_text_width,
+                                                  new_text_height,
+                                                  1);
       f->resized_p = true;
 
       return;
@@ -827,7 +834,7 @@ make_frame (bool mini_p)
   f->wants_modeline = true;
   f->redisplay = true;
   f->garbaged = true;
-  f->can_x_set_window_size = false;
+  f->can_set_window_size = false;
   f->after_make_frame = false;
   f->inhibit_horizontal_resize = false;
   f->inhibit_vertical_resize = false;
@@ -1089,7 +1096,7 @@ make_initial_frame (void)
 
   last_nonminibuf_frame = f;
 
-  f->can_x_set_window_size = true;
+  f->can_set_window_size = true;
   f->after_make_frame = true;
 
   return f;
@@ -1118,6 +1125,7 @@ make_terminal_frame (struct terminal *terminal)
   f->terminal = terminal;
   f->terminal->reference_count++;
 #ifdef MSDOS
+  f->output_data.tty = &the_only_tty_output;
   f->output_data.tty->display_info = &the_only_display_info;
   if (!inhibit_window_system
       && (!FRAMEP (selected_frame) || !FRAME_LIVE_P (XFRAME (selected_frame))
@@ -1290,7 +1298,7 @@ affects all frames on the same terminal device.  */)
   for (tem = f->face_alist; CONSP (tem); tem = XCDR (tem))
     XSETCDR (XCAR (tem), Fcopy_sequence (XCDR (XCAR (tem))));
 
-  f->can_x_set_window_size = true;
+  f->can_set_window_size = true;
   f->after_make_frame = true;
 
   return frame;
@@ -1364,20 +1372,20 @@ do_switch_frame (Lisp_Object frame, int track, int for_deletion, Lisp_Object nor
 #else /* ! 0 */
   /* Instead, apply it only to the frame we're pointing to.  */
 #ifdef HAVE_WINDOW_SYSTEM
-  if (track && FRAME_WINDOW_P (f))
+  if (track && FRAME_WINDOW_P (f) && FRAME_TERMINAL (f)->get_focus_frame)
     {
-      Lisp_Object focus, xfocus;
+      Lisp_Object focus, gfocus;
 
-      xfocus = x_get_focus_frame (f);
-      if (FRAMEP (xfocus))
+      gfocus = FRAME_TERMINAL (f)->get_focus_frame (f);
+      if (FRAMEP (gfocus))
 	{
-	  focus = FRAME_FOCUS_FRAME (XFRAME (xfocus));
+	  focus = FRAME_FOCUS_FRAME (XFRAME (gfocus));
 	  if ((FRAMEP (focus) && XFRAME (focus) == SELECTED_FRAME ())
 	      /* Redirect frame focus also when FRAME has its minibuffer
 		 window on the selected frame (see Bug#24500).  */
 	      || (NILP (focus)
 		  && EQ (FRAME_MINIBUF_WINDOW (f), sf->selected_window)))
-	    Fredirect_frame_focus (xfocus, frame);
+	    Fredirect_frame_focus (gfocus, frame);
 	}
     }
 #endif /* HAVE_X_WINDOWS */
@@ -2583,11 +2591,8 @@ If omitted, FRAME defaults to the currently selected frame.  */)
 {
   struct frame *f = decode_live_frame (frame);
 
-  /* I think this should be done with a hook.  */
-#ifdef HAVE_WINDOW_SYSTEM
-  if (FRAME_WINDOW_P (f))
-    x_make_frame_visible (f);
-#endif
+  if (FRAME_WINDOW_P (f) && FRAME_TERMINAL (f)->frame_visible_invisible_hook)
+    FRAME_TERMINAL (f)->frame_visible_invisible_hook (f, true);
 
   make_frame_visible_1 (f->root_window);
 
@@ -2639,11 +2644,8 @@ displayed in the terminal.  */)
   /* Don't allow minibuf_window to remain on an invisible frame.  */
   check_minibuf_window (frame, EQ (minibuf_window, selected_window));
 
-  /* I think this should be done with a hook.  */
-#ifdef HAVE_WINDOW_SYSTEM
-  if (FRAME_WINDOW_P (f))
-    x_make_frame_invisible (f);
-#endif
+  if (FRAME_WINDOW_P (f) && FRAME_TERMINAL (f)->frame_visible_invisible_hook)
+    FRAME_TERMINAL (f)->frame_visible_invisible_hook (f, false);
 
   /* Make menu bar update for the Buffers and Frames menus.  */
   windows_or_buffers_changed = 16;
@@ -2687,13 +2689,8 @@ for how to proceed.  */)
   /* Don't allow minibuf_window to remain on an iconified frame.  */
   check_minibuf_window (frame, EQ (minibuf_window, selected_window));
 
-  /* I think this should be done with a hook.  */
-  if (FRAME_WINDOW_P (f))
-    {
-#ifdef HAVE_WINDOW_SYSTEM
-      x_iconify_frame (f);
-#endif
-    }
+  if (FRAME_WINDOW_P (f) && FRAME_TERMINAL (f)->iconify_frame_hook)
+    FRAME_TERMINAL (f)->iconify_frame_hook (f);
 
   return Qnil;
 }
@@ -2755,7 +2752,7 @@ doesn't support multiple overlapping frames, this function selects FRAME.  */)
     Fmake_frame_visible (frame);
 
   if (FRAME_TERMINAL (f)->frame_raise_lower_hook)
-    (*FRAME_TERMINAL (f)->frame_raise_lower_hook) (f, 1);
+    (*FRAME_TERMINAL (f)->frame_raise_lower_hook) (f, true);
 
   return Qnil;
 }
@@ -2771,7 +2768,7 @@ doesn't support multiple overlapping frames, this function does nothing.  */)
   struct frame *f = decode_live_frame (frame);
 
   if (FRAME_TERMINAL (f)->frame_raise_lower_hook)
-    (*FRAME_TERMINAL (f)->frame_raise_lower_hook) (f, 0);
+    (*FRAME_TERMINAL (f)->frame_raise_lower_hook) (f, false);
 
   return Qnil;
 }
@@ -2840,7 +2837,9 @@ If there is no window system support, this function does nothing.  */)
      (Lisp_Object frame, Lisp_Object noactivate)
 {
 #ifdef HAVE_WINDOW_SYSTEM
-  x_focus_frame (decode_window_system_frame (frame), !NILP (noactivate));
+  struct frame *f = decode_window_system_frame (frame);
+  if (f && FRAME_TERMINAL (f)->focus_frame_hook)
+    FRAME_TERMINAL (f)->focus_frame_hook (f, !NILP (noactivate));
 #endif
   return Qnil;
 }
@@ -2911,7 +2910,7 @@ frame_name_fnn_p (char *str, ptrdiff_t len)
 }
 
 /* Set the name of the terminal frame.  Also used by MSDOS frames.
-   Modeled after x_set_name which is used for WINDOW frames.  */
+   Modeled after *_set_name which is used for WINDOW frames.  */
 
 static void
 set_term_frame_name (struct frame *f, Lisp_Object name)
@@ -3163,7 +3162,7 @@ If FRAME is omitted or nil, return information on the currently selected frame.
   /* I think this should be done with a hook.  */
 #ifdef HAVE_WINDOW_SYSTEM
   if (FRAME_WINDOW_P (f))
-    x_report_frame_params (f, &alist);
+    gui_report_frame_params (f, &alist);
   else
 #endif
     {
@@ -3269,7 +3268,7 @@ list, but are otherwise ignored.  */)
   /* I think this should be done with a hook.  */
 #ifdef HAVE_WINDOW_SYSTEM
   if (FRAME_WINDOW_P (f))
-    x_set_frame_parameters (f, alist);
+    gui_set_frame_parameters (f, alist);
   else
 #endif
 #ifdef MSDOS
@@ -3602,11 +3601,14 @@ bottom edge of FRAME's display.  */)
   CHECK_TYPE_RANGED_INTEGER (int, x);
   CHECK_TYPE_RANGED_INTEGER (int, y);
 
-  /* I think this should be done with a hook.  */
   if (FRAME_WINDOW_P (f))
     {
 #ifdef HAVE_WINDOW_SYSTEM
-      x_set_offset (f, XFIXNUM (x), XFIXNUM (y), 1);
+      if (FRAME_TERMINAL (f)->set_frame_offset_hook)
+        FRAME_TERMINAL (f)->set_frame_offset_hook (f,
+                                                   XFIXNUM (x),
+                                                   XFIXNUM (y),
+                                                   1);
 #endif
     }
 
@@ -3651,12 +3653,12 @@ window state change flag is reset.  */)
 				Frame Parameters
  ***********************************************************************/
 
-/* Connect the frame-parameter names for X frames
-   to the ways of passing the parameter values to the window system.
+/* Connect the frame-parameter names for frames to the ways of passing
+   the parameter values to the window system.
 
-   The name of a parameter, as a Lisp symbol,
-   has an `x-frame-parameter' property which is an integer in Lisp
-   that is an index in this table.  */
+   The name of a parameter, as a Lisp symbol, has a
+   `frame-parameter-pos' property which is an integer in Lisp that is
+   an index in this table.  */
 
 struct frame_parm_table {
   const char *name;
@@ -3903,12 +3905,12 @@ frame_float (struct frame *f, Lisp_Object val, enum frame_float_type what,
 
 /* Change the parameters of frame F as specified by ALIST.
    If a parameter is not specially recognized, do nothing special;
-   otherwise call the `x_set_...' function for that parameter.
+   otherwise call the `gui_set_...' function for that parameter.
    Except for certain geometry properties, always call store_frame_param
    to store the new value in the parameter alist.  */
 
 void
-x_set_frame_parameters (struct frame *f, Lisp_Object alist)
+gui_set_frame_parameters (struct frame *f, Lisp_Object alist)
 {
   Lisp_Object tail, frame;
 
@@ -4096,7 +4098,7 @@ x_set_frame_parameters (struct frame *f, Lisp_Object alist)
        all.  With the old setting it can get a Heisenbug when
        EmacsFrameResize intermittently provokes a delayed
        change_frame_size in the middle of adjust_frame_size.  */
-    /** 	|| (f->can_x_set_window_size && (f->new_height || f->new_width))) **/
+    /** 	|| (f->can_set_window_size && (f->new_height || f->new_width))) **/
     adjust_frame_size (f, width, height, 1, 0, Qx_set_frame_parameters);
 
   if ((!NILP (left) || !NILP (top))
@@ -4162,7 +4164,8 @@ x_set_frame_parameters (struct frame *f, Lisp_Object alist)
       f->win_gravity = NorthWestGravity;
 
       /* Actually set that position, and convert to absolute.  */
-      x_set_offset (f, leftpos, toppos, -1);
+      if (FRAME_TERMINAL (f)->set_frame_offset_hook)
+        FRAME_TERMINAL (f)->set_frame_offset_hook (f, leftpos, toppos, -1);
     }
 
   if (fullscreen_change)
@@ -4174,7 +4177,7 @@ x_set_frame_parameters (struct frame *f, Lisp_Object alist)
 
       store_frame_param (f, Qfullscreen, fullscreen);
       if (!EQ (fullscreen, old_value))
-	x_set_fullscreen (f, fullscreen, old_value);
+	gui_set_fullscreen (f, fullscreen, old_value);
     }
 
 
@@ -4188,14 +4191,14 @@ x_set_frame_parameters (struct frame *f, Lisp_Object alist)
 }
 
 
-/* Insert a description of internally-recorded parameters of frame X
+/* Insert a description of internally-recorded parameters of frame F
    into the parameter alist *ALISTPTR that is to be given to the user.
    Only parameters that are specific to the X window system
    and whose values are not correctly recorded in the frame's
    param_alist need to be considered here.  */
 
 void
-x_report_frame_params (struct frame *f, Lisp_Object *alistptr)
+gui_report_frame_params (struct frame *f, Lisp_Object *alistptr)
 {
   Lisp_Object tem;
   uprintmax_t w;
@@ -4240,11 +4243,11 @@ x_report_frame_params (struct frame *f, Lisp_Object *alistptr)
 		   /* nil means "use default height"
 		      for non-toolkit scroll bar.  */
 		   : Qnil));
-  /* FRAME_X_WINDOW is not guaranteed to return an integer.  E.g., on
-     MS-Windows it returns a value whose type is HANDLE, which is
-     actually a pointer.  Explicit casting avoids compiler
+  /* FRAME_NATIVE_WINDOW is not guaranteed to return an integer.
+     E.g., on MS-Windows it returns a value whose type is HANDLE,
+     which is actually a pointer.  Explicit casting avoids compiler
      warnings.  */
-  w = (uintptr_t) FRAME_X_WINDOW (f);
+  w = (uintptr_t) FRAME_NATIVE_WINDOW (f);
   store_in_alist (alistptr, Qwindow_id,
 		  make_formatted_string (buf, "%"pMu, w));
 #ifdef HAVE_X_WINDOWS
@@ -4263,10 +4266,10 @@ x_report_frame_params (struct frame *f, Lisp_Object *alistptr)
   store_in_alist (alistptr, Qdisplay,
 		  XCAR (FRAME_DISPLAY_INFO (f)->name_list_element));
 
-  if (FRAME_X_OUTPUT (f)->parent_desc == FRAME_DISPLAY_INFO (f)->root_window)
+  if (FRAME_OUTPUT_DATA (f)->parent_desc == FRAME_DISPLAY_INFO (f)->root_window)
     tem = Qnil;
   else
-    tem = make_fixed_natnum ((uintptr_t) FRAME_X_OUTPUT (f)->parent_desc);
+    tem = make_fixed_natnum ((uintptr_t) FRAME_OUTPUT_DATA (f)->parent_desc);
   store_in_alist (alistptr, Qexplicit_name, (f->explicit_name ? Qt : Qnil));
   store_in_alist (alistptr, Qparent_id, tem);
   store_in_alist (alistptr, Qtool_bar_position, FRAME_TOOL_BAR_POSITION (f));
@@ -4277,7 +4280,7 @@ x_report_frame_params (struct frame *f, Lisp_Object *alistptr)
    the previous value of that parameter, NEW_VALUE is the new value. */
 
 void
-x_set_fullscreen (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+gui_set_fullscreen (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   if (NILP (new_value))
     f->want_fullscreen = FULLSCREEN_NONE;
@@ -4299,7 +4302,7 @@ x_set_fullscreen (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
    the previous value of that parameter, NEW_VALUE is the new value.  */
 
 void
-x_set_line_spacing (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+gui_set_line_spacing (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   if (NILP (new_value))
     f->extra_line_spacing = 0;
@@ -4325,7 +4328,7 @@ x_set_line_spacing (struct frame *f, Lisp_Object new_value, Lisp_Object old_valu
    the previous value of that parameter, NEW_VALUE is the new value.  */
 
 void
-x_set_screen_gamma (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+gui_set_screen_gamma (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   Lisp_Object bgcolor;
 
@@ -4355,7 +4358,7 @@ x_set_screen_gamma (struct frame *f, Lisp_Object new_value, Lisp_Object old_valu
 
 
 void
-x_set_font (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_font (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   Lisp_Object font_object;
   int fontset = -1;
@@ -4425,8 +4428,8 @@ x_set_font (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 	  /* SPEC might be nil because ASCII_FONT's name doesn't parse
 	     according to stupid XLFD rules, which, for example,
 	     disallow font names that include a dash followed by a
-	     number.  So in those cases we simply request x_new_font
-	     below to generate a new fontset.  */
+	     number.  So in those cases we simply call
+	     set_new_font_hook below to generate a new fontset.  */
 	  if (NILP (spec) || ! font_match_p (spec, font_object))
 	    fontset = -1;
 	}
@@ -4437,7 +4440,8 @@ x_set_font (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
   if (! NILP (Fequal (font_object, oldval)))
     return;
 
-  x_new_font (f, font_object, fontset);
+  if (FRAME_TERMINAL (f)->set_new_font_hook)
+    FRAME_TERMINAL (f)->set_new_font_hook (f, font_object, fontset);
   store_frame_param (f, Qfont, arg);
 #ifdef HAVE_X_WINDOWS
   store_frame_param (f, Qfont_parameter, font_param);
@@ -4469,7 +4473,7 @@ x_set_font (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 
 
 void
-x_set_font_backend (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+gui_set_font_backend (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   if (! NILP (new_value)
       && !CONSP (new_value))
@@ -4517,14 +4521,14 @@ x_set_font_backend (struct frame *f, Lisp_Object new_value, Lisp_Object old_valu
       Lisp_Object frame;
 
       XSETFRAME (frame, f);
-      x_set_font (f, Fframe_parameter (frame, Qfont), Qnil);
+      gui_set_font (f, Fframe_parameter (frame, Qfont), Qnil);
       face_change = true;
       windows_or_buffers_changed = 18;
     }
 }
 
 void
-x_set_left_fringe (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+gui_set_left_fringe (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   int unit = FRAME_COLUMN_WIDTH (f);
   int old_width = FRAME_LEFT_FRINGE_WIDTH (f);
@@ -4539,7 +4543,7 @@ x_set_left_fringe (struct frame *f, Lisp_Object new_value, Lisp_Object old_value
       f->fringe_cols /* Round up.  */
 	= (new_width + FRAME_RIGHT_FRINGE_WIDTH (f) + unit - 1) / unit;
 
-      if (FRAME_X_WINDOW (f) != 0)
+      if (FRAME_NATIVE_WINDOW (f) != 0)
 	adjust_frame_size (f, -1, -1, 3, 0, Qleft_fringe);
 
       SET_FRAME_GARBAGED (f);
@@ -4548,7 +4552,7 @@ x_set_left_fringe (struct frame *f, Lisp_Object new_value, Lisp_Object old_value
 
 
 void
-x_set_right_fringe (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+gui_set_right_fringe (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   int unit = FRAME_COLUMN_WIDTH (f);
   int old_width = FRAME_RIGHT_FRINGE_WIDTH (f);
@@ -4563,7 +4567,7 @@ x_set_right_fringe (struct frame *f, Lisp_Object new_value, Lisp_Object old_valu
       f->fringe_cols /* Round up.  */
 	= (new_width + FRAME_LEFT_FRINGE_WIDTH (f) + unit - 1) / unit;
 
-      if (FRAME_X_WINDOW (f) != 0)
+      if (FRAME_NATIVE_WINDOW (f) != 0)
 	adjust_frame_size (f, -1, -1, 3, 0, Qright_fringe);
 
       SET_FRAME_GARBAGED (f);
@@ -4572,21 +4576,21 @@ x_set_right_fringe (struct frame *f, Lisp_Object new_value, Lisp_Object old_valu
 
 
 void
-x_set_border_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_border_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   CHECK_TYPE_RANGED_INTEGER (int, arg);
 
   if (XFIXNUM (arg) == f->border_width)
     return;
 
-  if (FRAME_X_WINDOW (f) != 0)
+  if (FRAME_NATIVE_WINDOW (f) != 0)
     error ("Cannot change the border width of a frame");
 
   f->border_width = XFIXNUM (arg);
 }
 
 void
-x_set_right_divider_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_right_divider_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   int old = FRAME_RIGHT_DIVIDER_WIDTH (f);
   CHECK_TYPE_RANGED_INTEGER (int, arg);
@@ -4601,7 +4605,7 @@ x_set_right_divider_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 }
 
 void
-x_set_bottom_divider_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_bottom_divider_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   int old = FRAME_BOTTOM_DIVIDER_WIDTH (f);
   CHECK_TYPE_RANGED_INTEGER (int, arg);
@@ -4616,7 +4620,7 @@ x_set_bottom_divider_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval
 }
 
 void
-x_set_visibility (struct frame *f, Lisp_Object value, Lisp_Object oldval)
+gui_set_visibility (struct frame *f, Lisp_Object value, Lisp_Object oldval)
 {
   Lisp_Object frame;
   XSETFRAME (frame, f);
@@ -4630,25 +4634,25 @@ x_set_visibility (struct frame *f, Lisp_Object value, Lisp_Object oldval)
 }
 
 void
-x_set_autoraise (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_autoraise (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   f->auto_raise = !NILP (arg);
 }
 
 void
-x_set_autolower (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_autolower (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   f->auto_lower = !NILP (arg);
 }
 
 void
-x_set_unsplittable (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_unsplittable (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   f->no_split = !NILP (arg);
 }
 
 void
-x_set_vertical_scroll_bars (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_vertical_scroll_bars (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   if ((EQ (arg, Qleft) && FRAME_HAS_VERTICAL_SCROLL_BARS_ON_RIGHT (f))
       || (EQ (arg, Qright) && FRAME_HAS_VERTICAL_SCROLL_BARS_ON_LEFT (f))
@@ -4668,11 +4672,11 @@ x_set_vertical_scroll_bars (struct frame *f, Lisp_Object arg, Lisp_Object oldval
 	   ? vertical_scroll_bar_right
 	   : vertical_scroll_bar_none);
 
-      /* We set this parameter before creating the X window for the
-	 frame, so we can get the geometry right from the start.
+      /* We set this parameter before creating the native window for
+	 the frame, so we can get the geometry right from the start.
 	 However, if the window hasn't been created yet, we shouldn't
-	 call x_set_window_size.  */
-      if (FRAME_X_WINDOW (f))
+	 call set_window_size_hook.  */
+      if (FRAME_NATIVE_WINDOW (f))
 	adjust_frame_size (f, -1, -1, 3, 0, Qvertical_scroll_bars);
 
       SET_FRAME_GARBAGED (f);
@@ -4680,7 +4684,7 @@ x_set_vertical_scroll_bars (struct frame *f, Lisp_Object arg, Lisp_Object oldval
 }
 
 void
-x_set_horizontal_scroll_bars (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_horizontal_scroll_bars (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
 #if USE_HORIZONTAL_SCROLL_BARS
   if ((NILP (arg) && FRAME_HAS_HORIZONTAL_SCROLL_BARS (f))
@@ -4688,11 +4692,11 @@ x_set_horizontal_scroll_bars (struct frame *f, Lisp_Object arg, Lisp_Object oldv
     {
       f->horizontal_scroll_bars = NILP (arg) ? false : true;
 
-      /* We set this parameter before creating the X window for the
-	 frame, so we can get the geometry right from the start.
+      /* We set this parameter before creating the native window for
+	 the frame, so we can get the geometry right from the start.
 	 However, if the window hasn't been created yet, we shouldn't
-	 call x_set_window_size.  */
-      if (FRAME_X_WINDOW (f))
+	 call set_window_size_hook.  */
+      if (FRAME_NATIVE_WINDOW (f))
 	adjust_frame_size (f, -1, -1, 3, 0, Qhorizontal_scroll_bars);
 
       SET_FRAME_GARBAGED (f);
@@ -4701,7 +4705,7 @@ x_set_horizontal_scroll_bars (struct frame *f, Lisp_Object arg, Lisp_Object oldv
 }
 
 void
-x_set_scroll_bar_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_scroll_bar_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   int unit = FRAME_COLUMN_WIDTH (f);
 
@@ -4710,16 +4714,17 @@ x_set_scroll_bar_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
     {
       FRAME_CONFIG_SCROLL_BAR_WIDTH (f) = XFIXNAT (arg);
       FRAME_CONFIG_SCROLL_BAR_COLS (f) = (XFIXNAT (arg) + unit - 1) / unit;
-      if (FRAME_X_WINDOW (f))
+      if (FRAME_NATIVE_WINDOW (f))
 	adjust_frame_size (f, -1, -1, 3, 0, Qscroll_bar_width);
 
       SET_FRAME_GARBAGED (f);
     }
   else
     {
-      x_set_scroll_bar_default_width (f);
+      if (FRAME_TERMINAL (f)->set_scroll_bar_default_width_hook)
+        FRAME_TERMINAL (f)->set_scroll_bar_default_width_hook (f);
 
-      if (FRAME_X_WINDOW (f))
+      if (FRAME_NATIVE_WINDOW (f))
 	adjust_frame_size (f, -1, -1, 3, 0, Qscroll_bar_width);
 
       SET_FRAME_GARBAGED (f);
@@ -4730,7 +4735,7 @@ x_set_scroll_bar_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 }
 
 void
-x_set_scroll_bar_height (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_scroll_bar_height (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
 #if USE_HORIZONTAL_SCROLL_BARS
   int unit = FRAME_LINE_HEIGHT (f);
@@ -4740,16 +4745,17 @@ x_set_scroll_bar_height (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
     {
       FRAME_CONFIG_SCROLL_BAR_HEIGHT (f) = XFIXNAT (arg);
       FRAME_CONFIG_SCROLL_BAR_LINES (f) = (XFIXNAT (arg) + unit - 1) / unit;
-      if (FRAME_X_WINDOW (f))
+      if (FRAME_NATIVE_WINDOW (f))
 	adjust_frame_size (f, -1, -1, 3, 0, Qscroll_bar_height);
 
       SET_FRAME_GARBAGED (f);
     }
   else
     {
-      x_set_scroll_bar_default_height (f);
+      if (FRAME_TERMINAL (f)->set_scroll_bar_default_height_hook)
+        FRAME_TERMINAL (f)->set_scroll_bar_default_height_hook (f);
 
-      if (FRAME_X_WINDOW (f))
+      if (FRAME_NATIVE_WINDOW (f))
 	adjust_frame_size (f, -1, -1, 3, 0, Qscroll_bar_height);
 
       SET_FRAME_GARBAGED (f);
@@ -4761,7 +4767,7 @@ x_set_scroll_bar_height (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 }
 
 void
-x_set_alpha (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+gui_set_alpha (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   double alpha = 1.0;
   double newval[2];
@@ -4802,25 +4808,24 @@ x_set_alpha (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
   for (i = 0; i < 2; i++)
     f->alpha[i] = newval[i];
 
-#if defined (HAVE_X_WINDOWS) || defined (HAVE_NTGUI) || defined (NS_IMPL_COCOA)
-  block_input ();
-  x_set_frame_alpha (f);
-  unblock_input ();
-#endif
-
-  return;
+  if (FRAME_TERMINAL (f)->set_frame_alpha_hook)
+    {
+      block_input ();
+      FRAME_TERMINAL (f)->set_frame_alpha_hook (f);
+      unblock_input ();
+    }
 }
 
 
 /**
- * x_set_no_special_glyphs:
+ * gui_set_no_special_glyphs:
  *
  * Set frame F's `no-special-glyphs' parameter which, if non-nil,
  * suppresses the display of truncation and continuation glyphs
  * outside fringes.
  */
 void
-x_set_no_special_glyphs (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+gui_set_no_special_glyphs (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   if (!EQ (new_value, old_value))
     FRAME_NO_SPECIAL_GLYPHS (f) = !NILP (new_value);
@@ -4832,7 +4837,8 @@ x_set_no_special_glyphs (struct frame *f, Lisp_Object new_value, Lisp_Object old
 /* Non-zero if mouse is grabbed on DPYINFO
    and we know the frame where it is.  */
 
-bool x_mouse_grabbed (Display_Info *dpyinfo)
+bool
+gui_mouse_grabbed (Display_Info *dpyinfo)
 {
   return (dpyinfo->grabbed
 	  && dpyinfo->last_mouse_frame
@@ -4843,7 +4849,7 @@ bool x_mouse_grabbed (Display_Info *dpyinfo)
    on DPYINFO using saved frame and mouse position.  */
 
 void
-x_redo_mouse_highlight (Display_Info *dpyinfo)
+gui_redo_mouse_highlight (Display_Info *dpyinfo)
 {
   if (dpyinfo->last_mouse_motion_frame
       && FRAME_LIVE_P (dpyinfo->last_mouse_motion_frame))
@@ -4925,11 +4931,13 @@ validate_x_resource_name (void)
     }
 }
 
-/* Get specified attribute from resource database RDB.
+/* Get a GUI resource, like Fx_get_resource, but for display DPYINFO.
    See Fx_get_resource below for other parameters.  */
 
-static Lisp_Object
-xrdb_get_resource (XrmDatabase rdb, Lisp_Object attribute, Lisp_Object class, Lisp_Object component, Lisp_Object subclass)
+Lisp_Object
+gui_display_get_resource (Display_Info *dpyinfo, Lisp_Object attribute,
+                          Lisp_Object class, Lisp_Object component,
+                          Lisp_Object subclass)
 {
   CHECK_STRING (attribute);
   CHECK_STRING (class);
@@ -4982,7 +4990,10 @@ xrdb_get_resource (XrmDatabase rdb, Lisp_Object attribute, Lisp_Object class, Li
   *nz++ = '.';
   lispstpcpy (nz, attribute);
 
-  char *value = x_get_string_resource (rdb, name_key, class_key);
+  const char *value =
+    dpyinfo->terminal->get_string_resource_hook (&dpyinfo->rdb,
+                                                 name_key,
+                                                 class_key);
   SAFE_FREE();
 
   if (value && *value)
@@ -5007,28 +5018,17 @@ and the class is `Emacs.CLASS.SUBCLASS'.  */)
 {
   check_window_system (NULL);
 
-  return xrdb_get_resource (check_x_display_info (Qnil)->xrdb,
-			    attribute, class, component, subclass);
-}
-
-/* Get an X resource, like Fx_get_resource, but for display DPYINFO.  */
-
-Lisp_Object
-display_x_get_resource (Display_Info *dpyinfo, Lisp_Object attribute,
-			Lisp_Object class, Lisp_Object component,
-			Lisp_Object subclass)
-{
-  return xrdb_get_resource (dpyinfo->xrdb,
-			    attribute, class, component, subclass);
+  return gui_display_get_resource (check_x_display_info (Qnil),
+                                   attribute, class, component, subclass);
 }
 
 #if defined HAVE_X_WINDOWS && !defined USE_X_TOOLKIT && !defined USE_GTK
 /* Used when C code wants a resource value.  */
 /* Called from oldXMenu/Create.c.  */
-char *
+const char *
 x_get_resource_string (const char *attribute, const char *class)
 {
-  char *result;
+  const char *result;
   struct frame *sf = SELECTED_FRAME ();
   ptrdiff_t invocation_namelen = SBYTES (Vinvocation_name);
   USE_SAFE_ALLOCA;
@@ -5045,7 +5045,7 @@ x_get_resource_string (const char *attribute, const char *class)
   esprintf (name_key, "%s.%s", SSDATA (Vinvocation_name), attribute);
   sprintf (class_key, "%s.%s", EMACS_CLASS, class);
 
-  result = x_get_string_resource (FRAME_DISPLAY_INFO (sf)->xrdb,
+  result = x_get_string_resource (&FRAME_DISPLAY_INFO (sf)->rdb,
 				  name_key, class_key);
   SAFE_FREE ();
   return result;
@@ -5054,18 +5054,21 @@ x_get_resource_string (const char *attribute, const char *class)
 
 /* Return the value of parameter PARAM.
 
-   First search ALIST, then Vdefault_frame_alist, then the X defaults
-   database, using ATTRIBUTE as the attribute name and CLASS as its class.
+   First search ALIST, then Vdefault_frame_alist, then the GUI
+   resource database, using ATTRIBUTE as the attribute name and CLASS
+   as its class.
 
    Convert the resource to the type specified by desired_type.
 
    If no default is specified, return Qunbound.  If you call
-   x_get_arg, make sure you deal with Qunbound in a reasonable way,
-   and don't let it get stored in any Lisp-visible variables!  */
+   gui_display_get_arg, make sure you deal with Qunbound in a
+   reasonable way, and don't let it get stored in any Lisp-visible
+   variables!  */
 
 Lisp_Object
-x_get_arg (Display_Info *dpyinfo, Lisp_Object alist, Lisp_Object param,
-	   const char *attribute, const char *class, enum resource_types type)
+gui_display_get_arg (Display_Info *dpyinfo, Lisp_Object alist, Lisp_Object param,
+                     const char *attribute, const char *class,
+                     enum resource_types type)
 {
   Lisp_Object tem;
 
@@ -5095,7 +5098,7 @@ x_get_arg (Display_Info *dpyinfo, Lisp_Object alist, Lisp_Object param,
 	{
 	  AUTO_STRING (at, attribute);
 	  AUTO_STRING (cl, class);
-	  tem = display_x_get_resource (dpyinfo, at, cl, Qnil, Qnil);
+	  tem = gui_display_get_resource (dpyinfo, at, cl, Qnil, Qnil);
 
 	  if (NILP (tem))
 	    return Qunbound;
@@ -5162,26 +5165,26 @@ x_get_arg (Display_Info *dpyinfo, Lisp_Object alist, Lisp_Object param,
 }
 
 static Lisp_Object
-x_frame_get_arg (struct frame *f, Lisp_Object alist, Lisp_Object param,
-		 const char *attribute, const char *class,
-		 enum resource_types type)
+gui_frame_get_arg (struct frame *f, Lisp_Object alist, Lisp_Object param,
+                   const char *attribute, const char *class,
+                   enum resource_types type)
 {
-  return x_get_arg (FRAME_DISPLAY_INFO (f),
-		    alist, param, attribute, class, type);
+  return gui_display_get_arg (FRAME_DISPLAY_INFO (f),
+                              alist, param, attribute, class, type);
 }
 
-/* Like x_frame_get_arg, but also record the value in f->param_alist.  */
+/* Like gui_frame_get_arg, but also record the value in f->param_alist.  */
 
 Lisp_Object
-x_frame_get_and_record_arg (struct frame *f, Lisp_Object alist,
-			    Lisp_Object param,
-			    const char *attribute, const char *class,
-			    enum resource_types type)
+gui_frame_get_and_record_arg (struct frame *f, Lisp_Object alist,
+                              Lisp_Object param,
+                              const char *attribute, const char *class,
+                              enum resource_types type)
 {
   Lisp_Object value;
 
-  value = x_get_arg (FRAME_DISPLAY_INFO (f), alist, param,
-		     attribute, class, type);
+  value = gui_display_get_arg (FRAME_DISPLAY_INFO (f), alist, param,
+                               attribute, class, type);
   if (! NILP (value) && ! EQ (value, Qunbound))
     store_frame_param (f, param, value);
 
@@ -5196,17 +5199,17 @@ x_frame_get_and_record_arg (struct frame *f, Lisp_Object alist,
    If that is not found either, use the value DEFLT.  */
 
 Lisp_Object
-x_default_parameter (struct frame *f, Lisp_Object alist, Lisp_Object prop,
-		     Lisp_Object deflt, const char *xprop, const char *xclass,
-		     enum resource_types type)
+gui_default_parameter (struct frame *f, Lisp_Object alist, Lisp_Object prop,
+                       Lisp_Object deflt, const char *xprop, const char *xclass,
+                       enum resource_types type)
 {
   Lisp_Object tem;
 
-  tem = x_frame_get_arg (f, alist, prop, xprop, xclass, type);
+  tem = gui_frame_get_arg (f, alist, prop, xprop, xclass, type);
   if (EQ (tem, Qunbound))
     tem = deflt;
   AUTO_FRAME_ARG (arg, prop, tem);
-  x_set_frame_parameters (f, arg);
+  gui_set_frame_parameters (f, arg);
   return tem;
 }
 
@@ -5381,7 +5384,8 @@ On Nextstep, this just calls `ns-parse-geometry'.  */)
 #define DEFAULT_COLS 80
 
 long
-x_figure_window_size (struct frame *f, Lisp_Object parms, bool toolbar_p, int *x_width, int *x_height)
+gui_figure_window_size (struct frame *f, Lisp_Object parms, bool toolbar_p,
+                        int *x_width, int *x_height)
 {
   Lisp_Object height, width, user_size, top, left, user_position;
   long window_prompting = 0;
@@ -5435,8 +5439,8 @@ x_figure_window_size (struct frame *f, Lisp_Object parms, bool toolbar_p, int *x
      override what we specify below.  */
   f->new_width = f->new_height = 0;
 
-  height = x_get_arg (dpyinfo, parms, Qheight, 0, 0, RES_TYPE_NUMBER);
-  width = x_get_arg (dpyinfo, parms, Qwidth, 0, 0, RES_TYPE_NUMBER);
+  height = gui_display_get_arg (dpyinfo, parms, Qheight, 0, 0, RES_TYPE_NUMBER);
+  width = gui_display_get_arg (dpyinfo, parms, Qwidth, 0, 0, RES_TYPE_NUMBER);
   if (!EQ (width, Qunbound) || !EQ (height, Qunbound))
     {
       if (!EQ (width, Qunbound))
@@ -5513,16 +5517,18 @@ x_figure_window_size (struct frame *f, Lisp_Object parms, bool toolbar_p, int *x
 	    }
 	}
 
-      user_size = x_get_arg (dpyinfo, parms, Quser_size, 0, 0, RES_TYPE_NUMBER);
+      user_size = gui_display_get_arg (dpyinfo, parms, Quser_size, 0, 0,
+                                       RES_TYPE_NUMBER);
       if (!NILP (user_size) && !EQ (user_size, Qunbound))
 	window_prompting |= USSize;
       else
 	window_prompting |= PSize;
     }
 
-  top = x_get_arg (dpyinfo, parms, Qtop, 0, 0, RES_TYPE_NUMBER);
-  left = x_get_arg (dpyinfo, parms, Qleft, 0, 0, RES_TYPE_NUMBER);
-  user_position = x_get_arg (dpyinfo, parms, Quser_position, 0, 0, RES_TYPE_NUMBER);
+  top = gui_display_get_arg (dpyinfo, parms, Qtop, 0, 0, RES_TYPE_NUMBER);
+  left = gui_display_get_arg (dpyinfo, parms, Qleft, 0, 0, RES_TYPE_NUMBER);
+  user_position = gui_display_get_arg (dpyinfo, parms, Quser_position, 0, 0,
+                                       RES_TYPE_NUMBER);
   if (! EQ (top, Qunbound) || ! EQ (left, Qunbound))
     {
       if (EQ (top, Qminus))
diff --git a/src/frame.h b/src/frame.h
index ec8f61465f..fa45a32d6b 100644
--- a/src/frame.h
+++ b/src/frame.h
@@ -397,9 +397,9 @@ struct frame
      in pixels.  */
   bool_bf new_pixelwise : 1;
 
-  /* True means x_set_window_size requests can be processed for this
-     frame.  */
-  bool_bf can_x_set_window_size : 1;
+  /* True means set_window_size_hook requests can be processed for
+     this frame.  */
+  bool_bf can_set_window_size : 1;
 
   /* Set to true after this frame was made by `make-frame'.  */
   bool_bf after_make_frame : 1;
@@ -786,8 +786,8 @@ default_pixels_per_inch_y (void)
 #define FRAME_NS_P(f) ((f)->output_method == output_ns)
 #endif
 
-/* FRAME_WINDOW_P tests whether the frame is a window, and is
-   defined to be the predicate for the window system being used.  */
+/* FRAME_WINDOW_P tests whether the frame is a graphical window system
+   frame.  */
 
 #ifdef HAVE_X_WINDOWS
 #define FRAME_WINDOW_P(f) FRAME_X_P (f)
@@ -1262,7 +1262,7 @@ extern int frame_default_tool_bar_height;
 #ifdef HAVE_WINDOW_SYSTEM
 # define WINDOW_SYSTEM_RETURN
 #else
-# define WINDOW_SYSTEM_RETURN _Noreturn
+# define WINDOW_SYSTEM_RETURN _Noreturn ATTRIBUTE_COLD
 #endif
 
 extern WINDOW_SYSTEM_RETURN struct frame *
@@ -1480,7 +1480,7 @@ FRAME_BOTTOM_DIVIDER_WIDTH (struct frame *f)
     - FRAME_TOTAL_FRINGE_WIDTH (f)					\
     - FRAME_SCROLL_BAR_AREA_WIDTH (f)					\
     - 2 * FRAME_INTERNAL_BORDER_WIDTH (f))				\
-   / FRAME_COLUMN_WIDTH (f))						\
+   / FRAME_COLUMN_WIDTH (f))
 
 #define FRAME_PIXEL_HEIGHT_TO_TEXT_LINES(f, height)			\
   (((height)								\
@@ -1544,86 +1544,67 @@ FRAME_BOTTOM_DIVIDER_WIDTH (struct frame *f)
 /* The class of this X application.  */
 #define EMACS_CLASS "Emacs"
 
-extern void x_set_scroll_bar_default_width (struct frame *);
-extern void x_set_scroll_bar_default_height (struct frame *);
-extern void x_set_offset (struct frame *, int, int, int);
-extern void x_wm_set_size_hint (struct frame *f, long flags, bool user_position);
-extern Lisp_Object x_new_font (struct frame *, Lisp_Object, int);
-extern void x_set_frame_parameters (struct frame *, Lisp_Object);
-extern void x_set_fullscreen (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_line_spacing (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_screen_gamma (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_font (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_font_backend (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_left_fringe (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_right_fringe (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_border_width (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_right_divider_width (struct frame *, Lisp_Object,
-				       Lisp_Object);
-extern void x_set_bottom_divider_width (struct frame *, Lisp_Object,
-					Lisp_Object);
-extern void x_set_visibility (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_autoraise (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_autolower (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_unsplittable (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_vertical_scroll_bars (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_horizontal_scroll_bars (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_scroll_bar_width (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_scroll_bar_height (struct frame *, Lisp_Object, Lisp_Object);
-
-extern long x_figure_window_size (struct frame *, Lisp_Object, bool, int *, int *);
-
-extern void x_set_alpha (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_no_special_glyphs (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_frame_parameters (struct frame *, Lisp_Object);
+extern void gui_set_fullscreen (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_line_spacing (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_screen_gamma (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_font (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_font_backend (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_left_fringe (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_right_fringe (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_border_width (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_right_divider_width (struct frame *, Lisp_Object,
+                                         Lisp_Object);
+extern void gui_set_bottom_divider_width (struct frame *, Lisp_Object,
+                                          Lisp_Object);
+extern void gui_set_visibility (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_autoraise (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_autolower (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_unsplittable (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_vertical_scroll_bars (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_horizontal_scroll_bars (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_scroll_bar_width (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_scroll_bar_height (struct frame *, Lisp_Object, Lisp_Object);
+
+extern long gui_figure_window_size (struct frame *, Lisp_Object, bool, int *, int *);
+
+extern void gui_set_alpha (struct frame *, Lisp_Object, Lisp_Object);
+extern void gui_set_no_special_glyphs (struct frame *, Lisp_Object, Lisp_Object);
 
 extern void validate_x_resource_name (void);
 
-extern Lisp_Object display_x_get_resource (Display_Info *,
-					   Lisp_Object attribute,
-					   Lisp_Object class,
-					   Lisp_Object component,
-					   Lisp_Object subclass);
+extern Lisp_Object gui_display_get_resource (Display_Info *,
+                                             Lisp_Object attribute,
+                                             Lisp_Object class,
+                                             Lisp_Object component,
+                                             Lisp_Object subclass);
 
 extern void set_frame_menubar (struct frame *f, bool first_time, bool deep_p);
-extern void x_set_window_size (struct frame *f, bool change_gravity,
-			       int width, int height, bool pixelwise);
-extern Lisp_Object x_get_focus_frame (struct frame *);
 extern void frame_set_mouse_pixel_position (struct frame *f, int pix_x, int pix_y);
-extern void x_make_frame_visible (struct frame *f);
-extern void x_make_frame_invisible (struct frame *f);
-extern void x_iconify_frame (struct frame *f);
-extern void x_set_frame_alpha (struct frame *f);
-extern void x_activate_menubar (struct frame *);
-extern void x_real_positions (struct frame *, int *, int *);
 extern void free_frame_menubar (struct frame *);
-extern void x_free_frame_resources (struct frame *);
 extern bool frame_ancestor_p (struct frame *af, struct frame *df);
 extern enum internal_border_part frame_internal_border_part (struct frame *f, int x, int y);
 
 #if defined HAVE_X_WINDOWS
 extern void x_wm_set_icon_position (struct frame *, int, int);
 #if !defined USE_X_TOOLKIT
-extern char *x_get_resource_string (const char *, const char *);
+extern const char *x_get_resource_string (const char *, const char *);
 #endif
 extern void x_sync (struct frame *);
 #endif /* HAVE_X_WINDOWS */
 
-extern void x_query_colors (struct frame *f, XColor *, int);
-extern void x_focus_frame (struct frame *, bool);
-
 #ifndef HAVE_NS
 
-extern bool x_bitmap_icon (struct frame *, Lisp_Object);
-
 /* Set F's bitmap icon, if specified among F's parameters.  */
 
 INLINE void
-x_set_bitmap_icon (struct frame *f)
+gui_set_bitmap_icon (struct frame *f)
 {
   Lisp_Object obj = assq_no_quit (Qicon_type, f->param_alist);
 
-  if (CONSP (obj) && !NILP (XCDR (obj)))
-    x_bitmap_icon (f, XCDR (obj));
+  if (CONSP (obj) && !NILP (XCDR (obj))
+      && FRAME_TERMINAL (f)->set_bitmap_icon_hook)
+    FRAME_TERMINAL (f)->set_bitmap_icon_hook (f, XCDR (obj));
 }
 
 #endif /* !HAVE_NS */
@@ -1645,7 +1626,7 @@ flush_frame (struct frame *f)
 #ifdef HAVE_WINDOW_SYSTEM
 
 struct MonitorInfo {
-  XRectangle geom, work;
+  Emacs_Rectangle geom, work;
   int mm_width, mm_height;
   char *name;
 };
diff --git a/src/ftcrfont.c b/src/ftcrfont.c
index 3a98e78d63..9686cec0e8 100644
--- a/src/ftcrfont.c
+++ b/src/ftcrfont.c
@@ -19,11 +19,13 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include <config.h>
 #include <stdio.h>
+#include <math.h>
 #include <cairo-ft.h>
 
 #include "lisp.h"
 #include "xterm.h"
 #include "blockinput.h"
+#include "composite.h"
 #include "font.h"
 #include "ftfont.h"
 #include "pdumper.h"
@@ -73,7 +75,18 @@ ftcrfont_glyph_extents (struct font *font,
   cache = ftcrfont_info->metrics[row] + col;
 
   if (METRICS_STATUS (cache) == METRICS_INVALID)
-    ftfont_text_extents (font, &glyph, 1, cache);
+    {
+      cairo_glyph_t cr_glyph = {.index = glyph};
+      cairo_text_extents_t extents;
+
+      cairo_scaled_font_glyph_extents (ftcrfont_info->cr_scaled_font,
+				       &cr_glyph, 1, &extents);
+      cache->lbearing = floor (extents.x_bearing);
+      cache->rbearing = ceil (extents.width + extents.x_bearing);
+      cache->width = lround (extents.x_advance);
+      cache->ascent = ceil (- extents.y_bearing);
+      cache->descent = ceil (extents.height + extents.y_bearing);
+    }
 
   if (metrics)
     *metrics = *cache;
@@ -104,34 +117,159 @@ ftcrfont_match (struct frame *f, Lisp_Object spec)
 static Lisp_Object
 ftcrfont_open (struct frame *f, Lisp_Object entity, int pixel_size)
 {
-  Lisp_Object font_object;
-  struct font *font;
+  FcResult result;
+  Lisp_Object val, filename, font_object;
+  FcPattern *pat, *match;
   struct font_info *ftcrfont_info;
+  struct font *font;
+  double size = 0;
+  cairo_font_face_t *font_face;
+  cairo_font_extents_t extents;
   FT_Face ft_face;
-  FT_UInt size;
+  FcMatrix *matrix;
 
-  block_input ();
+  val = assq_no_quit (QCfont_entity, AREF (entity, FONT_EXTRA_INDEX));
+  if (! CONSP (val))
+    return Qnil;
+  val = XCDR (val);
+  filename = XCAR (val);
   size = XFIXNUM (AREF (entity, FONT_SIZE_INDEX));
   if (size == 0)
     size = pixel_size;
+
+  block_input ();
+
+  pat = ftfont_entity_pattern (entity, pixel_size);
+  FcConfigSubstitute (NULL, pat, FcMatchPattern);
+  FcDefaultSubstitute (pat);
+  match = FcFontMatch (NULL, pat, &result);
+  ftfont_fix_match (pat, match);
+
+  FcPatternDestroy (pat);
+  font_face = cairo_ft_font_face_create_for_pattern (match);
+  if (!font_face)
+    {
+      unblock_input ();
+      FcPatternDestroy (match);
+      return Qnil;
+    }
+  cairo_matrix_t font_matrix, ctm;
+  cairo_matrix_init_scale (&font_matrix, pixel_size, pixel_size);
+  cairo_matrix_init_identity (&ctm);
+  cairo_font_options_t *options = cairo_font_options_create ();
+  cairo_scaled_font_t *scaled_font
+    = cairo_scaled_font_create (font_face, &font_matrix, &ctm, options);
+  cairo_font_face_destroy (font_face);
+  cairo_font_options_destroy (options);
+  unblock_input ();
+
   font_object = font_build_object (VECSIZE (struct font_info),
 				   Qftcr, entity, size);
-  font_object = ftfont_open2 (f, entity, pixel_size, font_object);
-  if (NILP (font_object)) return Qnil;
-
+  ASET (font_object, FONT_FILE_INDEX, filename);
   font = XFONT_OBJECT (font_object);
+  font->pixel_size = size;
   font->driver = &ftcrfont_driver;
+  font->encoding_charset = font->repertory_charset = -1;
+
   ftcrfont_info = (struct font_info *) font;
-  ft_face = ftcrfont_info->ft_size->face;
-  FT_New_Size (ft_face, &ftcrfont_info->ft_size_draw);
-  FT_Activate_Size (ftcrfont_info->ft_size_draw);
-  FT_Set_Pixel_Sizes (ft_face, 0, font->pixel_size);
-  ftcrfont_info->cr_font_face =
-    cairo_ft_font_face_create_for_ft_face (ft_face, 0);
+  ftcrfont_info->cr_scaled_font = scaled_font;
+
+  /* This means that there's no need of transformation.  */
+  ftcrfont_info->matrix.xx = 0;
+  if (FcPatternGetMatrix (match, FC_MATRIX, 0, &matrix) == FcResultMatch)
+    {
+      ftcrfont_info->matrix.xx = 0x10000L * matrix->xx;
+      ftcrfont_info->matrix.yy = 0x10000L * matrix->yy;
+      ftcrfont_info->matrix.xy = 0x10000L * matrix->xy;
+      ftcrfont_info->matrix.yx = 0x10000L * matrix->yx;
+    }
+
   ftcrfont_info->metrics = NULL;
   ftcrfont_info->metrics_nrows = 0;
+
+  block_input ();
+  cairo_glyph_t stack_glyph;
+  int n = 0;
+  font->min_width = font->average_width = font->space_width = 0;
+  for (char c = 32; c < 127; c++)
+    {
+      cairo_glyph_t *glyphs = &stack_glyph;
+      int num_glyphs = 1;
+      cairo_status_t status =
+	cairo_scaled_font_text_to_glyphs (ftcrfont_info->cr_scaled_font,
+					  0, 0, &c, 1, &glyphs, &num_glyphs,
+					  NULL, NULL, NULL);
+
+      if (status == CAIRO_STATUS_SUCCESS)
+	{
+	  if (glyphs != &stack_glyph)
+	    cairo_glyph_free (glyphs);
+	  else if (stack_glyph.index)
+	    {
+	      int this_width = ftcrfont_glyph_extents (font, stack_glyph.index,
+						       NULL);
+
+	      if (this_width > 0
+		  && (! font->min_width
+		      || font->min_width > this_width))
+		font->min_width = this_width;
+	      if (c == 32)
+		font->space_width = this_width;
+	      font->average_width += this_width;
+	      n++;
+	    }
+	}
+    }
+  if (n > 0)
+    font->average_width /= n;
+
+  cairo_scaled_font_extents (ftcrfont_info->cr_scaled_font, &extents);
+  font->ascent = lround (extents.ascent);
+  val = assq_no_quit (QCminspace, AREF (entity, FONT_EXTRA_INDEX));
+  if (!(CONSP (val) && NILP (XCDR (val))))
+    {
+      font->descent = lround (extents.descent);
+      font->height = font->ascent + font->descent;
+    }
+  else
+    {
+      font->height = lround (extents.height);
+      font->descent = font->height - font->ascent;
+    }
+
+  ft_face = cairo_ft_scaled_font_lock_face (scaled_font);
+  if (XFIXNUM (AREF (entity, FONT_SIZE_INDEX)) == 0)
+    {
+      int upEM = ft_face->units_per_EM;
+
+      font->underline_position = -ft_face->underline_position * size / upEM;
+      font->underline_thickness = ft_face->underline_thickness * size / upEM;
+      if (font->underline_thickness > 2)
+	font->underline_position -= font->underline_thickness / 2;
+    }
+  else
+    {
+      font->underline_position = -1;
+      font->underline_thickness = 0;
+    }
+#ifdef HAVE_LIBOTF
+  ftcrfont_info->maybe_otf = (ft_face->face_flags & FT_FACE_FLAG_SFNT) != 0;
+  ftcrfont_info->otf = NULL;
+#endif	/* HAVE_LIBOTF */
+  if (ft_face->units_per_EM)
+    ftcrfont_info->bitmap_position_unit = 0;
+  else
+    ftcrfont_info->bitmap_position_unit = (extents.height
+					   / ft_face->size->metrics.height);
+  cairo_ft_scaled_font_unlock_face (scaled_font);
+  ftcrfont_info->ft_size = NULL;
   unblock_input ();
 
+  font->baseline_offset = 0;
+  font->relative_compose = 0;
+  font->default_ascent = 0;
+  font->vertical_centering = false;
+
   return font_object;
 }
 
@@ -142,24 +280,63 @@ ftcrfont_close (struct font *font)
     return;
 
   struct font_info *ftcrfont_info = (struct font_info *) font;
-  int i;
 
   block_input ();
-  for (i = 0; i < ftcrfont_info->metrics_nrows; i++)
+#ifdef HAVE_LIBOTF
+  if (ftcrfont_info->otf)
+    {
+      OTF_close (ftcrfont_info->otf);
+      ftcrfont_info->otf = NULL;
+    }
+#endif
+  for (int i = 0; i < ftcrfont_info->metrics_nrows; i++)
     if (ftcrfont_info->metrics[i])
       xfree (ftcrfont_info->metrics[i]);
   if (ftcrfont_info->metrics)
     xfree (ftcrfont_info->metrics);
-  FT_Done_Size (ftcrfont_info->ft_size_draw);
-  cairo_font_face_destroy (ftcrfont_info->cr_font_face);
+  cairo_scaled_font_destroy (ftcrfont_info->cr_scaled_font);
   unblock_input ();
+}
+
+static int
+ftcrfont_has_char (Lisp_Object font, int c)
+{
+  if (FONT_ENTITY_P (font))
+    return ftfont_has_char (font, c);
+
+  return -1;
+}
+
+static unsigned
+ftcrfont_encode_char (struct font *font, int c)
+{
+  struct font_info *ftcrfont_info = (struct font_info *) font;
+  unsigned code = FONT_INVALID_CODE;
+  unsigned char utf8[MAX_MULTIBYTE_LENGTH];
+  unsigned char *p = utf8;
+  cairo_glyph_t stack_glyph;
+  cairo_glyph_t *glyphs = &stack_glyph;
+  int num_glyphs = 1;
+
+  CHAR_STRING_ADVANCE (c, p);
+  if (cairo_scaled_font_text_to_glyphs (ftcrfont_info->cr_scaled_font, 0, 0,
+					(char *) utf8, p - utf8,
+					&glyphs, &num_glyphs,
+					NULL, NULL, NULL)
+      == CAIRO_STATUS_SUCCESS)
+    {
+      if (glyphs != &stack_glyph)
+	cairo_glyph_free (glyphs);
+      else if (stack_glyph.index)
+	code = stack_glyph.index;
+    }
 
-  ftfont_close (font);
+  return code;
 }
 
 static void
 ftcrfont_text_extents (struct font *font,
-                       unsigned *code,
+                       const unsigned *code,
                        int nglyphs,
                        struct font_metrics *metrics)
 {
@@ -191,6 +368,102 @@ ftcrfont_text_extents (struct font *font,
     metrics->width = width;
 }
 
+static int
+ftcrfont_get_bitmap (struct font *font, unsigned int code,
+		     struct font_bitmap *bitmap, int bits_per_pixel)
+{
+  struct font_info *ftcrfont_info = (struct font_info *) font;
+
+  if (ftcrfont_info->bitmap_position_unit)
+    return -1;
+
+  cairo_scaled_font_t *scaled_font = ftcrfont_info->cr_scaled_font;
+  FT_Face ft_face = cairo_ft_scaled_font_lock_face (scaled_font);
+
+  ftcrfont_info->ft_size = ft_face->size;
+  int result = ftfont_get_bitmap (font, code, bitmap, bits_per_pixel);
+  cairo_ft_scaled_font_unlock_face (scaled_font);
+  ftcrfont_info->ft_size = NULL;
+
+  return result;
+}
+
+static int
+ftcrfont_anchor_point (struct font *font, unsigned int code, int idx,
+		       int *x, int *y)
+{
+  struct font_info *ftcrfont_info = (struct font_info *) font;
+
+  if (ftcrfont_info->bitmap_position_unit)
+    return -1;
+
+  cairo_scaled_font_t *scaled_font = ftcrfont_info->cr_scaled_font;
+  FT_Face ft_face = cairo_ft_scaled_font_lock_face (scaled_font);
+
+  ftcrfont_info->ft_size = ft_face->size;
+  int result = ftfont_anchor_point (font, code, idx, x, y);
+  cairo_ft_scaled_font_unlock_face (scaled_font);
+  ftcrfont_info->ft_size = NULL;
+
+  return result;
+}
+
+#ifdef HAVE_LIBOTF
+static Lisp_Object
+ftcrfont_otf_capability (struct font *font)
+{
+  struct font_info *ftcrfont_info = (struct font_info *) font;
+  cairo_scaled_font_t *scaled_font = ftcrfont_info->cr_scaled_font;
+  FT_Face ft_face = cairo_ft_scaled_font_lock_face (scaled_font);
+
+  ftcrfont_info->ft_size = ft_face->size;
+  Lisp_Object result = ftfont_otf_capability (font);
+  cairo_ft_scaled_font_unlock_face (scaled_font);
+  ftcrfont_info->ft_size = NULL;
+
+  return result;
+}
+#endif
+
+#if defined HAVE_M17N_FLT && defined HAVE_LIBOTF
+static Lisp_Object
+ftcrfont_shape (Lisp_Object lgstring)
+{
+  struct font *font = CHECK_FONT_GET_OBJECT (LGSTRING_FONT (lgstring));
+  struct font_info *ftcrfont_info = (struct font_info *) font;
+
+  if (ftcrfont_info->bitmap_position_unit)
+    return make_fixnum (0);
+
+  cairo_scaled_font_t *scaled_font = ftcrfont_info->cr_scaled_font;
+  FT_Face ft_face = cairo_ft_scaled_font_lock_face (scaled_font);
+
+  ftcrfont_info->ft_size = ft_face->size;
+  Lisp_Object result = ftfont_shape (lgstring);
+  cairo_ft_scaled_font_unlock_face (scaled_font);
+  ftcrfont_info->ft_size = NULL;
+
+  return result;
+}
+#endif
+
+#ifdef HAVE_OTF_GET_VARIATION_GLYPHS
+static int
+ftcrfont_variation_glyphs (struct font *font, int c, unsigned variations[256])
+{
+  struct font_info *ftcrfont_info = (struct font_info *) font;
+  cairo_scaled_font_t *scaled_font = ftcrfont_info->cr_scaled_font;
+  FT_Face ft_face = cairo_ft_scaled_font_lock_face (scaled_font);
+
+  ftcrfont_info->ft_size = ft_face->size;
+  int result = ftfont_variation_glyphs (font, c, variations);
+  cairo_ft_scaled_font_unlock_face (scaled_font);
+  ftcrfont_info->ft_size = NULL;
+
+  return result;
+}
+#endif	/* HAVE_OTF_GET_VARIATION_GLYPHS */
+
 static int
 ftcrfont_draw (struct glyph_string *s,
                int from, int to, int x, int y, bool with_background)
@@ -200,8 +473,6 @@ ftcrfont_draw (struct glyph_string *s,
   struct font_info *ftcrfont_info = (struct font_info *) s->font;
   cairo_t *cr;
   cairo_glyph_t *glyphs;
-  cairo_surface_t *surface;
-  cairo_surface_type_t surface_type;
   int len = to - from;
   int i;
 
@@ -220,31 +491,17 @@ ftcrfont_draw (struct glyph_string *s,
   glyphs = alloca (sizeof (cairo_glyph_t) * len);
   for (i = 0; i < len; i++)
     {
-      unsigned code = ((XCHAR2B_BYTE1 (s->char2b + from + i) << 8)
-		       | XCHAR2B_BYTE2 (s->char2b + from + i));
-
-      glyphs[i].index = code;
+      glyphs[i].index = s->char2b[from + i];
       glyphs[i].x = x;
       glyphs[i].y = y;
-      x += (s->padding_p ? 1 : ftcrfont_glyph_extents (s->font, code, NULL));
+      x += (s->padding_p ? 1 : ftcrfont_glyph_extents (s->font,
+                                                       glyphs[i].index,
+                                                       NULL));
     }
 
   x_set_cr_source_with_gc_foreground (f, s->gc);
-  cairo_set_font_face (cr, ftcrfont_info->cr_font_face);
-  cairo_set_font_size (cr, s->font->pixel_size);
-  /* cairo_set_font_matrix */
-  /* cairo_set_font_options */
-
-  FT_Activate_Size (ftcrfont_info->ft_size_draw);
+  cairo_set_scaled_font (cr, ftcrfont_info->cr_scaled_font);
   cairo_show_glyphs (cr, glyphs, len);
-  surface = cairo_get_target (cr);
-  /* XXX: It used to be necessary to flush when exporting.  It might
-     be the case that this is no longer necessary.  */
-  surface_type = cairo_surface_get_type (surface);
-  if (surface_type != CAIRO_SURFACE_TYPE_XLIB
-      && (surface_type != CAIRO_SURFACE_TYPE_IMAGE
-	  || cairo_image_surface_get_format (surface) != CAIRO_FORMAT_ARGB32))
-    cairo_surface_flush (surface);
 
   x_end_cr_clip (f);
 
@@ -266,20 +523,20 @@ struct font_driver const ftcrfont_driver =
   .list_family = ftfont_list_family,
   .open = ftcrfont_open,
   .close = ftcrfont_close,
-  .has_char = ftfont_has_char,
-  .encode_char = ftfont_encode_char,
+  .has_char = ftcrfont_has_char,
+  .encode_char = ftcrfont_encode_char,
   .text_extents = ftcrfont_text_extents,
   .draw = ftcrfont_draw,
-  .get_bitmap = ftfont_get_bitmap,
-  .anchor_point = ftfont_anchor_point,
+  .get_bitmap = ftcrfont_get_bitmap,
+  .anchor_point = ftcrfont_anchor_point,
 #ifdef HAVE_LIBOTF
-  .otf_capability = ftfont_otf_capability,
+  .otf_capability = ftcrfont_otf_capability,
 #endif
 #if defined HAVE_M17N_FLT && defined HAVE_LIBOTF
-  .shape = ftfont_shape,
+  .shape = ftcrfont_shape,
 #endif
 #ifdef HAVE_OTF_GET_VARIATION_GLYPHS
-  .get_variation_glyphs = ftfont_variation_glyphs,
+  .get_variation_glyphs = ftcrfont_variation_glyphs,
 #endif
   .filter_properties = ftfont_filter_properties,
   .combining_capability = ftfont_combining_capability,
diff --git a/src/ftfont.c b/src/ftfont.c
index 3e820f583f..d8b510d703 100644
--- a/src/ftfont.c
+++ b/src/ftfont.c
@@ -1079,12 +1079,159 @@ ftfont_list_family (struct frame *f)
   return list;
 }
 
+void
+ftfont_fix_match (FcPattern *pat, FcPattern *match)
+{
+  /*  These values are not used for matching (except antialias), but for
+      rendering, so make sure they are carried over to the match.
+      We also put antialias here because most fonts are antialiased, so
+      the match will have antialias true.  */
+
+  FcBool b = FcTrue;
+  int i;
+  double dpi;
+
+  FcPatternGetBool (pat, FC_ANTIALIAS, 0, &b);
+  if (! b)
+    {
+      FcPatternDel (match, FC_ANTIALIAS);
+      FcPatternAddBool (match, FC_ANTIALIAS, FcFalse);
+    }
+  FcPatternGetBool (pat, FC_HINTING, 0, &b);
+  if (! b)
+    {
+      FcPatternDel (match, FC_HINTING);
+      FcPatternAddBool (match, FC_HINTING, FcFalse);
+    }
+#ifndef FC_HINT_STYLE
+# define FC_HINT_STYLE "hintstyle"
+#endif
+  if (FcResultMatch == FcPatternGetInteger (pat, FC_HINT_STYLE, 0, &i))
+    {
+      FcPatternDel (match, FC_HINT_STYLE);
+      FcPatternAddInteger (match, FC_HINT_STYLE, i);
+    }
+#ifndef FC_LCD_FILTER
+  /* Older fontconfig versions don't have FC_LCD_FILTER. */
+#define FC_LCD_FILTER "lcdfilter"
+#endif
+  if (FcResultMatch == FcPatternGetInteger (pat, FC_LCD_FILTER, 0, &i))
+    {
+      FcPatternDel (match, FC_LCD_FILTER);
+      FcPatternAddInteger (match, FC_LCD_FILTER, i);
+    }
+  if (FcResultMatch == FcPatternGetInteger (pat, FC_RGBA, 0, &i))
+    {
+      FcPatternDel (match, FC_RGBA);
+      FcPatternAddInteger (match, FC_RGBA, i);
+    }
+  if (FcResultMatch == FcPatternGetDouble (pat, FC_DPI, 0, &dpi))
+    {
+      FcPatternDel (match, FC_DPI);
+      FcPatternAddDouble (match, FC_DPI, dpi);
+    }
+}
+
+void
+ftfont_add_rendering_parameters (FcPattern *pat, Lisp_Object entity)
+{
+  Lisp_Object tail;
+  int ival;
+
+  for (tail = AREF (entity, FONT_EXTRA_INDEX); CONSP (tail); tail = XCDR (tail))
+    {
+      Lisp_Object key = XCAR (XCAR (tail));
+      Lisp_Object val = XCDR (XCAR (tail));
+
+      if (EQ (key, QCantialias))
+          FcPatternAddBool (pat, FC_ANTIALIAS, NILP (val) ? FcFalse : FcTrue);
+      else if (EQ (key, QChinting))
+	FcPatternAddBool (pat, FC_HINTING, NILP (val) ? FcFalse : FcTrue);
+      else if (EQ (key, QCautohint))
+	FcPatternAddBool (pat, FC_AUTOHINT, NILP (val) ? FcFalse : FcTrue);
+      else if (EQ (key, QChintstyle))
+	{
+	  if (FIXNUMP (val))
+	    FcPatternAddInteger (pat, FC_HINT_STYLE, XFIXNUM (val));
+          else if (SYMBOLP (val)
+                   && FcNameConstant (SDATA (SYMBOL_NAME (val)), &ival))
+	    FcPatternAddInteger (pat, FC_HINT_STYLE, ival);
+	}
+      else if (EQ (key, QCrgba))
+	{
+	  if (FIXNUMP (val))
+	    FcPatternAddInteger (pat, FC_RGBA, XFIXNUM (val));
+          else if (SYMBOLP (val)
+                   && FcNameConstant (SDATA (SYMBOL_NAME (val)), &ival))
+	    FcPatternAddInteger (pat, FC_RGBA, ival);
+	}
+      else if (EQ (key, QClcdfilter))
+	{
+	  if (FIXNUMP (val))
+	    FcPatternAddInteger (pat, FC_LCD_FILTER, ival = XFIXNUM (val));
+          else if (SYMBOLP (val)
+                   && FcNameConstant (SDATA (SYMBOL_NAME (val)), &ival))
+	    FcPatternAddInteger (pat, FC_LCD_FILTER, ival);
+	}
+#ifdef FC_EMBOLDEN
+      else if (EQ (key, QCembolden))
+	FcPatternAddBool (pat, FC_EMBOLDEN, NILP (val) ? FcFalse : FcTrue);
+#endif
+    }
+}
+
+FcPattern *
+ftfont_entity_pattern (Lisp_Object entity, int pixel_size)
+{
+  Lisp_Object val, filename, idx;
+  FcPattern *pat;
+  int i;
+
+  val = assq_no_quit (QCfont_entity, AREF (entity, FONT_EXTRA_INDEX));
+  eassert (CONSP (val));
+  val = XCDR (val);
+  filename = XCAR (val);
+  idx = XCDR (val);
+  pat = FcPatternCreate ();
+  FcPatternAddInteger (pat, FC_WEIGHT, FONT_WEIGHT_NUMERIC (entity));
+  i = FONT_SLANT_NUMERIC (entity) - 100;
+  if (i < 0) i = 0;
+  FcPatternAddInteger (pat, FC_SLANT, i);
+  FcPatternAddInteger (pat, FC_WIDTH, FONT_WIDTH_NUMERIC (entity));
+  FcPatternAddDouble (pat, FC_PIXEL_SIZE, pixel_size);
+  val = AREF (entity, FONT_FAMILY_INDEX);
+  if (! NILP (val))
+    FcPatternAddString (pat, FC_FAMILY, (FcChar8 *) SDATA (SYMBOL_NAME (val)));
+  val = AREF (entity, FONT_FOUNDRY_INDEX);
+  if (! NILP (val))
+    FcPatternAddString (pat, FC_FOUNDRY, (FcChar8 *) SDATA (SYMBOL_NAME (val)));
+  val = AREF (entity, FONT_SPACING_INDEX);
+  if (! NILP (val))
+    FcPatternAddInteger (pat, FC_SPACING, XFIXNUM (val));
+  val = AREF (entity, FONT_DPI_INDEX);
+  if (! NILP (val))
+    {
+      double dbl = XFIXNUM (val);
+
+      FcPatternAddDouble (pat, FC_DPI, dbl);
+    }
+  val = AREF (entity, FONT_AVGWIDTH_INDEX);
+  if (FIXNUMP (val) && XFIXNUM (val) == 0)
+    FcPatternAddBool (pat, FC_SCALABLE, FcTrue);
+  /* This is necessary to identify the exact font (e.g. 10x20.pcf.gz
+     over 10x20-ISO8859-1.pcf.gz).  */
+  FcPatternAddCharSet (pat, FC_CHARSET, ftfont_get_fc_charset (entity));
+
+  ftfont_add_rendering_parameters (pat, entity);
+
+  FcPatternAddString (pat, FC_FILE, (FcChar8 *) SDATA (filename));
+  FcPatternAddInteger (pat, FC_INDEX, XFIXNUM (idx));
+
+  return pat;
+}
 
 Lisp_Object
-ftfont_open2 (struct frame *f,
-              Lisp_Object entity,
-              int pixel_size,
-              Lisp_Object font_object)
+ftfont_open (struct frame *f, Lisp_Object entity, int pixel_size)
 {
   struct font_info *ftfont_info;
   struct font *font;
@@ -1092,7 +1239,7 @@ ftfont_open2 (struct frame *f,
   FT_Face ft_face;
   FT_Size ft_size;
   FT_UInt size;
-  Lisp_Object val, filename, idx, cache;
+  Lisp_Object val, filename, idx, cache, font_object;
   bool scalable;
   int spacing;
   int i;
@@ -1107,7 +1254,6 @@ ftfont_open2 (struct frame *f,
     return Qnil;
   filename = XCAR (val);
   idx = XCDR (val);
-  val = XCDR (cache);
   cache_data = xmint_pointer (XCDR (cache));
   ft_face = cache_data->ft_face;
   if (cache_data->face_refcount > 0)
@@ -1135,6 +1281,8 @@ ftfont_open2 (struct frame *f,
     }
   cache_data->face_refcount++;
 
+  font_object = font_build_object (VECSIZE (struct font_info),
+				   Qfreetype, entity, size);
   ASET (font_object, FONT_FILE_INDEX, filename);
   font = XFONT_OBJECT (font_object);
   ftfont_info = (struct font_info *) font;
@@ -1150,20 +1298,38 @@ ftfont_open2 (struct frame *f,
   font->driver = &ftfont_driver;
   font->encoding_charset = font->repertory_charset = -1;
 
+  val = assq_no_quit (QCminspace, AREF (entity, FONT_EXTRA_INDEX));
+  bool no_leading_p = !(CONSP (val) && NILP (XCDR (val)));
   upEM = ft_face->units_per_EM;
   scalable = (FIXNUMP (AREF (entity, FONT_AVGWIDTH_INDEX))
 	      && XFIXNUM (AREF (entity, FONT_AVGWIDTH_INDEX)) == 0);
   if (scalable)
     {
       font->ascent = ft_face->ascender * size / upEM + 0.5;
-      font->descent = - ft_face->descender * size / upEM + 0.5;
-      font->height = ft_face->height * size / upEM + 0.5;
+      if (no_leading_p)
+	{
+	  font->descent = - ft_face->descender * size / upEM + 0.5;
+	  font->height = font->ascent + font->descent;
+	}
+      else
+	{
+	  font->height = ft_face->height * size / upEM + 0.5;
+	  font->descent = font->height - font->ascent;
+	}
     }
   else
     {
       font->ascent = ft_face->size->metrics.ascender >> 6;
-      font->descent = - ft_face->size->metrics.descender >> 6;
-      font->height = ft_face->size->metrics.height >> 6;
+      if (no_leading_p)
+	{
+	  font->descent = - ft_face->size->metrics.descender >> 6;
+	  font->height = font->ascent + font->descent;
+	}
+      else
+	{
+	  font->height = ft_face->size->metrics.height >> 6;
+	  font->descent = font->height - font->ascent;
+	}
     }
   if (FIXNUMP (AREF (entity, FONT_SPACING_INDEX)))
     spacing = XFIXNUM (AREF (entity, FONT_SPACING_INDEX));
@@ -1219,19 +1385,6 @@ ftfont_open2 (struct frame *f,
   return font_object;
 }
 
-Lisp_Object
-ftfont_open (struct frame *f, Lisp_Object entity, int pixel_size)
-{
-  Lisp_Object font_object;
-  FT_UInt size;
-  size = XFIXNUM (AREF (entity, FONT_SIZE_INDEX));
-  if (size == 0)
-    size = pixel_size;
-  font_object = font_build_object (VECSIZE (struct font_info),
-				   Qfreetype, entity, size);
-  return ftfont_open2 (f, entity, pixel_size, font_object);
-}
-
 void
 ftfont_close (struct font *font)
 {
@@ -1302,7 +1455,7 @@ ftfont_encode_char (struct font *font, int c)
 }
 
 void
-ftfont_text_extents (struct font *font, unsigned int *code,
+ftfont_text_extents (struct font *font, const unsigned int *code,
 		     int nglyphs, struct font_metrics *metrics)
 {
   struct font_info *ftfont_info = (struct font_info *) font;
@@ -2735,6 +2888,17 @@ syms_of_ftfont (void)
   DEFSYM (Qsans, "sans");
   DEFSYM (Qsans__serif, "sans serif");
 
+  /* The boolean-valued font property key specifying the use of leading.  */
+  DEFSYM (QCminspace, ":minspace");
+
+  /* Fontconfig's rendering parameters.  */
+  DEFSYM (QChinting, ":hinting");
+  DEFSYM (QCautohint, ":autohint");
+  DEFSYM (QChintstyle, ":hintstyle");
+  DEFSYM (QCrgba, ":rgba");
+  DEFSYM (QCembolden, ":embolden");
+  DEFSYM (QClcdfilter, ":lcdfilter");
+
   staticpro (&freetype_font_cache);
   freetype_font_cache = list1 (Qt);
 
diff --git a/src/ftfont.h b/src/ftfont.h
index b6b0c5ba47..7860469491 100644
--- a/src/ftfont.h
+++ b/src/ftfont.h
@@ -37,10 +37,9 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #endif	/* HAVE_LIBOTF */
 
 extern FcCharSet *ftfont_get_fc_charset (Lisp_Object);
-extern Lisp_Object ftfont_open2 (struct frame *f,
-                                 Lisp_Object entity,
-                                 int pixel_size,
-                                 Lisp_Object font_object);
+extern void ftfont_fix_match (FcPattern *, FcPattern *);
+extern void ftfont_add_rendering_parameters (FcPattern *, Lisp_Object);
+extern FcPattern *ftfont_entity_pattern (Lisp_Object, int);
 
 /* This struct is shared by the XFT, Freetype, and Cairo font
    backends.  Members up to and including 'matrix' are common, the
@@ -57,10 +56,11 @@ struct font_info
   FT_Matrix matrix;
 
 #ifdef USE_CAIRO
-  cairo_font_face_t *cr_font_face;
-  /* To prevent cairo from cluttering the activated FT_Size maintained
-     in ftfont.c, we activate this special FT_Size before drawing.  */
-  FT_Size ft_size_draw;
+  cairo_scaled_font_t *cr_scaled_font;
+  /* Scale factor from the bitmap strike metrics in 1/64 pixels, used
+     as the hb_position_t value in HarfBuzz, to those in (scaled)
+     pixels.  The value is 0 for scalable fonts.  */
+  double bitmap_position_unit;
   /* Font metrics cache.  */
   struct font_metrics **metrics;
   short metrics_nrows;
diff --git a/src/ftxfont.c b/src/ftxfont.c
index f9a69c3515..8bce7f10f1 100644
--- a/src/ftxfont.c
+++ b/src/ftxfont.c
@@ -252,7 +252,7 @@ ftxfont_draw (struct glyph_string *s, int from, int to, int x, int y,
   struct font *font = s->font;
   XPoint p[0x700];
   int n[7];
-  unsigned *code;
+  unsigned *code = s->char2b + from;
   int len = to - from;
   int i;
   GC *gcs;
@@ -260,14 +260,9 @@ ftxfont_draw (struct glyph_string *s, int from, int to, int x, int y,
 
   n[0] = n[1] = n[2] = n[3] = n[4] = n[5] = n[6] = 0;
 
-  USE_SAFE_ALLOCA;
-  SAFE_NALLOCA (code, 1, len);
   block_input ();
   if (with_background)
     ftxfont_draw_background (f, font, s->gc, x, y, s->width);
-  for (i = 0; i < len; i++)
-    code[i] = ((XCHAR2B_BYTE1 (s->char2b + from + i) << 8)
-	       | XCHAR2B_BYTE2 (s->char2b + from + i));
 
   if (face->gc == s->gc)
     {
@@ -312,7 +307,6 @@ ftxfont_draw (struct glyph_string *s, int from, int to, int x, int y,
     }
 
   unblock_input ();
-  SAFE_FREE ();
 
   return len;
 }
diff --git a/src/gfilenotify.c b/src/gfilenotify.c
index a9f33c9900..ddb19770c3 100644
--- a/src/gfilenotify.c
+++ b/src/gfilenotify.c
@@ -18,7 +18,6 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include <config.h>
 
-#ifdef HAVE_GFILENOTIFY
 #include <stdio.h>
 #include <gio/gio.h>
 #include "lisp.h"
@@ -333,7 +332,4 @@ syms_of_gfilenotify (void)
   staticpro (&watch_list);
 
   Fprovide (intern_c_string ("gfilenotify"), Qnil);
-
 }
-
-#endif /* HAVE_GFILENOTIFY  */
diff --git a/src/gmalloc.c b/src/gmalloc.c
index b6a96d5572..779cdb36d6 100644
--- a/src/gmalloc.c
+++ b/src/gmalloc.c
@@ -181,7 +181,7 @@ struct list
   };
 
 /* Free list headers for each fragment size.  */
-extern struct list _fraghead[];
+static struct list _fraghead[BLOCKLOG];
 
 /* List of blocks allocated with aligned_alloc and friends.  */
 struct alignlist
@@ -339,9 +339,6 @@ size_t _heapindex;
 /* Limit of valid info table indices.  */
 size_t _heaplimit;
 
-/* Free lists for each fragment size.  */
-struct list _fraghead[BLOCKLOG];
-
 /* Instrumentation.  */
 size_t _chunks_used;
 size_t _bytes_used;
@@ -351,10 +348,6 @@ size_t _bytes_free;
 /* Are you experienced?  */
 int __malloc_initialized;
 
-#else
-
-static struct list _fraghead[BLOCKLOG];
-
 #endif /* HYBRID_MALLOC */
 
 /* Number of extra blocks to get each time we ask for more core.
diff --git a/src/gtkutil.c b/src/gtkutil.c
index b130692c87..59e4328a6f 100644
--- a/src/gtkutil.c
+++ b/src/gtkutil.c
@@ -52,48 +52,19 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <X11/extensions/Xdbe.h>
 #endif
 
-#ifndef HAVE_GTK_WIDGET_SET_HAS_WINDOW
-#define gtk_widget_set_has_window(w, b) \
-  (gtk_fixed_set_has_window (GTK_FIXED (w), b))
-#endif
-#ifndef HAVE_GTK_DIALOG_GET_ACTION_AREA
-#define gtk_dialog_get_action_area(w) ((w)->action_area)
-#define gtk_dialog_get_content_area(w) ((w)->vbox)
-#endif
-#ifndef HAVE_GTK_WIDGET_GET_SENSITIVE
-#define gtk_widget_get_sensitive(w) (GTK_WIDGET_SENSITIVE (w))
-#endif
-#ifndef HAVE_GTK_ADJUSTMENT_GET_PAGE_SIZE
-#define gtk_adjustment_set_page_size(w, s) ((w)->page_size = (s))
-#define gtk_adjustment_set_page_increment(w, s) ((w)->page_increment = (s))
-#define gtk_adjustment_get_step_increment(w) ((w)->step_increment)
-#define gtk_adjustment_set_step_increment(w, s) ((w)->step_increment = (s))
-#endif
-#if GTK_CHECK_VERSION (2, 12, 0)
-#define remove_submenu(w) gtk_menu_item_set_submenu ((w), NULL)
+#ifdef HAVE_GTK3
+#define XG_TEXT_CANCEL "Cancel"
+#define XG_TEXT_OK     "OK"
+#define XG_TEXT_OPEN   "Open"
 #else
-#define remove_submenu(w) gtk_menu_item_remove_submenu ((w))
+#define XG_TEXT_CANCEL GTK_STOCK_CANCEL
+#define XG_TEXT_OK     GTK_STOCK_OK
+#define XG_TEXT_OPEN   GTK_STOCK_OPEN
 #endif
 
-#if ! GTK_CHECK_VERSION (2, 14, 0)
-#define gtk_adjustment_configure(adj, xvalue, xlower,            \
-                                 xupper, xstep_increment,        \
-                                 xpage_increment, xpagesize)     \
-  do {                                                           \
-    adj->lower = xlower;                                         \
-    adj->upper = xupper;                                         \
-    adj->page_size = xpagesize;                                  \
-    gtk_adjustment_set_value (adj, xvalue);                      \
-    adj->page_increment = xpage_increment;                       \
-    adj->step_increment = xstep_increment;                       \
-  } while (0)
-#endif /* < Gtk+ 2.14 */
+#ifndef HAVE_GTK3
 
 #ifdef HAVE_FREETYPE
-#if GTK_CHECK_VERSION (3, 2, 0)
-#define USE_NEW_GTK_FONT_CHOOSER 1
-#else
-#define USE_NEW_GTK_FONT_CHOOSER 0
 #define gtk_font_chooser_dialog_new(x, y) \
   gtk_font_selection_dialog_new (x)
 #undef GTK_FONT_CHOOSER
@@ -101,35 +72,15 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #define  gtk_font_chooser_set_font(x, y) \
   gtk_font_selection_dialog_set_font_name (x, y)
 #endif
-#endif /* HAVE_FREETYPE */
-
-#if GTK_CHECK_VERSION (3, 10, 0)
-#define XG_TEXT_CANCEL "Cancel"
-#define XG_TEXT_OK     "OK"
-#define XG_TEXT_OPEN   "Open"
-#else
-#define XG_TEXT_CANCEL GTK_STOCK_CANCEL
-#define XG_TEXT_OK     GTK_STOCK_OK
-#define XG_TEXT_OPEN   GTK_STOCK_OPEN
-#endif
 
-#ifndef HAVE_GTK3
-#ifdef USE_GTK_TOOLTIP
-#define gdk_window_get_screen(w) gdk_drawable_get_screen (w)
-#endif
 #define gdk_window_get_geometry(w, a, b, c, d) \
   gdk_window_get_geometry (w, a, b, c, d, 0)
-#define gdk_x11_window_lookup_for_display(d, w) \
-  gdk_xid_table_lookup_for_display (d, w)
 #define gtk_box_new(ori, spacing)                                       \
   ((ori) == GTK_ORIENTATION_HORIZONTAL                                  \
    ? gtk_hbox_new (FALSE, (spacing)) : gtk_vbox_new (FALSE, (spacing)))
 #define gtk_scrollbar_new(ori, spacing)                                 \
   ((ori) == GTK_ORIENTATION_HORIZONTAL                                  \
    ? gtk_hscrollbar_new ((spacing)) : gtk_vscrollbar_new ((spacing)))
-#ifndef GDK_KEY_g
-#define GDK_KEY_g GDK_g
-#endif
 #endif /* HAVE_GTK3 */
 
 #define XG_BIN_CHILD(x) gtk_bin_get_child (GTK_BIN (x))
@@ -227,7 +178,7 @@ xg_get_gdk_scale (void)
 int
 xg_get_scale (struct frame *f)
 {
-#if GTK_CHECK_VERSION (3, 10, 0)
+#ifdef HAVE_GTK3
   if (FRAME_GTK_WIDGET (f))
     return gtk_widget_get_scale_factor (FRAME_GTK_WIDGET (f));
 #endif
@@ -261,15 +212,7 @@ xg_display_close (Display *dpy)
       gdpy_def = gdpy_new;
     }
 
-#if GTK_CHECK_VERSION (2, 0, 0) && ! GTK_CHECK_VERSION (2, 10, 0)
-  /* GTK 2.2-2.8 has a bug that makes gdk_display_close crash
-     <https://gitlab.gnome.org/GNOME/gtk/issues/221>.  This way we
-     can continue running, but there will be memory leaks.  */
-  g_object_run_dispose (G_OBJECT (gdpy));
-#else
-  /* This seems to be fixed in GTK 2.10. */
   gdk_display_close (gdpy);
-#endif
 }
 
 
@@ -336,6 +279,56 @@ xg_get_pixbuf_from_pix_and_mask (struct frame *f,
   return icon_buf;
 }
 
+#if defined USE_CAIRO && !defined HAVE_GTK3
+static GdkPixbuf *
+xg_get_pixbuf_from_surface (cairo_surface_t *surface)
+{
+  int width = cairo_image_surface_get_width (surface);
+  int height = cairo_image_surface_get_height (surface);
+  GdkPixbuf *icon_buf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8,
+					width, height);
+  if (icon_buf)
+    {
+      guchar *pixels = gdk_pixbuf_get_pixels (icon_buf);
+      int rowstride = gdk_pixbuf_get_rowstride (icon_buf);
+      cairo_surface_t *icon_surface
+	= cairo_image_surface_create_for_data (pixels, CAIRO_FORMAT_ARGB32,
+					       width, height, rowstride);
+      cairo_t *cr = cairo_create (icon_surface);
+      cairo_surface_destroy (icon_surface);
+      cairo_set_source_surface (cr, surface, 0, 0);
+      cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
+      cairo_paint (cr);
+      cairo_destroy (cr);
+
+      for (int y = 0; y < height; y++)
+	{
+	  for (int x = 0; x < width; x++)
+	    {
+	      guint32 argb = ((guint32 *) pixels)[x];
+	      int alpha = argb >> 24;
+
+	      if (alpha == 0)
+		((guint32 *) pixels)[x] = 0;
+	      else
+		{
+		  int red = (argb >> 16) & 0xff, green = (argb >> 8) & 0xff;
+		  int blue = argb & 0xff;
+
+		  pixels[x * 4    ] = red   * 0xff / alpha;
+		  pixels[x * 4 + 1] = green * 0xff / alpha;
+		  pixels[x * 4 + 2] = blue  * 0xff / alpha;
+		  pixels[x * 4 + 3] = alpha;
+		}
+	    }
+	  pixels += rowstride;
+	}
+    }
+
+  return icon_buf;
+}
+#endif	/* USE_CAIRO && !HAVE_GTK3 */
+
 static Lisp_Object
 file_for_image (Lisp_Object image)
 {
@@ -368,7 +361,7 @@ xg_get_image_for_pixmap (struct frame *f,
                          GtkWidget *widget,
                          GtkImage *old_widget)
 {
-#if defined USE_CAIRO && GTK_CHECK_VERSION (3, 10, 0)
+#ifdef USE_CAIRO
   cairo_surface_t *surface;
 #else
   GdkPixbuf *icon_buf;
@@ -385,7 +378,7 @@ xg_get_image_for_pixmap (struct frame *f,
      In that case, use the pixmap already loaded.  */
 
   if (STRINGP (specified_file)
-      && STRINGP (file = x_find_image_file (specified_file)))
+      && STRINGP (file = image_find_image_file (specified_file)))
     {
       char *encoded_file = SSDATA (ENCODE_FILE (file));
       if (! old_widget)
@@ -400,15 +393,29 @@ xg_get_image_for_pixmap (struct frame *f,
      on a monochrome display, and sometimes bad on all displays with
      certain themes.  */
 
-#if defined USE_CAIRO && GTK_CHECK_VERSION (3, 10, 0)
+#ifdef USE_CAIRO
   surface = img->cr_data;
 
   if (surface)
     {
+#ifdef HAVE_GTK3
       if (! old_widget)
         old_widget = GTK_IMAGE (gtk_image_new_from_surface (surface));
       else
         gtk_image_set_from_surface (old_widget, surface);
+#else  /* !HAVE_GTK3 */
+      GdkPixbuf *icon_buf = xg_get_pixbuf_from_surface (surface);
+
+      if (icon_buf)
+	{
+	  if (! old_widget)
+	    old_widget = GTK_IMAGE (gtk_image_new_from_pixbuf (icon_buf));
+	  else
+	    gtk_image_set_from_pixbuf (old_widget, icon_buf);
+
+	  g_object_unref (G_OBJECT (icon_buf));
+	}
+#endif	/* !HAVE_GTK3 */
     }
 #else
   /* This is a workaround to make icons look good on pseudo color
@@ -577,7 +584,7 @@ get_utf8_string (const char *str)
 bool
 xg_check_special_colors (struct frame *f,
                          const char *color_name,
-                         XColor *color)
+                         Emacs_Color *color)
 {
   bool success_p = 0;
   bool get_bg = strcmp ("gtk_selection_bg_color", color_name) == 0;
@@ -643,8 +650,6 @@ xg_check_special_colors (struct frame *f,
    We use that to pop down the tooltip.  This happens if Gtk+ for some
    reason wants to change or hide the tooltip.  */
 
-#ifdef USE_GTK_TOOLTIP
-
 static void
 hierarchy_ch_cb (GtkWidget *widget,
                  GtkWidget *previous_toplevel,
@@ -711,8 +716,6 @@ qttip_cb (GtkWidget  *widget,
   return FALSE;
 }
 
-#endif /* USE_GTK_TOOLTIP */
-
 /* Prepare a tooltip to be shown, i.e. calculate WIDTH and HEIGHT.
    Return true if a system tooltip is available.  */
 
@@ -722,9 +725,6 @@ xg_prepare_tooltip (struct frame *f,
                     int *width,
                     int *height)
 {
-#ifndef USE_GTK_TOOLTIP
-  return 0;
-#else
   struct x_output *x = f->output_data.x;
   GtkWidget *widget;
   GdkWindow *gwin;
@@ -768,7 +768,6 @@ xg_prepare_tooltip (struct frame *f,
   unblock_input ();
 
   return TRUE;
-#endif /* USE_GTK_TOOLTIP */
 }
 
 /* Show the tooltip at ROOT_X and ROOT_Y.
@@ -777,7 +776,6 @@ xg_prepare_tooltip (struct frame *f,
 void
 xg_show_tooltip (struct frame *f, int root_x, int root_y)
 {
-#ifdef USE_GTK_TOOLTIP
   struct x_output *x = f->output_data.x;
   if (x->ttip_window)
     {
@@ -787,7 +785,6 @@ xg_show_tooltip (struct frame *f, int root_x, int root_y)
       gtk_widget_show (GTK_WIDGET (x->ttip_window));
       unblock_input ();
     }
-#endif
 }
 
 
@@ -797,7 +794,6 @@ xg_show_tooltip (struct frame *f, int root_x, int root_y)
 bool
 xg_hide_tooltip (struct frame *f)
 {
-#ifdef USE_GTK_TOOLTIP
   if (f->output_data.x->ttip_window)
     {
       GtkWindow *win = f->output_data.x->ttip_window;
@@ -816,7 +812,6 @@ xg_hide_tooltip (struct frame *f)
 
       return TRUE;
     }
-#endif
   return FALSE;
 }
 
@@ -935,7 +930,7 @@ xg_frame_resized (struct frame *f, int pixelwidth, int pixelheight)
       || pixelwidth != FRAME_PIXEL_WIDTH (f)
       || pixelheight != FRAME_PIXEL_HEIGHT (f))
     {
-      x_clear_under_internal_border (f);
+      FRAME_RIF (f)->clear_under_internal_border (f);
       change_frame_size (f, width, height, 0, 1, 0, 1);
       SET_FRAME_GARBAGED (f);
       cancel_mouse_face (f);
@@ -963,7 +958,7 @@ xg_frame_set_char_size (struct frame *f, int width, int height)
 		       &gwidth, &gheight);
 
   /* Do this before resize, as we don't know yet if we will be resized.  */
-  x_clear_under_internal_border (f);
+  FRAME_RIF (f)->clear_under_internal_border (f);
 
   totalheight /= xg_get_scale (f);
   totalwidth /= xg_get_scale (f);
@@ -1029,7 +1024,7 @@ xg_frame_set_char_size (struct frame *f, int width, int height)
 	/* Try to restore fullscreen state.  */
 	{
 	  store_frame_param (f, Qfullscreen, fullscreen);
-	  x_set_fullscreen (f, fullscreen, fullscreen);
+	  gui_set_fullscreen (f, fullscreen, fullscreen);
 	}
     }
   else
@@ -1147,8 +1142,8 @@ style_changed_cb (GObject *go,
               && FRAME_X_P (f)
               && FRAME_X_DISPLAY (f) == dpy)
             {
-              x_set_scroll_bar_default_width (f);
-              x_set_scroll_bar_default_height (f);
+              FRAME_TERMINAL (f)->set_scroll_bar_default_width_hook (f);
+              FRAME_TERMINAL (f)->set_scroll_bar_default_height_hook (f);
               xg_frame_set_char_size (f, FRAME_TEXT_WIDTH (f), FRAME_TEXT_HEIGHT (f));
             }
         }
@@ -1193,7 +1188,7 @@ xg_create_frame_widgets (struct frame *f)
      has backported it to Gtk+ 2.0 and they add the resize grip for
      Gtk+ 2.0 applications also.  But it has a bug that makes Emacs loop
      forever, so disable the grip.  */
-#if (! GTK_CHECK_VERSION (3, 0, 0) \
+#if (! defined HAVE_GTK3 \
      && defined HAVE_GTK_WINDOW_SET_HAS_RESIZE_GRIP)
   gtk_window_set_has_resize_grip (GTK_WINDOW (wtop), FALSE);
 #endif
@@ -1328,14 +1323,12 @@ xg_create_frame_widgets (struct frame *f)
 	gdk_window_set_override_redirect (gwin, TRUE);
     }
 
-#ifdef USE_GTK_TOOLTIP
   /* Steal a tool tip window we can move ourselves.  */
   f->output_data.x->ttip_widget = 0;
   f->output_data.x->ttip_lbl = 0;
   f->output_data.x->ttip_window = 0;
   gtk_widget_set_tooltip_text (wtop, "Dummy text");
   g_signal_connect (wtop, "query-tooltip", G_CALLBACK (qttip_cb), f);
-#endif
 
   {
     GdkScreen *screen = gtk_widget_get_screen (wtop);
@@ -1363,9 +1356,7 @@ xg_free_frame_widgets (struct frame *f)
 {
   if (FRAME_GTK_OUTER_WIDGET (f))
     {
-#ifdef USE_GTK_TOOLTIP
       struct x_output *x = f->output_data.x;
-#endif
       struct xg_frame_tb_info *tbinfo
         = g_object_get_data (G_OBJECT (FRAME_GTK_OUTER_WIDGET (f)),
                              TB_INFO_KEY);
@@ -1378,12 +1369,10 @@ xg_free_frame_widgets (struct frame *f)
       FRAME_X_WINDOW (f) = 0; /* Set to avoid XDestroyWindow in xterm.c */
       FRAME_X_RAW_DRAWABLE (f) = 0;
       FRAME_GTK_OUTER_WIDGET (f) = 0;
-#ifdef USE_GTK_TOOLTIP
       if (x->ttip_lbl)
         gtk_widget_destroy (x->ttip_lbl);
       if (x->ttip_widget)
         g_object_unref (G_OBJECT (x->ttip_widget));
-#endif
     }
 }
 
@@ -1561,7 +1550,6 @@ xg_set_undecorated (struct frame *f, Lisp_Object undecorated)
 void
 xg_frame_restack (struct frame *f1, struct frame *f2, bool above_flag)
 {
-#if GTK_CHECK_VERSION (2, 18, 0)
   block_input ();
   if (FRAME_GTK_OUTER_WIDGET (f1) && FRAME_GTK_OUTER_WIDGET (f2))
     {
@@ -1576,7 +1564,6 @@ xg_frame_restack (struct frame *f1, struct frame *f2, bool above_flag)
       x_sync (f1);
     }
   unblock_input ();
-#endif
 }
 
 
@@ -2216,7 +2203,7 @@ xg_get_file_name (struct frame *f,
 
 #ifdef HAVE_FREETYPE
 
-#if USE_NEW_GTK_FONT_CHOOSER
+#ifdef HAVE_GTK3
 
 #define XG_WEIGHT_TO_SYMBOL(w)			\
   (w <= PANGO_WEIGHT_THIN ? Qextra_light	\
@@ -2233,7 +2220,7 @@ xg_get_file_name (struct frame *f,
    : s == PANGO_STYLE_ITALIC ? Qitalic		\
    : Qnormal)
 
-#endif /* USE_NEW_GTK_FONT_CHOOSER */
+#endif /* HAVE_GTK3 */
 
 
 static char *x_last_font_name;
@@ -2280,7 +2267,7 @@ xg_get_font (struct frame *f, const char *default_name)
   done = xg_dialog_run (f, w);
   if (done == GTK_RESPONSE_OK)
     {
-#if USE_NEW_GTK_FONT_CHOOSER
+#ifdef HAVE_GTK3
       /* Use the GTK3 font chooser.  */
       PangoFontDescription *desc
 	= gtk_font_chooser_get_font_desc (GTK_FONT_CHOOSER (w));
@@ -2320,7 +2307,7 @@ xg_get_font (struct frame *f, const char *default_name)
 	  g_free (x_last_font_name);
 	  x_last_font_name = font_name;
 	}
-#endif /* USE_NEW_GTK_FONT_CHOOSER */
+#endif /* HAVE_GTK3 */
     }
 
   gtk_widget_destroy (w);
@@ -3041,9 +3028,7 @@ xg_update_menubar (GtkWidget *menubar,
              bridge that might be loaded) that the item's label has
              changed.  */
           gtk_label_set_text (wlabel, utf8_label);
-#if GTK_CHECK_VERSION (2, 16, 0)
           g_object_notify (G_OBJECT (witem), "label");
-#endif
           if (utf8_label) g_free (utf8_label);
           iter = g_list_next (iter);
           val = val->next;
@@ -3222,10 +3207,8 @@ xg_update_menu_item (widget_value *val,
         }
     }
 
-#if GTK_CHECK_VERSION (2, 16, 0)
   if (label_changed) /* See comment in xg_update_menubar.  */
     g_object_notify (G_OBJECT (w), "label");
-#endif
 }
 
 /* Update the toggle menu item W so it corresponds to VAL.  */
@@ -3324,7 +3307,7 @@ xg_update_submenu (GtkWidget *submenu,
           {
             /* Not a submenu anymore.  */
             g_object_ref (G_OBJECT (sub));
-            remove_submenu (witem);
+            gtk_menu_item_set_submenu (witem, NULL);
             gtk_widget_destroy (sub);
           }
         else if (cur->contents)
@@ -4405,7 +4388,7 @@ xg_tool_bar_callback (GtkWidget *w, gpointer client_data)
 
   /* Return focus to the frame after we have clicked on a detached
      tool bar button. */
-  x_focus_frame (f, false);
+  FRAME_TERMINAL (f)->focus_frame_hook (f, false);
 }
 
 static GtkWidget *
@@ -4492,14 +4475,6 @@ xg_tool_bar_item_expose_callback (GtkWidget *w,
 }
 #endif
 
-#ifdef HAVE_GTK_ORIENTABLE_SET_ORIENTATION
-#define toolbar_set_orientation(w, o) \
-  gtk_orientable_set_orientation (GTK_ORIENTABLE (w), o)
-#else
-#define toolbar_set_orientation(w, o) \
-  gtk_toolbar_set_orientation (GTK_TOOLBAR (w), o)
-#endif
-
 /* Attach a tool bar to frame F.  */
 
 static void
@@ -4509,10 +4484,10 @@ xg_pack_tool_bar (struct frame *f, Lisp_Object pos)
   bool into_hbox = EQ (pos, Qleft) || EQ (pos, Qright);
   GtkWidget *top_widget = x->toolbar_widget;
 
-  toolbar_set_orientation (x->toolbar_widget,
-                           into_hbox
-                           ? GTK_ORIENTATION_VERTICAL
-                           : GTK_ORIENTATION_HORIZONTAL);
+  gtk_orientable_set_orientation (GTK_ORIENTABLE (x->toolbar_widget),
+                                  into_hbox
+                                  ? GTK_ORIENTATION_VERTICAL
+                                  : GTK_ORIENTATION_HORIZONTAL);
 
   if (into_hbox)
     {
@@ -4565,7 +4540,7 @@ static void
 xg_create_tool_bar (struct frame *f)
 {
   struct x_output *x = f->output_data.x;
-#if GTK_CHECK_VERSION (3, 3, 6)
+#ifdef HAVE_GTK3
   GtkStyleContext *gsty;
 #endif
   struct xg_frame_tb_info *tbinfo
@@ -4589,10 +4564,11 @@ xg_create_tool_bar (struct frame *f)
   gtk_widget_set_name (x->toolbar_widget, "emacs-toolbar");
 
   gtk_toolbar_set_style (GTK_TOOLBAR (x->toolbar_widget), GTK_TOOLBAR_ICONS);
-  toolbar_set_orientation (x->toolbar_widget, GTK_ORIENTATION_HORIZONTAL);
+  gtk_orientable_set_orientation (GTK_ORIENTABLE (x->toolbar_widget),
+                                  GTK_ORIENTATION_HORIZONTAL);
   g_signal_connect (x->toolbar_widget, "size-allocate",
                     G_CALLBACK (tb_size_cb), f);
-#if GTK_CHECK_VERSION (3, 3, 6)
+#ifdef HAVE_GTK3
   gsty = gtk_widget_get_style_context (x->toolbar_widget);
   gtk_style_context_add_class (gsty, "primary-toolbar");
 #endif
@@ -4645,7 +4621,7 @@ xg_make_tool_item (struct frame *f,
   GtkWidget *wb = gtk_button_new ();
   /* The eventbox is here so we can have tooltips on disabled items.  */
   GtkWidget *weventbox = gtk_event_box_new ();
-#if GTK_CHECK_VERSION (3, 3, 6)
+#ifdef HAVE_GTK3
   GtkCssProvider *css_prov = gtk_css_provider_new ();
   GtkStyleContext *gsty;
 
@@ -4777,7 +4753,7 @@ xg_tool_item_stale_p (GtkWidget *wbutton, const char *stock_name,
     {
       gpointer gold_img = g_object_get_data (G_OBJECT (wimage),
                                              XG_TOOL_BAR_IMAGE_DATA);
-#if defined USE_CAIRO && GTK_CHECK_VERSION (3, 10, 0)
+#ifdef USE_CAIRO
       void *old_img = (void *) gold_img;
       if (old_img != img->cr_data)
 	return 1;
@@ -4850,7 +4826,7 @@ find_icon_from_name (char *name,
                      GtkIconTheme *icon_theme,
                      char **icon_name)
 {
-#if ! GTK_CHECK_VERSION (3, 10, 0)
+#ifndef HAVE_GTK3
   GtkStockItem stock_item;
 #endif
 
@@ -4863,7 +4839,7 @@ find_icon_from_name (char *name,
         *icon_name = NULL;
     }
 
-#if ! GTK_CHECK_VERSION (3, 10, 0)
+#ifndef HAVE_GTK3
   else if (gtk_stock_lookup (name, &stock_item))
     *icon_name = NULL;
 #endif
@@ -5078,7 +5054,7 @@ update_frame_tool_bar (struct frame *f)
           prepare_image_for_display (f, img);
 
           if (img->load_failed_p
-#if defined USE_CAIRO && GTK_CHECK_VERSION (3, 10, 0)
+#ifdef USE_CAIRO
 	      || img->cr_data == NULL
 #else
 	      || img->pixmap == None
@@ -5113,7 +5089,7 @@ update_frame_tool_bar (struct frame *f)
 	  else if (stock_name)
             {
 
-#if GTK_CHECK_VERSION (3, 10, 0)
+#ifdef HAVE_GTK3
               w = gtk_image_new_from_icon_name (stock_name, icon_size);
 #else
               w = gtk_image_new_from_stock (stock_name, icon_size);
@@ -5133,7 +5109,7 @@ update_frame_tool_bar (struct frame *f)
             {
               w = xg_get_image_for_pixmap (f, img, x->widget, NULL);
               g_object_set_data (G_OBJECT (w), XG_TOOL_BAR_IMAGE_DATA,
-#if defined USE_CAIRO && GTK_CHECK_VERSION (3, 10, 0)
+#ifdef USE_CAIRO
                                  (gpointer)img->cr_data
 #else
                                  (gpointer)img->pixmap
@@ -5309,7 +5285,7 @@ xg_initialize (void)
 
   settings = gtk_settings_get_for_screen (gdk_display_get_default_screen
                                           (gdk_display_get_default ()));
-#if ! GTK_CHECK_VERSION (3, 10, 0)
+#ifndef HAVE_GTK3
   /* Remove F10 as a menu accelerator, it does not mix well with Emacs key
      bindings.  It doesn't seem to be any way to remove properties,
      so we set it to "" which in means "no key".  */
diff --git a/src/gtkutil.h b/src/gtkutil.h
index ec899781ca..229aa08f81 100644
--- a/src/gtkutil.h
+++ b/src/gtkutil.h
@@ -166,7 +166,7 @@ extern void xg_free_frame_widgets (struct frame *f);
 extern void xg_set_background_color (struct frame *f, unsigned long bg);
 extern bool xg_check_special_colors (struct frame *f,
 				     const char *color_name,
-				     XColor *color);
+				     Emacs_Color *color);
 
 extern void xg_set_frame_icon (struct frame *f,
                                Pixmap icon_pixmap,
diff --git a/src/image.c b/src/image.c
index de423a227a..71930f56ec 100644
--- a/src/image.c
+++ b/src/image.c
@@ -30,6 +30,7 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include <setjmp.h>
 
+#include <stdint.h>
 #include <c-ctype.h>
 #include <flexmember.h>
 
@@ -67,13 +68,37 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #ifdef HAVE_X_WINDOWS
 typedef struct x_bitmap_record Bitmap_Record;
+#ifndef USE_CAIRO
 #define GET_PIXEL(ximg, x, y) XGetPixel (ximg, x, y)
+#define PUT_PIXEL XPutPixel
 #define NO_PIXMAP None
 
 #define PIX_MASK_RETAIN	0
 #define PIX_MASK_DRAW	1
+#endif	/* !USE_CAIRO */
 #endif /* HAVE_X_WINDOWS */
 
+#ifdef USE_CAIRO
+#define GET_PIXEL image_pix_context_get_pixel
+#define PUT_PIXEL image_pix_container_put_pixel
+#define NO_PIXMAP 0
+
+#define PIX_MASK_RETAIN	0
+#define PIX_MASK_DRAW	255
+
+#define RGB_TO_ULONG(r, g, b) (((r) << 16) | ((g) << 8) | (b))
+#define ARGB_TO_ULONG(a, r, g, b) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b))
+#define RED_FROM_ULONG(color)	(((color) >> 16) & 0xff)
+#define GREEN_FROM_ULONG(color)	(((color) >> 8) & 0xff)
+#define BLUE_FROM_ULONG(color)	((color) & 0xff)
+#define RED16_FROM_ULONG(color)		(RED_FROM_ULONG (color) * 0x101)
+#define GREEN16_FROM_ULONG(color)	(GREEN_FROM_ULONG (color) * 0x101)
+#define BLUE16_FROM_ULONG(color)	(BLUE_FROM_ULONG (color) * 0x101)
+
+static unsigned long image_alloc_image_color (struct frame *, struct image *,
+					      Lisp_Object, unsigned long);
+#endif	/* USE_CAIRO */
+
 #ifdef HAVE_NTGUI
 
 /* We need (or want) w32.h only when we're _not_ compiling for Cygwin.  */
@@ -84,25 +109,23 @@ typedef struct x_bitmap_record Bitmap_Record;
 
 typedef struct w32_bitmap_record Bitmap_Record;
 #define GET_PIXEL(ximg, x, y) GetPixel (ximg, x, y)
+#define PUT_PIXEL XPutPixel
 #define NO_PIXMAP 0
 
 #define PIX_MASK_RETAIN	0
 #define PIX_MASK_DRAW	1
 
-#define x_defined_color w32_defined_color
-
 #endif /* HAVE_NTGUI */
 
 #ifdef HAVE_NS
 typedef struct ns_bitmap_record Bitmap_Record;
 
 #define GET_PIXEL(ximg, x, y) XGetPixel (ximg, x, y)
+#define PUT_PIXEL XPutPixel
 #define NO_PIXMAP 0
 
 #define PIX_MASK_RETAIN	0
 
-#define x_defined_color(f, name, color_def, alloc) \
-  ns_defined_color (f, name, color_def, alloc, 0)
 #endif /* HAVE_NS */
 
 #if (defined HAVE_X_WINDOWS \
@@ -111,9 +134,9 @@ typedef struct ns_bitmap_record Bitmap_Record;
 # define COLOR_TABLE_SUPPORT 1
 #endif
 
-static void x_disable_image (struct frame *, struct image *);
-static void x_edge_detection (struct frame *, struct image *, Lisp_Object,
-                              Lisp_Object);
+static void image_disable_image (struct frame *, struct image *);
+static void image_edge_detection (struct frame *, struct image *, Lisp_Object,
+                                  Lisp_Object);
 
 static void init_color_table (void);
 static unsigned long lookup_rgb_color (struct frame *f, int r, int g, int b);
@@ -122,34 +145,137 @@ static void free_color_table (void);
 static unsigned long *colors_in_color_table (int *n);
 #endif
 
-/* Code to deal with bitmaps.  Bitmaps are referenced by their bitmap
-   id, which is just an int that this section returns.  Bitmaps are
-   reference counted so they can be shared among frames.
+#ifdef USE_CAIRO
 
-   Bitmap indices are guaranteed to be > 0, so a negative number can
-   be used to indicate no bitmap.
+static Emacs_Pix_Container
+image_create_pix_container (struct frame *f, unsigned int width,
+			    unsigned int height, unsigned int depth)
+{
+  Emacs_Pix_Container pimg;
 
-   If you use x_create_bitmap_from_data, then you must keep track of
-   the bitmaps yourself.  That is, creating a bitmap from the same
-   data more than once will not be caught.  */
+  pimg = xmalloc (sizeof (*pimg));
+  pimg->width = width;
+  pimg->height = height;
+  pimg->bits_per_pixel = depth == 1 ? 8 : 32;
+  pimg->bytes_per_line = cairo_format_stride_for_width ((depth == 1
+							 ? CAIRO_FORMAT_A8
+							 : CAIRO_FORMAT_RGB24),
+							width);
+  pimg->data = xmalloc (pimg->bytes_per_line * height);
+
+  return pimg;
+}
+
+static void
+image_pix_container_put_pixel (Emacs_Pix_Container image,
+			       int x, int y, unsigned long pixel)
+{
+  if (image->bits_per_pixel == 32)
+    ((uint32_t *)(image->data + y * image->bytes_per_line))[x] = pixel;
+  else
+    ((uint8_t *)(image->data + y * image->bytes_per_line))[x] = pixel;
+}
+
+static unsigned long
+image_pix_context_get_pixel (Emacs_Pix_Context image, int x, int y)
+{
+  if (image->bits_per_pixel == 32)
+    return ((uint32_t *)(image->data + y * image->bytes_per_line))[x];
+  else
+    return ((uint8_t *)(image->data + y * image->bytes_per_line))[x];
+}
+
+static Emacs_Pix_Container
+image_pix_container_create_from_bitmap_data (struct frame *f,
+					     char *data, unsigned int width,
+					     unsigned int height,
+					     unsigned long fg,
+					     unsigned long bg)
+{
+  Emacs_Pix_Container pimg = image_create_pix_container (f, width, height, 0);
+  int bytes_per_line = (width + (CHAR_BIT - 1)) / CHAR_BIT;
+
+  for (int y = 0; y < height; y++)
+    {
+      for (int x = 0; x < width; x++)
+	PUT_PIXEL (pimg, x, y,
+		   (data[x / CHAR_BIT] >> (x % CHAR_BIT)) & 1 ? fg : bg);
+      data += bytes_per_line;
+    }
+
+  return pimg;
+}
+
+static cairo_surface_t *
+cr_create_cr_surface_from_image (struct frame *f, struct image *img)
+{
+  Emacs_Pix_Container pimg = img->pixmap;
+  cairo_surface_t *surface;
+
+  if (img->mask)
+    {
+      int x, y;
+
+      for (y = 0; y < pimg->height; y++)
+	for (x = 0; x < pimg->width; x++)
+	  {
+	    unsigned long color, alpha;
+	    int r, g, b;
+
+	    color = GET_PIXEL (pimg, x, y);
+	    alpha = GET_PIXEL (img->mask, x, y);
+	    r = (RED_FROM_ULONG (color) * alpha + 0x7f) / 0xff;
+	    g = (GREEN_FROM_ULONG (color) * alpha + 0x7f) / 0xff;
+	    b = (BLUE_FROM_ULONG (color) * alpha + 0x7f) / 0xff;
+	    PUT_PIXEL (pimg, x, y, ARGB_TO_ULONG (alpha, r, g, b));
+	  }
+      xfree (img->mask->data);
+      img->mask->data = NULL;
+    }
+  block_input ();
+  surface = cairo_image_surface_create_for_data ((unsigned char *) pimg->data,
+						 (img->mask
+						  ? CAIRO_FORMAT_ARGB32
+						  : CAIRO_FORMAT_RGB24),
+						 pimg->width, pimg->height,
+						 pimg->bytes_per_line);
+  static const cairo_user_data_key_t key;
+  cairo_surface_set_user_data (surface, &key, pimg->data, xfree);
+  unblock_input ();
+  pimg->data = NULL;
+
+  return surface;
+}
+
+#endif	/* USE_CAIRO */
 
 #ifdef HAVE_NS
 /* Use with images created by ns_image_for_XPM.  */
 static unsigned long
-XGetPixel (XImagePtr ximage, int x, int y)
+XGetPixel (Emacs_Pix_Container image, int x, int y)
 {
-  return ns_get_pixel (ximage, x, y);
+  return ns_get_pixel (image, x, y);
 }
 
 /* Use with images created by ns_image_for_XPM; alpha set to 1;
    pixel is assumed to be in RGB form.  */
 static void
-XPutPixel (XImagePtr ximage, int x, int y, unsigned long pixel)
+XPutPixel (Emacs_Pix_Container image, int x, int y, unsigned long pixel)
 {
-  ns_put_pixel (ximage, x, y, pixel);
+  ns_put_pixel (image, x, y, pixel);
 }
 #endif /* HAVE_NS */
 
+/* Code to deal with bitmaps.  Bitmaps are referenced by their bitmap
+   id, which is just an int that this section returns.  Bitmaps are
+   reference counted so they can be shared among frames.
+
+   Bitmap indices are guaranteed to be > 0, so a negative number can
+   be used to indicate no bitmap.
+
+   If you use image_create_bitmap_from_data, then you must keep track
+   of the bitmaps yourself.  That is, creating a bitmap from the same
+   data more than once will not be caught.  */
 
 /* Functions to access the contents of a bitmap, given an id.  */
 
@@ -165,11 +291,46 @@ x_bitmap_width (struct frame *f, ptrdiff_t id)
 {
   return FRAME_DISPLAY_INFO (f)->bitmaps[id - 1].width;
 }
+
+#ifdef USE_CAIRO
+cairo_pattern_t *
+x_bitmap_stipple (struct frame *f, Pixmap pixmap)
+{
+  Display_Info *dpyinfo = FRAME_DISPLAY_INFO (f);
+
+  for (ptrdiff_t i = 0; i < dpyinfo->bitmaps_last; i++)
+    {
+      struct x_bitmap_record *bm = dpyinfo->bitmaps + i;
+
+      if (bm->refcount && bm->pixmap == pixmap && bm->depth == 1)
+	{
+	  if (bm->stipple == NULL)
+	    {
+	      cairo_surface_t *surface
+		= cairo_xlib_surface_create_for_bitmap (FRAME_X_DISPLAY (f),
+							pixmap,
+							FRAME_X_SCREEN (f),
+							bm->width, bm->height);
+	      cairo_pattern_t *pattern
+		= cairo_pattern_create_for_surface (surface);
+	      cairo_surface_destroy (surface);
+	      cairo_pattern_set_extend (pattern, CAIRO_EXTEND_REPEAT);
+	      bm->stipple = pattern;
+	    }
+
+	  return bm->stipple;
+	}
+    }
+
+  return NULL;
+}
+
+#endif	/* USE_CAIRO */
 #endif
 
 #if defined (HAVE_X_WINDOWS) || defined (HAVE_NTGUI)
 ptrdiff_t
-x_bitmap_pixmap (struct frame *f, ptrdiff_t id)
+image_bitmap_pixmap (struct frame *f, ptrdiff_t id)
 {
   /* HAVE_NTGUI needs the explicit cast here.  */
   return (ptrdiff_t) FRAME_DISPLAY_INFO (f)->bitmaps[id - 1].pixmap;
@@ -187,7 +348,7 @@ x_bitmap_mask (struct frame *f, ptrdiff_t id)
 /* Allocate a new bitmap record.  Returns index of new record.  */
 
 static ptrdiff_t
-x_allocate_bitmap_record (struct frame *f)
+image_allocate_bitmap_record (struct frame *f)
 {
   Display_Info *dpyinfo = FRAME_DISPLAY_INFO (f);
   ptrdiff_t i;
@@ -208,7 +369,7 @@ x_allocate_bitmap_record (struct frame *f)
 /* Add one reference to the reference count of the bitmap with id ID.  */
 
 void
-x_reference_bitmap (struct frame *f, ptrdiff_t id)
+image_reference_bitmap (struct frame *f, ptrdiff_t id)
 {
   ++FRAME_DISPLAY_INFO (f)->bitmaps[id - 1].refcount;
 }
@@ -216,7 +377,8 @@ x_reference_bitmap (struct frame *f, ptrdiff_t id)
 /* Create a bitmap for frame F from a HEIGHT x WIDTH array of bits at BITS.  */
 
 ptrdiff_t
-x_create_bitmap_from_data (struct frame *f, char *bits, unsigned int width, unsigned int height)
+image_create_bitmap_from_data (struct frame *f, char *bits,
+                               unsigned int width, unsigned int height)
 {
   Display_Info *dpyinfo = FRAME_DISPLAY_INFO (f);
   ptrdiff_t id;
@@ -231,7 +393,7 @@ x_create_bitmap_from_data (struct frame *f, char *bits, unsigned int width, unsi
 
 #ifdef HAVE_NTGUI
   Lisp_Object frame UNINIT;	/* The value is not used.  */
-  Pixmap bitmap;
+  Emacs_Pixmap bitmap;
   bitmap = CreateBitmap (width, height,
 			 FRAME_DISPLAY_INFO (XFRAME (frame))->n_planes,
 			 FRAME_DISPLAY_INFO (XFRAME (frame))->n_cbits,
@@ -246,7 +408,7 @@ x_create_bitmap_from_data (struct frame *f, char *bits, unsigned int width, unsi
       return -1;
 #endif
 
-  id = x_allocate_bitmap_record (f);
+  id = image_allocate_bitmap_record (f);
 
 #ifdef HAVE_NS
   dpyinfo->bitmaps[id - 1].img = bitmap;
@@ -262,6 +424,9 @@ x_create_bitmap_from_data (struct frame *f, char *bits, unsigned int width, unsi
   dpyinfo->bitmaps[id - 1].pixmap = bitmap;
   dpyinfo->bitmaps[id - 1].have_mask = false;
   dpyinfo->bitmaps[id - 1].depth = 1;
+#ifdef USE_CAIRO
+  dpyinfo->bitmaps[id - 1].stipple = NULL;
+#endif	/* USE_CAIRO */
 #endif /* HAVE_X_WINDOWS */
 
 #ifdef HAVE_NTGUI
@@ -276,7 +441,7 @@ x_create_bitmap_from_data (struct frame *f, char *bits, unsigned int width, unsi
 /* Create bitmap from file FILE for frame F.  */
 
 ptrdiff_t
-x_create_bitmap_from_file (struct frame *f, Lisp_Object file)
+image_create_bitmap_from_file (struct frame *f, Lisp_Object file)
 {
 #ifdef HAVE_NTGUI
   return -1;  /* W32_TODO : bitmap support */
@@ -292,7 +457,7 @@ x_create_bitmap_from_file (struct frame *f, Lisp_Object file)
       return -1;
 
 
-  id = x_allocate_bitmap_record (f);
+  id = image_allocate_bitmap_record (f);
   dpyinfo->bitmaps[id - 1].img = bitmap;
   dpyinfo->bitmaps[id - 1].refcount = 1;
   dpyinfo->bitmaps[id - 1].file = xlispstrdup (file);
@@ -335,7 +500,7 @@ x_create_bitmap_from_file (struct frame *f, Lisp_Object file)
   if (result != BitmapSuccess)
     return -1;
 
-  id = x_allocate_bitmap_record (f);
+  id = image_allocate_bitmap_record (f);
   dpyinfo->bitmaps[id - 1].pixmap = bitmap;
   dpyinfo->bitmaps[id - 1].have_mask = false;
   dpyinfo->bitmaps[id - 1].refcount = 1;
@@ -343,6 +508,9 @@ x_create_bitmap_from_file (struct frame *f, Lisp_Object file)
   dpyinfo->bitmaps[id - 1].depth = 1;
   dpyinfo->bitmaps[id - 1].height = height;
   dpyinfo->bitmaps[id - 1].width = width;
+#ifdef USE_CAIRO
+  dpyinfo->bitmaps[id - 1].stipple = NULL;
+#endif	/* USE_CAIRO */
 
   return id;
 #endif /* HAVE_X_WINDOWS */
@@ -357,6 +525,10 @@ free_bitmap_record (Display_Info *dpyinfo, Bitmap_Record *bm)
   XFreePixmap (dpyinfo->display, bm->pixmap);
   if (bm->have_mask)
     XFreePixmap (dpyinfo->display, bm->mask);
+#ifdef USE_CAIRO
+  if (bm->stipple)
+    cairo_pattern_destroy (bm->stipple);
+#endif	/* USE_CAIRO */
 #endif /* HAVE_X_WINDOWS */
 
 #ifdef HAVE_NTGUI
@@ -377,7 +549,7 @@ free_bitmap_record (Display_Info *dpyinfo, Bitmap_Record *bm)
 /* Remove reference to bitmap with id number ID.  */
 
 void
-x_destroy_bitmap (struct frame *f, ptrdiff_t id)
+image_destroy_bitmap (struct frame *f, ptrdiff_t id)
 {
   Display_Info *dpyinfo = FRAME_DISPLAY_INFO (f);
 
@@ -397,7 +569,7 @@ x_destroy_bitmap (struct frame *f, ptrdiff_t id)
 /* Free all the bitmaps for the display specified by DPYINFO.  */
 
 void
-x_destroy_all_bitmaps (Display_Info *dpyinfo)
+image_destroy_all_bitmaps (Display_Info *dpyinfo)
 {
   ptrdiff_t i;
   Bitmap_Record *bm = dpyinfo->bitmaps;
@@ -410,22 +582,24 @@ x_destroy_all_bitmaps (Display_Info *dpyinfo)
 }
 
 #ifndef HAVE_XRENDER
-/* Required for the definition of x_create_x_image_and_pixmap below.  */
+/* Required for the definition of image_create_x_image_and_pixmap_1 below.  */
 typedef void Picture;
 #endif
 
-static bool x_create_x_image_and_pixmap (struct frame *, int, int, int,
-					 XImagePtr *, Pixmap *, Picture *);
-static void x_destroy_x_image (XImagePtr ximg);
+static bool image_create_x_image_and_pixmap_1 (struct frame *, int, int, int,
+                                               Emacs_Pix_Container *,
+                                               Emacs_Pixmap *, Picture *);
+static void image_destroy_x_image (Emacs_Pix_Container);
 
 #ifdef HAVE_NTGUI
-static XImagePtr_or_DC image_get_x_image_or_dc (struct frame *, struct image *,
-						bool, HGDIOBJ *);
-static void image_unget_x_image_or_dc (struct image *, bool, XImagePtr_or_DC,
-				       HGDIOBJ);
+static HDC image_get_x_image_or_dc (struct frame *, struct image *,
+                                    bool, HGDIOBJ *);
+static void image_unget_x_image_or_dc (struct image *, bool,
+                                       HDC, HGDIOBJ);
 #else
-static XImagePtr image_get_x_image (struct frame *, struct image *, bool);
-static void image_unget_x_image (struct image *, bool, XImagePtr);
+static Emacs_Pix_Container image_get_x_image (struct frame *, struct image *,
+                                              bool);
+static void image_unget_x_image (struct image *, bool, Emacs_Pix_Container);
 #define image_get_x_image_or_dc(f, img, mask_p, dummy)	\
   image_get_x_image (f, img, mask_p)
 #define image_unget_x_image_or_dc(img, mask_p, ximg, dummy)	\
@@ -434,16 +608,17 @@ static void image_unget_x_image (struct image *, bool, XImagePtr);
 
 #ifdef HAVE_X_WINDOWS
 
+#ifndef USE_CAIRO
 static void image_sync_to_pixmaps (struct frame *, struct image *);
+#endif	/* !USE_CAIRO */
 
-/* Useful functions defined in the section
-   `Image type independent image structures' below. */
-
-static unsigned long four_corners_best (XImagePtr ximg,
-                                        int *corners,
-                                        unsigned long width,
-                                        unsigned long height);
+/* We are working on X-specific data structures here even with cairo.
+   So we use X-specific versions of image construction/destruction
+   functions and inline the specific case of four_corners_best.  */
 
+static bool x_create_x_image_and_pixmap (struct frame *, int, int, int,
+					 XImage **, Pixmap *);
+static void x_destroy_x_image (XImage *);
 
 /* Create a mask of a bitmap. Note is this not a perfect mask.
    It's nicer with some borders in this context */
@@ -452,10 +627,10 @@ void
 x_create_bitmap_mask (struct frame *f, ptrdiff_t id)
 {
   Pixmap pixmap, mask;
-  XImagePtr ximg, mask_img;
+  XImage *ximg, *mask_img;
   unsigned long width, height;
   bool result;
-  unsigned long bg;
+  unsigned long bg UNINIT;
   unsigned long x, y, xp, xm, yp, ym;
   GC gc;
 
@@ -464,7 +639,7 @@ x_create_bitmap_mask (struct frame *f, ptrdiff_t id)
   if (!(id > 0))
     return;
 
-  pixmap = x_bitmap_pixmap (f, id);
+  pixmap = image_bitmap_pixmap (f, id);
   width = x_bitmap_width (f, id);
   height = x_bitmap_height (f, id);
 
@@ -478,8 +653,7 @@ x_create_bitmap_mask (struct frame *f, ptrdiff_t id)
       return;
     }
 
-  result = x_create_x_image_and_pixmap (f, width, height, 1,
-                                        &mask_img, &mask, NULL);
+  result = x_create_x_image_and_pixmap (f, width, height, 1, &mask_img, &mask);
 
   unblock_input ();
   if (!result)
@@ -488,7 +662,23 @@ x_create_bitmap_mask (struct frame *f, ptrdiff_t id)
       return;
     }
 
-  bg = four_corners_best (ximg, NULL, width, height);
+  unsigned long corner_pixels[4];
+  corner_pixels[0] = XGetPixel (ximg, 0, 0);
+  corner_pixels[1] = XGetPixel (ximg, width - 1, 0);
+  corner_pixels[2] = XGetPixel (ximg, width - 1, height - 1);
+  corner_pixels[3] = XGetPixel (ximg, 0, height - 1);
+  int i, best_count;
+  for (i = best_count = 0; i < 4; ++i)
+    {
+      int j, n;
+
+      for (j = n = 0; j < 4; ++j)
+	if (corner_pixels[i] == corner_pixels[j])
+	  ++n;
+
+      if (n > best_count)
+	bg = corner_pixels[i], best_count = n;
+    }
 
   for (y = 0; y < ximg->height; ++y)
     {
@@ -551,82 +741,29 @@ struct image_type
   /* Free resources of image IMG which is used on frame F.  */
   void (*free) (struct frame *f, struct image *img);
 
+#ifdef WINDOWSNT
   /* Initialization function (used for dynamic loading of image
      libraries on Windows), or NULL if none.  */
   bool (*init) (void);
-
-  /* Next in list of all supported image types.  */
-  struct image_type *next;
+  /* An initializer for the init field.  */
+# define IMAGE_TYPE_INIT(f) f
+#else
+# define IMAGE_TYPE_INIT(f)
+#endif
 };
 
-/* List of supported image types.  Use define_image_type to add new
-   types.  Use lookup_image_type to find a type for a given symbol.  */
-
-static struct image_type *image_types;
-
 /* Forward function prototypes.  */
 
-static struct image_type *lookup_image_type (Lisp_Object);
-static void x_laplace (struct frame *, struct image *);
-static void x_emboss (struct frame *, struct image *);
-static void x_build_heuristic_mask (struct frame *, struct image *,
+static struct image_type const *lookup_image_type (Lisp_Object);
+static void image_laplace (struct frame *, struct image *);
+static void image_emboss (struct frame *, struct image *);
+static void image_build_heuristic_mask (struct frame *, struct image *,
                                     Lisp_Object);
-#ifdef WINDOWSNT
-#define CACHE_IMAGE_TYPE(type, status) \
-  do { Vlibrary_cache = Fcons (Fcons (type, status), Vlibrary_cache); } while (0)
-#else
-#define CACHE_IMAGE_TYPE(type, status)
-#endif
-
-#define ADD_IMAGE_TYPE(type) \
-  do { Vimage_types = Fcons (type, Vimage_types); } while (0)
 
-/* Define a new image type from TYPE.  This adds a copy of TYPE to
-   image_types and caches the loading status of TYPE.  */
-
-static struct image_type *
-define_image_type (struct image_type *type)
+static void
+add_image_type (Lisp_Object type)
 {
-  struct image_type *p = NULL;
-  int new_type = type->type;
-  bool type_valid = true;
-
-  block_input ();
-
-  for (p = image_types; p; p = p->next)
-    if (p->type == new_type)
-      goto done;
-
-  if (type->init)
-    {
-#if defined HAVE_NTGUI && defined WINDOWSNT
-      /* If we failed to load the library before, don't try again.  */
-      Lisp_Object tested = Fassq (builtin_lisp_symbol (new_type),
-				  Vlibrary_cache);
-      if (CONSP (tested) && NILP (XCDR (tested)))
-	type_valid = false;
-      else
-#endif
-	{
-	  type_valid = type->init ();
-	  CACHE_IMAGE_TYPE (builtin_lisp_symbol (new_type),
-			    type_valid ? Qt : Qnil);
-	}
-    }
-
-  if (type_valid)
-    {
-      /* Make a copy of TYPE to avoid a bus error in a dumped Emacs.
-         The initialized data segment is read-only.  */
-      p = xmalloc (sizeof *p);
-      *p = *type;
-      p->next = image_types;
-      image_types = p;
-    }
-
- done:
-  unblock_input ();
-  return p;
+  Vimage_types = Fcons (type, Vimage_types);
 }
 
 
@@ -640,29 +777,24 @@ define_image_type (struct image_type *type)
 bool
 valid_image_p (Lisp_Object object)
 {
-  bool valid_p = 0;
-
   if (IMAGEP (object))
     {
-      Lisp_Object tem;
-
-      for (tem = XCDR (object); CONSP (tem); tem = XCDR (tem))
-	if (EQ (XCAR (tem), QCtype))
+      Lisp_Object tail = XCDR (object);
+      FOR_EACH_TAIL_SAFE (tail)
+	if (EQ (XCAR (tail), QCtype))
 	  {
-	    tem = XCDR (tem);
-	    if (CONSP (tem) && SYMBOLP (XCAR (tem)))
+	    tail = XCDR (tail);
+	    if (CONSP (tail))
 	      {
-		struct image_type *type;
-		type = lookup_image_type (XCAR (tem));
+		struct image_type const *type = lookup_image_type (XCAR (tail));
 		if (type)
-		  valid_p = type->valid_p (object);
+		  return type->valid_p (object);
 	      }
-
 	    break;
 	  }
     }
 
-  return valid_p;
+  return false;
 }
 
 
@@ -1074,13 +1206,22 @@ prepare_image_for_display (struct frame *f, struct image *img)
   /* We're about to display IMG, so set its timestamp to `now'.  */
   img->timestamp = current_timespec ();
 
-#ifndef USE_CAIRO
   /* If IMG doesn't have a pixmap yet, load it now, using the image
      type dependent loader function.  */
   if (img->pixmap == NO_PIXMAP && !img->load_failed_p)
     img->load_failed_p = ! img->type->load (f, img);
 
-#ifdef HAVE_X_WINDOWS
+#ifdef USE_CAIRO
+  if (!img->load_failed_p && img->cr_data == NULL)
+    {
+      img->cr_data = cr_create_cr_surface_from_image (f, img);
+      if (img->cr_data == NULL)
+	{
+	  img->load_failed_p = 1;
+	  img->type->free (f, img);
+	}
+    }
+#elif defined HAVE_X_WINDOWS
   if (!img->load_failed_p)
     {
       block_input ();
@@ -1088,7 +1229,6 @@ prepare_image_for_display (struct frame *f, struct image *img)
       unblock_input ();
     }
 #endif
-#endif
 }
 
 
@@ -1135,57 +1275,15 @@ image_ascent (struct image *img, struct face *face, struct glyph_slice *slice)
   return ascent;
 }
 
-#ifdef USE_CAIRO
-static uint32_t
-xcolor_to_argb32 (XColor xc)
-{
-  return ((0xffu << 24) | ((xc.red / 256) << 16)
-	  | ((xc.green / 256) << 8) | (xc.blue / 256));
-}
-
-static uint32_t
-get_spec_bg_or_alpha_as_argb (struct image *img,
-                              struct frame *f)
-{
-  uint32_t bgcolor = 0;
-  XColor xbgcolor;
-  Lisp_Object bg = image_spec_value (img->spec, QCbackground, NULL);
-
-  if (STRINGP (bg) && x_parse_color (f, SSDATA (bg), &xbgcolor))
-    bgcolor = xcolor_to_argb32 (xbgcolor);
-
-  return bgcolor;
-}
-
-static cairo_surface_t *
-create_cairo_image_surface (int width, int height)
-{
-  cairo_format_t format = CAIRO_FORMAT_ARGB32;
-  eassert (cairo_format_stride_for_width (format, width) == width * 4);
-
-  return cairo_image_surface_create (format, width, height);
-}
-
-static void
-set_cairo_image_surface (struct image *img, cairo_surface_t *surface)
-{
-  cairo_surface_mark_dirty (surface);
-  img->width = cairo_image_surface_get_width (surface);
-  img->height = cairo_image_surface_get_height (surface);
-  img->cr_data = surface;
-  img->pixmap = 0;
-}
-#endif
-
 
 
 /* Image background colors.  */
 
 /* Find the "best" corner color of a bitmap.
-   On W32, XIMG is assumed to a device context with the bitmap selected.  */
+   On W32, PIMG is assumed to a device context with the bitmap selected.  */
 
 static RGB_PIXEL_COLOR
-four_corners_best (XImagePtr_or_DC ximg, int *corners,
+four_corners_best (Emacs_Pix_Context pimg, int *corners,
 		   unsigned long width, unsigned long height)
 {
   RGB_PIXEL_COLOR corner_pixels[4];
@@ -1194,19 +1292,19 @@ four_corners_best (XImagePtr_or_DC ximg, int *corners,
 
   if (corners && corners[BOT_CORNER] >= 0)
     {
-      /* Get the colors at the corner_pixels of ximg.  */
-      corner_pixels[0] = GET_PIXEL (ximg, corners[LEFT_CORNER], corners[TOP_CORNER]);
-      corner_pixels[1] = GET_PIXEL (ximg, corners[RIGHT_CORNER] - 1, corners[TOP_CORNER]);
-      corner_pixels[2] = GET_PIXEL (ximg, corners[RIGHT_CORNER] - 1, corners[BOT_CORNER] - 1);
-      corner_pixels[3] = GET_PIXEL (ximg, corners[LEFT_CORNER], corners[BOT_CORNER] - 1);
+      /* Get the colors at the corner_pixels of pimg.  */
+      corner_pixels[0] = GET_PIXEL (pimg, corners[LEFT_CORNER], corners[TOP_CORNER]);
+      corner_pixels[1] = GET_PIXEL (pimg, corners[RIGHT_CORNER] - 1, corners[TOP_CORNER]);
+      corner_pixels[2] = GET_PIXEL (pimg, corners[RIGHT_CORNER] - 1, corners[BOT_CORNER] - 1);
+      corner_pixels[3] = GET_PIXEL (pimg, corners[LEFT_CORNER], corners[BOT_CORNER] - 1);
     }
   else
     {
-      /* Get the colors at the corner_pixels of ximg.  */
-      corner_pixels[0] = GET_PIXEL (ximg, 0, 0);
-      corner_pixels[1] = GET_PIXEL (ximg, width - 1, 0);
-      corner_pixels[2] = GET_PIXEL (ximg, width - 1, height - 1);
-      corner_pixels[3] = GET_PIXEL (ximg, 0, height - 1);
+      /* Get the colors at the corner_pixels of pimg.  */
+      corner_pixels[0] = GET_PIXEL (pimg, 0, 0);
+      corner_pixels[1] = GET_PIXEL (pimg, width - 1, 0);
+      corner_pixels[2] = GET_PIXEL (pimg, width - 1, height - 1);
+      corner_pixels[3] = GET_PIXEL (pimg, 0, height - 1);
     }
   /* Choose the most frequently found color as background.  */
   for (i = best_count = 0; i < 4; ++i)
@@ -1224,49 +1322,41 @@ four_corners_best (XImagePtr_or_DC ximg, int *corners,
   return best;
 }
 
-/* Portability macros */
-
-#ifdef HAVE_NTGUI
-
-#define Free_Pixmap(display, pixmap) \
-  DeleteObject (pixmap)
-
-#elif defined (HAVE_NS)
-
-#define Free_Pixmap(display, pixmap) \
-  ns_release_object (pixmap)
-
-#else
-
-#define Free_Pixmap(display, pixmap) \
-  XFreePixmap (display, pixmap)
-
-#endif /* !HAVE_NTGUI && !HAVE_NS */
-
-
 /* Return the `background' field of IMG.  If IMG doesn't have one yet,
    it is guessed heuristically.  If non-zero, XIMG is an existing
-   XImage object (or device context with the image selected on W32) to
-   use for the heuristic.  */
+   Emacs_Pix_Context object (device context with the image selected on
+   W32) to use for the heuristic.  */
 
 RGB_PIXEL_COLOR
-image_background (struct image *img, struct frame *f, XImagePtr_or_DC ximg)
+image_background (struct image *img, struct frame *f, Emacs_Pix_Context pimg)
 {
   if (! img->background_valid)
     /* IMG doesn't have a background yet, try to guess a reasonable value.  */
     {
-      bool free_ximg = !ximg;
+      bool free_pimg = !pimg;
 #ifdef HAVE_NTGUI
       HGDIOBJ prev;
 #endif /* HAVE_NTGUI */
 
-      if (free_ximg)
-	ximg = image_get_x_image_or_dc (f, img, 0, &prev);
+      if (free_pimg)
+	pimg = image_get_x_image_or_dc (f, img, 0, &prev);
 
-      img->background = four_corners_best (ximg, img->corners, img->width, img->height);
+      RGB_PIXEL_COLOR bg
+	= four_corners_best (pimg, img->corners, img->width, img->height);
+#ifdef USE_CAIRO
+      {
+	char color_name[30];
+	sprintf (color_name, "#%04x%04x%04x",
+		 (unsigned int) RED16_FROM_ULONG (bg),
+		 (unsigned int) GREEN16_FROM_ULONG (bg),
+		 (unsigned int) BLUE16_FROM_ULONG (bg));
+	bg = image_alloc_image_color (f, img, build_string (color_name), 0);
+      }
+#endif
+      img->background = bg;
 
-      if (free_ximg)
-	image_unget_x_image_or_dc (img, 0, ximg, prev);
+      if (free_pimg)
+	image_unget_x_image_or_dc (img, 0, pimg, prev);
 
       img->background_valid = 1;
     }
@@ -1276,10 +1366,12 @@ image_background (struct image *img, struct frame *f, XImagePtr_or_DC ximg)
 
 /* Return the `background_transparent' field of IMG.  If IMG doesn't
    have one yet, it is guessed heuristically.  If non-zero, MASK is an
-   existing XImage object to use for the heuristic.  */
+   existing Emacs_Pix_Context (XImage* on X) object to use for the
+   heuristic.  */
 
 int
-image_background_transparent (struct image *img, struct frame *f, XImagePtr_or_DC mask)
+image_background_transparent (struct image *img, struct frame *f,
+                              Emacs_Pix_Context mask)
 {
   if (! img->background_transparent_valid)
     /* IMG doesn't have a background yet, try to guess a reasonable value.  */
@@ -1309,22 +1401,6 @@ image_background_transparent (struct image *img, struct frame *f, XImagePtr_or_D
   return img->background_transparent;
 }
 
-#if defined (HAVE_PNG) || defined (HAVE_IMAGEMAGICK) || defined (HAVE_RSVG)
-
-/* Store F's background color into *BGCOLOR.  */
-static void
-x_query_frame_background_color (struct frame *f, XColor *bgcolor)
-{
-#ifndef HAVE_NS
-  bgcolor->pixel = FRAME_BACKGROUND_PIXEL (f);
-  x_query_color (f, bgcolor);
-#else
-  ns_query_color (FRAME_BACKGROUND_COLOR (f), bgcolor, 1);
-#endif
-}
-
-#endif /* HAVE_PNG || HAVE_IMAGEMAGICK || HAVE_RSVG */
-
 /***********************************************************************
 		  Helper functions for X image types
  ***********************************************************************/
@@ -1341,21 +1417,21 @@ x_query_frame_background_color (struct frame *f, XColor *bgcolor)
 #define CLEAR_IMAGE_COLORS	(1 << 2)
 
 static void
-x_clear_image_1 (struct frame *f, struct image *img, int flags)
+image_clear_image_1 (struct frame *f, struct image *img, int flags)
 {
   if (flags & CLEAR_IMAGE_PIXMAP)
     {
       if (img->pixmap)
 	{
-	  Free_Pixmap (FRAME_X_DISPLAY (f), img->pixmap);
+	  FRAME_TERMINAL (f)->free_pixmap (f, img->pixmap);
 	  img->pixmap = NO_PIXMAP;
 	  /* NOTE (HAVE_NS): background color is NOT an indexed color! */
 	  img->background_valid = 0;
 	}
-#ifdef HAVE_X_WINDOWS
+#if defined HAVE_X_WINDOWS && !defined USE_CAIRO
       if (img->ximg)
 	{
-	  x_destroy_x_image (img->ximg);
+	  image_destroy_x_image (img->ximg);
 	  img->ximg = NULL;
 	  img->background_valid = 0;
 	}
@@ -1366,14 +1442,14 @@ x_clear_image_1 (struct frame *f, struct image *img, int flags)
     {
       if (img->mask)
 	{
-	  Free_Pixmap (FRAME_X_DISPLAY (f), img->mask);
+	  FRAME_TERMINAL (f)->free_pixmap (f, img->mask);
 	  img->mask = NO_PIXMAP;
 	  img->background_transparent_valid = 0;
 	}
-#ifdef HAVE_X_WINDOWS
+#if defined HAVE_X_WINDOWS && !defined USE_CAIRO
       if (img->mask_img)
 	{
-	  x_destroy_x_image (img->mask_img);
+	  image_destroy_x_image (img->mask_img);
 	  img->mask_img = NULL;
 	  img->background_transparent_valid = 0;
 	}
@@ -1383,27 +1459,30 @@ x_clear_image_1 (struct frame *f, struct image *img, int flags)
   if ((flags & CLEAR_IMAGE_COLORS) && img->ncolors)
     {
       /* W32_TODO: color table support.  */
-#ifdef HAVE_X_WINDOWS
+#if defined HAVE_X_WINDOWS && !defined USE_CAIRO
       x_free_colors (f, img->colors, img->ncolors);
-#endif /* HAVE_X_WINDOWS */
+#endif /* HAVE_X_WINDOWS && !USE_CAIRO */
       xfree (img->colors);
       img->colors = NULL;
       img->ncolors = 0;
     }
 
+#ifdef USE_CAIRO
+  if (img->cr_data)
+    {
+      cairo_surface_destroy ((cairo_surface_t *) img->cr_data);
+      img->cr_data = NULL;
+    }
+#endif	/* USE_CAIRO */
 }
 
 /* Free X resources of image IMG which is used on frame F.  */
 
 static void
-x_clear_image (struct frame *f, struct image *img)
+image_clear_image (struct frame *f, struct image *img)
 {
   block_input ();
-#ifdef USE_CAIRO
-  if (img->cr_data)
-    cairo_surface_destroy ((cairo_surface_t *)img->cr_data);
-#endif
-  x_clear_image_1 (f, img,
+  image_clear_image_1 (f, img,
 		   CLEAR_IMAGE_PIXMAP | CLEAR_IMAGE_MASK | CLEAR_IMAGE_COLORS);
   unblock_input ();
 }
@@ -1415,15 +1494,19 @@ x_clear_image (struct frame *f, struct image *img)
    color.  */
 
 static unsigned long
-x_alloc_image_color (struct frame *f, struct image *img, Lisp_Object color_name,
-		     unsigned long dflt)
+image_alloc_image_color (struct frame *f, struct image *img,
+                         Lisp_Object color_name, unsigned long dflt)
 {
-  XColor color;
+  Emacs_Color color;
   unsigned long result;
 
   eassert (STRINGP (color_name));
 
-  if (x_defined_color (f, SSDATA (color_name), &color, 1)
+  if (FRAME_TERMINAL (f)->defined_color_hook (f,
+                                              SSDATA (color_name),
+                                              &color,
+                                              true,
+                                              false)
       && img->ncolors < min (min (PTRDIFF_MAX, SIZE_MAX) / sizeof *img->colors,
 			     INT_MAX))
     {
@@ -1715,7 +1798,7 @@ postprocess_image (struct frame *f, struct image *img)
 
       mask = image_spec_value (spec, QCheuristic_mask, NULL);
       if (!NILP (mask))
-	x_build_heuristic_mask (f, img, mask);
+	image_build_heuristic_mask (f, img, mask);
       else
 	{
 	  bool found_p;
@@ -1723,42 +1806,42 @@ postprocess_image (struct frame *f, struct image *img)
 	  mask = image_spec_value (spec, QCmask, &found_p);
 
 	  if (EQ (mask, Qheuristic))
-	    x_build_heuristic_mask (f, img, Qt);
+	    image_build_heuristic_mask (f, img, Qt);
 	  else if (CONSP (mask)
 		   && EQ (XCAR (mask), Qheuristic))
 	    {
 	      if (CONSP (XCDR (mask)))
-		x_build_heuristic_mask (f, img, XCAR (XCDR (mask)));
+		image_build_heuristic_mask (f, img, XCAR (XCDR (mask)));
 	      else
-		x_build_heuristic_mask (f, img, XCDR (mask));
+		image_build_heuristic_mask (f, img, XCDR (mask));
 	    }
 	  else if (NILP (mask) && found_p && img->mask)
-	    x_clear_image_1 (f, img, CLEAR_IMAGE_MASK);
+	    image_clear_image_1 (f, img, CLEAR_IMAGE_MASK);
 	}
 
 
       /* Should we apply an image transformation algorithm?  */
       conversion = image_spec_value (spec, QCconversion, NULL);
       if (EQ (conversion, Qdisabled))
-	x_disable_image (f, img);
+	image_disable_image (f, img);
       else if (EQ (conversion, Qlaplace))
-	x_laplace (f, img);
+	image_laplace (f, img);
       else if (EQ (conversion, Qemboss))
-	x_emboss (f, img);
+	image_emboss (f, img);
       else if (CONSP (conversion)
 	       && EQ (XCAR (conversion), Qedge_detection))
 	{
 	  Lisp_Object tem;
 	  tem = XCDR (conversion);
 	  if (CONSP (tem))
-	    x_edge_detection (f, img,
-			      Fplist_get (tem, QCmatrix),
-			      Fplist_get (tem, QCcolor_adjustment));
+	    image_edge_detection (f, img,
+                                  Fplist_get (tem, QCmatrix),
+                                  Fplist_get (tem, QCcolor_adjustment));
 	}
     }
 }
 
-#if defined (HAVE_IMAGEMAGICK) || defined (HAVE_NATIVE_SCALING)
+#if defined (HAVE_IMAGEMAGICK) || defined (HAVE_NATIVE_TRANSFORMS)
 /* Scale an image size by returning SIZE / DIVISOR * MULTIPLIER,
    safely rounded and clipped to int range.  */
 
@@ -1857,49 +1940,241 @@ compute_image_size (size_t width, size_t height,
   *d_width = desired_width;
   *d_height = desired_height;
 }
-#endif /* HAVE_IMAGEMAGICK || HAVE_NATIVE_SCALING */
+#endif /* HAVE_IMAGEMAGICK || HAVE_NATIVE_TRANSFORMS */
 
 static void
-x_set_image_size (struct frame *f, struct image *img)
+image_set_rotation (struct image *img, double tm[3][3])
 {
-#ifdef HAVE_NATIVE_SCALING
+#ifdef HAVE_NATIVE_TRANSFORMS
 # ifdef HAVE_IMAGEMAGICK
-  /* ImageMagick images are already the correct size.  */
+  /* ImageMagick images are already rotated.  */
   if (EQ (image_spec_value (img->spec, QCtype, NULL), Qimagemagick))
     return;
 # endif
 
-  int width, height;
-  compute_image_size (img->width, img->height, img->spec, &width, &height);
+# ifdef HAVE_XRENDER
+  if (!img->picture)
+    return;
+# endif
+
+  Lisp_Object value;
+  double t[3][3], rot[3][3], tmp[3][3], tmp2[3][3];
+  int rotation, cos_r, sin_r, width, height;
+
+  value = image_spec_value (img->spec, QCrotation, NULL);
+  if (! NUMBERP (value))
+    return;
+
+  rotation = XFLOATINT (value);
+  rotation = rotation % 360;
+
+  if (rotation < 0)
+    rotation += 360;
+
+  if (rotation == 0)
+    return;
+
+  if (rotation == 90)
+    {
+      width = img->height;
+      height = img->width;
+
+      cos_r = 0;
+      sin_r = 1;
+    }
+  else if (rotation == 180)
+    {
+      width = img->width;
+      height = img->height;
+
+      cos_r = -1;
+      sin_r = 0;
+    }
+  else if (rotation == 270)
+    {
+      width = img->height;
+      height = img->width;
+
+      cos_r = 0;
+      sin_r = -1;
+    }
+  else
+    {
+      image_error ("Native image rotation only supports multiples of 90 degrees");
+      return;
+    }
+
+  /* Translate so (0, 0) is in the centre of the image.  */
+  INIT_MATRIX (t);
+  t[2][0] = img->width/2;
+  t[2][1] = img->height/2;
+
+  MULT_MATRICES (tm, t, tmp);
+
+  /* Rotate.  */
+  INIT_MATRIX (rot);
+  rot[0][0] = cos_r;
+  rot[1][0] = sin_r;
+  rot[0][1] = - sin_r;
+  rot[1][1] = cos_r;
+
+  MULT_MATRICES (tmp, rot, tmp2);
+
+  /* Translate back.  */
+  INIT_MATRIX (t);
+  t[2][0] = - width/2;
+  t[2][1] = - height/2;
+
+  MULT_MATRICES (tmp2, t, tm);
 
-# ifdef HAVE_NS
-  ns_image_set_size (img->pixmap, width, height);
   img->width = width;
   img->height = height;
+#endif
+}
+
+static void
+image_set_crop (struct image *img, double tm[3][3])
+{
+#ifdef HAVE_NATIVE_TRANSFORMS
+# ifdef HAVE_IMAGEMAGICK
+  /* ImageMagick images are already cropped.  */
+  if (EQ (image_spec_value (img->spec, QCtype, NULL), Qimagemagick))
+    return;
 # endif
 
 # ifdef USE_CAIRO
   img->width = width;
   img->height = height;
 # elif defined HAVE_XRENDER
-  if (img->picture)
+  if (!img->picture)
+    return;
+# endif
+
+  double m[3][3], tmp[3][3];
+  int left, top, width, height;
+  Lisp_Object x = Qnil;
+  Lisp_Object y = Qnil;
+  Lisp_Object w = Qnil;
+  Lisp_Object h = Qnil;
+  Lisp_Object crop = image_spec_value (img->spec, QCcrop, NULL);
+
+  if (!CONSP (crop))
+    return;
+  else
+    {
+      w = XCAR (crop);
+      crop = XCDR (crop);
+      if (CONSP (crop))
+	{
+          h = XCAR (crop);
+	  crop = XCDR (crop);
+	  if (CONSP (crop))
+	    {
+              x = XCAR (crop);
+	      crop = XCDR (crop);
+	      if (CONSP (crop))
+                y = XCAR (crop);
+	    }
+	}
+    }
+
+  if (FIXNATP (w) && XFIXNAT (w) < img->width)
+    width = XFIXNAT (w);
+  else
+    width = img->width;
+
+  if (TYPE_RANGED_FIXNUMP (int, x))
     {
-      double xscale = img->width / (double) width;
-      double yscale = img->height / (double) height;
+      left = XFIXNUM (x);
+      if (left < 0)
+        left = img->width - width + left;
+    }
+  else
+    left = (img->width - width)/2;
 
-      XTransform tmat
-	= {{{XDoubleToFixed (xscale), XDoubleToFixed (0), XDoubleToFixed (0)},
-	    {XDoubleToFixed (0), XDoubleToFixed (yscale), XDoubleToFixed (0)},
-	    {XDoubleToFixed (0), XDoubleToFixed (0), XDoubleToFixed (1)}}};
+  if (FIXNATP (h) && XFIXNAT (h) < img->height)
+    height = XFIXNAT (h);
+  else
+    height = img->height;
 
-      XRenderSetPictureFilter (FRAME_X_DISPLAY (f), img->picture, FilterBest,
-			       0, 0);
-      XRenderSetPictureTransform (FRAME_X_DISPLAY (f), img->picture, &tmat);
+  if (TYPE_RANGED_FIXNUMP (int, y))
+    {
+      top = XFIXNUM (y);
+      if (top < 0)
+        top = img->height - height + top;
+    }
+  else
+    top = (img->height - height)/2;
+
+  /* Negative values operate from the right and bottom of the image
+     instead of the left and top.  */
+  if (left < 0)
+    {
+      width = img->width + left;
+      left = 0;
+    }
+
+  if (width + left > img->width)
+    width = img->width - left;
 
-      img->width = width;
-      img->height = height;
+  if (top < 0)
+    {
+      height = img->height + top;
+      top = 0;
     }
+
+  if (height + top > img->height)
+    height = img->height - top;
+
+  INIT_MATRIX (m);
+  m[2][0] = left;
+  m[2][1] = top;
+
+  MULT_MATRICES (tm, m, tmp);
+  COPY_MATRIX (tmp, tm);
+
+  img->width = width;
+  img->height = height;
+#endif
+}
+
+static void
+image_set_size (struct image *img, double tm[3][3])
+{
+#ifdef HAVE_NATIVE_TRANSFORMS
+# ifdef HAVE_IMAGEMAGICK
+  /* ImageMagick images are already the correct size.  */
+  if (EQ (image_spec_value (img->spec, QCtype, NULL), Qimagemagick))
+    return;
+# endif
+
+# ifdef HAVE_XRENDER
+  if (!img->picture)
+    return;
 # endif
+
+  int width, height;
+
+  compute_image_size (img->width, img->height, img->spec, &width, &height);
+
+# if defined (HAVE_NS) || defined (HAVE_XRENDER)
+  double rm[3][3], tmp[3][3];
+  double xscale, yscale;
+
+  xscale = img->width / (double) width;
+  yscale = img->height / (double) height;
+
+  INIT_MATRIX (rm);
+  rm[0][0] = xscale;
+  rm[1][1] = yscale;
+
+  MULT_MATRICES (tm, rm, tmp);
+  COPY_MATRIX (tmp, tm);
+
+  img->width = width;
+  img->height = height;
+# endif
+
 # ifdef HAVE_NTGUI
   /* Under HAVE_NTGUI, we will scale the image on the fly, when we
      draw it.  See w32term.c:x_draw_image_foreground.  */
@@ -1909,6 +2184,36 @@ x_set_image_size (struct frame *f, struct image *img)
 #endif
 }
 
+static void
+image_set_transform (struct frame *f, struct image *img, double matrix[3][3])
+{
+  /* TODO: Add MS Windows support.  */
+#ifdef HAVE_NATIVE_TRANSFORMS
+# if defined (HAVE_NS)
+  /* Under NS the transform is applied to the drawing surface at
+     drawing time, so store it for later.  */
+  ns_image_set_transform (img->pixmap, matrix);
+# elif defined (HAVE_XRENDER)
+  if (img->picture)
+    {
+      XTransform tmat
+	= {{{XDoubleToFixed (matrix[0][0]),
+             XDoubleToFixed (matrix[1][0]),
+             XDoubleToFixed (matrix[2][0])},
+	    {XDoubleToFixed (matrix[0][1]),
+             XDoubleToFixed (matrix[1][1]),
+             XDoubleToFixed (matrix[2][1])},
+	    {XDoubleToFixed (matrix[0][2]),
+             XDoubleToFixed (matrix[1][2]),
+             XDoubleToFixed (matrix[2][2])}}};
+
+      XRenderSetPictureFilter (FRAME_X_DISPLAY (f), img->picture, FilterBest,
+			       0, 0);
+      XRenderSetPictureTransform (FRAME_X_DISPLAY (f), img->picture, &tmat);
+    }
+# endif
+#endif
+}
 
 /* Return the id of image with Lisp specification SPEC on frame F.
    SPEC must be a valid Lisp image specification (see valid_image_p).  */
@@ -1964,7 +2269,16 @@ lookup_image (struct frame *f, Lisp_Object spec)
 	     `:background COLOR'.  */
 	  Lisp_Object ascent, margin, relief, bg;
 	  int relief_bound;
-          x_set_image_size (f, img);
+
+#ifdef HAVE_NATIVE_TRANSFORMS
+          double transform_matrix[3][3];
+
+          INIT_MATRIX (transform_matrix);
+          image_set_size (img, transform_matrix);
+          image_set_crop (img, transform_matrix);
+          image_set_rotation (img, transform_matrix);
+          image_set_transform (f, img, transform_matrix);
+#endif
 
 	  ascent = image_spec_value (spec, QCascent, NULL);
 	  if (FIXNUMP (ascent))
@@ -1996,8 +2310,8 @@ lookup_image (struct frame *f, Lisp_Object spec)
 	      if (!NILP (bg))
 		{
 		  img->background
-		    = x_alloc_image_color (f, img, bg,
-					   FRAME_BACKGROUND_PIXEL (f));
+		    = image_alloc_image_color (f, img, bg,
+                                               FRAME_BACKGROUND_PIXEL (f));
 		  img->background_valid = 1;
 		}
 	    }
@@ -2089,14 +2403,10 @@ mark_image_cache (struct image_cache *c)
 			  X / NS / W32 support code
  ***********************************************************************/
 
-/* Return true if XIMG's size WIDTH x HEIGHT doesn't break the
-   windowing system.
-   WIDTH and HEIGHT must both be positive.
-   If XIMG is null, assume it is a bitmap.  */
+#ifdef HAVE_X_WINDOWS
 static bool
-x_check_image_size (XImagePtr ximg, int width, int height)
+x_check_image_size (XImage *ximg, int width, int height)
 {
-#ifdef HAVE_X_WINDOWS
   /* Respect Xlib's limits: it cannot deal with images that have more
      than INT_MAX (and/or UINT_MAX) bytes.  And respect Emacs's limits
      of PTRDIFF_MAX (and/or SIZE_MAX) bytes for any object.  */
@@ -2121,27 +2431,12 @@ x_check_image_size (XImagePtr ximg, int width, int height)
     }
   return (width <= (INT_MAX - (bitmap_pad - 1)) / depth
 	  && height <= X_IMAGE_BYTES_MAX / bytes_per_line);
-#else
-  /* FIXME: Implement this check for the HAVE_NS and HAVE_NTGUI cases.
-     For now, assume that every image size is allowed on these systems.  */
-  return 1;
-#endif
 }
 
-/* Create an XImage and a pixmap of size WIDTH x HEIGHT for use on
-   frame F.  Set *XIMG and *PIXMAP to the XImage and Pixmap created.
-   Set (*XIMG)->data to a raster of WIDTH x HEIGHT pixels allocated
-   via xmalloc.  Print error messages via image_error if an error
-   occurs.  Value is true if successful.
-
-   On W32, a DEPTH of zero signifies a 24 bit image, otherwise DEPTH
-   should indicate the bit depth of the image.  */
-
 static bool
 x_create_x_image_and_pixmap (struct frame *f, int width, int height, int depth,
-			     XImagePtr *ximg, Pixmap *pixmap, Picture *picture)
+			     XImage **ximg, Pixmap *pixmap)
 {
-#ifdef HAVE_X_WINDOWS
   Display *display = FRAME_X_DISPLAY (f);
   Drawable drawable = FRAME_X_DRAWABLE (f);
   Screen *screen = FRAME_X_SCREEN (f);
@@ -2181,10 +2476,78 @@ x_create_x_image_and_pixmap (struct frame *f, int width, int height, int depth,
       return 0;
     }
 
+  return 1;
+}
+
+static void
+x_destroy_x_image (XImage *ximg)
+{
+  eassert (input_blocked_p ());
+  if (ximg)
+    {
+      xfree (ximg->data);
+      ximg->data = NULL;
+    }
+}
+
+#endif	/* HAVE_X_WINDOWS */
+
+/* Return true if XIMG's size WIDTH x HEIGHT doesn't break the
+   windowing system.
+   WIDTH and HEIGHT must both be positive.
+   If XIMG is null, assume it is a bitmap.  */
+
+static bool
+image_check_image_size (Emacs_Pix_Container ximg, int width, int height)
+{
+#if defined HAVE_X_WINDOWS && !defined USE_CAIRO
+  return x_check_image_size (ximg, width, height);
+#else
+  /* FIXME: Implement this check for the HAVE_NS and HAVE_NTGUI cases.
+     For now, assume that every image size is allowed on these systems.  */
+  return 1;
+#endif
+}
+
+/* Create an Emacs_Pix_Container and a pixmap of size WIDTH x
+   HEIGHT for use on frame F.  Set *PIMG and *PIXMAP to the
+   Emacs_Pix_Container and Emacs_Pixmap created.  Set (*PIMG)->data
+   to a raster of WIDTH x HEIGHT pixels allocated via xmalloc.  Print
+   error messages via image_error if an error occurs.  Value is true
+   if successful.
+
+   On W32, a DEPTH of zero signifies a 24 bit image, otherwise DEPTH
+   should indicate the bit depth of the image.  */
+
+static bool
+image_create_x_image_and_pixmap_1 (struct frame *f, int width, int height, int depth,
+                                   Emacs_Pix_Container *pimg,
+                                   Emacs_Pixmap *pixmap, Picture *picture)
+{
+#ifdef USE_CAIRO
+  eassert (input_blocked_p ());
+
+  /* Allocate a pixmap of the same size.  */
+  *pixmap = image_create_pix_container (f, width, height, depth);
+  if (*pixmap == NO_PIXMAP)
+    {
+      *pimg = NULL;
+      image_error ("Unable to create X pixmap", Qnil, Qnil);
+      return 0;
+    }
+
+  *pimg = *pixmap;
+  return 1;
+#elif defined HAVE_X_WINDOWS
+  if (!x_create_x_image_and_pixmap (f, width, height, depth, pimg, pixmap))
+    return 0;
 # ifdef HAVE_XRENDER
+  Display *display = FRAME_X_DISPLAY (f);
   int event_basep, error_basep;
   if (picture && XRenderQueryExtension (display, &event_basep, &error_basep))
     {
+      if (depth <= 0)
+	depth = DefaultDepthOfScreen (FRAME_X_SCREEN (f));
       if (depth == 32 || depth == 24 || depth == 8)
         {
           XRenderPictFormat *format;
@@ -2243,10 +2606,10 @@ x_create_x_image_and_pixmap (struct frame *f, int width, int height, int depth,
   if (depth < 16)
     palette_colors = 1 << (depth - 1);
 
-  *ximg = xmalloc (sizeof (XImage) + palette_colors * sizeof (RGBQUAD));
+  *pimg = xmalloc (sizeof (XImage) + palette_colors * sizeof (RGBQUAD));
 
-  header = &(*ximg)->info.bmiHeader;
-  memset (&(*ximg)->info, 0, sizeof (BITMAPINFO));
+  header = &(*pimg)->info.bmiHeader;
+  memset (&(*pimg)->info, 0, sizeof (BITMAPINFO));
   header->biSize = sizeof (*header);
   header->biWidth = width;
   header->biHeight = -height;  /* negative indicates a top-down bitmap.  */
@@ -2258,10 +2621,10 @@ x_create_x_image_and_pixmap (struct frame *f, int width, int height, int depth,
   /* TODO: fill in palette.  */
   if (depth == 1)
     {
-      (*ximg)->info.bmiColors[0].rgbBlue = 0;
-      (*ximg)->info.bmiColors[0].rgbGreen = 0;
-      (*ximg)->info.bmiColors[0].rgbRed = 0;
-      (*ximg)->info.bmiColors[0].rgbReserved = 0;
+      (*pimg)->info.bmiColors[0].rgbBlue = 0;
+      (*pimg)->info.bmiColors[0].rgbGreen = 0;
+      (*pimg)->info.bmiColors[0].rgbRed = 0;
+      (*pimg)->info.bmiColors[0].rgbReserved = 0;
       /* bmiColors is a variable-length array declared by w32api
 	 headers as bmiColors[1], which triggers a warning under
 	 -Warray-bounds; shut that up.  */
@@ -2269,10 +2632,10 @@ x_create_x_image_and_pixmap (struct frame *f, int width, int height, int depth,
 #      pragma GCC push_options
 #      pragma GCC diagnostic ignored "-Warray-bounds"
 #     endif
-      (*ximg)->info.bmiColors[1].rgbBlue = 255;
-      (*ximg)->info.bmiColors[1].rgbGreen = 255;
-      (*ximg)->info.bmiColors[1].rgbRed = 255;
-      (*ximg)->info.bmiColors[1].rgbReserved = 0;
+      (*pimg)->info.bmiColors[1].rgbBlue = 255;
+      (*pimg)->info.bmiColors[1].rgbGreen = 255;
+      (*pimg)->info.bmiColors[1].rgbRed = 255;
+      (*pimg)->info.bmiColors[1].rgbReserved = 0;
 #     if GNUC_PREREQ (4, 4, 0)
 #      pragma GCC pop_options
 #     endif
@@ -2282,10 +2645,10 @@ x_create_x_image_and_pixmap (struct frame *f, int width, int height, int depth,
 
   /* Create a DIBSection and raster array for the bitmap,
      and store its handle in *pixmap.  */
-  *pixmap = CreateDIBSection (hdc, &((*ximg)->info),
+  *pixmap = CreateDIBSection (hdc, &((*pimg)->info),
 			      (depth < 16) ? DIB_PAL_COLORS : DIB_RGB_COLORS,
 			      /* casting avoids a GCC warning */
-			      (void **)&((*ximg)->data), NULL, 0);
+			      (void **)&((*pimg)->data), NULL, 0);
 
   /* Realize display palette and garbage all frames. */
   release_frame_dc (f, hdc);
@@ -2297,8 +2660,8 @@ x_create_x_image_and_pixmap (struct frame *f, int width, int height, int depth,
       /* All system errors are < 10000, so the following is safe.  */
       XSETINT (errcode, err);
       image_error ("Unable to create bitmap, error code %d", errcode);
-      x_destroy_x_image (*ximg);
-      *ximg = NULL;
+      image_destroy_x_image (*pimg);
+      *pimg = NULL;
       return 0;
     }
 
@@ -2310,78 +2673,83 @@ x_create_x_image_and_pixmap (struct frame *f, int width, int height, int depth,
   *pixmap = ns_image_for_XPM (width, height, depth);
   if (*pixmap == 0)
     {
-      *ximg = NULL;
+      *pimg = NULL;
       image_error ("Unable to allocate NSImage for XPM pixmap");
       return 0;
     }
-  *ximg = *pixmap;
+  *pimg = *pixmap;
   return 1;
 #endif
 }
 
 
-/* Destroy XImage XIMG.  Free XIMG->data.  */
+/* Destroy Emacs_Pix_Container PIMG.  Free data associated with PIMG.  */
 
 static void
-x_destroy_x_image (XImagePtr ximg)
+image_destroy_x_image (Emacs_Pix_Container pimg)
 {
+#if defined HAVE_X_WINDOWS && !defined USE_CAIRO
+  x_destroy_x_image (pimg);
+#else
   eassert (input_blocked_p ());
-  if (ximg)
+  if (pimg)
     {
-#ifdef HAVE_X_WINDOWS
-      xfree (ximg->data);
-      ximg->data = NULL;
-      XDestroyImage (ximg);
-#endif /* HAVE_X_WINDOWS */
+#ifdef USE_CAIRO
+#endif	/* USE_CAIRO */
 #ifdef HAVE_NTGUI
       /* Data will be freed by DestroyObject.  */
-      ximg->data = NULL;
-      xfree (ximg);
+      pimg->data = NULL;
+      xfree (pimg);
 #endif /* HAVE_NTGUI */
 #ifdef HAVE_NS
-      ns_release_object (ximg);
+      ns_release_object (pimg);
 #endif /* HAVE_NS */
     }
+#endif
 }
 
 
-/* Put XImage XIMG into pixmap PIXMAP on frame F.  WIDTH and HEIGHT
-   are width and height of both the image and pixmap.  */
+/* Put Emacs_Pix_Container PIMG into pixmap PIXMAP on frame F.
+   WIDTH and HEIGHT are width and height of both the image and
+   pixmap.  */
 
 static void
-x_put_x_image (struct frame *f, XImagePtr ximg, Pixmap pixmap, int width, int height)
+gui_put_x_image (struct frame *f, Emacs_Pix_Container pimg,
+                 Emacs_Pixmap pixmap, int width, int height)
 {
-#ifdef HAVE_X_WINDOWS
+#ifdef USE_CAIRO
+  eassert (pimg == pixmap);
+#elif defined HAVE_X_WINDOWS
   GC gc;
 
   eassert (input_blocked_p ());
   gc = XCreateGC (FRAME_X_DISPLAY (f), pixmap, 0, NULL);
-  XPutImage (FRAME_X_DISPLAY (f), pixmap, gc, ximg, 0, 0, 0, 0,
-             ximg->width, ximg->height);
+  XPutImage (FRAME_X_DISPLAY (f), pixmap, gc, pimg, 0, 0, 0, 0,
+             pimg->width, pimg->height);
   XFreeGC (FRAME_X_DISPLAY (f), gc);
 #endif /* HAVE_X_WINDOWS */
 
 #ifdef HAVE_NTGUI
 #if 0  /* I don't think this is necessary looking at where it is used.  */
   HDC hdc = get_frame_dc (f);
-  SetDIBits (hdc, pixmap, 0, height, ximg->data, &(ximg->info), DIB_RGB_COLORS);
+  SetDIBits (hdc, pixmap, 0, height, pimg->data, &(pimg->info), DIB_RGB_COLORS);
   release_frame_dc (f, hdc);
 #endif
 #endif /* HAVE_NTGUI */
 
 #ifdef HAVE_NS
-  eassert (ximg == pixmap);
-  ns_retain_object (ximg);
+  eassert (pimg == pixmap);
+  ns_retain_object (pimg);
 #endif
 }
 
-/* Thin wrapper for x_create_x_image_and_pixmap, so that it matches
+/* Thin wrapper for image_create_x_image_and_pixmap_1, so that it matches
    with image_put_x_image.  */
 
 static bool
 image_create_x_image_and_pixmap (struct frame *f, struct image *img,
 				 int width, int height, int depth,
-				 XImagePtr *ximg, bool mask_p)
+				 Emacs_Pix_Container *ximg, bool mask_p)
 {
   eassert ((!mask_p ? img->pixmap : img->mask) == NO_PIXMAP);
 
@@ -2389,22 +2757,22 @@ image_create_x_image_and_pixmap (struct frame *f, struct image *img,
 #ifdef HAVE_XRENDER
   picture = !mask_p ? &img->picture : &img->mask_picture;
 #endif
-  return x_create_x_image_and_pixmap (f, width, height, depth, ximg,
-				      !mask_p ? &img->pixmap : &img->mask,
-				      picture);
+  return image_create_x_image_and_pixmap_1 (f, width, height, depth, ximg,
+                                            !mask_p ? &img->pixmap : &img->mask,
+                                            picture);
 }
 
-/* Put X image XIMG into image IMG on frame F, as a mask if and only
-   if MASK_P.  On X, this simply records XIMG on a member of IMG, so
+/* Put pixel image PIMG into image IMG on frame F, as a mask if and only
+   if MASK_P.  On X, this simply records PIMG on a member of IMG, so
    it can be put into the pixmap afterwards via image_sync_to_pixmaps.
-   On the other platforms, it puts XIMG into the pixmap, then frees
-   the X image and its buffer.  */
+   On the other platforms, it puts PIMG into the pixmap, then frees
+   the pixel image and its buffer.  */
 
 static void
-image_put_x_image (struct frame *f, struct image *img, XImagePtr ximg,
+image_put_x_image (struct frame *f, struct image *img, Emacs_Pix_Container ximg,
 		   bool mask_p)
 {
-#ifdef HAVE_X_WINDOWS
+#if defined HAVE_X_WINDOWS && !defined USE_CAIRO
   if (!mask_p)
     {
       eassert (img->ximg == NULL);
@@ -2416,13 +2784,13 @@ image_put_x_image (struct frame *f, struct image *img, XImagePtr ximg,
       img->mask_img = ximg;
     }
 #else
-  x_put_x_image (f, ximg, !mask_p ? img->pixmap : img->mask,
-		 img->width, img->height);
-  x_destroy_x_image (ximg);
+  gui_put_x_image (f, ximg, !mask_p ? img->pixmap : img->mask,
+                   img->width, img->height);
+  image_destroy_x_image (ximg);
 #endif
 }
 
-#ifdef HAVE_X_WINDOWS
+#if defined HAVE_X_WINDOWS && !defined USE_CAIRO
 /* Put the X images recorded in IMG on frame F into pixmaps, then free
    the X images and their buffers.  */
 
@@ -2431,14 +2799,14 @@ image_sync_to_pixmaps (struct frame *f, struct image *img)
 {
   if (img->ximg)
     {
-      x_put_x_image (f, img->ximg, img->pixmap, img->width, img->height);
-      x_destroy_x_image (img->ximg);
+      gui_put_x_image (f, img->ximg, img->pixmap, img->width, img->height);
+      image_destroy_x_image (img->ximg);
       img->ximg = NULL;
     }
   if (img->mask_img)
     {
-      x_put_x_image (f, img->mask_img, img->mask, img->width, img->height);
-      x_destroy_x_image (img->mask_img);
+      gui_put_x_image (f, img->mask_img, img->mask, img->width, img->height);
+      image_destroy_x_image (img->mask_img);
       img->mask_img = NULL;
     }
 }
@@ -2449,12 +2817,12 @@ image_sync_to_pixmaps (struct frame *f, struct image *img)
    currently selected GDI object into *PREV for future restoration by
    image_unget_x_image_or_dc.  */
 
-static XImagePtr_or_DC
+static HDC
 image_get_x_image_or_dc (struct frame *f, struct image *img, bool mask_p,
 			 HGDIOBJ *prev)
 {
   HDC frame_dc = get_frame_dc (f);
-  XImagePtr_or_DC ximg = CreateCompatibleDC (frame_dc);
+  HDC ximg = CreateCompatibleDC (frame_dc);
 
   release_frame_dc (f, frame_dc);
   *prev = SelectObject (ximg, !mask_p ? img->pixmap : img->mask);
@@ -2464,7 +2832,7 @@ image_get_x_image_or_dc (struct frame *f, struct image *img, bool mask_p,
 
 static void
 image_unget_x_image_or_dc (struct image *img, bool mask_p,
-			   XImagePtr_or_DC ximg, HGDIOBJ prev)
+			   HDC ximg, HGDIOBJ prev)
 {
   SelectObject (ximg, prev);
   DeleteDC (ximg);
@@ -2473,11 +2841,13 @@ image_unget_x_image_or_dc (struct image *img, bool mask_p,
 /* Get the X image for IMG on frame F.  The resulting X image data
    should be treated as read-only at least on X.  */
 
-static XImagePtr
+static Emacs_Pix_Container
 image_get_x_image (struct frame *f, struct image *img, bool mask_p)
 {
-#ifdef HAVE_X_WINDOWS
-  XImagePtr ximg_in_img = !mask_p ? img->ximg : img->mask_img;
+#ifdef USE_CAIRO
+  return !mask_p ? img->pixmap : img->mask;
+#elif defined HAVE_X_WINDOWS
+  XImage *ximg_in_img = !mask_p ? img->ximg : img->mask_img;
 
   if (ximg_in_img)
     return ximg_in_img;
@@ -2485,7 +2855,7 @@ image_get_x_image (struct frame *f, struct image *img, bool mask_p)
     return XGetImage (FRAME_X_DISPLAY (f), !mask_p ? img->pixmap : img->mask,
 		      0, 0, img->width, img->height, ~0, ZPixmap);
 #elif defined (HAVE_NS)
-  XImagePtr pixmap = !mask_p ? img->pixmap : img->mask;
+  Emacs_Pix_Container pixmap = !mask_p ? img->pixmap : img->mask;
 
   ns_retain_object (pixmap);
   return pixmap;
@@ -2493,10 +2863,11 @@ image_get_x_image (struct frame *f, struct image *img, bool mask_p)
 }
 
 static void
-image_unget_x_image (struct image *img, bool mask_p, XImagePtr ximg)
+image_unget_x_image (struct image *img, bool mask_p, Emacs_Pix_Container ximg)
 {
-#ifdef HAVE_X_WINDOWS
-  XImagePtr ximg_in_img = !mask_p ? img->ximg : img->mask_img;
+#ifdef USE_CAIRO
+#elif defined HAVE_X_WINDOWS
+  XImage *ximg_in_img = !mask_p ? img->ximg : img->mask_img;
 
   if (ximg_in_img)
     eassert (ximg == ximg_in_img);
@@ -2520,7 +2891,7 @@ image_unget_x_image (struct image *img, bool mask_p, XImagePtr ximg)
    PFD is null, do not open the file.  */
 
 static Lisp_Object
-x_find_image_fd (Lisp_Object file, int *pfd)
+image_find_image_fd (Lisp_Object file, int *pfd)
 {
   Lisp_Object file_found, search_path;
   int fd;
@@ -2558,9 +2929,9 @@ x_find_image_fd (Lisp_Object file, int *pfd)
    found, or nil if not found.  */
 
 Lisp_Object
-x_find_image_file (Lisp_Object file)
+image_find_image_file (Lisp_Object file)
 {
-  return x_find_image_fd (file, 0);
+  return image_find_image_fd (file, 0);
 }
 
 /* Read FILE into memory.  Value is a pointer to a buffer allocated
@@ -2609,8 +2980,6 @@ slurp_file (int fd, ptrdiff_t *size)
 			      XBM images
  ***********************************************************************/
 
-static bool xbm_load (struct frame *f, struct image *img);
-static bool xbm_image_p (Lisp_Object object);
 static bool xbm_file_p (Lisp_Object);
 
 
@@ -2654,18 +3023,6 @@ static const struct image_keyword xbm_format[XBM_LAST] =
   {":mask",		IMAGE_DONT_CHECK_VALUE_TYPE,		0}
 };
 
-/* Structure describing the image type XBM.  */
-
-static struct image_type xbm_type =
-{
-  SYMBOL_INDEX (Qxbm),
-  xbm_image_p,
-  xbm_load,
-  x_clear_image,
-  NULL,
-  NULL
-};
-
 /* Tokens returned from xbm_scan.  */
 
 enum xbm_token
@@ -2968,28 +3325,32 @@ Create_Pixmap_From_Bitmap_Data (struct frame *f, struct image *img, char *data,
 				RGB_PIXEL_COLOR fg, RGB_PIXEL_COLOR bg,
 				bool non_default_colors)
 {
-#ifdef HAVE_NTGUI
+#ifdef USE_CAIRO
+  Emacs_Color fgbg[] = {{.pixel = fg}, {.pixel = bg}};
+  FRAME_TERMINAL (f)->query_colors (f, fgbg, ARRAYELTS (fgbg));
+  fg = lookup_rgb_color (f, fgbg[0].red, fgbg[0].green, fgbg[0].blue);
+  bg = lookup_rgb_color (f, fgbg[1].red, fgbg[1].green, fgbg[1].blue);
+  img->pixmap
+    = image_pix_container_create_from_bitmap_data (f, data, img->width,
+						   img->height, fg, bg);
+#elif defined HAVE_X_WINDOWS
+  img->pixmap
+    = XCreatePixmapFromBitmapData (FRAME_X_DISPLAY (f),
+				   FRAME_X_DRAWABLE (f),
+				   data,
+				   img->width, img->height,
+				   fg, bg,
+				   DefaultDepthOfScreen (FRAME_X_SCREEN (f)));
+#elif defined HAVE_NTGUI
   img->pixmap
     = w32_create_pixmap_from_bitmap_data (img->width, img->height, data);
 
   /* If colors were specified, transfer the bitmap to a color one.  */
   if (non_default_colors)
     convert_mono_to_color_image (f, img, fg, bg);
-
-#elif defined (HAVE_NS)
+#elif defined HAVE_NS
   img->pixmap = ns_image_from_XBM (data, img->width, img->height, fg, bg);
-
-#else
-  img->pixmap =
-   (x_check_image_size (0, img->width, img->height)
-    ? XCreatePixmapFromBitmapData (FRAME_X_DISPLAY (f),
-                                   FRAME_X_DRAWABLE (f),
-				   data,
-				   img->width, img->height,
-				   fg, bg,
-				   DefaultDepthOfScreen (FRAME_X_SCREEN (f)))
-    : NO_PIXMAP);
-#endif /* !HAVE_NTGUI && !HAVE_NS */
+#endif
 }
 
 
@@ -3098,7 +3459,7 @@ xbm_read_bitmap_data (struct frame *f, char *contents, char *end,
   expect ('=');
   expect ('{');
 
-  if (! x_check_image_size (0, *width, *height))
+  if (! image_check_image_size (0, *width, *height))
     {
       if (!inhibit_image_error)
 	image_error ("Image too large (%dx%d)",
@@ -3186,26 +3547,29 @@ xbm_load_image (struct frame *f, struct image *img, char *contents, char *end)
       value = image_spec_value (img->spec, QCforeground, NULL);
       if (!NILP (value))
 	{
-	  foreground = x_alloc_image_color (f, img, value, foreground);
+	  foreground = image_alloc_image_color (f, img, value, foreground);
 	  non_default_colors = 1;
 	}
       value = image_spec_value (img->spec, QCbackground, NULL);
       if (!NILP (value))
 	{
-	  background = x_alloc_image_color (f, img, value, background);
+	  background = image_alloc_image_color (f, img, value, background);
 	  img->background = background;
 	  img->background_valid = 1;
 	  non_default_colors = 1;
 	}
 
-      Create_Pixmap_From_Bitmap_Data (f, img, data,
-				      foreground, background,
-				      non_default_colors);
+      if (image_check_image_size (0, img->width, img->height))
+	Create_Pixmap_From_Bitmap_Data (f, img, data,
+					foreground, background,
+					non_default_colors);
+      else
+	img->pixmap = NO_PIXMAP;
       xfree (data);
 
       if (img->pixmap == NO_PIXMAP)
 	{
-	  x_clear_image (f, img);
+	  image_clear_image (f, img);
 	  image_error ("Unable to create X pixmap for `%s'", img->spec);
 	}
       else
@@ -3247,7 +3611,7 @@ xbm_load (struct frame *f, struct image *img)
   if (STRINGP (file_name))
     {
       int fd;
-      Lisp_Object file = x_find_image_fd (file_name, &fd);
+      Lisp_Object file = image_find_image_fd (file_name, &fd);
       if (!STRINGP (file))
 	{
 	  image_error ("Cannot find image file `%s'", file_name);
@@ -3302,16 +3666,20 @@ xbm_load (struct frame *f, struct image *img)
       if (fmt[XBM_FOREGROUND].count
 	  && STRINGP (fmt[XBM_FOREGROUND].value))
 	{
-	  foreground = x_alloc_image_color (f, img, fmt[XBM_FOREGROUND].value,
-					    foreground);
+	  foreground = image_alloc_image_color (f,
+                                                img,
+                                                fmt[XBM_FOREGROUND].value,
+                                                foreground);
 	  non_default_colors = 1;
 	}
 
       if (fmt[XBM_BACKGROUND].count
 	  && STRINGP (fmt[XBM_BACKGROUND].value))
 	{
-	  background = x_alloc_image_color (f, img, fmt[XBM_BACKGROUND].value,
-					    background);
+	  background = image_alloc_image_color (f,
+                                                img,
+                                                fmt[XBM_BACKGROUND].value,
+                                                background);
 	  non_default_colors = 1;
 	}
 
@@ -3358,7 +3726,7 @@ xbm_load (struct frame *f, struct image *img)
 #endif
 	  /* Create the pixmap.  */
 
-	  if (x_check_image_size (0, img->width, img->height))
+	  if (image_check_image_size (0, img->width, img->height))
 	    Create_Pixmap_From_Bitmap_Data (f, img, bits,
 					    foreground, background,
 					    non_default_colors);
@@ -3371,7 +3739,7 @@ xbm_load (struct frame *f, struct image *img)
 	    {
 	      image_error ("Unable to create pixmap for XBM image `%s'",
 			   img->spec);
-	      x_clear_image (f, img);
+	      image_clear_image (f, img);
 	    }
 
 	  SAFE_FREE ();
@@ -3387,13 +3755,6 @@ xbm_load (struct frame *f, struct image *img)
 			      XPM images
  ***********************************************************************/
 
-#if defined (HAVE_XPM) || defined (HAVE_NS)
-
-static bool xpm_image_p (Lisp_Object object);
-static bool xpm_load (struct frame *f, struct image *img);
-
-#endif /* HAVE_XPM || HAVE_NS */
-
 #ifdef HAVE_XPM
 #ifdef HAVE_NTGUI
 /* Indicate to xpm.h that we don't have Xlib.  */
@@ -3417,7 +3778,7 @@ static bool xpm_load (struct frame *f, struct image *img);
 #endif /* not HAVE_NTGUI */
 #endif /* HAVE_XPM */
 
-#if defined (HAVE_XPM) || defined (HAVE_NS)
+#if defined HAVE_XPM || defined USE_CAIRO || defined HAVE_NS
 
 /* Indices of image specification fields in xpm_format, below.  */
 
@@ -3455,37 +3816,17 @@ static const struct image_keyword xpm_format[XPM_LAST] =
   {":background",	IMAGE_STRING_OR_NIL_VALUE,		0}
 };
 
-#if defined HAVE_NTGUI && defined WINDOWSNT
-static bool init_xpm_functions (void);
-#else
-#define init_xpm_functions NULL
-#endif
-
-/* Structure describing the image type XPM.  */
-
-static struct image_type xpm_type =
-{
-  SYMBOL_INDEX (Qxpm),
-  xpm_image_p,
-  xpm_load,
-  x_clear_image,
-  init_xpm_functions,
-  NULL
-};
-
-#ifdef HAVE_X_WINDOWS
+#if defined HAVE_X_WINDOWS && !defined USE_CAIRO
 
 /* Define ALLOC_XPM_COLORS if we can use Emacs' own color allocation
    functions for allocating image colors.  Our own functions handle
    color allocation failures more gracefully than the ones on the XPM
    lib.  */
 
-#ifndef USE_CAIRO
 #if defined XpmAllocColor && defined XpmFreeColors && defined XpmColorClosure
 #define ALLOC_XPM_COLORS
 #endif
-#endif /* USE_CAIRO */
-#endif /* HAVE_X_WINDOWS */
+#endif /* HAVE_X_WINDOWS && !USE_CAIRO */
 
 #ifdef ALLOC_XPM_COLORS
 
@@ -3734,7 +4075,7 @@ xpm_image_p (Lisp_Object object)
 	      || xpm_valid_color_symbols_p (fmt[XPM_COLOR_SYMBOLS].value)));
 }
 
-#endif /* HAVE_XPM || HAVE_NS */
+#endif /* HAVE_XPM || USE_CAIRO || HAVE_NS */
 
 #if defined HAVE_XPM && defined HAVE_X_WINDOWS && !defined USE_GTK
 ptrdiff_t
@@ -3769,7 +4110,7 @@ x_create_bitmap_from_xpm_data (struct frame *f, const char **bits)
       return -1;
     }
 
-  id = x_allocate_bitmap_record (f);
+  id = image_allocate_bitmap_record (f);
   dpyinfo->bitmaps[id - 1].pixmap = bitmap;
   dpyinfo->bitmaps[id - 1].have_mask = true;
   dpyinfo->bitmaps[id - 1].mask = mask;
@@ -3778,6 +4119,9 @@ x_create_bitmap_from_xpm_data (struct frame *f, const char **bits)
   dpyinfo->bitmaps[id - 1].width = attrs.width;
   dpyinfo->bitmaps[id - 1].depth = attrs.depth;
   dpyinfo->bitmaps[id - 1].refcount = 1;
+#ifdef USE_CAIRO
+  dpyinfo->bitmaps[id - 1].stipple = NULL;
+#endif	/* USE_CAIRO */
 
 #ifdef ALLOC_XPM_COLORS
   xpm_free_color_cache ();
@@ -3790,7 +4134,7 @@ x_create_bitmap_from_xpm_data (struct frame *f, const char **bits)
 /* Load image IMG which will be displayed on frame F.  Value is
    true if successful.  */
 
-#ifdef HAVE_XPM
+#if defined HAVE_XPM && !defined USE_CAIRO
 
 static bool
 xpm_load (struct frame *f, struct image *img)
@@ -3903,7 +4247,7 @@ xpm_load (struct frame *f, struct image *img)
 
   if (STRINGP (specified_file))
     {
-      Lisp_Object file = x_find_image_file (specified_file);
+      Lisp_Object file = image_find_image_file (specified_file);
       if (!STRINGP (file))
 	{
 	  image_error ("Cannot find image file `%s'", specified_file);
@@ -3958,44 +4302,6 @@ xpm_load (struct frame *f, struct image *img)
 #endif /* HAVE_NTGUI */
     }
 
-#ifdef USE_CAIRO
-  /* Load very specific Xpm:s.  */
-  if (rc == XpmSuccess
-      && img->ximg->format == ZPixmap
-      && img->ximg->bits_per_pixel == 32
-      && (! img->mask_img || img->mask_img->bits_per_pixel == 1))
-    {
-      int width = img->ximg->width;
-      int height = img->ximg->height;
-      cairo_surface_t *surface = create_cairo_image_surface (width, height);
-      int i;
-      uint32_t *od = (uint32_t *) cairo_image_surface_get_data (surface);
-      uint32_t *id = (uint32_t *) img->ximg->data;
-      char *mid = img->mask_img ? img->mask_img->data : 0;
-      uint32_t bgcolor = get_spec_bg_or_alpha_as_argb (img, f);
-
-      for (i = 0; i < height; ++i)
-        {
-          int k;
-          for (k = 0; k < width; ++k)
-            {
-              int idx = i * img->ximg->bytes_per_line/4 + k;
-              int maskidx = mid ? i * img->mask_img->bytes_per_line + k/8 : 0;
-              int mask = mid ? mid[maskidx] & (1 << (k % 8)) : 1;
-
-              if (mask) od[idx] = id[idx] + 0xff000000; /* ff => full alpha */
-              else od[idx] = bgcolor;
-            }
-        }
-
-      set_cairo_image_surface (img, surface);
-    }
-  else
-    {
-      rc = XpmFileInvalid;
-      x_clear_image (f, img);
-    }
-#else
 #ifdef HAVE_X_WINDOWS
   if (rc == XpmSuccess)
     {
@@ -4004,7 +4310,7 @@ xpm_load (struct frame *f, struct image *img)
 				   img->ximg->depth);
       if (img->pixmap == NO_PIXMAP)
 	{
-	  x_clear_image (f, img);
+	  image_clear_image (f, img);
 	  rc = XpmNoMemory;
 	}
       else if (img->mask_img)
@@ -4015,13 +4321,12 @@ xpm_load (struct frame *f, struct image *img)
 				     img->mask_img->depth);
 	  if (img->mask == NO_PIXMAP)
 	    {
-	      x_clear_image (f, img);
+	      image_clear_image (f, img);
 	      rc = XpmNoMemory;
 	    }
 	}
     }
 #endif
-#endif /* ! USE_CAIRO */
 
   if (rc == XpmSuccess)
     {
@@ -4124,9 +4429,9 @@ xpm_load (struct frame *f, struct image *img)
   return rc == XpmSuccess;
 }
 
-#endif /* HAVE_XPM */
+#endif /* HAVE_XPM && !USE_CAIRO */
 
-#if defined (HAVE_NS) && !defined (HAVE_XPM)
+#if defined USE_CAIRO || (defined HAVE_NS && !defined HAVE_XPM)
 
 /* XPM support functions for NS where libxpm is not available.
    Only XPM version 3 (without any extensions) is supported.  */
@@ -4328,7 +4633,7 @@ xpm_load_image (struct frame *f,
 #ifndef HAVE_NS
   bool have_mask = false;
 #endif
-  XImagePtr ximg = NULL, mask_img = NULL;
+  Emacs_Pix_Container ximg = NULL, mask_img = NULL;
 
 #define match() \
      LA1 = xpm_scan (&s, end, &beg, &len)
@@ -4413,7 +4718,7 @@ xpm_load_image (struct frame *f,
       char *color, *max_color;
       int key, next_key, max_key = 0;
       Lisp_Object symbol_color = Qnil, color_val;
-      XColor cdef;
+      Emacs_Color cdef;
 
       expect (XPM_TK_STRING);
       if (len <= chars_per_pixel || len >= BUFSIZ + chars_per_pixel)
@@ -4464,17 +4769,21 @@ xpm_load_image (struct frame *f,
 	    {
 	      if (xstrcasecmp (SSDATA (XCDR (specified_color)), "None") == 0)
 		color_val = Qt;
-	      else if (x_defined_color (f, SSDATA (XCDR (specified_color)),
-					&cdef, 0))
-		color_val = make_fixnum (cdef.pixel);
+	      else if (FRAME_TERMINAL (f)->defined_color_hook
+                       (f, SSDATA (XCDR (specified_color)), &cdef, false, false))
+		color_val
+		  = make_fixnum (lookup_rgb_color (f, cdef.red, cdef.green,
+						   cdef.blue));
 	    }
 	}
       if (NILP (color_val) && max_key > 0)
 	{
 	  if (xstrcasecmp (max_color, "None") == 0)
 	    color_val = Qt;
-	  else if (x_defined_color (f, max_color, &cdef, 0))
-	    color_val = make_fixnum (cdef.pixel);
+	  else if (FRAME_TERMINAL (f)->defined_color_hook
+                   (f, max_color, &cdef, false, false))
+	    color_val = make_fixnum (lookup_rgb_color (f, cdef.red, cdef.green,
+						       cdef.blue));
 	}
       if (!NILP (color_val))
 	(*put_color_table) (color_table, beg, chars_per_pixel, color_val);
@@ -4482,6 +4791,14 @@ xpm_load_image (struct frame *f,
       expect (',');
     }
 
+  unsigned long frame_fg = FRAME_FOREGROUND_PIXEL (f);
+#ifdef USE_CAIRO
+  {
+    Emacs_Color color = {.pixel = frame_fg};
+    FRAME_TERMINAL (f)->query_colors (f, &color, 1);
+    frame_fg = lookup_rgb_color (f, color.red, color.green, color.blue);
+  }
+#endif
   for (y = 0; y < height; y++)
     {
       expect (XPM_TK_STRING);
@@ -4493,11 +4810,10 @@ xpm_load_image (struct frame *f,
 	  Lisp_Object color_val =
 	    (*get_color_table) (color_table, str, chars_per_pixel);
 
-	  XPutPixel (ximg, x, y,
-		     (FIXNUMP (color_val) ? XFIXNUM (color_val)
-		      : FRAME_FOREGROUND_PIXEL (f)));
+	  PUT_PIXEL (ximg, x, y,
+		     FIXNUMP (color_val) ? XFIXNUM (color_val) : frame_fg);
 #ifndef HAVE_NS
-	  XPutPixel (mask_img, x, y,
+	  PUT_PIXEL (mask_img, x, y,
 		     (!EQ (color_val, Qt) ? PIX_MASK_DRAW
 		      : (have_mask = true, PIX_MASK_RETAIN)));
 #else
@@ -4528,17 +4844,17 @@ xpm_load_image (struct frame *f,
     }
   else
     {
-      x_destroy_x_image (mask_img);
-      x_clear_image_1 (f, img, CLEAR_IMAGE_MASK);
+      image_destroy_x_image (mask_img);
+      image_clear_image_1 (f, img, CLEAR_IMAGE_MASK);
     }
 #endif
   return 1;
 
  failure:
   image_error ("Invalid XPM3 file (%s)", img->spec);
-  x_destroy_x_image (ximg);
-  x_destroy_x_image (mask_img);
-  x_clear_image (f, img);
+  image_destroy_x_image (ximg);
+  image_destroy_x_image (mask_img);
+  image_clear_image (f, img);
   return 0;
 
 #undef match
@@ -4558,7 +4874,7 @@ xpm_load (struct frame *f,
   if (STRINGP (file_name))
     {
       int fd;
-      Lisp_Object file = x_find_image_fd (file_name, &fd);
+      Lisp_Object file = image_find_image_fd (file_name, &fd);
       if (!STRINGP (file))
 	{
 	  image_error ("Cannot find image file `%s'", file_name);
@@ -4789,7 +5105,7 @@ lookup_pixel_color (struct frame *f, unsigned long pixel)
 #ifdef HAVE_X_WINDOWS
       cmap = FRAME_X_COLORMAP (f);
       color.pixel = pixel;
-      x_query_color (f, &color);
+      x_query_colors (f, &color, 1);
       rc = x_alloc_nearest_color (f, cmap, &color);
 #else
       block_input ();
@@ -4854,10 +5170,8 @@ lookup_rgb_color (struct frame *f, int r, int g, int b)
 {
 #ifdef HAVE_NTGUI
   return PALETTERGB (r >> 8, g >> 8, b >> 8);
-#elif defined HAVE_NS
+#elif defined USE_CAIRO || defined HAVE_NS
   return RGB_TO_ULONG (r >> 8, g >> 8, b >> 8);
-#elif defined USE_CAIRO
-  return (0xffu << 24) | (r << 16) | (g << 8) | b;
 #else
   xsignal1 (Qfile_error,
 	    build_string ("This Emacs mishandles this image file type"));
@@ -4898,18 +5212,18 @@ static int laplace_matrix[9] = {
 #define COLOR_INTENSITY(R, G, B) ((2 * (R) + 3 * (G) + (B)) / 6)
 
 
-/* On frame F, return an array of XColor structures describing image
-   IMG->pixmap.  Each XColor structure has its pixel color set.  RGB_P
-   means also fill the red/green/blue members of the XColor
-   structures.  Value is a pointer to the array of XColors structures,
+/* On frame F, return an array of Emacs_Color structures describing image
+   IMG->pixmap.  Each Emacs_Color structure has its pixel color set.  RGB_P
+   means also fill the red/green/blue members of the Emacs_Color
+   structures.  Value is a pointer to the array of Emacs_Color structures,
    allocated with xmalloc; it must be freed by the caller.  */
 
-static XColor *
-x_to_xcolors (struct frame *f, struct image *img, bool rgb_p)
+static Emacs_Color *
+image_to_emacs_colors (struct frame *f, struct image *img, bool rgb_p)
 {
   int x, y;
-  XColor *colors, *p;
-  XImagePtr_or_DC ximg;
+  Emacs_Color *colors, *p;
+  Emacs_Pix_Context ximg;
   ptrdiff_t nbytes;
 #ifdef HAVE_NTGUI
   HGDIOBJ prev;
@@ -4924,23 +5238,22 @@ x_to_xcolors (struct frame *f, struct image *img, bool rgb_p)
   /* Get the X image or create a memory device context for IMG. */
   ximg = image_get_x_image_or_dc (f, img, 0, &prev);
 
-  /* Fill the `pixel' members of the XColor array.  I wished there
+  /* Fill the `pixel' members of the Emacs_Color array.  I wished there
      were an easy and portable way to circumvent XGetPixel.  */
   p = colors;
   for (y = 0; y < img->height; ++y)
     {
-#if defined (HAVE_X_WINDOWS) || defined (HAVE_NTGUI)
-      XColor *row = p;
+#if !defined USE_CAIRO && !defined HAVE_NS
+      Emacs_Color *row = p;
       for (x = 0; x < img->width; ++x, ++p)
 	p->pixel = GET_PIXEL (ximg, x, y);
       if (rgb_p)
-	x_query_colors (f, row, img->width);
-
-#else
-
+        {
+          FRAME_TERMINAL (f)->query_colors (f, row, img->width);
+        }
+#else  /* USE_CAIRO || HAVE_NS */
       for (x = 0; x < img->width; ++x, ++p)
 	{
-	  /* W32_TODO: palette support needed here?  */
 	  p->pixel = GET_PIXEL (ximg, x, y);
 	  if (rgb_p)
 	    {
@@ -4949,7 +5262,7 @@ x_to_xcolors (struct frame *f, struct image *img, bool rgb_p)
 	      p->blue = BLUE16_FROM_ULONG (p->pixel);
 	    }
 	}
-#endif /* HAVE_X_WINDOWS */
+#endif	/* USE_CAIRO || HAVE_NS */
     }
 
   image_unget_x_image_or_dc (img, 0, ximg, prev);
@@ -4964,7 +5277,7 @@ x_to_xcolors (struct frame *f, struct image *img, bool rgb_p)
    stored in ximg->data.  */
 
 static void
-XPutPixel (XImagePtr ximg, int x, int y, COLORREF color)
+XPutPixel (XImage *ximg, int x, int y, COLORREF color)
 {
   int width = ximg->info.bmiHeader.biWidth;
   unsigned char * pixel;
@@ -5003,20 +5316,20 @@ XPutPixel (XImagePtr ximg, int x, int y, COLORREF color)
 
 #endif /* HAVE_NTGUI */
 
-/* Create IMG->pixmap from an array COLORS of XColor structures, whose
+/* Create IMG->pixmap from an array COLORS of Emacs_Color structures, whose
    RGB members are set.  F is the frame on which this all happens.
    COLORS will be freed; an existing IMG->pixmap will be freed, too.  */
 
 static void
-x_from_xcolors (struct frame *f, struct image *img, XColor *colors)
+image_from_emacs_colors (struct frame *f, struct image *img, Emacs_Color *colors)
 {
   int x, y;
-  XImagePtr oimg = NULL;
-  XColor *p;
+  Emacs_Pix_Container oimg = NULL;
+  Emacs_Color *p;
 
   init_color_table ();
 
-  x_clear_image_1 (f, img, CLEAR_IMAGE_PIXMAP | CLEAR_IMAGE_COLORS);
+  image_clear_image_1 (f, img, CLEAR_IMAGE_PIXMAP | CLEAR_IMAGE_COLORS);
   image_create_x_image_and_pixmap (f, img, img->width, img->height, 0,
 				   &oimg, 0);
   p = colors;
@@ -5025,7 +5338,7 @@ x_from_xcolors (struct frame *f, struct image *img, XColor *colors)
       {
 	unsigned long pixel;
 	pixel = lookup_rgb_color (f, p->red, p->green, p->blue);
-	XPutPixel (oimg, x, y, pixel);
+	PUT_PIXEL (oimg, x, y, pixel);
       }
 
   xfree (colors);
@@ -5047,10 +5360,11 @@ x_from_xcolors (struct frame *f, struct image *img, XColor *colors)
    outgoing image.  */
 
 static void
-x_detect_edges (struct frame *f, struct image *img, int *matrix, int color_adjust)
+image_detect_edges (struct frame *f, struct image *img,
+                    int *matrix, int color_adjust)
 {
-  XColor *colors = x_to_xcolors (f, img, 1);
-  XColor *new, *p;
+  Emacs_Color *colors = image_to_emacs_colors (f, img, 1);
+  Emacs_Color *new, *p;
   int x, y, i, sum;
   ptrdiff_t nbytes;
 
@@ -5093,7 +5407,7 @@ x_detect_edges (struct frame *f, struct image *img, int *matrix, int color_adjus
 	    for (xx = x - 1; xx < x + 2; ++xx, ++i)
 	      if (matrix[i])
 	        {
-	          XColor *t = COLOR (colors, xx, yy);
+	          Emacs_Color *t = COLOR (colors, xx, yy);
 		  r += matrix[i] * t->red;
 		  g += matrix[i] * t->green;
 		  b += matrix[i] * t->blue;
@@ -5107,7 +5421,7 @@ x_detect_edges (struct frame *f, struct image *img, int *matrix, int color_adjus
     }
 
   xfree (colors);
-  x_from_xcolors (f, img, new);
+  image_from_emacs_colors (f, img, new);
 
 #undef COLOR
 }
@@ -5117,9 +5431,9 @@ x_detect_edges (struct frame *f, struct image *img, int *matrix, int color_adjus
    on frame F.  */
 
 static void
-x_emboss (struct frame *f, struct image *img)
+image_emboss (struct frame *f, struct image *img)
 {
-  x_detect_edges (f, img, emboss_matrix, 0xffff / 2);
+  image_detect_edges (f, img, emboss_matrix, 0xffff / 2);
 }
 
 
@@ -5128,9 +5442,9 @@ x_emboss (struct frame *f, struct image *img)
    to draw disabled buttons, for example.  */
 
 static void
-x_laplace (struct frame *f, struct image *img)
+image_laplace (struct frame *f, struct image *img)
 {
-  x_detect_edges (f, img, laplace_matrix, 45000);
+  image_detect_edges (f, img, laplace_matrix, 45000);
 }
 
 
@@ -5146,8 +5460,8 @@ x_laplace (struct frame *f, struct image *img)
    number.  */
 
 static void
-x_edge_detection (struct frame *f, struct image *img, Lisp_Object matrix,
-		  Lisp_Object color_adjust)
+image_edge_detection (struct frame *f, struct image *img,
+                      Lisp_Object matrix, Lisp_Object color_adjust)
 {
   int i = 0;
   int trans[9];
@@ -5169,14 +5483,52 @@ x_edge_detection (struct frame *f, struct image *img, Lisp_Object matrix,
     color_adjust = make_fixnum (0xffff / 2);
 
   if (i == 9 && NUMBERP (color_adjust))
-    x_detect_edges (f, img, trans, XFLOATINT (color_adjust));
+    image_detect_edges (f, img, trans, XFLOATINT (color_adjust));
 }
 
 
+#if defined HAVE_X_WINDOWS || defined USE_CAIRO
+static void
+image_pixmap_draw_cross (struct frame *f, Emacs_Pixmap pixmap,
+			 int x, int y, unsigned int width, unsigned int height,
+			 unsigned long color)
+{
+#ifdef USE_CAIRO
+  cairo_surface_t *surface
+    = cairo_image_surface_create_for_data ((unsigned char *) pixmap->data,
+					   (pixmap->bits_per_pixel == 32
+					    ? CAIRO_FORMAT_RGB24
+					    : CAIRO_FORMAT_A8),
+					   pixmap->width, pixmap->height,
+					   pixmap->bytes_per_line);
+  cairo_t *cr = cairo_create (surface);
+  cairo_surface_destroy (surface);
+  cairo_set_source_rgb (cr, RED_FROM_ULONG (color) / 255.0,
+			GREEN_FROM_ULONG (color) / 255.0,
+			BLUE_FROM_ULONG (color) / 255.0);
+  cairo_move_to (cr, x + 0.5, y + 0.5);
+  cairo_rel_line_to (cr, width - 1, height - 1);
+  cairo_rel_move_to (cr, 0, - (height - 1));
+  cairo_rel_line_to (cr, - (width - 1), height - 1);
+  cairo_set_line_width (cr, 1);
+  cairo_stroke (cr);
+  cairo_destroy (cr);
+#elif HAVE_X_WINDOWS
+  Display *dpy = FRAME_X_DISPLAY (f);
+  GC gc = XCreateGC (dpy, pixmap, 0, NULL);
+
+  XSetForeground (dpy, gc, color);
+  XDrawLine (dpy, pixmap, gc, x, y, x + width - 1, y + height - 1);
+  XDrawLine (dpy, pixmap, gc, x, y + height - 1, x + width - 1, y);
+  XFreeGC (dpy, gc);
+#endif	/* HAVE_X_WINDOWS */
+}
+#endif	/* HAVE_X_WINDOWS || USE_CAIRO */
+
 /* Transform image IMG on frame F so that it looks disabled.  */
 
 static void
-x_disable_image (struct frame *f, struct image *img)
+image_disable_image (struct frame *f, struct image *img)
 {
   Display_Info *dpyinfo = FRAME_DISPLAY_INFO (f);
 #ifdef HAVE_NTGUI
@@ -5190,8 +5542,8 @@ x_disable_image (struct frame *f, struct image *img)
       /* Color (or grayscale).  Convert to gray, and equalize.  Just
 	 drawing such images with a stipple can look very odd, so
 	 we're using this method instead.  */
-      XColor *colors = x_to_xcolors (f, img, 1);
-      XColor *p, *end;
+      Emacs_Color *colors = image_to_emacs_colors (f, img, 1);
+      Emacs_Color *p, *end;
       const int h = 15000;
       const int l = 30000;
 
@@ -5204,7 +5556,7 @@ x_disable_image (struct frame *f, struct image *img)
 	  p->red = p->green = p->blue = i2;
 	}
 
-      x_from_xcolors (f, img, colors);
+      image_from_emacs_colors (f, img, colors);
     }
 
   /* Draw a cross over the disabled image, if we must or if we
@@ -5214,30 +5566,22 @@ x_disable_image (struct frame *f, struct image *img)
 #ifndef HAVE_NTGUI
 #ifndef HAVE_NS  /* TODO: NS support, however this not needed for toolbars */
 
+#ifndef USE_CAIRO
+#define CrossForeground(f) BLACK_PIX_DEFAULT (f)
 #define MaskForeground(f)  WHITE_PIX_DEFAULT (f)
+#else  /* USE_CAIRO */
+#define CrossForeground(f) 0
+#define MaskForeground(f)  PIX_MASK_DRAW
+#endif	/* USE_CAIRO */
 
-      Display *dpy = FRAME_X_DISPLAY (f);
-      GC gc;
-
+#ifndef USE_CAIRO
       image_sync_to_pixmaps (f, img);
-      gc = XCreateGC (dpy, img->pixmap, 0, NULL);
-      XSetForeground (dpy, gc, BLACK_PIX_DEFAULT (f));
-      XDrawLine (dpy, img->pixmap, gc, 0, 0,
-		 img->width - 1, img->height - 1);
-      XDrawLine (dpy, img->pixmap, gc, 0, img->height - 1,
-		 img->width - 1, 0);
-      XFreeGC (dpy, gc);
-
+#endif	/* !USE_CAIRO */
+      image_pixmap_draw_cross (f, img->pixmap, 0, 0, img->width, img->height,
+			       CrossForeground (f));
       if (img->mask)
-	{
-	  gc = XCreateGC (dpy, img->mask, 0, NULL);
-	  XSetForeground (dpy, gc, MaskForeground (f));
-	  XDrawLine (dpy, img->mask, gc, 0, 0,
-		     img->width - 1, img->height - 1);
-	  XDrawLine (dpy, img->mask, gc, 0, img->height - 1,
-		     img->width - 1, 0);
-	  XFreeGC (dpy, gc);
-	}
+	image_pixmap_draw_cross (f, img->mask, 0, 0, img->width, img->height,
+				 MaskForeground (f));
 #endif /* !HAVE_NS */
 #else
       HDC hdc, bmpdc;
@@ -5279,22 +5623,23 @@ x_disable_image (struct frame *f, struct image *img)
    heuristically.  */
 
 static void
-x_build_heuristic_mask (struct frame *f, struct image *img, Lisp_Object how)
+image_build_heuristic_mask (struct frame *f, struct image *img,
+                            Lisp_Object how)
 {
-  XImagePtr_or_DC ximg;
+  Emacs_Pix_Context ximg;
 #ifdef HAVE_NTGUI
   HGDIOBJ prev;
   char *mask_img;
   int row_width;
 #elif !defined HAVE_NS
-  XImagePtr mask_img;
+  Emacs_Pix_Container mask_img;
 #endif
   int x, y;
   bool use_img_background;
   unsigned long bg = 0;
 
   if (img->mask)
-    x_clear_image_1 (f, img, CLEAR_IMAGE_MASK);
+    image_clear_image_1 (f, img, CLEAR_IMAGE_MASK);
 
 #ifndef HAVE_NTGUI
 #ifndef HAVE_NS
@@ -5328,6 +5673,7 @@ x_build_heuristic_mask (struct frame *f, struct image *img, Lisp_Object how)
 
       if (i == 3 && NILP (how))
 	{
+#ifndef USE_CAIRO
 	  char color_name[30];
 	  sprintf (color_name, "#%04x%04x%04x",
 		   rgb[0] + 0u, rgb[1] + 0u, rgb[2] + 0u);
@@ -5335,7 +5681,10 @@ x_build_heuristic_mask (struct frame *f, struct image *img, Lisp_Object how)
 #ifdef HAVE_NTGUI
 		0x00ffffff & /* Filter out palette info.  */
 #endif /* HAVE_NTGUI */
-		x_alloc_image_color (f, img, build_string (color_name), 0));
+		image_alloc_image_color (f, img, build_string (color_name), 0));
+#else  /* USE_CAIRO */
+	  bg = lookup_rgb_color (f, rgb[0], rgb[1], rgb[2]);
+#endif	/* USE_CAIRO */
 	  use_img_background = 0;
 	}
     }
@@ -5349,7 +5698,7 @@ x_build_heuristic_mask (struct frame *f, struct image *img, Lisp_Object how)
   for (y = 0; y < img->height; ++y)
     for (x = 0; x < img->width; ++x)
 #ifndef HAVE_NS
-      XPutPixel (mask_img, x, y, (XGetPixel (ximg, x, y) != bg
+      PUT_PIXEL (mask_img, x, y, (GET_PIXEL (ximg, x, y) != bg
 				  ? PIX_MASK_DRAW : PIX_MASK_RETAIN));
 #else
       if (XGetPixel (ximg, x, y) == bg)
@@ -5378,7 +5727,7 @@ x_build_heuristic_mask (struct frame *f, struct image *img, Lisp_Object how)
   SelectObject (ximg, img->mask);
   image_background_transparent (img, f, ximg);
 
-  /* Was: x_destroy_x_image ((XImagePtr )mask_img); which seems bogus ++kfs */
+  /* Was: image_destroy_x_image ((XImagePtr )mask_img); which seems bogus ++kfs */
   xfree (mask_img);
 #endif /* HAVE_NTGUI */
 
@@ -5390,9 +5739,6 @@ x_build_heuristic_mask (struct frame *f, struct image *img, Lisp_Object how)
 		       PBM (mono, gray, color)
  ***********************************************************************/
 
-static bool pbm_image_p (Lisp_Object object);
-static bool pbm_load (struct frame *f, struct image *img);
-
 /* Indices of image specification fields in gs_format, below.  */
 
 enum pbm_keyword_index
@@ -5429,19 +5775,6 @@ static const struct image_keyword pbm_format[PBM_LAST] =
   {":background",	IMAGE_STRING_OR_NIL_VALUE,		0}
 };
 
-/* Structure describing the image type `pbm'.  */
-
-static struct image_type pbm_type =
-{
-  SYMBOL_INDEX (Qpbm),
-  pbm_image_p,
-  pbm_load,
-  x_clear_image,
-  NULL,
-  NULL
-};
-
-
 /* Return true if OBJECT is a valid PBM image specification.  */
 
 static bool
@@ -5538,16 +5871,14 @@ pbm_load (struct frame *f, struct image *img)
   enum {PBM_MONO, PBM_GRAY, PBM_COLOR} type;
   char *contents = NULL;
   char *end, *p;
-#ifndef USE_CAIRO
-  XImagePtr ximg;
-#endif
+  Emacs_Pix_Container ximg;
 
   specified_file = image_spec_value (img->spec, QCfile, NULL);
 
   if (STRINGP (specified_file))
     {
       int fd;
-      Lisp_Object file = x_find_image_fd (specified_file, &fd);
+      Lisp_Object file = image_find_image_fd (specified_file, &fd);
       if (!STRINGP (file))
 	{
 	  image_error ("Cannot find image file `%s'", specified_file);
@@ -5624,11 +5955,6 @@ pbm_load (struct frame *f, struct image *img)
   width = pbm_scan_number (&p, end);
   height = pbm_scan_number (&p, end);
 
-#ifdef USE_CAIRO
-  cairo_surface_t *surface = create_cairo_image_surface (width, height);
-  uint32_t *dataptr = (uint32_t *) cairo_image_surface_get_data (surface);
-#endif
-
   if (type != PBM_MONO)
     {
       max_color_idx = pbm_scan_number (&p, end);
@@ -5645,10 +5971,8 @@ pbm_load (struct frame *f, struct image *img)
       goto error;
     }
 
-#ifndef USE_CAIRO
   if (!image_create_x_image_and_pixmap (f, img, width, height, 0, &ximg, 0))
     goto error;
-#endif
 
   /* Initialize the color hash table.  */
   init_color_table ();
@@ -5659,47 +5983,31 @@ pbm_load (struct frame *f, struct image *img)
       int g;
       struct image_keyword fmt[PBM_LAST];
       unsigned long fg = FRAME_FOREGROUND_PIXEL (f);
-      unsigned long bg = FRAME_BACKGROUND_PIXEL (f);
-#ifdef USE_CAIRO
-      XColor xfg, xbg;
-      int fga32, bga32;
-#endif
+      unsigned long bg = FRAME_BACKGROUND_PIXEL (f);
       /* Parse the image specification.  */
       memcpy (fmt, pbm_format, sizeof fmt);
       parse_image_spec (img->spec, fmt, PBM_LAST, Qpbm);
 
       /* Get foreground and background colors, maybe allocate colors.  */
-#ifdef USE_CAIRO
-      if (! fmt[PBM_FOREGROUND].count
-          || ! STRINGP (fmt[PBM_FOREGROUND].value)
-          || ! x_defined_color (f, SSDATA (fmt[PBM_FOREGROUND].value), &xfg, 0))
-        {
-          xfg.pixel = fg;
-          x_query_color (f, &xfg);
-        }
-      fga32 = xcolor_to_argb32 (xfg);
-
-      if (! fmt[PBM_BACKGROUND].count
-          || ! STRINGP (fmt[PBM_BACKGROUND].value)
-          || ! x_defined_color (f, SSDATA (fmt[PBM_BACKGROUND].value), &xbg, 0))
-	{
-          xbg.pixel = bg;
-          x_query_color (f, &xbg);
-	}
-      bga32 = xcolor_to_argb32 (xbg);
-#else
       if (fmt[PBM_FOREGROUND].count
 	  && STRINGP (fmt[PBM_FOREGROUND].value))
-	fg = x_alloc_image_color (f, img, fmt[PBM_FOREGROUND].value, fg);
+	fg = image_alloc_image_color (f, img, fmt[PBM_FOREGROUND].value, fg);
       if (fmt[PBM_BACKGROUND].count
 	  && STRINGP (fmt[PBM_BACKGROUND].value))
 	{
-	  bg = x_alloc_image_color (f, img, fmt[PBM_BACKGROUND].value, bg);
+	  bg = image_alloc_image_color (f, img, fmt[PBM_BACKGROUND].value, bg);
 	  img->background = bg;
 	  img->background_valid = 1;
 	}
-#endif
 
+#ifdef USE_CAIRO
+      {
+	Emacs_Color fgbg[] = {{.pixel = fg}, {.pixel = bg}};
+	FRAME_TERMINAL (f)->query_colors (f, fgbg, ARRAYELTS (fgbg));
+	fg = lookup_rgb_color (f, fgbg[0].red, fgbg[0].green, fgbg[0].blue);
+	bg = lookup_rgb_color (f, fgbg[1].red, fgbg[1].green, fgbg[1].blue);
+      }
+#endif
       for (y = 0; y < height; ++y)
 	for (x = 0; x < width; ++x)
 	  {
@@ -5709,12 +6017,8 @@ pbm_load (struct frame *f, struct image *img)
 		  {
 		    if (p >= end)
 		      {
-#ifdef USE_CAIRO
-                        cairo_surface_destroy (surface);
-#else
-			x_destroy_x_image (ximg);
-#endif
-			x_clear_image (f, img);
+			image_destroy_x_image (ximg);
+			image_clear_image (f, img);
 			image_error ("Invalid image size in image `%s'",
 				     img->spec);
 			goto error;
@@ -5737,11 +6041,7 @@ pbm_load (struct frame *f, struct image *img)
 		  g = 0;
 	      }
 
-#ifdef USE_CAIRO
-            *dataptr++ = g ? fga32 : bga32;
-#else
-	    XPutPixel (ximg, x, y, g ? fg : bg);
-#endif
+	    PUT_PIXEL (ximg, x, y, g ? fg : bg);
 	  }
     }
   else
@@ -5755,12 +6055,8 @@ pbm_load (struct frame *f, struct image *img)
 
       if (raw_p && p + expected_size > end)
 	{
-#ifdef USE_CAIRO
-          cairo_surface_destroy (surface);
-#else
-	  x_destroy_x_image (ximg);
-#endif
-	  x_clear_image (f, img);
+	  image_destroy_x_image (ximg);
+	  image_clear_image (f, img);
 	  image_error ("Invalid image size in image `%s'", img->spec);
 	  goto error;
 	}
@@ -5789,28 +6085,17 @@ pbm_load (struct frame *f, struct image *img)
 
 	    if (r < 0 || g < 0 || b < 0)
 	      {
-#ifdef USE_CAIRO
-                cairo_surface_destroy (surface);
-#else
-		x_destroy_x_image (ximg);
-#endif
+		image_destroy_x_image (ximg);
 		image_error ("Invalid pixel value in image `%s'", img->spec);
 		goto error;
 	      }
 
-#ifdef USE_CAIRO
-	    r = (double) r * 255 / max_color_idx;
-	    g = (double) g * 255 / max_color_idx;
-	    b = (double) b * 255 / max_color_idx;
-            *dataptr++ = (0xffu << 24) | (r << 16) | (g << 8) | b;
-#else
 	    /* RGB values are now in the range 0..max_color_idx.
 	       Scale this to the range 0..0xffff supported by X.  */
 	    r = (double) r * 65535 / max_color_idx;
 	    g = (double) g * 65535 / max_color_idx;
 	    b = (double) b * 65535 / max_color_idx;
-	    XPutPixel (ximg, x, y, lookup_rgb_color (f, r, g, b));
-#endif
+	    PUT_PIXEL (ximg, x, y, lookup_rgb_color (f, r, g, b));
 	  }
     }
 
@@ -5826,16 +6111,12 @@ pbm_load (struct frame *f, struct image *img)
 
   /* Maybe fill in the background field while we have ximg handy.  */
 
-#ifdef USE_CAIRO
-  set_cairo_image_surface (img, surface);
-#else
   if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
     /* Casting avoids a GCC warning.  */
-    IMAGE_BACKGROUND (img, f, (XImagePtr_or_DC)ximg);
+    IMAGE_BACKGROUND (img, f, (Emacs_Pix_Context)ximg);
 
   /* Put ximg into the image.  */
   image_put_x_image (f, img, ximg, 0);
-#endif
 
   /* X and W32 versions did it here, MAC version above.  ++kfs
      img->width = width;
@@ -5852,11 +6133,6 @@ pbm_load (struct frame *f, struct image *img)
 
 #if defined (HAVE_PNG) || defined (HAVE_NS) || defined (USE_CAIRO)
 
-/* Function prototypes.  */
-
-static bool png_image_p (Lisp_Object object);
-static bool png_load (struct frame *f, struct image *img);
-
 /* Indices of image specification fields in png_format, below.  */
 
 enum png_keyword_index
@@ -5891,24 +6167,6 @@ static const struct image_keyword png_format[PNG_LAST] =
   {":background",	IMAGE_STRING_OR_NIL_VALUE,		0}
 };
 
-#if defined HAVE_NTGUI && defined WINDOWSNT
-static bool init_png_functions (void);
-#else
-#define init_png_functions NULL
-#endif
-
-/* Structure describing the image type `png'.  */
-
-static struct image_type png_type =
-{
-  SYMBOL_INDEX (Qpng),
-  png_image_p,
-  png_load,
-  x_clear_image,
-  init_png_functions,
-  NULL
-};
-
 /* Return true if OBJECT is a valid PNG image specification.  */
 
 static bool
@@ -5949,6 +6207,7 @@ DEF_DLL_FN (png_uint_32, png_get_valid, (png_structp, png_infop, png_uint_32));
 DEF_DLL_FN (void, png_set_strip_16, (png_structp));
 DEF_DLL_FN (void, png_set_expand, (png_structp));
 DEF_DLL_FN (void, png_set_gray_to_rgb, (png_structp));
+DEF_DLL_FN (int, png_set_interlace_handling, (png_structp));
 DEF_DLL_FN (void, png_set_background,
 	    (png_structp, png_color_16p, int, int, double));
 DEF_DLL_FN (png_uint_32, png_get_bKGD,
@@ -5987,6 +6246,7 @@ init_png_functions (void)
   LOAD_DLL_FN (library, png_set_strip_16);
   LOAD_DLL_FN (library, png_set_expand);
   LOAD_DLL_FN (library, png_set_gray_to_rgb);
+  LOAD_DLL_FN (library, png_set_interlace_handling);
   LOAD_DLL_FN (library, png_set_background);
   LOAD_DLL_FN (library, png_get_bKGD);
   LOAD_DLL_FN (library, png_read_update_info);
@@ -6022,6 +6282,7 @@ init_png_functions (void)
 #  undef png_set_background
 #  undef png_set_expand
 #  undef png_set_gray_to_rgb
+#  undef png_set_interlace_handling
 #  undef png_set_longjmp_fn
 #  undef png_set_read_fn
 #  undef png_set_sig_bytes
@@ -6046,6 +6307,7 @@ init_png_functions (void)
 #  define png_set_background fn_png_set_background
 #  define png_set_expand fn_png_set_expand
 #  define png_set_gray_to_rgb fn_png_set_gray_to_rgb
+#  define png_set_interlace_handling fn_png_set_interlace_handling
 #  define png_set_longjmp_fn fn_png_set_longjmp_fn
 #  define png_set_read_fn fn_png_set_read_fn
 #  define png_set_sig_bytes fn_png_set_sig_bytes
@@ -6079,7 +6341,7 @@ init_png_functions (void)
 /* Error and warning handlers installed when the PNG library
    is initialized.  */
 
-static _Noreturn void
+static AVOID
 my_png_error (png_struct *png_ptr, const char *msg)
 {
   eassert (png_ptr != NULL);
@@ -6171,13 +6433,7 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
   bool transparent_p;
   struct png_memory_storage tbr;  /* Data to be read */
   ptrdiff_t nbytes;
-
-#ifdef USE_CAIRO
-  cairo_surface_t *surface;
-  uint32_t *dataptr;
-#else
-  XImagePtr ximg, mask_img = NULL;
-#endif
+  Emacs_Pix_Container ximg, mask_img = NULL;
 
   /* Find out what file to load.  */
   specified_file = image_spec_value (img->spec, QCfile, NULL);
@@ -6186,7 +6442,7 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
   if (NILP (specified_data))
     {
       int fd;
-      Lisp_Object file = x_find_image_fd (specified_file, &fd);
+      Lisp_Object file = image_find_image_fd (specified_file, &fd);
       if (!STRINGP (file))
 	{
 	  image_error ("Cannot find image file `%s'", specified_file);
@@ -6295,12 +6551,10 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
       goto error;
     }
 
-#ifndef USE_CAIRO
   /* Create the X image and pixmap now, so that the work below can be
      omitted if the image is too large for X.  */
   if (!image_create_x_image_and_pixmap (f, img, width, height, 0, &ximg, 0))
     goto error;
-#endif
 
   /* If image contains simply transparency data, we prefer to
      construct a clipping mask.  */
@@ -6334,14 +6588,19 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
       /* png_color_16 *image_bg; */
       Lisp_Object specified_bg
 	= image_spec_value (img->spec, QCbackground, NULL);
-      XColor color;
+      Emacs_Color color;
 
       /* If the user specified a color, try to use it; if not, use the
 	 current frame background, ignoring any default background
 	 color set by the image.  */
       if (STRINGP (specified_bg)
-	  ? x_defined_color (f, SSDATA (specified_bg), &color, false)
-	  : (x_query_frame_background_color (f, &color), true))
+	  ? FRAME_TERMINAL (f)->defined_color_hook (f,
+                                                    SSDATA (specified_bg),
+                                                    &color,
+                                                    false,
+                                                    false)
+	  : (FRAME_TERMINAL (f)->query_frame_background_color (f, &color),
+             true))
 	/* The user specified `:background', use that.  */
 	{
 	  int shift = bit_depth == 16 ? 0 : 8;
@@ -6355,7 +6614,7 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
 	}
     }
 
-  /* Update info structure.  */
+  png_set_interlace_handling (png_ptr);
   png_read_update_info (png_ptr, info_ptr);
 
   /* Get number of channels.  Valid values are 1 for grayscale images
@@ -6387,10 +6646,6 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
       c->fp = NULL;
     }
 
-#ifdef USE_CAIRO
-  surface = create_cairo_image_surface (width, height);
-  dataptr = (uint32_t *) cairo_image_surface_get_data (surface);
-#else
   /* Create an image and pixmap serving as mask if the PNG image
      contains an alpha channel.  */
   if (channels == 4
@@ -6398,11 +6653,10 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
       && !image_create_x_image_and_pixmap (f, img, width, height, 1,
 					   &mask_img, 1))
     {
-      x_destroy_x_image (ximg);
-      x_clear_image_1 (f, img, CLEAR_IMAGE_PIXMAP);
+      image_destroy_x_image (ximg);
+      image_clear_image_1 (f, img, CLEAR_IMAGE_PIXMAP);
       goto error;
     }
-#endif
 
   /* Fill the X image and mask from PNG data.  */
   init_color_table ();
@@ -6415,18 +6669,10 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
 	{
 	  int r, g, b;
 
-#ifdef USE_CAIRO
-          int a = 0xff;
-	  r = *p++;
-	  g = *p++;
-	  b = *p++;
-          if (channels == 4) a = *p++;
-          *dataptr++ = (a << 24) | (r << 16) | (g << 8) | b;
-#else
 	  r = *p++ << 8;
 	  g = *p++ << 8;
 	  b = *p++ << 8;
-	  XPutPixel (ximg, x, y, lookup_rgb_color (f, r, g, b));
+	  PUT_PIXEL (ximg, x, y, lookup_rgb_color (f, r, g, b));
 	  /* An alpha channel, aka mask channel, associates variable
 	     transparency with an image.  Where other image formats
 	     support binary transparency---fully transparent or fully
@@ -6446,10 +6692,9 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
 	  if (channels == 4)
 	    {
 	      if (mask_img)
-		XPutPixel (mask_img, x, y, *p > 0 ? PIX_MASK_DRAW : PIX_MASK_RETAIN);
+		PUT_PIXEL (mask_img, x, y, *p > 0 ? PIX_MASK_DRAW : PIX_MASK_RETAIN);
 	      ++p;
 	    }
-#endif
 	}
     }
 
@@ -6460,7 +6705,14 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
       png_color_16 *bg;
       if (png_get_bKGD (png_ptr, info_ptr, &bg))
 	{
+#ifndef USE_CAIRO
 	  img->background = lookup_rgb_color (f, bg->red, bg->green, bg->blue);
+#else  /* USE_CAIRO */
+	  char color_name[30];
+	  sprintf (color_name, "#%04x%04x%04x", bg->red, bg->green, bg->blue);
+	  img->background
+	    = image_alloc_image_color (f, img, build_string (color_name), 0);
+#endif /* USE_CAIRO */
 	  img->background_valid = 1;
 	}
     }
@@ -6479,12 +6731,9 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
   img->width = width;
   img->height = height;
 
-#ifdef USE_CAIRO
-  set_cairo_image_surface (img, surface);
-#else
   /* Maybe fill in the background field while we have ximg handy.
      Casting avoids a GCC warning.  */
-  IMAGE_BACKGROUND (img, f, (XImagePtr_or_DC)ximg);
+  IMAGE_BACKGROUND (img, f, (Emacs_Pix_Context)ximg);
 
   /* Put ximg into the image.  */
   image_put_x_image (f, img, ximg, 0);
@@ -6494,11 +6743,10 @@ png_load_body (struct frame *f, struct image *img, struct png_load_context *c)
     {
       /* Fill in the background_transparent field while we have the
 	 mask handy.  Casting avoids a GCC warning.  */
-      image_background_transparent (img, f, (XImagePtr_or_DC)mask_img);
+      image_background_transparent (img, f, (Emacs_Pix_Context)mask_img);
 
       image_put_x_image (f, img, mask_img, 1);
     }
-#endif
 
   return 1;
 }
@@ -6531,9 +6779,6 @@ png_load (struct frame *f, struct image *img)
 
 #if defined (HAVE_JPEG) || defined (HAVE_NS)
 
-static bool jpeg_image_p (Lisp_Object object);
-static bool jpeg_load (struct frame *f, struct image *img);
-
 /* Indices of image specification fields in gs_format, below.  */
 
 enum jpeg_keyword_index
@@ -6568,24 +6813,6 @@ static const struct image_keyword jpeg_format[JPEG_LAST] =
   {":background",	IMAGE_STRING_OR_NIL_VALUE,		0}
 };
 
-#if defined HAVE_NTGUI && defined WINDOWSNT
-static bool init_jpeg_functions (void);
-#else
-#define init_jpeg_functions NULL
-#endif
-
-/* Structure describing the image type `jpeg'.  */
-
-static struct image_type jpeg_type =
-{
-  SYMBOL_INDEX (Qjpeg),
-  jpeg_image_p,
-  jpeg_load,
-  x_clear_image,
-  init_jpeg_functions,
-  NULL
-};
-
 /* Return true if OBJECT is a valid JPEG image specification.  */
 
 static bool
@@ -6718,7 +6945,7 @@ struct my_jpeg_error_mgr
 };
 
 
-static _Noreturn void
+static AVOID
 my_error_exit (j_common_ptr cinfo)
 {
   struct my_jpeg_error_mgr *mgr = (struct my_jpeg_error_mgr *) cinfo->err;
@@ -6728,7 +6955,7 @@ my_error_exit (j_common_ptr cinfo)
 
 
 /* Init source method for JPEG data source manager.  Called by
-   jpeg_read_header() before any data is actually read.  See
+   jpeg_read_header before any data is actually read.  See
    libjpeg.doc from the JPEG lib distribution.  */
 
 static void
@@ -6738,7 +6965,7 @@ our_common_init_source (j_decompress_ptr cinfo)
 
 
 /* Method to terminate data source.  Called by
-   jpeg_finish_decompress() after all data has been processed.  */
+   jpeg_finish_decompress after all data has been processed.  */
 
 static void
 our_common_term_source (j_decompress_ptr cinfo)
@@ -6933,10 +7160,8 @@ jpeg_load_body (struct frame *f, struct image *img,
   int row_stride, x, y;
   int width, height;
   int i, ir, ig, ib;
-#ifndef USE_CAIRO
   unsigned long *colors;
-  XImagePtr ximg = NULL;
-#endif
+  Emacs_Pix_Container ximg = NULL;
 
   /* Open the JPEG file.  */
   specified_file = image_spec_value (img->spec, QCfile, NULL);
@@ -6945,7 +7170,7 @@ jpeg_load_body (struct frame *f, struct image *img,
   if (NILP (specified_data))
     {
       int fd;
-      Lisp_Object file = x_find_image_fd (specified_file, &fd);
+      Lisp_Object file = image_find_image_fd (specified_file, &fd);
       if (!STRINGP (file))
 	{
 	  image_error ("Cannot find image file `%s'", specified_file);
@@ -6996,11 +7221,9 @@ jpeg_load_body (struct frame *f, struct image *img,
       jpeg_destroy_decompress (&mgr->cinfo);
 
       /* If we already have an XImage, free that.  */
-#ifndef USE_CAIRO
-      x_destroy_x_image (ximg);
-#endif
+      image_destroy_x_image (ximg);
       /* Free pixmap and colors.  */
-      x_clear_image (f, img);
+      image_clear_image (f, img);
       return 0;
     }
 
@@ -7029,14 +7252,12 @@ jpeg_load_body (struct frame *f, struct image *img,
       sys_longjmp (mgr->setjmp_buffer, 1);
     }
 
-#ifndef USE_CAIRO
   /* Create X image and pixmap.  */
   if (!image_create_x_image_and_pixmap (f, img, width, height, 0, &ximg, 0))
     {
       mgr->failure_code = MY_JPEG_CANNOT_CREATE_X;
       sys_longjmp (mgr->setjmp_buffer, 1);
     }
-#endif
 
   /* Allocate colors.  When color quantization is used,
      mgr->cinfo.actual_number_of_colors has been set with the number of
@@ -7052,7 +7273,6 @@ jpeg_load_body (struct frame *f, struct image *img,
     else
       ir = 0, ig = 0, ib = 0;
 
-#ifndef USE_CAIRO
     /* Use the color table mechanism because it handles colors that
        cannot be allocated nicely.  Such colors will be replaced with
        a default color, and we don't have to care about which colors
@@ -7069,7 +7289,6 @@ jpeg_load_body (struct frame *f, struct image *img,
 	int b = mgr->cinfo.colormap[ib][i] << 8;
 	colors[i] = lookup_rgb_color (f, r, g, b);
       }
-#endif
 
 #ifdef COLOR_TABLE_SUPPORT
     /* Remember those colors actually allocated.  */
@@ -7082,36 +7301,12 @@ jpeg_load_body (struct frame *f, struct image *img,
   row_stride = width * mgr->cinfo.output_components;
   buffer = mgr->cinfo.mem->alloc_sarray ((j_common_ptr) &mgr->cinfo,
 					 JPOOL_IMAGE, row_stride, 1);
-#ifdef USE_CAIRO
-  {
-    cairo_surface_t *surface = create_cairo_image_surface (width, height);
-    uint32_t *dataptr = (uint32_t *) cairo_image_surface_get_data (surface);
-    int r, g, b;
-
-    for (y = 0; y < height; ++y)
-      {
-        jpeg_read_scanlines (&mgr->cinfo, buffer, 1);
-
-        for (x = 0; x < width; ++x)
-          {
-            i = buffer[0][x];
-            r = mgr->cinfo.colormap[ir][i];
-            g = mgr->cinfo.colormap[ig][i];
-            b = mgr->cinfo.colormap[ib][i];
-            *dataptr++ = (0xffu << 24) | (r << 16) | (g << 8) | b;
-          }
-      }
-
-    set_cairo_image_surface (img, surface);
-  }
-#else
   for (y = 0; y < height; ++y)
     {
       jpeg_read_scanlines (&mgr->cinfo, buffer, 1);
       for (x = 0; x < mgr->cinfo.output_width; ++x)
-	XPutPixel (ximg, x, y, colors[buffer[0][x]]);
+	PUT_PIXEL (ximg, x, y, colors[buffer[0][x]]);
     }
-#endif
 
   /* Clean up.  */
   jpeg_finish_decompress (&mgr->cinfo);
@@ -7119,15 +7314,13 @@ jpeg_load_body (struct frame *f, struct image *img,
   if (fp)
     fclose (fp);
 
-#ifndef USE_CAIRO
   /* Maybe fill in the background field while we have ximg handy. */
   if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
     /* Casting avoids a GCC warning.  */
-    IMAGE_BACKGROUND (img, f, (XImagePtr_or_DC)ximg);
+    IMAGE_BACKGROUND (img, f, (Emacs_Pix_Context)ximg);
 
   /* Put ximg into the image.  */
   image_put_x_image (f, img, ximg, 0);
-#endif
   SAFE_FREE ();
   return 1;
 }
@@ -7161,9 +7354,6 @@ jpeg_load (struct frame *f, struct image *img)
 
 #if defined (HAVE_TIFF) || defined (HAVE_NS)
 
-static bool tiff_image_p (Lisp_Object object);
-static bool tiff_load (struct frame *f, struct image *img);
-
 /* Indices of image specification fields in tiff_format, below.  */
 
 enum tiff_keyword_index
@@ -7200,24 +7390,6 @@ static const struct image_keyword tiff_format[TIFF_LAST] =
   {":index",		IMAGE_NON_NEGATIVE_INTEGER_VALUE,	0}
 };
 
-#if defined HAVE_NTGUI && defined WINDOWSNT
-static bool init_tiff_functions (void);
-#else
-#define init_tiff_functions NULL
-#endif
-
-/* Structure describing the image type `tiff'.  */
-
-static struct image_type tiff_type =
-{
-  SYMBOL_INDEX (Qtiff),
-  tiff_image_p,
-  tiff_load,
-  x_clear_image,
-  init_tiff_functions,
-  NULL
-};
-
 /* Return true if OBJECT is a valid TIFF image specification.  */
 
 static bool
@@ -7444,7 +7616,7 @@ tiff_load (struct frame *f, struct image *img)
   int width, height, x, y, count;
   uint32 *buf;
   int rc;
-  XImagePtr ximg;
+  Emacs_Pix_Container ximg;
   tiff_memory_source memsrc;
   Lisp_Object image;
 
@@ -7457,7 +7629,7 @@ tiff_load (struct frame *f, struct image *img)
   if (NILP (specified_data))
     {
       /* Read from a file */
-      Lisp_Object file = x_find_image_file (specified_file);
+      Lisp_Object file = image_find_image_file (specified_file);
       if (!STRINGP (file))
 	{
 	  image_error ("Cannot find image file `%s'", specified_file);
@@ -7562,28 +7734,6 @@ tiff_load (struct frame *f, struct image *img)
       return 0;
     }
 
-#ifdef USE_CAIRO
-  {
-    cairo_surface_t *surface = create_cairo_image_surface (width, height);
-    uint32_t *dataptr = (uint32_t *) cairo_image_surface_get_data (surface);
-
-    for (y = 0; y < height; ++y)
-      {
-        uint32 *row = buf + (height - 1 - y) * width;
-        for (x = 0; x < width; ++x)
-          {
-            uint32 abgr = row[x];
-            int r = TIFFGetR (abgr);
-            int g = TIFFGetG (abgr);
-            int b = TIFFGetB (abgr);
-            int a = TIFFGetA (abgr);
-            *dataptr++ = (a << 24) | (r << 16) | (g << 8) | b;
-          }
-      }
-
-    set_cairo_image_surface (img, surface);
-  }
-#else
   /* Initialize the color table.  */
   init_color_table ();
 
@@ -7598,7 +7748,7 @@ tiff_load (struct frame *f, struct image *img)
 	  int r = TIFFGetR (abgr) << 8;
 	  int g = TIFFGetG (abgr) << 8;
 	  int b = TIFFGetB (abgr) << 8;
-	  XPutPixel (ximg, x, height - 1 - y, lookup_rgb_color (f, r, g, b));
+	  PUT_PIXEL (ximg, x, height - 1 - y, lookup_rgb_color (f, r, g, b));
 	}
     }
 
@@ -7614,13 +7764,11 @@ tiff_load (struct frame *f, struct image *img)
   /* Maybe fill in the background field while we have ximg handy. */
   if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
     /* Casting avoids a GCC warning on W32.  */
-    IMAGE_BACKGROUND (img, f, (XImagePtr_or_DC)ximg);
+    IMAGE_BACKGROUND (img, f, (Emacs_Pix_Context)ximg);
 
   /* Put ximg into the image.  */
   image_put_x_image (f, img, ximg, 0);
 
-#endif /* ! USE_CAIRO */
-
   xfree (buf);
   return 1;
 }
@@ -7645,10 +7793,6 @@ tiff_load (struct frame *f, struct image *img)
 
 #if defined (HAVE_GIF) || defined (HAVE_NS)
 
-static bool gif_image_p (Lisp_Object object);
-static bool gif_load (struct frame *f, struct image *img);
-static void gif_clear_image (struct frame *f, struct image *img);
-
 /* Indices of image specification fields in gif_format, below.  */
 
 enum gif_keyword_index
@@ -7685,31 +7829,13 @@ static const struct image_keyword gif_format[GIF_LAST] =
   {":background",	IMAGE_STRING_OR_NIL_VALUE,		0}
 };
 
-#if defined HAVE_NTGUI && defined WINDOWSNT
-static bool init_gif_functions (void);
-#else
-#define init_gif_functions NULL
-#endif
-
-/* Structure describing the image type `gif'.  */
-
-static struct image_type gif_type =
-{
-  SYMBOL_INDEX (Qgif),
-  gif_image_p,
-  gif_load,
-  gif_clear_image,
-  init_gif_functions,
-  NULL
-};
-
 /* Free X resources of GIF image IMG which is used on frame F.  */
 
 static void
 gif_clear_image (struct frame *f, struct image *img)
 {
   img->lisp_data = Qnil;
-  x_clear_image (f, img);
+  image_clear_image (f, img);
 }
 
 /* Return true if OBJECT is a valid GIF image specification.  */
@@ -7893,7 +8019,7 @@ gif_load (struct frame *f, struct image *img)
 
   if (NILP (specified_data))
     {
-      Lisp_Object file = x_find_image_file (specified_file);
+      Lisp_Object file = image_find_image_file (specified_file);
       if (!STRINGP (file))
 	{
 	  image_error ("Cannot find image file `%s'", specified_file);
@@ -8019,27 +8145,8 @@ gif_load (struct frame *f, struct image *img)
 	}
     }
 
-#ifdef USE_CAIRO
-  cairo_surface_t *surface = create_cairo_image_surface (width, height);
-  uint32_t *data32 = (uint32_t *) cairo_image_surface_get_data (surface);
-  if (STRINGP (specified_bg))
-    {
-      XColor color;
-      if (x_defined_color (f, SSDATA (specified_bg), &color, 0))
-        {
-          uint32_t *dataptr = data32;
-          int r = color.red/256;
-          int g = color.green/256;
-          int b = color.blue/256;
-
-          for (y = 0; y < height; ++y)
-            for (x = 0; x < width; ++x)
-              *dataptr++ = (0xffu << 24) | (r << 16) | (g << 8) | b;
-        }
-    }
-#else
   /* Create the X image and pixmap.  */
-  XImagePtr ximg;
+  Emacs_Pix_Container ximg;
   if (!image_create_x_image_and_pixmap (f, img, width, height, 0, &ximg, 0))
     {
       gif_close (gif, NULL);
@@ -8050,22 +8157,31 @@ gif_load (struct frame *f, struct image *img)
      Full animated GIF support requires more here (see the gif89 spec,
      disposal methods).  Let's simply assume that the part not covered
      by a sub-image is in the frame's background color.  */
+  unsigned long frame_bg;
+#ifndef USE_CAIRO
+  frame_bg = FRAME_BACKGROUND_PIXEL (f);
+#else  /* USE_CAIRO */
+  {
+    Emacs_Color color;
+    FRAME_TERMINAL (f)->query_frame_background_color (f, &color);
+    frame_bg = lookup_rgb_color (f, color.red, color.green, color.blue);
+  }
+#endif	/* USE_CAIRO */
   for (y = 0; y < img->corners[TOP_CORNER]; ++y)
     for (x = 0; x < width; ++x)
-      XPutPixel (ximg, x, y, FRAME_BACKGROUND_PIXEL (f));
+      PUT_PIXEL (ximg, x, y, frame_bg);
 
   for (y = img->corners[BOT_CORNER]; y < height; ++y)
     for (x = 0; x < width; ++x)
-      XPutPixel (ximg, x, y, FRAME_BACKGROUND_PIXEL (f));
+      PUT_PIXEL (ximg, x, y, frame_bg);
 
   for (y = img->corners[TOP_CORNER]; y < img->corners[BOT_CORNER]; ++y)
     {
       for (x = 0; x < img->corners[LEFT_CORNER]; ++x)
-	XPutPixel (ximg, x, y, FRAME_BACKGROUND_PIXEL (f));
+	PUT_PIXEL (ximg, x, y, frame_bg);
       for (x = img->corners[RIGHT_CORNER]; x < width; ++x)
-	XPutPixel (ximg, x, y, FRAME_BACKGROUND_PIXEL (f));
+	PUT_PIXEL (ximg, x, y, frame_bg);
     }
-#endif
 
   /* Read the GIF image into the X image.   */
 
@@ -8076,12 +8192,17 @@ gif_load (struct frame *f, struct image *img)
 
   init_color_table ();
 
-#ifndef USE_CAIRO
   unsigned long bgcolor UNINIT;
   if (STRINGP (specified_bg))
-    bgcolor = x_alloc_image_color (f, img, specified_bg,
-				   FRAME_BACKGROUND_PIXEL (f));
+    {
+      bgcolor = image_alloc_image_color (f, img, specified_bg,
+					 FRAME_BACKGROUND_PIXEL (f));
+#ifdef USE_CAIRO
+      Emacs_Color color = {.pixel = bgcolor};
+      FRAME_TERMINAL (f)->query_colors (f, &color, 1);
+      bgcolor = lookup_rgb_color (f, color.red, color.green, color.blue);
 #endif
+    }
 
   for (j = 0; j <= idx; ++j)
     {
@@ -8129,7 +8250,6 @@ gif_load (struct frame *f, struct image *img)
       if (!gif_color_map)
 	gif_color_map = gif->SColorMap;
 
-#ifndef USE_CAIRO
       /* Allocate subimage colors.  */
       unsigned long pixel_colors[256] = { 0, };
 
@@ -8138,7 +8258,7 @@ gif_load (struct frame *f, struct image *img)
 	  {
 	    if (transparency_color_index == i)
 	      pixel_colors[i] = STRINGP (specified_bg)
-		? bgcolor : FRAME_BACKGROUND_PIXEL (f);
+		? bgcolor : frame_bg;
 	    else
 	      {
 		int r = gif_color_map->Colors[i].Red << 8;
@@ -8147,7 +8267,6 @@ gif_load (struct frame *f, struct image *img)
 		pixel_colors[i] = lookup_rgb_color (f, r, g, b);
 	      }
 	  }
-#endif
 
       /* Apply the pixel values.  */
       if (GIFLIB_MAJOR < 5 && gif->SavedImages[j].ImageDesc.Interlace)
@@ -8166,21 +8285,9 @@ gif_load (struct frame *f, struct image *img)
 		  int c = raster[y * subimg_width + x];
 		  if (transparency_color_index != c || disposal != 1)
                     {
-#ifdef USE_CAIRO
-                      uint32_t *dataptr =
-                        (data32 + ((row + subimg_top) * width
-				   + x + subimg_left));
-                      int r = gif_color_map->Colors[c].Red;
-                      int g = gif_color_map->Colors[c].Green;
-                      int b = gif_color_map->Colors[c].Blue;
-
-                      if (transparency_color_index != c)
-                        *dataptr = (0xffu << 24) | (r << 16) | (g << 8) | b;
-#else
-                      XPutPixel (ximg, x + subimg_left, row + subimg_top,
+                      PUT_PIXEL (ximg, x + subimg_left, row + subimg_top,
                                  pixel_colors[c]);
-#endif
-                   }
+		    }
 		}
 	    }
 	}
@@ -8192,19 +8299,8 @@ gif_load (struct frame *f, struct image *img)
 		int c = raster[y * subimg_width + x];
 		if (transparency_color_index != c || disposal != 1)
                   {
-#ifdef USE_CAIRO
-                    uint32_t *dataptr =
-                      (data32 + ((y + subimg_top) * width
-				 + x + subimg_left));
-                    int r = gif_color_map->Colors[c].Red;
-                    int g = gif_color_map->Colors[c].Green;
-                    int b = gif_color_map->Colors[c].Blue;
-                    if (transparency_color_index != c)
-                      *dataptr = (0xffu << 24) | (r << 16) | (g << 8) | b;
-#else
-                    XPutPixel (ximg, x + subimg_left, y + subimg_top,
+                    PUT_PIXEL (ximg, x + subimg_left, y + subimg_top,
                                pixel_colors[c]);
-#endif
                   }
 	      }
 	}
@@ -8263,17 +8359,13 @@ gif_load (struct frame *f, struct image *img)
 #endif
     }
 
-#ifdef USE_CAIRO
-  set_cairo_image_surface (img, surface);
-#else
   /* Maybe fill in the background field while we have ximg handy. */
   if (NILP (image_spec_value (img->spec, QCbackground, NULL)))
     /* Casting avoids a GCC warning.  */
-    IMAGE_BACKGROUND (img, f, (XImagePtr_or_DC)ximg);
+    IMAGE_BACKGROUND (img, f, (Emacs_Pix_Context)ximg);
 
   /* Put ximg into the image.  */
   image_put_x_image (f, img, ximg, 0);
-#endif
 
   return 1;
 }
@@ -8299,10 +8391,6 @@ gif_load (struct frame *f, struct image *img)
 				 ImageMagick
 ***********************************************************************/
 
-static bool imagemagick_image_p (Lisp_Object);
-static bool imagemagick_load (struct frame *, struct image *);
-static void imagemagick_clear_image (struct frame *, struct image *);
-
 /* Indices of image specification fields in imagemagick_format.  */
 
 enum imagemagick_keyword_index
@@ -8351,32 +8439,13 @@ static struct image_keyword imagemagick_format[IMAGEMAGICK_LAST] =
     {":crop",		IMAGE_DONT_CHECK_VALUE_TYPE,		0}
   };
 
-#if defined HAVE_NTGUI && defined WINDOWSNT
-static bool init_imagemagick_functions (void);
-#else
-#define init_imagemagick_functions NULL
-#endif
-
-/* Structure describing the image type for any image handled via
-   ImageMagick.  */
-
-static struct image_type imagemagick_type =
-  {
-    SYMBOL_INDEX (Qimagemagick),
-    imagemagick_image_p,
-    imagemagick_load,
-    imagemagick_clear_image,
-    init_imagemagick_functions,
-    NULL
-  };
-
 /* Free X resources of imagemagick image IMG which is used on frame F.  */
 
 static void
 imagemagick_clear_image (struct frame *f,
                          struct image *img)
 {
-  x_clear_image (f, img);
+  image_clear_image (f, img);
 }
 
 /* Return true if OBJECT is a valid IMAGEMAGICK image specification.  Do
@@ -8924,9 +8993,7 @@ imagemagick_load_image (struct frame *f, struct image *img,
   int width, height;
   size_t image_width, image_height;
   MagickBooleanType status;
-#ifndef USE_CAIRO
-  XImagePtr ximg;
-#endif
+  Emacs_Pix_Container ximg;
   int x, y;
   MagickWand *image_wand;
   PixelIterator *iterator;
@@ -8940,9 +9007,6 @@ imagemagick_load_image (struct frame *f, struct image *img,
   double rotation;
   char hint_buffer[MaxTextExtent];
   char *filename_hint = NULL;
-#ifdef USE_CAIRO
-  cairo_surface_t *surface;
-#endif
 
   /* Initialize the ImageMagick environment.  */
   static bool imagemagick_initialized;
@@ -9030,13 +9094,17 @@ imagemagick_load_image (struct frame *f, struct image *img,
 
   /* Retrieve the frame's background color, for use later.  */
   {
-    XColor bgcolor;
+    Emacs_Color bgcolor;
     Lisp_Object specified_bg;
 
     specified_bg = image_spec_value (img->spec, QCbackground, NULL);
     if (!STRINGP (specified_bg)
-	|| !x_defined_color (f, SSDATA (specified_bg), &bgcolor, 0))
-      x_query_frame_background_color (f, &bgcolor);
+	|| !FRAME_TERMINAL (f)->defined_color_hook (f,
+                                                    SSDATA (specified_bg),
+                                                    &bgcolor,
+                                                    false,
+                                                    false))
+      FRAME_TERMINAL (f)->query_frame_background_color (f, &bgcolor);
 
     bg_wand = NewPixelWand ();
     PixelSetRed   (bg_wand, (double) bgcolor.red   / 65535);
@@ -9152,11 +9220,6 @@ imagemagick_load_image (struct frame *f, struct image *img,
          method is also well tested.  Some aspects of this method are
          ad-hoc and needs to be more researched. */
       void *dataptr;
-#ifdef USE_CAIRO
-      surface = create_cairo_image_surface (width, height);
-      const char *exportdepth = "BGRA";
-      dataptr = cairo_image_surface_get_data (surface);
-#else
       int imagedepth = 24; /*MagickGetImageDepth(image_wand);*/
       const char *exportdepth = imagedepth <= 8 ? "I" : "BGRP"; /*"RGBP";*/
       /* Try to create a x pixmap to hold the imagemagick pixmap.  */
@@ -9170,7 +9233,6 @@ imagemagick_load_image (struct frame *f, struct image *img,
 	  goto imagemagick_error;
 	}
       dataptr = ximg->data;
-#endif /* not USE_CAIRO */
 
       /* Oddly, the below code doesn't seem to work:*/
       /* switch(ximg->bitmap_unit){ */
@@ -9201,11 +9263,6 @@ imagemagick_load_image (struct frame *f, struct image *img,
       size_t image_height;
       double quantum_range = QuantumRange;
       MagickRealType color_scale = 65535.0 / quantum_range;
-#ifdef USE_CAIRO
-      surface = create_cairo_image_surface (width, height);
-      uint32_t *dataptr = (uint32_t *) cairo_image_surface_get_data (surface);
-      color_scale /= 256;
-#else
       /* Try to create a x pixmap to hold the imagemagick pixmap.  */
       if (!image_create_x_image_and_pixmap (f, img, width, height, 0,
 					    &ximg, 0))
@@ -9216,7 +9273,6 @@ imagemagick_load_image (struct frame *f, struct image *img,
           image_error ("Imagemagick X bitmap allocation failure");
           goto imagemagick_error;
         }
-#endif
 
       /* Copy imagemagick image to x with primitive yet robust pixel
          pusher loop.  This has been tested a lot with many different
@@ -9229,9 +9285,7 @@ imagemagick_load_image (struct frame *f, struct image *img,
 #ifdef COLOR_TABLE_SUPPORT
 	  free_color_table ();
 #endif
-#ifndef USE_CAIRO
-	  x_destroy_x_image (ximg);
-#endif
+	  image_destroy_x_image (ximg);
           image_error ("Imagemagick pixel iterator creation failed");
           goto imagemagick_error;
         }
@@ -9247,27 +9301,16 @@ imagemagick_load_image (struct frame *f, struct image *img,
 	  for (x = 0; x < xlim; x++)
             {
               PixelGetMagickColor (pixels[x], &pixel);
-#ifdef USE_CAIRO
-	      dataptr[width * y + x] =
-		lookup_rgb_color (f,
-				  color_scale * pixel.red,
-				  color_scale * pixel.green,
-				  color_scale * pixel.blue);
-#else
-              XPutPixel (ximg, x, y,
+              PUT_PIXEL (ximg, x, y,
                          lookup_rgb_color (f,
 					   color_scale * pixel.red,
 					   color_scale * pixel.green,
 					   color_scale * pixel.blue));
-#endif
             }
         }
       DestroyPixelIterator (iterator);
     }
 
-#ifdef USE_CAIRO
-  set_cairo_image_surface (img, surface);
-#else
 #ifdef COLOR_TABLE_SUPPORT
   /* Remember colors allocated for this image.  */
   img->colors = colors_in_color_table (&img->ncolors);
@@ -9279,7 +9322,6 @@ imagemagick_load_image (struct frame *f, struct image *img,
 
   /* Put ximg into the image.  */
   image_put_x_image (f, img, ximg, 0);
-#endif
 
   /* Final cleanup. image_wand should be the only resource left. */
   DestroyMagickWand (image_wand);
@@ -9316,7 +9358,7 @@ imagemagick_load (struct frame *f, struct image *img)
   file_name = image_spec_value (img->spec, QCfile, NULL);
   if (STRINGP (file_name))
     {
-      Lisp_Object file = x_find_image_file (file_name);
+      Lisp_Object file = image_find_image_file (file_name);
       if (!STRINGP (file))
 	{
 	  image_error ("Cannot find image file `%s'", file_name);
@@ -9395,9 +9437,6 @@ and `imagemagick-types-inhibit'.  */)
 
 /* Function prototypes.  */
 
-static bool svg_image_p (Lisp_Object object);
-static bool svg_load (struct frame *f, struct image *img);
-
 static bool svg_load_image (struct frame *, struct image *,
 			    char *, ptrdiff_t, char *);
 
@@ -9435,27 +9474,6 @@ static const struct image_keyword svg_format[SVG_LAST] =
   {":background",	IMAGE_STRING_OR_NIL_VALUE,		0}
 };
 
-# if defined HAVE_NTGUI && defined WINDOWSNT
-static bool init_svg_functions (void);
-# else
-#define init_svg_functions NULL
-# endif
-
-/* Structure describing the image type `svg'.  Its the same type of
-   structure defined for all image formats, handled by emacs image
-   functions.  See struct image_type in dispextern.h.  */
-
-static struct image_type svg_type =
-{
-  SYMBOL_INDEX (Qsvg),
-  svg_image_p,
-  svg_load,
-  x_clear_image,
-  init_svg_functions,
-  NULL
-};
-
-
 /* Return true if OBJECT is a valid SVG image specification.  Do
    this by calling parse_image_spec and supplying the keywords that
    identify the SVG format.   */
@@ -9486,6 +9504,11 @@ svg_image_p (Lisp_Object object)
 
 # include <librsvg/rsvg.h>
 
+/* librsvg is too old for us if it doesn't define this macro.  */
+# ifndef LIBRSVG_CHECK_VERSION
+#  define LIBRSVG_CHECK_VERSION(v, w, x) false
+# endif
+
 # ifdef WINDOWSNT
 
 /* Restore the original definition of __MINGW_MAJOR_VERSION.  */
@@ -9620,7 +9643,7 @@ svg_load (struct frame *f, struct image *img)
   if (STRINGP (file_name))
     {
       int fd;
-      Lisp_Object file = x_find_image_fd (file_name, &fd);
+      Lisp_Object file = image_find_image_fd (file_name, &fd);
       if (!STRINGP (file))
 	{
 	  image_error ("Cannot find image file `%s'", file_name);
@@ -9694,7 +9717,18 @@ svg_load_image (struct frame *f, struct image *img, char *contents,
      See rsvg bug 596114 - "image refs are relative to curdir, not .svg file"
      <https://gitlab.gnome.org/GNOME/librsvg/issues/33>. */
   if (filename)
-    rsvg_handle_set_base_uri(rsvg_handle, filename);
+    rsvg_handle_set_base_uri (rsvg_handle, filename);
+
+  /* Suppress GCC deprecation warnings starting in librsvg 2.45.1 for
+     rsvg_handle_write and rsvg_handle_close.  FIXME: Use functions
+     like rsvg_handle_new_from_gfile_sync on newer librsvg versions,
+     and remove this hack.  */
+  #if GNUC_PREREQ (4, 6, 0)
+   #pragma GCC diagnostic push
+  #endif
+  #if LIBRSVG_CHECK_VERSION (2, 45, 1) && GNUC_PREREQ (4, 2, 0)
+   #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+  #endif
 
   /* Parse the contents argument and fill in the rsvg_handle.  */
   rsvg_handle_write (rsvg_handle, (unsigned char *) contents, size, &err);
@@ -9705,6 +9739,10 @@ svg_load_image (struct frame *f, struct image *img, char *contents,
   rsvg_handle_close (rsvg_handle, &err);
   if (err) goto rsvg_error;
 
+  #if GNUC_PREREQ (4, 6, 0)
+   #pragma GCC diagnostic pop
+  #endif
+
   rsvg_handle_get_dimensions (rsvg_handle, &dimension_data);
   if (! check_image_size (f, dimension_data.width, dimension_data.height))
     {
@@ -9731,35 +9769,8 @@ svg_load_image (struct frame *f, struct image *img, char *contents,
   eassert (gdk_pixbuf_get_bits_per_sample (pixbuf) == 8);
 
   {
-#ifdef USE_CAIRO
-    cairo_surface_t *surface = create_cairo_image_surface (width, height);
-    uint32_t *dataptr = (uint32_t *) cairo_image_surface_get_data (surface);
-    uint32_t bgcolor = get_spec_bg_or_alpha_as_argb (img, f);
-
-    for (int y = 0; y < height; ++y)
-      {
-        const guchar *iconptr = pixels + y * rowstride;
-
-        for (int x = 0; x < width; ++x)
-          {
-            if (iconptr[3] == 0)
-              *dataptr = bgcolor;
-            else
-              *dataptr = (iconptr[0] << 16)
-                | (iconptr[1] << 8)
-                | iconptr[2]
-                | (iconptr[3] << 24);
-
-            iconptr += 4;
-            ++dataptr;
-          }
-      }
-
-    set_cairo_image_surface (img, surface);
-    g_object_unref (pixbuf);
-#else
     /* Try to create a x pixmap to hold the svg pixmap.  */
-    XImagePtr ximg;
+    Emacs_Pix_Container ximg;
     if (!image_create_x_image_and_pixmap (f, img, width, height, 0, &ximg, 0))
       {
 	g_object_unref (pixbuf);
@@ -9770,11 +9781,15 @@ svg_load_image (struct frame *f, struct image *img, char *contents,
 
     /* Handle alpha channel by combining the image with a background
        color.  */
-    XColor background;
+    Emacs_Color background;
     Lisp_Object specified_bg = image_spec_value (img->spec, QCbackground, NULL);
     if (!STRINGP (specified_bg)
-	|| !x_defined_color (f, SSDATA (specified_bg), &background, 0))
-      x_query_frame_background_color (f, &background);
+	|| !FRAME_TERMINAL (f)->defined_color_hook (f,
+                                                    SSDATA (specified_bg),
+                                                    &background,
+                                                    false,
+                                                    false))
+      FRAME_TERMINAL (f)->query_frame_background_color (f, &background);
 
     /* SVG pixmaps specify transparency in the last byte, so right
        shift 8 bits to get rid of it, since emacs doesn't support
@@ -9803,7 +9818,7 @@ svg_load_image (struct frame *f, struct image *img, char *contents,
 	    blue  = ((blue * opacity)
 		     + (background.blue * ((1 << 8) - opacity)));
 
-	    XPutPixel (ximg, x, y, lookup_rgb_color (f, red, green, blue));
+	    PUT_PIXEL (ximg, x, y, lookup_rgb_color (f, red, green, blue));
 	  }
 
 	pixels += rowstride - 4 * width;
@@ -9822,11 +9837,10 @@ svg_load_image (struct frame *f, struct image *img, char *contents,
 
     /* Maybe fill in the background field while we have ximg handy.
        Casting avoids a GCC warning.  */
-    IMAGE_BACKGROUND (img, f, (XImagePtr_or_DC)ximg);
+    IMAGE_BACKGROUND (img, f, (Emacs_Pix_Context)ximg);
 
     /* Put ximg into the image.  */
     image_put_x_image (f, img, ximg, 0);
-#endif /* ! USE_CAIRO */
   }
 
   return 1;
@@ -9849,16 +9863,12 @@ svg_load_image (struct frame *f, struct image *img, char *contents,
 				Ghostscript
  ***********************************************************************/
 
-#ifdef HAVE_X_WINDOWS
+#if defined HAVE_X_WINDOWS && !defined USE_CAIRO
 #define HAVE_GHOSTSCRIPT 1
-#endif /* HAVE_X_WINDOWS */
+#endif /* HAVE_X_WINDOWS && !USE_CAIRO */
 
 #ifdef HAVE_GHOSTSCRIPT
 
-static bool gs_image_p (Lisp_Object object);
-static bool gs_load (struct frame *f, struct image *img);
-static void gs_clear_image (struct frame *f, struct image *img);
-
 /* Indices of image specification fields in gs_format, below.  */
 
 enum gs_keyword_index
@@ -9899,28 +9909,6 @@ static const struct image_keyword gs_format[GS_LAST] =
   {":background",	IMAGE_STRING_OR_NIL_VALUE,		0}
 };
 
-/* Structure describing the image type `ghostscript'.  */
-
-static struct image_type gs_type =
-{
-  SYMBOL_INDEX (Qpostscript),
-  gs_image_p,
-  gs_load,
-  gs_clear_image,
-  NULL,
-  NULL
-};
-
-
-/* Free X resources of Ghostscript image IMG which is used on frame F.  */
-
-static void
-gs_clear_image (struct frame *f, struct image *img)
-{
-  x_clear_image (f, img);
-}
-
-
 /* Return true if OBJECT is a valid Ghostscript image
    specification.  */
 
@@ -9997,7 +9985,7 @@ gs_load (struct frame *f, struct image *img)
   /* Create the pixmap.  */
   eassert (img->pixmap == NO_PIXMAP);
 
-  if (x_check_image_size (0, img->width, img->height))
+  if (image_check_image_size (0, img->width, img->height))
     {
       /* Only W32 version did BLOCK_INPUT here.  ++kfs */
       block_input ();
@@ -10076,7 +10064,7 @@ x_kill_gs_process (Pixmap pixmap, struct frame *f)
      img->pixmap.  */
   if (x_mutable_colormap (FRAME_X_VISUAL (f)))
     {
-      XImagePtr ximg;
+      XImage *ximg;
 
       block_input ();
 
@@ -10107,7 +10095,7 @@ x_kill_gs_process (Pixmap pixmap, struct frame *f)
 	  XDestroyImage (ximg);
 
 #if 0 /* This doesn't seem to be the case.  If we free the colors
-	 here, we get a BadAccess later in x_clear_image when
+	 here, we get a BadAccess later in image_clear_image when
 	 freeing the colors.  */
 	  /* We have allocated colors once, but Ghostscript has also
 	     allocated colors on behalf of us.  So, to get the
@@ -10168,9 +10156,9 @@ DEFUN ("lookup-image", Flookup_image, Slookup_image, 1, 1, 0,
 			    Initialization
  ***********************************************************************/
 
-DEFUN ("image-scaling-p", Fimage_scaling_p, Simage_scaling_p, 0, 1, 0,
-       doc: /* Test whether FRAME supports resizing images.
-Return t if FRAME supports native scaling, nil otherwise.  */)
+DEFUN ("image-transforms-p", Fimage_transforms_p, Simage_transforms_p, 0, 1, 0,
+       doc: /* Test whether FRAME supports image transformation.
+Return t if FRAME supports native transforms, nil otherwise.  */)
      (Lisp_Object frame)
 {
 #if defined (USE_CAIRO) || defined (HAVE_NS) || defined (HAVE_NTGUI)
@@ -10199,87 +10187,86 @@ the library file(s) specified by `dynamic-library-alist'.  */)
   return lookup_image_type (type) ? Qt : Qnil;
 }
 
-/* Look up image type TYPE, and return a pointer to its image_type
-   structure.  Return 0 if TYPE is not a known image type.  */
-
-static struct image_type *
-lookup_image_type (Lisp_Object type)
+static bool
+initialize_image_type (struct image_type const *type)
 {
-  /* Types pbm and xbm are built-in and always available.  */
-  if (EQ (type, Qpbm))
-    return define_image_type (&pbm_type);
-
-  if (EQ (type, Qxbm))
-    return define_image_type (&xbm_type);
+#ifdef WINDOWSNT
+  Lisp_Object typesym = builtin_lisp_symbol (type->type);
+  Lisp_Object tested = Fassq (typesym, Vlibrary_cache);
+  /* If we failed to load the library before, don't try again.  */
+  if (CONSP (tested))
+    return !NILP (XCDR (tested)) ? true : false;
 
-#if defined (HAVE_XPM) || defined (HAVE_NS)
-  if (EQ (type, Qxpm))
-    return define_image_type (&xpm_type);
+  bool (*init) (void) = type->init;
+  if (init)
+    {
+      bool type_valid = init ();
+      Vlibrary_cache = Fcons (Fcons (typesym, type_valid ? Qt : Qnil),
+			      Vlibrary_cache);
+      return type_valid;
+    }
 #endif
+  return true;
+}
 
-#if defined (HAVE_JPEG) || defined (HAVE_NS)
-  if (EQ (type, Qjpeg))
-    return define_image_type (&jpeg_type);
-#endif
+/* Array of supported image types.  */
 
-#if defined (HAVE_TIFF) || defined (HAVE_NS)
-  if (EQ (type, Qtiff))
-    return define_image_type (&tiff_type);
+static struct image_type const image_types[] =
+{
+#ifdef HAVE_GHOSTSCRIPT
+ { SYMBOL_INDEX (Qpostscript), gs_image_p, gs_load, image_clear_image },
 #endif
-
-#if defined (HAVE_GIF) || defined (HAVE_NS)
-  if (EQ (type, Qgif))
-    return define_image_type (&gif_type);
+#ifdef HAVE_IMAGEMAGICK
+ { SYMBOL_INDEX (Qimagemagick), imagemagick_image_p, imagemagick_load,
+   imagemagick_clear_image },
 #endif
-
-#if defined (HAVE_PNG) || defined (HAVE_NS) || defined (USE_CAIRO)
-  if (EQ (type, Qpng))
-    return define_image_type (&png_type);
+#ifdef HAVE_RSVG
+ { SYMBOL_INDEX (Qsvg), svg_image_p, svg_load, image_clear_image,
+   IMAGE_TYPE_INIT (init_svg_functions) },
 #endif
-
-#if defined (HAVE_RSVG)
-  if (EQ (type, Qsvg))
-    return define_image_type (&svg_type);
+#if defined HAVE_PNG || defined HAVE_NS || defined USE_CAIRO
+ { SYMBOL_INDEX (Qpng), png_image_p, png_load, image_clear_image,
+   IMAGE_TYPE_INIT (init_png_functions) },
 #endif
-
-#if defined (HAVE_IMAGEMAGICK)
-  if (EQ (type, Qimagemagick))
-    return define_image_type (&imagemagick_type);
+#if defined HAVE_GIF || defined HAVE_NS
+ { SYMBOL_INDEX (Qgif), gif_image_p, gif_load, gif_clear_image,
+   IMAGE_TYPE_INIT (init_gif_functions) },
 #endif
-
-#ifdef HAVE_GHOSTSCRIPT
-  if (EQ (type, Qpostscript))
-    return define_image_type (&gs_type);
+#if defined HAVE_TIFF || defined HAVE_NS
+ { SYMBOL_INDEX (Qtiff), tiff_image_p, tiff_load, image_clear_image,
+   IMAGE_TYPE_INIT (init_tiff_functions) },
 #endif
+#if defined HAVE_JPEG || defined HAVE_NS
+ { SYMBOL_INDEX (Qjpeg), jpeg_image_p, jpeg_load, image_clear_image,
+   IMAGE_TYPE_INIT (init_jpeg_functions) },
+#endif
+#if defined HAVE_XPM || defined HAVE_NS
+ { SYMBOL_INDEX (Qxpm), xpm_image_p, xpm_load, image_clear_image,
+   IMAGE_TYPE_INIT (init_xpm_functions) },
+#endif
+ { SYMBOL_INDEX (Qxbm), xbm_image_p, xbm_load, image_clear_image },
+ { SYMBOL_INDEX (Qpbm), pbm_image_p, pbm_load, image_clear_image },
+};
 
-  return NULL;
-}
-
-#if defined HAVE_UNEXEC && defined HAVE_WINDOW_SYSTEM
-
-/* Reset image_types before dumping.
-   Called from Fdump_emacs.  */
+/* Look up image type TYPE, and return a pointer to its image_type
+   structure.  Return 0 if TYPE is not a known image type.  */
 
-void
-reset_image_types (void)
+static struct image_type const *
+lookup_image_type (Lisp_Object type)
 {
-  while (image_types)
+  for (int i = 0; i < ARRAYELTS (image_types); i++)
     {
-      struct image_type *next = image_types->next;
-      xfree (image_types);
-      image_types = next;
+      struct image_type const *r = &image_types[i];
+      if (EQ (type, builtin_lisp_symbol (r->type)))
+	return initialize_image_type (r) ? r : NULL;
     }
+  return NULL;
 }
-#endif
+
 
 void
 syms_of_image (void)
 {
-  /* Initialize this only once; it will be reset before dumping.  */
-  /* The portable dumper will just leave it NULL, so no need to reset.  */
-  image_types = NULL;
-  PDUMPER_IGNORE (image_types);
-
   /* Must be defined now because we're going to update it below, while
      defining the supported image types.  */
   DEFVAR_LISP ("image-types", Vimage_types,
@@ -10330,7 +10317,7 @@ non-numeric, there is no explicit limit on the size of images.  */);
   DEFSYM (QCmax_width, ":max-width");
   DEFSYM (QCmax_height, ":max-height");
 #ifdef HAVE_GHOSTSCRIPT
-  ADD_IMAGE_TYPE (Qpostscript);
+  add_image_type (Qpostscript);
   DEFSYM (QCloader, ":loader");
   DEFSYM (QCpt_width, ":pt-width");
   DEFSYM (QCpt_height, ":pt-height");
@@ -10370,44 +10357,44 @@ non-numeric, there is no explicit limit on the size of images.  */);
 #endif
 
   DEFSYM (Qpbm, "pbm");
-  ADD_IMAGE_TYPE (Qpbm);
+  add_image_type (Qpbm);
 
   DEFSYM (Qxbm, "xbm");
-  ADD_IMAGE_TYPE (Qxbm);
+  add_image_type (Qxbm);
 
 #if defined (HAVE_XPM) || defined (HAVE_NS)
   DEFSYM (Qxpm, "xpm");
-  ADD_IMAGE_TYPE (Qxpm);
+  add_image_type (Qxpm);
 #endif
 
 #if defined (HAVE_JPEG) || defined (HAVE_NS)
   DEFSYM (Qjpeg, "jpeg");
-  ADD_IMAGE_TYPE (Qjpeg);
+  add_image_type (Qjpeg);
 #endif
 
 #if defined (HAVE_TIFF) || defined (HAVE_NS)
   DEFSYM (Qtiff, "tiff");
-  ADD_IMAGE_TYPE (Qtiff);
+  add_image_type (Qtiff);
 #endif
 
 #if defined (HAVE_GIF) || defined (HAVE_NS)
   DEFSYM (Qgif, "gif");
-  ADD_IMAGE_TYPE (Qgif);
+  add_image_type (Qgif);
 #endif
 
 #if defined (HAVE_PNG) || defined (HAVE_NS)
   DEFSYM (Qpng, "png");
-  ADD_IMAGE_TYPE (Qpng);
+  add_image_type (Qpng);
 #endif
 
 #if defined (HAVE_IMAGEMAGICK)
   DEFSYM (Qimagemagick, "imagemagick");
-  ADD_IMAGE_TYPE (Qimagemagick);
+  add_image_type (Qimagemagick);
 #endif
 
 #if defined (HAVE_RSVG)
   DEFSYM (Qsvg, "svg");
-  ADD_IMAGE_TYPE (Qsvg);
+  add_image_type (Qsvg);
 #ifdef HAVE_NTGUI
   /* Other libraries used directly by svg code.  */
   DEFSYM (Qgdk_pixbuf, "gdk-pixbuf");
@@ -10431,7 +10418,7 @@ non-numeric, there is no explicit limit on the size of images.  */);
   defsubr (&Slookup_image);
 #endif
 
-  defsubr (&Simage_scaling_p);
+  defsubr (&Simage_transforms_p);
 
   DEFVAR_BOOL ("cross-disabled-images", cross_disabled_images,
     doc: /* Non-nil means always draw a cross over disabled images.
diff --git a/src/indent.c b/src/indent.c
index 1d5d346e63..90d8b1ce8e 100644
--- a/src/indent.c
+++ b/src/indent.c
@@ -983,9 +983,10 @@ If specified column is within a character, point goes after that character.
 If it's past end of line, point goes to end of line.
 
 Optional second argument FORCE non-nil means if COLUMN is in the
-middle of a tab character, change it to spaces.
-In addition, if FORCE is t, and the line is too short to reach
-COLUMN, add spaces/tabs to get there.
+middle of a tab character, either change it to spaces (when
+`indent-tabs-mode' is nil), or insert enough spaces before it to reach
+COLUMN (otherwise).  In addition, if FORCE is t, and the line is too short
+to reach COLUMN, add spaces/tabs to get there.
 
 The return value is the current column.  */)
   (Lisp_Object column, Lisp_Object force)
@@ -1968,8 +1969,11 @@ line_number_display_width (struct window *w, int *width, int *pixel_width)
 	 outside the accessible region, in which case we widen the
 	 buffer temporarily.  It could even be beyond the buffer's end
 	 (Org mode's display of source code snippets is known to cause
-	 that), in which case we just punt and start from point instead.  */
-      if (startpos.charpos > Z)
+	 that) or belong to the wrong buffer, in which cases we just
+	 punt and start from point instead.  */
+      if (startpos.charpos > Z
+	  || !(BUFFERP (w->contents)
+	       && XBUFFER (w->contents) == XMARKER (w->start)->buffer))
 	SET_TEXT_POS (startpos, PT, PT_BYTE);
       if (startpos.charpos < BEGV || startpos.charpos > ZV)
 	{
diff --git a/src/inotify.c b/src/inotify.c
index ecbe31c168..9a7dbb8f41 100644
--- a/src/inotify.c
+++ b/src/inotify.c
@@ -19,8 +19,6 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include <config.h>
 
-#ifdef HAVE_INOTIFY
-
 #include "lisp.h"
 #include "coding.h"
 #include "process.h"
@@ -550,5 +548,3 @@ syms_of_inotify (void)
 
   Fprovide (intern_c_string ("inotify"), Qnil);
 }
-
-#endif /* HAVE_INOTIFY */
diff --git a/src/insdel.c b/src/insdel.c
index 1231bb2682..85fffd8fd1 100644
--- a/src/insdel.c
+++ b/src/insdel.c
@@ -2178,6 +2178,7 @@ signal_after_change (ptrdiff_t charpos, ptrdiff_t lendel, ptrdiff_t lenins)
 {
   ptrdiff_t count = SPECPDL_INDEX ();
   struct rvoe_arg rvoe_arg;
+  Lisp_Object tmp;
 
   if (inhibit_modification_hooks)
     return;
@@ -2186,7 +2187,16 @@ signal_after_change (ptrdiff_t charpos, ptrdiff_t lendel, ptrdiff_t lenins)
      and there are no before-change functions,
      just record the args that we were going to use.  */
   if (! NILP (Vcombine_after_change_calls)
-      && NILP (Vbefore_change_functions)
+      /* It's OK to defer after-changes even if syntax-ppss-flush-cache
+       * is on before-change-functions, which is common enough to be worth
+       * adding a special case for it.  */
+      && (NILP (Vbefore_change_functions)
+          || (CONSP (Vbefore_change_functions)
+              && EQ (Qt, XCAR (Vbefore_change_functions))
+              && NILP (Fdefault_value (Qbefore_change_functions))
+              && CONSP (tmp = XCDR (Vbefore_change_functions))
+              && NILP (XCDR (tmp))
+              && EQ (XCAR (tmp), Qsyntax_ppss_flush_cache)))
       && !buffer_has_overlays ())
     {
       Lisp_Object elt;
@@ -2343,6 +2353,7 @@ syms_of_insdel (void)
   combine_after_change_buffer = Qnil;
 
   DEFSYM (Qundo_auto__undoable_change, "undo-auto--undoable-change");
+  DEFSYM (Qsyntax_ppss_flush_cache, "syntax-ppss-flush-cache");
 
   DEFVAR_LISP ("combine-after-change-calls", Vcombine_after_change_calls,
 	       doc: /* Used internally by the function `combine-after-change-calls' macro.  */);
diff --git a/src/intervals.c b/src/intervals.c
index 8f39c45762..38367460a5 100644
--- a/src/intervals.c
+++ b/src/intervals.c
@@ -2334,23 +2334,10 @@ set_intervals_multibyte_1 (INTERVAL i, bool multi_flag,
 
       if (multi_flag)
 	{
-	  ptrdiff_t temp;
-	  left_end_byte = start_byte + LEFT_TOTAL_LENGTH (i);
+	  left_end_byte
+            = advance_to_char_boundary (start_byte + LEFT_TOTAL_LENGTH (i));
 	  left_end = BYTE_TO_CHAR (left_end_byte);
-
-	  temp = CHAR_TO_BYTE (left_end);
-
-	  /* If LEFT_END_BYTE is in the middle of a character,
-	     adjust it and LEFT_END to a char boundary.  */
-	  if (left_end_byte > temp)
-	    {
-	      left_end_byte = temp;
-	    }
-	  if (left_end_byte < temp)
-	    {
-	      left_end--;
-	      left_end_byte = CHAR_TO_BYTE (left_end);
-	    }
+	  eassert (CHAR_TO_BYTE (left_end) == left_end_byte);
 	}
       else
 	{
@@ -2367,24 +2354,10 @@ set_intervals_multibyte_1 (INTERVAL i, bool multi_flag,
 
       if (multi_flag)
 	{
-	  ptrdiff_t temp;
-
-	  right_start_byte = end_byte - RIGHT_TOTAL_LENGTH (i);
+	  right_start_byte
+            = advance_to_char_boundary (end_byte - RIGHT_TOTAL_LENGTH (i));
 	  right_start = BYTE_TO_CHAR (right_start_byte);
-
-	  /* If RIGHT_START_BYTE is in the middle of a character,
-	     adjust it and RIGHT_START to a char boundary.  */
-	  temp = CHAR_TO_BYTE (right_start);
-
-	  if (right_start_byte < temp)
-	    {
-	      right_start_byte = temp;
-	    }
-	  if (right_start_byte > temp)
-	    {
-	      right_start++;
-	      right_start_byte = CHAR_TO_BYTE (right_start);
-	    }
+	  eassert (CHAR_TO_BYTE (right_start) == right_start_byte);
 	}
       else
 	{
diff --git a/src/json.c b/src/json.c
index 74e0534065..e2a4424463 100644
--- a/src/json.c
+++ b/src/json.c
@@ -215,33 +215,11 @@ json_has_suffix (const char *string, const char *suffix)
 
 #endif
 
-/* Create a multibyte Lisp string from the UTF-8 string in
-   [DATA, DATA + SIZE).  If the range [DATA, DATA + SIZE) does not
-   contain a valid UTF-8 string, an unspecified string is returned.
-   Note that all callers below either pass only value UTF-8 strings or
-   use this function for formatting error messages; in the latter case
-   correctness isn't critical.  */
-
-static Lisp_Object
-json_make_string (const char *data, ptrdiff_t size)
-{
-  return code_convert_string (make_specified_string (data, -1, size, false),
-                              Qutf_8_unix, Qt, false, true, true);
-}
-
-/* Create a multibyte Lisp string from the NUL-terminated UTF-8
-   string beginning at DATA.  If the string is not a valid UTF-8
-   string, an unspecified string is returned.  Note that all callers
-   below either pass only value UTF-8 strings or use this function for
+/* Note that all callers of make_string_from_utf8 and build_string_from_utf8
+   below either pass only value UTF-8 strings or use the functionf for
    formatting error messages; in the latter case correctness isn't
    critical.  */
 
-static Lisp_Object
-json_build_string (const char *data)
-{
-  return json_make_string (data, strlen (data));
-}
-
 /* Return a unibyte string containing the sequence of UTF-8 encoding
    units of the UTF-8 representation of STRING.  If STRING does not
    represent a sequence of Unicode scalar values, return a string with
@@ -255,7 +233,7 @@ json_encode (Lisp_Object string)
   return code_convert_string (string, Qutf_8_unix, Qt, true, true, true);
 }
 
-static _Noreturn void
+static AVOID
 json_out_of_memory (void)
 {
   xsignal0 (Qjson_out_of_memory);
@@ -263,7 +241,7 @@ json_out_of_memory (void)
 
 /* Signal a Lisp error corresponding to the JSON ERROR.  */
 
-static _Noreturn void
+static AVOID
 json_parse_error (const json_error_t *error)
 {
   Lisp_Object symbol;
@@ -289,9 +267,11 @@ json_parse_error (const json_error_t *error)
     symbol = Qjson_parse_error;
 #endif
   xsignal (symbol,
-           list5 (json_build_string (error->text),
-                  json_build_string (error->source), make_fixed_natnum (error->line),
-                  make_fixed_natnum (error->column), make_fixed_natnum (error->position)));
+           list5 (build_string_from_utf8 (error->text),
+                  build_string_from_utf8 (error->source),
+		  INT_TO_INTEGER (error->line),
+                  INT_TO_INTEGER (error->column),
+		  INT_TO_INTEGER (error->position)));
 }
 
 static void
@@ -499,7 +479,7 @@ lisp_to_json (Lisp_Object lisp, struct json_configuration *conf)
       intmax_t low = TYPE_MINIMUM (json_int_t);
       intmax_t high = TYPE_MAXIMUM (json_int_t);
       intmax_t value;
-      if (! integer_to_intmax (lisp, &value) || value < low || high < value)
+      if (! (integer_to_intmax (lisp, &value) && low <= value && value <= high))
         args_out_of_range_3 (lisp, make_int (low), make_int (high));
       return json_check (json_integer (value));
     }
@@ -634,7 +614,7 @@ usage: (json-serialize OBJECT &rest ARGS)  */)
     json_out_of_memory ();
   record_unwind_protect_ptr (json_free, string);
 
-  return unbind_to (count, json_build_string (string));
+  return unbind_to (count, build_string_from_utf8 (string));
 }
 
 struct json_buffer_and_size
@@ -665,6 +645,20 @@ json_insert (void *data)
   return Qnil;
 }
 
+static Lisp_Object
+json_handle_nonlocal_exit (enum nonlocal_exit type, Lisp_Object data)
+{
+  switch (type)
+    {
+    case NONLOCAL_EXIT_SIGNAL:
+      return data;
+    case NONLOCAL_EXIT_THROW:
+      return Fcons (Qno_catch, data);
+    default:
+      eassume (false);
+    }
+}
+
 struct json_insert_data
 {
   /* This tracks how many bytes were inserted by the callback since
@@ -687,7 +681,8 @@ json_insert_callback (const char *buffer, size_t size, void *data)
   struct json_insert_data *d = data;
   struct json_buffer_and_size buffer_and_size
     = {.buffer = buffer, .size = size, .inserted_bytes = d->inserted_bytes};
-  d->error = internal_catch_all (json_insert, &buffer_and_size, Fidentity);
+  d->error = internal_catch_all (json_insert, &buffer_and_size,
+                                 json_handle_nonlocal_exit);
   d->inserted_bytes = buffer_and_size.inserted_bytes;
   return NILP (d->error) ? 0 : -1;
 }
@@ -826,8 +821,8 @@ json_to_lisp (json_t *json, struct json_configuration *conf)
     case JSON_REAL:
       return make_float (json_real_value (json));
     case JSON_STRING:
-      return json_make_string (json_string_value (json),
-                               json_string_length (json));
+      return make_string_from_utf8 (json_string_value (json),
+				    json_string_length (json));
     case JSON_ARRAY:
       {
         if (++lisp_eval_depth > max_lisp_eval_depth)
@@ -886,7 +881,7 @@ json_to_lisp (json_t *json, struct json_configuration *conf)
               json_t *value;
               json_object_foreach (json, key_str, value)
                 {
-                  Lisp_Object key = json_build_string (key_str);
+                  Lisp_Object key = build_string_from_utf8 (key_str);
                   EMACS_UINT hash;
                   ptrdiff_t i = hash_lookup (h, key, &hash);
                   /* Keys in JSON objects are unique, so the key can't
@@ -903,7 +898,8 @@ json_to_lisp (json_t *json, struct json_configuration *conf)
               json_t *value;
               json_object_foreach (json, key_str, value)
                 {
-                  Lisp_Object key = Fintern (json_build_string (key_str), Qnil);
+                  Lisp_Object key
+		    = Fintern (build_string_from_utf8 (key_str), Qnil);
                   result
                     = Fcons (Fcons (key, json_to_lisp (value, conf)),
                              result);
diff --git a/src/keyboard.c b/src/keyboard.c
index 8fb6db987b..bb4d185c91 100644
--- a/src/keyboard.c
+++ b/src/keyboard.c
@@ -364,7 +364,7 @@ static void restore_getcjmp (void *);
 static Lisp_Object apply_modifiers (int, Lisp_Object);
 static void restore_kboard_configuration (int);
 static void handle_interrupt (bool);
-static _Noreturn void quit_throw_to_read_char (bool);
+static AVOID quit_throw_to_read_char (bool);
 static void timer_start_idle (void);
 static void timer_stop_idle (void);
 static void timer_resume_idle (void);
@@ -1131,13 +1131,12 @@ This also exits all active minibuffers.  */
   Fthrow (Qtop_level, Qnil);
 }
 
-static _Noreturn void
+static AVOID
 user_error (const char *msg)
 {
   xsignal1 (Quser_error, build_string (msg));
 }
 
-/* _Noreturn will be added to prototype by make-docfile.  */
 DEFUN ("exit-recursive-edit", Fexit_recursive_edit, Sexit_recursive_edit, 0, 0, "",
        doc: /* Exit from the innermost recursive edit or minibuffer.  */
        attributes: noreturn)
@@ -1149,7 +1148,6 @@ DEFUN ("exit-recursive-edit", Fexit_recursive_edit, Sexit_recursive_edit, 0, 0,
   user_error ("No recursive edit is in progress");
 }
 
-/* _Noreturn will be added to prototype by make-docfile.  */
 DEFUN ("abort-recursive-edit", Fabort_recursive_edit, Sabort_recursive_edit, 0, 0, "",
        doc: /* Abort the command that requested this recursive edit or minibuffer input.  */
        attributes: noreturn)
@@ -3892,10 +3890,12 @@ kbd_buffer_get_event (KBOARD **kbp,
 #ifdef HAVE_EXT_MENU_BAR
       case MENU_BAR_ACTIVATE_EVENT:
 	{
+          struct frame *f;
 	  kbd_fetch_ptr = next_kbd_event (event);
 	  input_pending = readable_events (0);
-	  if (FRAME_LIVE_P (XFRAME (event->ie.frame_or_window)))
-	    x_activate_menubar (XFRAME (event->ie.frame_or_window));
+          f = (XFRAME (event->ie.frame_or_window));
+	  if (FRAME_LIVE_P (f) && FRAME_TERMINAL (f)->activate_menubar_hook)
+	    FRAME_TERMINAL (f)->activate_menubar_hook (f);
 	}
         break;
 #endif
@@ -3909,7 +3909,7 @@ kbd_buffer_get_event (KBOARD **kbp,
       case END_SESSION_EVENT:
       case LANGUAGE_CHANGE_EVENT:
 #endif
-#if defined (HAVE_X11) || defined (HAVE_NTGUI) || defined (HAVE_NS)
+#ifdef HAVE_WINDOW_SYSTEM
       case DELETE_WINDOW_EVENT:
       case ICONIFY_EVENT:
       case DEICONIFY_EVENT:
@@ -5283,7 +5283,7 @@ make_lispy_event (struct input_event *event)
 
   switch (event->kind)
     {
-#if defined (HAVE_X11) || defined (HAVE_NTGUI) || defined (HAVE_NS)
+#ifdef HAVE_WINDOW_SYSTEM
     case DELETE_WINDOW_EVENT:
       /* Make an event (delete-frame (FRAME)).  */
       return list2 (Qdelete_frame, list1 (event->frame_or_window));
@@ -6510,7 +6510,7 @@ modify_event_symbol (ptrdiff_t symbol_num, int modifiers, Lisp_Object symbol_kin
 #ifdef HAVE_WINDOW_SYSTEM
       if (NILP (value))
 	{
-	  char *name = x_get_keysym_name (symbol_num);
+	  char *name = get_keysym_name (symbol_num);
 	  if (name)
 	    value = intern (name);
 	}
@@ -9968,7 +9968,7 @@ If CHECK-TIMERS is non-nil, timers that are ready to run will do so.  */)
 DEFUN ("recent-keys", Frecent_keys, Srecent_keys, 0, 1, 0,
        doc: /* Return vector of last few events, not counting those from keyboard macros.
 If INCLUDE-CMDS is non-nil, include the commands that were run,
-represented as events of the form (nil . COMMAND).  */)
+represented as pseudo-events of the form (nil . COMMAND).  */)
   (Lisp_Object include_cmds)
 {
   bool cmds = !NILP (include_cmds);
diff --git a/src/kqueue.c b/src/kqueue.c
index 48121bd663..42391f8467 100644
--- a/src/kqueue.c
+++ b/src/kqueue.c
@@ -19,7 +19,6 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include <config.h>
 
-#ifdef HAVE_KQUEUE
 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/event.h>
@@ -533,8 +532,6 @@ syms_of_kqueue (void)
   Fprovide (intern_c_string ("kqueue"), Qnil);
 }
 
-#endif /* HAVE_KQUEUE  */
-
 /* PROBLEMS
    * https://bugs.launchpad.net/ubuntu/+source/libkqueue/+bug/1514837
      prevents tests on Ubuntu.  */
diff --git a/src/lisp.h b/src/lisp.h
index 681efc3b52..6db9059689 100644
--- a/src/lisp.h
+++ b/src/lisp.h
@@ -144,11 +144,13 @@ typedef intmax_t printmax_t;
 typedef uintmax_t uprintmax_t;
 # define pMd PRIdMAX
 # define pMu PRIuMAX
+# define pMx PRIxMAX
 #else
 typedef EMACS_INT printmax_t;
 typedef EMACS_UINT uprintmax_t;
 # define pMd pI"d"
 # define pMu pI"u"
+# define pMx pI"x"
 #endif
 
 /* Use pD to format ptrdiff_t values, which suffice for indexes into
@@ -166,6 +168,9 @@ typedef EMACS_UINT uprintmax_t;
 # define pD "t"
 #endif
 
+/* Convenience macro for rarely-used functions that do not return.  */
+#define AVOID _Noreturn ATTRIBUTE_COLD void
+
 /* Extra internal type checking?  */
 
 /* Define Emacs versions of <assert.h>'s 'assert (COND)' and <verify.h>'s
@@ -196,7 +201,7 @@ typedef EMACS_UINT uprintmax_t;
 # define eassume(cond) assume (cond)
 #else /* ENABLE_CHECKING */
 
-extern _Noreturn void die (const char *, const char *, int);
+extern AVOID die (const char *, const char *, int);
 
 extern bool suppress_checking EXTERNALLY_VISIBLE;
 
@@ -410,27 +415,11 @@ typedef EMACS_INT Lisp_Word;
 #define lisp_h_XCONS(a) \
    (eassert (CONSP (a)), XUNTAG (a, Lisp_Cons, struct Lisp_Cons))
 #define lisp_h_XHASH(a) XUFIXNUM (a)
-#ifndef GC_CHECK_CONS_LIST
-# define lisp_h_check_cons_list() ((void) 0)
-#endif
 #if USE_LSB_TAG
 # define lisp_h_make_fixnum(n) \
     XIL ((EMACS_INT) (((EMACS_UINT) (n) << INTTYPEBITS) + Lisp_Int0))
 # define lisp_h_XFIXNAT(a) XFIXNUM (a)
 # define lisp_h_XFIXNUM(a) (XLI (a) >> INTTYPEBITS)
-# ifdef __CHKP__
-#  define lisp_h_XSYMBOL(a) \
-    (eassert (SYMBOLP (a)), \
-     (struct Lisp_Symbol *) ((char *) XUNTAG (a, Lisp_Symbol, \
-					      struct Lisp_Symbol) \
-			     + (intptr_t) lispsym))
-# else
-   /* If !__CHKP__ this is equivalent, and is a bit faster as of GCC 7.  */
-#  define lisp_h_XSYMBOL(a) \
-    (eassert (SYMBOLP (a)), \
-     (struct Lisp_Symbol *) ((intptr_t) XLI (a) - Lisp_Symbol \
-			     + (char *) lispsym))
-# endif
 # define lisp_h_XTYPE(a) ((enum Lisp_Type) (XLI (a) & ~VALMASK))
 #endif
 
@@ -469,14 +458,10 @@ typedef EMACS_INT Lisp_Word;
 # define XCDR(c) lisp_h_XCDR (c)
 # define XCONS(a) lisp_h_XCONS (a)
 # define XHASH(a) lisp_h_XHASH (a)
-# ifndef GC_CHECK_CONS_LIST
-#  define check_cons_list() lisp_h_check_cons_list ()
-# endif
 # if USE_LSB_TAG
 #  define make_fixnum(n) lisp_h_make_fixnum (n)
 #  define XFIXNAT(a) lisp_h_XFIXNAT (a)
 #  define XFIXNUM(a) lisp_h_XFIXNUM (a)
-#  define XSYMBOL(a) lisp_h_XSYMBOL (a)
 #  define XTYPE(a) lisp_h_XTYPE (a)
 # endif
 #endif
@@ -621,7 +606,7 @@ extern Lisp_Object char_table_ref (Lisp_Object, int);
 extern void char_table_set (Lisp_Object, int, Lisp_Object);
 
 /* Defined in data.c.  */
-extern _Noreturn void wrong_type_argument (Lisp_Object, Lisp_Object);
+extern AVOID wrong_type_argument (Lisp_Object, Lisp_Object);
 
 
 /* Defined in emacs.c.  */
@@ -1020,21 +1005,17 @@ INLINE bool
 }
 
 INLINE struct Lisp_Symbol * ATTRIBUTE_NO_SANITIZE_UNDEFINED
-(XSYMBOL) (Lisp_Object a)
+XSYMBOL (Lisp_Object a)
 {
-#if USE_LSB_TAG
-  return lisp_h_XSYMBOL (a);
-#else
   eassert (SYMBOLP (a));
   intptr_t i = (intptr_t) XUNTAG (a, Lisp_Symbol, struct Lisp_Symbol);
   void *p = (char *) lispsym + i;
-# ifdef __CHKP__
+#ifdef __CHKP__
   /* Bypass pointer checking.  Although this could be improved it is
      probably not worth the trouble.  */
   p = __builtin___bnd_set_ptr_bounds (p, sizeof (struct Lisp_Symbol));
-# endif
-  return p;
 #endif
+  return p;
 }
 
 INLINE Lisp_Object
@@ -1094,9 +1075,7 @@ enum pvec_type
   PVEC_OVERLAY,
   PVEC_FINALIZER,
   PVEC_MISC_PTR,
-#ifdef HAVE_MODULES
   PVEC_USER_PTR,
-#endif
   PVEC_PROCESS,
   PVEC_FRAME,
   PVEC_WINDOW,
@@ -1302,11 +1281,11 @@ INLINE bool
 
 #define XSETPVECTYPE(v, code)						\
   ((v)->header.size |= PSEUDOVECTOR_FLAG | ((code) << PSEUDOVECTOR_AREA_BITS))
+#define PVECHEADERSIZE(code, lispsize, restsize) \
+  (PSEUDOVECTOR_FLAG | ((code) << PSEUDOVECTOR_AREA_BITS) \
+   | ((restsize) << PSEUDOVECTOR_SIZE_BITS) | (lispsize))
 #define XSETPVECTYPESIZE(v, code, lispsize, restsize)		\
-  ((v)->header.size = (PSEUDOVECTOR_FLAG			\
-		       | ((code) << PSEUDOVECTOR_AREA_BITS)	\
-		       | ((restsize) << PSEUDOVECTOR_SIZE_BITS) \
-		       | (lispsize)))
+  ((v)->header.size = PVECHEADERSIZE (code, lispsize, restsize))
 
 /* The cast to union vectorlike_header * avoids aliasing issues.  */
 #define XSETPSEUDOVECTOR(a, b, code) \
@@ -2257,7 +2236,7 @@ INLINE int
 }
 
 /* Placeholder for make-docfile to process.  The actual symbol
-   definition is done by lread.c's defsym.  */
+   definition is done by lread.c's define_symbol.  */
 #define DEFSYM(sym, name) /* empty */
 
 
@@ -2558,14 +2537,12 @@ xmint_pointer (Lisp_Object a)
   return XUNTAG (a, Lisp_Vectorlike, struct Lisp_Misc_Ptr)->pointer;
 }
 
-#ifdef HAVE_MODULES
 struct Lisp_User_Ptr
 {
   union vectorlike_header header;
   void (*finalizer) (void *);
   void *p;
 } GCALIGNED_STRUCT;
-#endif
 
 /* A finalizer sentinel.  */
 struct Lisp_Finalizer
@@ -2624,7 +2601,6 @@ XOVERLAY (Lisp_Object a)
   return XUNTAG (a, Lisp_Vectorlike, struct Lisp_Overlay);
 }
 
-#ifdef HAVE_MODULES
 INLINE bool
 USER_PTRP (Lisp_Object x)
 {
@@ -2637,7 +2613,6 @@ XUSER_PTR (Lisp_Object a)
   eassert (USER_PTRP (a));
   return XUNTAG (a, Lisp_Vectorlike, struct Lisp_User_Ptr);
 }
-#endif
 
 INLINE bool
 BIGNUMP (Lisp_Object x)
@@ -2704,7 +2679,7 @@ struct Lisp_Buffer_Objfwd
   {
     enum Lisp_Fwd_Type type;	/* = Lisp_Fwd_Buffer_Obj */
     int offset;
-    /* One of Qnil, Qfixnump, Qsymbolp, Qstringp, Qfloatp or Qnumberp.  */
+    /* One of Qnil, Qintegerp, Qsymbolp, Qstringp, Qfloatp or Qnumberp.  */
     Lisp_Object predicate;
   };
 
@@ -3096,7 +3071,9 @@ enum maxargs
 /* Call a function F that accepts many args, passing it the remaining args,
    E.g., 'return CALLN (Fformat, fmt, text);' is less error-prone than
    '{ Lisp_Object a[2]; a[0] = fmt; a[1] = text; return Fformat (2, a); }'.
-   CALLN is overkill for simple usages like 'Finsert (1, &text);'.  */
+   CALLN requires at least one function argument (as C99 prohibits
+   empty initializers), and is overkill for simple usages like
+   'Finsert (1, &text);'.  */
 #define CALLN(f, ...) CALLMANY (f, ((Lisp_Object []) {__VA_ARGS__}))
 
 extern void defvar_lisp (struct Lisp_Objfwd const *, char const *);
@@ -3259,8 +3236,10 @@ SPECPDL_INDEX (void)
    member is TAG, and then unbinds to it.  The `val' member is used to
    hold VAL while the stack is unwound; `val' is returned as the value
    of the catch form.  If there is a handler of type CATCHER_ALL, it will
-   be treated as a handler for all invocations of `throw'; in this case
-   `val' will be set to (TAG . VAL).
+   be treated as a handler for all invocations of `signal' and `throw';
+   in this case `val' will be set to (ERROR-SYMBOL . DATA) or (TAG . VAL),
+   respectively.  During stack unwinding, `nonlocal_exit' is set to
+   specify the type of nonlocal exit that caused the stack unwinding.
 
    All the other members are concerned with restoring the interpreter
    state.
@@ -3270,11 +3249,21 @@ SPECPDL_INDEX (void)
 
 enum handlertype { CATCHER, CONDITION_CASE, CATCHER_ALL };
 
+enum nonlocal_exit
+{
+  NONLOCAL_EXIT_SIGNAL,
+  NONLOCAL_EXIT_THROW,
+};
+
 struct handler
 {
   enum handlertype type;
   Lisp_Object tag_or_ch;
+
+  /* The next two are set by unwind_to_catch.  */
+  enum nonlocal_exit nonlocal_exit;
   Lisp_Object val;
+
   struct handler *next;
   struct handler *nextfree;
 
@@ -3472,7 +3461,7 @@ extern Lisp_Object make_bignum_str (char const *, int);
 extern Lisp_Object make_neg_biguint (uintmax_t);
 extern Lisp_Object double_to_integer (double);
 
-/* Converthe integer NUM to *N.  Return true if successful, false
+/* Convert the integer NUM to *N.  Return true if successful, false
    (possibly setting *N) otherwise.  */
 INLINE bool
 integer_to_intmax (Lisp_Object num, intmax_t *n)
@@ -3528,7 +3517,7 @@ modiff_to_integer (modiff_count a)
 }
 
 /* Defined in data.c.  */
-extern _Noreturn void wrong_choice (Lisp_Object, Lisp_Object);
+extern AVOID wrong_choice (Lisp_Object, Lisp_Object);
 extern void notify_variable_watchers (Lisp_Object, Lisp_Object,
 				      Lisp_Object, Lisp_Object);
 extern Lisp_Object indirect_function (Lisp_Object);
@@ -3555,10 +3544,9 @@ extern intmax_t cons_to_signed (Lisp_Object, intmax_t, intmax_t);
 extern uintmax_t cons_to_unsigned (Lisp_Object, uintmax_t);
 
 extern struct Lisp_Symbol *indirect_variable (struct Lisp_Symbol *);
-extern _Noreturn void args_out_of_range (Lisp_Object, Lisp_Object);
-extern _Noreturn void args_out_of_range_3 (Lisp_Object, Lisp_Object,
-					   Lisp_Object);
-extern _Noreturn void circular_list (Lisp_Object);
+extern AVOID args_out_of_range (Lisp_Object, Lisp_Object);
+extern AVOID args_out_of_range_3 (Lisp_Object, Lisp_Object, Lisp_Object);
+extern AVOID circular_list (Lisp_Object);
 extern Lisp_Object do_symval_forwarding (lispfwd);
 enum Set_Internal_Bind {
   SET_INTERNAL_SET,
@@ -3655,7 +3643,6 @@ extern void init_fringe_once (void);
 
 /* Defined in image.c.  */
 extern int x_bitmap_mask (struct frame *, ptrdiff_t);
-extern void reset_image_types (void);
 extern void syms_of_image (void);
 
 #ifdef HAVE_JSON
@@ -3666,7 +3653,7 @@ extern void syms_of_json (void);
 
 /* Defined in insdel.c.  */
 extern void move_gap_both (ptrdiff_t, ptrdiff_t);
-extern _Noreturn void buffer_overflow (void);
+extern AVOID buffer_overflow (void);
 extern void make_gap (ptrdiff_t);
 extern void make_gap_1 (struct buffer *, ptrdiff_t);
 extern ptrdiff_t copy_text (const unsigned char *, unsigned char *,
@@ -3766,8 +3753,8 @@ extern void *my_heap_start (void);
 extern void check_pure_size (void);
 extern void allocate_string_data (struct Lisp_String *, EMACS_INT, EMACS_INT);
 extern void malloc_warning (const char *);
-extern _Noreturn void memory_full (size_t);
-extern _Noreturn void buffer_memory_full (ptrdiff_t);
+extern AVOID memory_full (size_t);
+extern AVOID buffer_memory_full (ptrdiff_t);
 extern bool survives_gc_p (Lisp_Object);
 extern void mark_object (Lisp_Object);
 #if defined REL_ALLOC && !defined SYSTEM_MALLOC && !defined HYBRID_MALLOC
@@ -3848,7 +3835,7 @@ list4i (EMACS_INT x, EMACS_INT y, EMACS_INT w, EMACS_INT h)
 
 extern Lisp_Object make_uninit_bool_vector (EMACS_INT);
 extern Lisp_Object bool_vector_fill (Lisp_Object, Lisp_Object);
-extern _Noreturn void string_overflow (void);
+extern AVOID string_overflow (void);
 extern Lisp_Object make_string (const char *, ptrdiff_t);
 extern Lisp_Object make_formatted_string (char *, const char *, ...)
   ATTRIBUTE_FORMAT_PRINTF (2, 3);
@@ -3975,11 +3962,6 @@ extern void init_alloc (void);
 extern void syms_of_alloc (void);
 extern struct buffer * allocate_buffer (void);
 extern int valid_lisp_object_p (Lisp_Object);
-#ifdef GC_CHECK_CONS_LIST
-extern void check_cons_list (void);
-#else
-INLINE void (check_cons_list) (void) { lisp_h_check_cons_list (); }
-#endif
 
 /* Defined in gmalloc.c.  */
 #if !defined DOUG_LEA_MALLOC && !defined HYBRID_MALLOC && !defined SYSTEM_MALLOC
@@ -4095,18 +4077,17 @@ extern Lisp_Object run_hook_with_args (ptrdiff_t nargs, Lisp_Object *args,
 				       Lisp_Object (*funcall)
 				       (ptrdiff_t nargs, Lisp_Object *args));
 extern Lisp_Object quit (void);
-INLINE _Noreturn void
+INLINE AVOID
 xsignal (Lisp_Object error_symbol, Lisp_Object data)
 {
   Fsignal (error_symbol, data);
 }
-extern _Noreturn void xsignal0 (Lisp_Object);
-extern _Noreturn void xsignal1 (Lisp_Object, Lisp_Object);
-extern _Noreturn void xsignal2 (Lisp_Object, Lisp_Object, Lisp_Object);
-extern _Noreturn void xsignal3 (Lisp_Object, Lisp_Object, Lisp_Object,
-				Lisp_Object);
-extern _Noreturn void signal_error (const char *, Lisp_Object);
-extern _Noreturn void overflow_error (void);
+extern AVOID xsignal0 (Lisp_Object);
+extern AVOID xsignal1 (Lisp_Object, Lisp_Object);
+extern AVOID xsignal2 (Lisp_Object, Lisp_Object, Lisp_Object);
+extern AVOID xsignal3 (Lisp_Object, Lisp_Object, Lisp_Object, Lisp_Object);
+extern AVOID signal_error (const char *, Lisp_Object);
+extern AVOID overflow_error (void);
 extern bool FUNCTIONP (Lisp_Object);
 extern Lisp_Object funcall_subr (struct Lisp_Subr *subr, ptrdiff_t numargs, Lisp_Object *arg_vector);
 extern Lisp_Object eval_sub (Lisp_Object form);
@@ -4128,7 +4109,7 @@ extern Lisp_Object internal_condition_case_2 (Lisp_Object (*) (Lisp_Object, Lisp
 extern Lisp_Object internal_condition_case_n
     (Lisp_Object (*) (ptrdiff_t, Lisp_Object *), ptrdiff_t, Lisp_Object *,
      Lisp_Object, Lisp_Object (*) (Lisp_Object, ptrdiff_t, Lisp_Object *));
-extern Lisp_Object internal_catch_all (Lisp_Object (*) (void *), void *, Lisp_Object (*) (Lisp_Object));
+extern Lisp_Object internal_catch_all (Lisp_Object (*) (void *), void *, Lisp_Object (*) (enum nonlocal_exit, Lisp_Object));
 extern struct handler *push_handler (Lisp_Object, enum handlertype);
 extern struct handler *push_handler_nosignal (Lisp_Object, enum handlertype);
 extern void specbind (Lisp_Object, Lisp_Object);
@@ -4145,8 +4126,8 @@ extern void set_unwind_protect_ptr (ptrdiff_t, void (*) (void *), void *);
 extern Lisp_Object unbind_to (ptrdiff_t, Lisp_Object);
 extern void rebind_for_thread_switch (void);
 extern void unbind_for_thread_switch (struct thread_state *);
-extern _Noreturn void error (const char *, ...) ATTRIBUTE_FORMAT_PRINTF (1, 2);
-extern _Noreturn void verror (const char *, va_list)
+extern AVOID error (const char *, ...) ATTRIBUTE_FORMAT_PRINTF (1, 2);
+extern AVOID verror (const char *, va_list)
   ATTRIBUTE_FORMAT_PRINTF (1, 0);
 extern Lisp_Object vformat_string (const char *, va_list)
   ATTRIBUTE_FORMAT_PRINTF (1, 0);
@@ -4173,31 +4154,8 @@ extern void *unexec_realloc (void *, size_t);
 extern void unexec_free (void *);
 #endif
 
-#include "emacs-module.h"
-
-/* Function prototype for the module Lisp functions.  */
-typedef emacs_value (*emacs_subr) (emacs_env *, ptrdiff_t,
-				   emacs_value [], void *);
-
-/* Module function.  */
-
-/* A function environment is an auxiliary structure returned by
-   `module_make_function' to store information about a module
-   function.  It is stored in a pseudovector.  Its members correspond
-   to the arguments given to `module_make_function'.  */
-
-struct Lisp_Module_Function
-{
-  union vectorlike_header header;
-
-  /* Fields traced by GC; these must come first.  */
-  Lisp_Object documentation;
-
-  /* Fields ignored by GC.  */
-  ptrdiff_t min_arity, max_arity;
-  emacs_subr subr;
-  void *data;
-} GCALIGNED_STRUCT;
+/* The definition of Lisp_Module_Function depends on emacs-module.h,
+   so we don't define it here.  It's defined in emacs-module.c.  */
 
 INLINE bool
 MODULE_FUNCTIONP (Lisp_Object o)
@@ -4213,12 +4171,21 @@ XMODULE_FUNCTION (Lisp_Object o)
 }
 
 #ifdef HAVE_MODULES
+/* A function pointer type good enough for lisp.h.  Actual module
+   function pointers are of a different type that relies on details
+   internal to emacs-module.c.  */
+typedef void (*module_funcptr) (void);
+
 /* Defined in alloc.c.  */
 extern Lisp_Object make_user_ptr (void (*finalizer) (void *), void *p);
 
 /* Defined in emacs-module.c.  */
 extern Lisp_Object funcall_module (Lisp_Object, ptrdiff_t, Lisp_Object *);
 extern Lisp_Object module_function_arity (const struct Lisp_Module_Function *);
+extern Lisp_Object module_function_documentation
+  (struct Lisp_Module_Function const *);
+extern module_funcptr module_function_address
+  (struct Lisp_Module_Function const *);
 extern void mark_modules (void);
 extern void init_module_assertions (bool);
 extern void syms_of_module (void);
@@ -4243,7 +4210,7 @@ extern void syms_of_editfns (void);
 /* Defined in buffer.c.  */
 extern bool mouse_face_overlay_overlaps (Lisp_Object);
 extern Lisp_Object disable_line_numbers_overlay_at_eob (void);
-extern _Noreturn void nsberror (Lisp_Object);
+extern AVOID nsberror (Lisp_Object);
 extern void adjust_overlays_for_insert (ptrdiff_t, ptrdiff_t);
 extern void adjust_overlays_for_delete (ptrdiff_t, ptrdiff_t);
 extern void fix_start_end_in_overlays (ptrdiff_t, ptrdiff_t);
@@ -4286,9 +4253,9 @@ extern void close_file_unwind (int);
 extern void fclose_unwind (void *);
 extern void restore_point_unwind (Lisp_Object);
 extern Lisp_Object get_file_errno_data (const char *, Lisp_Object, int);
-extern _Noreturn void report_file_errno (const char *, Lisp_Object, int);
-extern _Noreturn void report_file_error (const char *, Lisp_Object);
-extern _Noreturn void report_file_notify_error (const char *, Lisp_Object);
+extern AVOID report_file_errno (const char *, Lisp_Object, int);
+extern AVOID report_file_error (const char *, Lisp_Object);
+extern AVOID report_file_notify_error (const char *, Lisp_Object);
 extern bool internal_delete_file (Lisp_Object);
 extern Lisp_Object emacs_readlinkat (int, const char *);
 extern bool file_directory_p (Lisp_Object);
@@ -4409,7 +4376,7 @@ extern bool display_arg;
 #endif
 extern Lisp_Object decode_env_path (const char *, const char *, bool);
 extern Lisp_Object empty_unibyte_string, empty_multibyte_string;
-extern _Noreturn void terminate_due_to_signal (int, int);
+extern AVOID terminate_due_to_signal (int, int);
 #ifdef WINDOWSNT
 extern Lisp_Object Vlibrary_cache;
 #endif
@@ -4480,11 +4447,14 @@ extern void syms_of_process (void);
 extern void setup_process_coding_systems (Lisp_Object);
 
 /* Defined in callproc.c.  */
-#ifndef DOS_NT
-# define CHILD_SETUP_TYPE _Noreturn void
-#else
+#ifdef DOS_NT
 # define CHILD_SETUP_TYPE int
+# define CHILD_SETUP_ERROR_DESC "Spawning child process"
+#else
+# define CHILD_SETUP_TYPE _Noreturn void
+# define CHILD_SETUP_ERROR_DESC "Doing vfork"
 #endif
+
 extern CHILD_SETUP_TYPE child_setup (int, int, int, char **, bool, Lisp_Object);
 extern void init_callproc_1 (void);
 extern void init_callproc (void);
@@ -4571,7 +4541,7 @@ extern EMACS_INT get_random (void);
 extern void seed_random (void *, ptrdiff_t);
 extern void init_random (void);
 extern void emacs_backtrace (int);
-extern _Noreturn void emacs_abort (void) NO_INLINE;
+extern AVOID emacs_abort (void) NO_INLINE;
 extern int emacs_open (const char *, int, int);
 extern int emacs_pipe (int[2]);
 extern int emacs_close (int);
@@ -4612,8 +4582,7 @@ extern Lisp_Object directory_files_internal (Lisp_Object, Lisp_Object,
 /* Defined in term.c.  */
 extern int *char_ins_del_vector;
 extern void syms_of_term (void);
-extern _Noreturn void fatal (const char *msgid, ...)
-  ATTRIBUTE_FORMAT_PRINTF (1, 2);
+extern AVOID fatal (const char *msgid, ...) ATTRIBUTE_FORMAT_PRINTF (1, 2);
 
 /* Defined in terminal.c.  */
 extern void syms_of_terminal (void);
@@ -4679,7 +4648,7 @@ extern void syms_of_xterm (void);
 
 #ifdef HAVE_WINDOW_SYSTEM
 /* Defined in xterm.c, nsterm.m, w32term.c.  */
-extern char *x_get_keysym_name (int);
+extern char *get_keysym_name (int);
 #endif /* HAVE_WINDOW_SYSTEM */
 
 /* Defined in xml.c.  */
diff --git a/src/lread.c b/src/lread.c
index 5f33fcd695..5fa90cad3f 100644
--- a/src/lread.c
+++ b/src/lread.c
@@ -44,6 +44,7 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include "blockinput.h"
 #include "pdumper.h"
 #include <c-ctype.h>
+#include <vla.h>
 
 #ifdef MSDOS
 #include "msdos.h"
@@ -1019,7 +1020,7 @@ load_error_handler (Lisp_Object data)
   return Qnil;
 }
 
-static _Noreturn void
+static AVOID
 load_error_old_style_backquotes (void)
 {
   if (NILP (Vload_file_name))
@@ -1034,18 +1035,12 @@ load_error_old_style_backquotes (void)
 static void
 load_warn_unescaped_character_literals (Lisp_Object file)
 {
-  if (NILP (Vlread_unescaped_character_literals)) return;
-  CHECK_CONS (Vlread_unescaped_character_literals);
-  Lisp_Object format =
-    build_string ("Loading `%s': unescaped character literals %s detected!");
-  Lisp_Object separator = build_string (", ");
-  Lisp_Object inner_format = build_string ("`?%c'");
-  CALLN (Fmessage,
-         format, file,
-         Fmapconcat (list3 (Qlambda, list1 (Qchar),
-                            list3 (Qformat, inner_format, Qchar)),
-                     Fsort (Vlread_unescaped_character_literals, Qlss),
-                     separator));
+  Lisp_Object warning = call0 (Qbyte_run_unescaped_character_literals_warning);
+  if (!NILP (warning))
+    {
+      AUTO_STRING (format, "Loading `%s': %s");
+      CALLN (Fmessage, format, file, warning);
+    }
 }
 
 DEFUN ("get-load-suffixes", Fget_load_suffixes, Sget_load_suffixes, 0, 0, 0,
@@ -1307,8 +1302,8 @@ Return t if the file exists and loads successfully.  */)
   specbind (Qlread_unescaped_character_literals, Qnil);
   record_unwind_protect (load_warn_unescaped_character_literals, file);
 
-  int is_elc;
-  if ((is_elc = suffix_p (found, ".elc")) != 0
+  bool is_elc = suffix_p (found, ".elc");
+  if (is_elc
       /* version = 1 means the file is empty, in which case we can
 	 treat it as not byte-compiled.  */
       || (fd >= 0 && (version = safe_to_load_version (fd)) > 1))
@@ -1445,6 +1440,10 @@ Return t if the file exists and loads successfully.  */)
   specbind (Qinhibit_file_name_operation, Qnil);
   specbind (Qload_in_progress, Qt);
 
+  /* Declare here rather than inside the else-part because the storage
+     might be accessed by the unbind_to call below.  */
+  struct infile input;
+
   if (is_module)
     {
 #ifdef HAVE_MODULES
@@ -1459,7 +1458,6 @@ Return t if the file exists and loads successfully.  */)
     }
   else
     {
-      struct infile input;
       input.stream = stream;
       input.lookahead = 0;
       infile = &input;
@@ -1874,7 +1872,7 @@ readevalloop_1 (int old)
 /* Signal an `end-of-file' error, if possible with file name
    information.  */
 
-static _Noreturn void
+static AVOID
 end_of_file_error (void)
 {
   if (STRINGP (Vload_file_name))
@@ -2297,7 +2295,7 @@ read_internal_start (Lisp_Object stream, Lisp_Object start, Lisp_Object end)
 /* Signal Qinvalid_read_syntax error.
    S is error string of length N (if > 0)  */
 
-static _Noreturn void
+static AVOID
 invalid_syntax (const char *s)
 {
   xsignal1 (Qinvalid_read_syntax, build_string (s));
@@ -2643,90 +2641,83 @@ digit_to_number (int character, int base)
   return digit < base ? digit : -1;
 }
 
+static char const invalid_radix_integer_format[] = "integer, radix %"pI"d";
+
+/* Small, as read1 is recursive (Bug#31995).  But big enough to hold
+   the invalid_radix_integer string.  */
+enum { stackbufsize = max (64,
+			   (sizeof invalid_radix_integer_format
+			    - sizeof "%"pI"d"
+			    + INT_STRLEN_BOUND (EMACS_INT) + 1)) };
+
 static void
-free_contents (void *p)
+invalid_radix_integer (EMACS_INT radix, char stackbuf[VLA_ELEMS (stackbufsize)])
 {
-  void **ptr = (void **) p;
-  xfree (*ptr);
+  sprintf (stackbuf, invalid_radix_integer_format, radix);
+  invalid_syntax (stackbuf);
 }
 
 /* Read an integer in radix RADIX using READCHARFUN to read
-   characters.  RADIX must be in the interval [2..36]; if it isn't, a
-   read error is signaled .  Value is the integer read.  Signals an
-   error if encountering invalid read syntax or if RADIX is out of
-   range.  */
+   characters.  RADIX must be in the interval [2..36].  Use STACKBUF
+   for temporary storage as needed.  Value is the integer read.
+   Signal an error if encountering invalid read syntax.  */
 
 static Lisp_Object
-read_integer (Lisp_Object readcharfun, EMACS_INT radix)
+read_integer (Lisp_Object readcharfun, int radix,
+	      char stackbuf[VLA_ELEMS (stackbufsize)])
 {
-  /* Room for sign, leading 0, other digits, trailing NUL byte.
-     Also, room for invalid syntax diagnostic.  */
-  size_t len = max (1 + 1 + UINTMAX_WIDTH + 1,
-		    sizeof "integer, radix " + INT_STRLEN_BOUND (EMACS_INT));
-  char *buf = NULL;
-  char *p = buf;
+  char *read_buffer = stackbuf;
+  ptrdiff_t read_buffer_size = stackbufsize;
+  char *p = read_buffer;
+  char *heapbuf = NULL;
   int valid = -1; /* 1 if valid, 0 if not, -1 if incomplete.  */
-
   ptrdiff_t count = SPECPDL_INDEX ();
 
-  if (radix < 2 || radix > 36)
-    valid = 0;
-  else
+  int c = READCHAR;
+  if (c == '-' || c == '+')
     {
-      int c, digit;
-
-      buf = xmalloc (len);
-      record_unwind_protect_ptr (free_contents, &buf);
-      p = buf;
-
+      *p++ = c;
       c = READCHAR;
-      if (c == '-' || c == '+')
-	{
-	  *p++ = c;
-	  c = READCHAR;
-	}
+    }
 
-      if (c == '0')
-	{
-	  *p++ = c;
-	  valid = 1;
+  if (c == '0')
+    {
+      *p++ = c;
+      valid = 1;
 
-	  /* Ignore redundant leading zeros, so the buffer doesn't
-	     fill up with them.  */
-	  do
-	    c = READCHAR;
-	  while (c == '0');
-	}
+      /* Ignore redundant leading zeros, so the buffer doesn't
+	 fill up with them.  */
+      do
+	c = READCHAR;
+      while (c == '0');
+    }
 
-      while ((digit = digit_to_number (c, radix)) >= -1)
+  for (int digit; (digit = digit_to_number (c, radix)) >= -1; )
+    {
+      if (digit == -1)
+	valid = 0;
+      if (valid < 0)
+	valid = 1;
+      /* Allow 1 extra byte for the \0.  */
+      if (p + 1 == read_buffer + read_buffer_size)
 	{
-	  if (digit == -1)
-	    valid = 0;
-	  if (valid < 0)
-	    valid = 1;
-	  /* Allow 1 extra byte for the \0.  */
-	  if (p + 1 == buf + len)
-	    {
-	      ptrdiff_t where = p - buf;
-	      len *= 2;
-	      buf = xrealloc (buf, len);
-	      p = buf + where;
-	    }
-	  *p++ = c;
-	  c = READCHAR;
+	  ptrdiff_t offset = p - read_buffer;
+	  read_buffer = grow_read_buffer (read_buffer, offset,
+					  &heapbuf, &read_buffer_size,
+					  count);
+	  p = read_buffer + offset;
 	}
-
-      UNREAD (c);
+      *p++ = c;
+      c = READCHAR;
     }
 
+  UNREAD (c);
+
   if (valid != 1)
-    {
-      sprintf (buf, "integer, radix %"pI"d", radix);
-      invalid_syntax (buf);
-    }
+    invalid_radix_integer (radix, stackbuf);
 
   *p = '\0';
-  return unbind_to (count, string_to_number (buf, radix, 0));
+  return unbind_to (count, string_to_number (read_buffer, radix, NULL));
 }
 
 
@@ -2742,7 +2733,7 @@ read1 (Lisp_Object readcharfun, int *pch, bool first_in_list)
   int c;
   bool uninterned_symbol = false;
   bool multibyte;
-  char stackbuf[128];  /* Small, as read1 is recursive (Bug#31995).  */
+  char stackbuf[stackbufsize];
   current_thread->stack_top = stackbuf;
 
   *pch = 0;
@@ -3112,30 +3103,34 @@ read1 (Lisp_Object readcharfun, int *pch, bool first_in_list)
       /* ## is the empty symbol.  */
       if (c == '#')
 	return Fintern (empty_unibyte_string, Qnil);
-      /* Reader forms that can reuse previously read objects.  */
+
       if (c >= '0' && c <= '9')
 	{
-	  EMACS_INT n = 0;
-	  Lisp_Object tem;
+	  EMACS_INT n = c - '0';
 	  bool overflow = false;
 
 	  /* Read a non-negative integer.  */
-	  while (c >= '0' && c <= '9')
+	  while ('0' <= (c = READCHAR) && c <= '9')
 	    {
 	      overflow |= INT_MULTIPLY_WRAPV (n, 10, &n);
 	      overflow |= INT_ADD_WRAPV (n, c - '0', &n);
-	      c = READCHAR;
 	    }
 
-	  if (!overflow && n <= MOST_POSITIVE_FIXNUM)
+	  if (!overflow)
 	    {
 	      if (c == 'r' || c == 'R')
-		return read_integer (readcharfun, n);
+		{
+		  if (! (2 <= n && n <= 36))
+		    invalid_radix_integer (n, stackbuf);
+		  return read_integer (readcharfun, n, stackbuf);
+		}
 
-	      if (! NILP (Vread_circle))
+	      if (n <= MOST_POSITIVE_FIXNUM && ! NILP (Vread_circle))
 		{
+		  /* Reader forms that can reuse previously read objects.  */
+
 		  /* #n=object returns object, but associates it with
-                      n for #n#.  */
+		     n for #n#.  */
 		  if (c == '=')
 		    {
 		      /* Make a placeholder for #n# to use temporarily.  */
@@ -3164,7 +3159,7 @@ read1 (Lisp_Object readcharfun, int *pch, bool first_in_list)
 			hash_put (h, number, placeholder, hash);
 
 		      /* Read the object itself.  */
-		      tem = read0 (readcharfun);
+		      Lisp_Object tem = read0 (readcharfun);
 
 		      /* If it can be recursive, remember it for
 			 future substitutions.  */
@@ -3214,11 +3209,11 @@ read1 (Lisp_Object readcharfun, int *pch, bool first_in_list)
 	  /* Fall through to error message.  */
 	}
       else if (c == 'x' || c == 'X')
-	return read_integer (readcharfun, 16);
+	return read_integer (readcharfun, 16, stackbuf);
       else if (c == 'o' || c == 'O')
-	return read_integer (readcharfun, 8);
+	return read_integer (readcharfun, 8, stackbuf);
       else if (c == 'b' || c == 'B')
-	return read_integer (readcharfun, 2);
+	return read_integer (readcharfun, 2, stackbuf);
 
       UNREAD (c);
       invalid_syntax ("#");
@@ -3785,7 +3780,7 @@ string_to_number (char const *string, int base, ptrdiff_t *plen)
 	      state |= E_EXP;
 	      cp += 3;
 	      union ieee754_double u
-		= { .ieee_nan = { .exponent = -1, .quiet_nan = 1,
+		= { .ieee_nan = { .exponent = 0x7ff, .quiet_nan = 1,
 				  .mantissa0 = n >> 31 >> 1, .mantissa1 = n }};
 	      value = u.d;
 	    }
@@ -5014,9 +5009,9 @@ For internal use only.  */);
   DEFSYM (Qlread_unescaped_character_literals,
           "lread--unescaped-character-literals");
 
-  DEFSYM (Qlss, "<");
-  DEFSYM (Qchar, "char");
-  DEFSYM (Qformat, "format");
+  /* Defined in lisp/emacs-lisp/byte-run.el.  */
+  DEFSYM (Qbyte_run_unescaped_character_literals_warning,
+          "byte-run--unescaped-character-literals-warning");
 
   DEFVAR_BOOL ("load-prefer-newer", load_prefer_newer,
                doc: /* Non-nil means `load' prefers the newest version of a file.
diff --git a/src/macfont.m b/src/macfont.m
index d8e86201f5..f825e6291d 100644
--- a/src/macfont.m
+++ b/src/macfont.m
@@ -1639,7 +1639,7 @@ static CGGlyph macfont_get_glyph_for_cid (struct font *font,
 static void macfont_close (struct font *);
 static int macfont_has_char (Lisp_Object, int);
 static unsigned macfont_encode_char (struct font *, int);
-static void macfont_text_extents (struct font *, unsigned int *, int,
+static void macfont_text_extents (struct font *, const unsigned int *, int,
                                   struct font_metrics *);
 static int macfont_draw (struct glyph_string *, int, int, int, int, bool);
 static Lisp_Object macfont_shape (Lisp_Object);
@@ -2735,7 +2735,7 @@ So we use CTFontDescriptorCreateMatchingFontDescriptor (no
 }
 
 static void
-macfont_text_extents (struct font *font, unsigned int *code, int nglyphs,
+macfont_text_extents (struct font *font, const unsigned int *code, int nglyphs,
                       struct font_metrics *metrics)
 {
   int width, i;
@@ -2818,7 +2818,18 @@ So we use CTFontDescriptorCreateMatchingFontDescriptor (no
       }
   }
 
-  context = [[NSGraphicsContext currentContext] graphicsPort];
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 101000
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 101000
+  if ([[NSGraphicsContext currentContext] respondsToSelector:@selector(CGContext)])
+#endif
+    context = [[NSGraphicsContext currentContext] CGContext];
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 101000
+  else
+#endif
+#endif
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 101000
+    context = [[NSGraphicsContext currentContext] graphicsPort];
+#endif
   CGContextSaveGState (context);
 
   if (!CGRectIsNull (background_rect))
@@ -2991,7 +3002,7 @@ So we use CTFontDescriptorCreateMatchingFontDescriptor (no
 
       if (NILP (lglyph))
         {
-          lglyph = make_nil_vector (LGLYPH_SIZE);
+          lglyph = LGLYPH_NEW ();
           LGSTRING_SET_GLYPH (lgstring, i, lglyph);
         }
 
diff --git a/src/marker.c b/src/marker.c
index b58051a8c2..0b2e1bf5c6 100644
--- a/src/marker.c
+++ b/src/marker.c
@@ -332,6 +332,10 @@ buf_bytepos_to_charpos (struct buffer *b, ptrdiff_t bytepos)
   if (best_above == best_above_byte)
     return bytepos;
 
+  /* Check bytepos is not in the middle of a character. */
+  eassert (bytepos >= BUF_Z_BYTE (b)
+           || CHAR_HEAD_P (BUF_FETCH_BYTE (b, bytepos)));
+
   best_below = BEG;
   best_below_byte = BEG_BYTE;
 
diff --git a/src/menu.c b/src/menu.c
index 7f46e68e73..e82c857059 100644
--- a/src/menu.c
+++ b/src/menu.c
@@ -687,7 +687,7 @@ digest_single_submenu (int start, int end, bool top_level_items)
 
 		  ASET (menu_items, i + MENU_ITEMS_PANE_NAME, pane_name);
 		}
-#elif defined (USE_LUCID) && defined (HAVE_XFT)
+#elif defined (USE_LUCID) && (defined USE_CAIRO || defined HAVE_XFT)
 	      if (STRINGP (pane_name))
 		{
 		  pane_name = ENCODE_UTF_8 (pane_name);
diff --git a/src/menu.h b/src/menu.h
index 0321c27454..4412948224 100644
--- a/src/menu.h
+++ b/src/menu.h
@@ -47,14 +47,17 @@ extern widget_value *digest_single_submenu (int, int, bool);
 #if defined (HAVE_X_WINDOWS) || defined (MSDOS)
 extern Lisp_Object x_menu_show (struct frame *, int, int, int,
 				Lisp_Object, const char **);
+extern void x_activate_menubar (struct frame *);
 #endif
 #ifdef HAVE_NTGUI
 extern Lisp_Object w32_menu_show (struct frame *, int, int, int,
 				  Lisp_Object, const char **);
+extern void w32_activate_menubar (struct frame *);
 #endif
 #ifdef HAVE_NS
 extern Lisp_Object ns_menu_show (struct frame *, int, int, int,
 				 Lisp_Object, const char **);
+extern void ns_activate_menubar (struct frame *);
 #endif
 extern Lisp_Object tty_menu_show (struct frame *, int, int, int,
 				  Lisp_Object, const char **);
diff --git a/src/mini-gmp.c b/src/mini-gmp.c
index 90beb6e832..88b71c3f9a 100644
--- a/src/mini-gmp.c
+++ b/src/mini-gmp.c
@@ -2,7 +2,7 @@
 
    Contributed to the GNU project by Niels Möller
 
-Copyright 1991-1997, 1999-2019 Free Software Foundation, Inc.
+Copyright 1991-1997, 1999-2018 Free Software Foundation, Inc.
 
 This file is part of the GNU MP Library.
 
@@ -58,7 +58,7 @@ see https://www.gnu.org/licenses/.  */
 /* Macros */
 #define GMP_LIMB_BITS (sizeof(mp_limb_t) * CHAR_BIT)
 
-#define GMP_LIMB_MAX (~ (mp_limb_t) 0)
+#define GMP_LIMB_MAX ((mp_limb_t) ~ (mp_limb_t) 0)
 #define GMP_LIMB_HIGHBIT ((mp_limb_t) 1 << (GMP_LIMB_BITS - 1))
 
 #define GMP_HLIMB_BIT ((mp_limb_t) 1 << (GMP_LIMB_BITS / 2))
@@ -129,6 +129,20 @@ see https://www.gnu.org/licenses/.  */
 
 #define gmp_umul_ppmm(w1, w0, u, v)					\
   do {									\
+    int LOCAL_GMP_LIMB_BITS = GMP_LIMB_BITS;				\
+    if (sizeof(unsigned int) * CHAR_BIT >= 2 * GMP_LIMB_BITS)		\
+      {									\
+	unsigned int __ww = (unsigned int) (u) * (v);			\
+	w0 = (mp_limb_t) __ww;						\
+	w1 = (mp_limb_t) (__ww >> LOCAL_GMP_LIMB_BITS);			\
+      }									\
+    else if (GMP_ULONG_BITS >= 2 * GMP_LIMB_BITS)			\
+      {									\
+	unsigned long int __ww = (unsigned long int) (u) * (v);		\
+	w0 = (mp_limb_t) __ww;						\
+	w1 = (mp_limb_t) (__ww >> LOCAL_GMP_LIMB_BITS);			\
+      }									\
+    else {								\
     mp_limb_t __x0, __x1, __x2, __x3;					\
     unsigned __ul, __vl, __uh, __vh;					\
     mp_limb_t __u = (u), __v = (v);					\
@@ -150,6 +164,7 @@ see https://www.gnu.org/licenses/.  */
 									\
     (w1) = __x3 + (__x1 >> (GMP_LIMB_BITS / 2));			\
     (w0) = (__x1 << (GMP_LIMB_BITS / 2)) + (__x0 & GMP_LLIMB_MASK);	\
+    }									\
   } while (0)
 
 #define gmp_udiv_qrnnd_preinv(q, r, nh, nl, d, di)			\
@@ -753,6 +768,18 @@ mpn_neg (mp_ptr rp, mp_srcptr up, mp_size_t n)
 mp_limb_t
 mpn_invert_3by2 (mp_limb_t u1, mp_limb_t u0)
 {
+  int GMP_LIMB_BITS_MUL_3 = GMP_LIMB_BITS * 3;
+  if (sizeof (unsigned) * CHAR_BIT > GMP_LIMB_BITS * 3)
+    {
+      return (((unsigned) 1 << GMP_LIMB_BITS_MUL_3) - 1) /
+	(((unsigned) u1 << GMP_LIMB_BITS_MUL_3 / 3) + u0);
+    }
+  else if (GMP_ULONG_BITS > GMP_LIMB_BITS * 3)
+    {
+      return (((unsigned long) 1 << GMP_LIMB_BITS_MUL_3) - 1) /
+	(((unsigned long) u1 << GMP_LIMB_BITS_MUL_3 / 3) + u0);
+    }
+  else {
   mp_limb_t r, p, m, ql;
   unsigned ul, uh, qh;
 
@@ -827,7 +854,7 @@ mpn_invert_3by2 (mp_limb_t u1, mp_limb_t u0)
       r -= u1;
     }
 
-  /* Now m is the 2/1 invers of u1. If u0 > 0, adjust it to become a
+  /* Now m is the 2/1 inverse of u1. If u0 > 0, adjust it to become a
      3/2 inverse. */
   if (u0 > 0)
     {
@@ -854,6 +881,7 @@ mpn_invert_3by2 (mp_limb_t u1, mp_limb_t u0)
     }
 
   return m;
+  }
 }
 
 struct gmp_div_inverse
@@ -964,36 +992,6 @@ mpn_div_qr_1_preinv (mp_ptr qp, mp_srcptr np, mp_size_t nn,
   return r >> inv->shift;
 }
 
-static mp_limb_t
-mpn_div_qr_1 (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_limb_t d)
-{
-  assert (d > 0);
-
-  /* Special case for powers of two. */
-  if ((d & (d-1)) == 0)
-    {
-      mp_limb_t r = np[0] & (d-1);
-      if (qp)
-	{
-	  if (d <= 1)
-	    mpn_copyi (qp, np, nn);
-	  else
-	    {
-	      unsigned shift;
-	      gmp_ctz (shift, d);
-	      mpn_rshift (qp, np, nn, shift);
-	    }
-	}
-      return r;
-    }
-  else
-    {
-      struct gmp_div_inverse inv;
-      mpn_div_qr_1_invert (&inv, d);
-      return mpn_div_qr_1_preinv (qp, np, nn, &inv);
-    }
-}
-
 static void
 mpn_div_qr_2_preinv (mp_ptr qp, mp_ptr np, mp_size_t nn,
 		     const struct gmp_div_inverse *inv)
@@ -1029,7 +1027,7 @@ mpn_div_qr_2_preinv (mp_ptr qp, mp_ptr np, mp_size_t nn,
 
   if (shift > 0)
     {
-      assert ((r0 << (GMP_LIMB_BITS - shift)) == 0);
+      assert ((r0 & (GMP_LIMB_MAX >> (GMP_LIMB_BITS - shift))) == 0);
       r0 = (r0 >> shift) | (r1 << (GMP_LIMB_BITS - shift));
       r1 >>= shift;
     }
@@ -1252,7 +1250,7 @@ mpn_limb_get_str (unsigned char *sp, mp_limb_t w,
       l = w << binv->shift;
 
       gmp_udiv_qrnnd_preinv (w, r, h, l, binv->d1, binv->di);
-      assert ( (r << (GMP_LIMB_BITS - binv->shift)) == 0);
+      assert ((r & (GMP_LIMB_MAX >> (GMP_LIMB_BITS - binv->shift))) == 0);
       r >>= binv->shift;
 
       sp[i] = r;
@@ -1420,7 +1418,7 @@ mpn_set_str (mp_ptr rp, const unsigned char *sp, size_t sn, int base)
 void
 mpz_init (mpz_t r)
 {
-  static const mp_limb_t dummy_limb = 0xc1a0;
+  static const mp_limb_t dummy_limb = GMP_LIMB_MAX & 0xc1a0;
 
   r->_mp_alloc = 0;
   r->_mp_size = 0;
@@ -1478,6 +1476,12 @@ mpz_set_si (mpz_t r, signed long int x)
   if (x >= 0)
     mpz_set_ui (r, x);
   else /* (x < 0) */
+    if (GMP_LIMB_BITS < GMP_ULONG_BITS)
+      {
+	mpz_set_ui (r, GMP_NEG_CAST (unsigned long int, x));
+	mpz_neg (r, r);
+      }
+  else
     {
       r->_mp_size = -1;
       MPZ_REALLOC (r, 1)[0] = GMP_NEG_CAST (unsigned long int, x);
@@ -1491,6 +1495,15 @@ mpz_set_ui (mpz_t r, unsigned long int x)
     {
       r->_mp_size = 1;
       MPZ_REALLOC (r, 1)[0] = x;
+      if (GMP_LIMB_BITS < GMP_ULONG_BITS)
+	{
+	  int LOCAL_GMP_LIMB_BITS = GMP_LIMB_BITS;
+	  while (x >>= LOCAL_GMP_LIMB_BITS)
+	    {
+	      ++ r->_mp_size;
+	      MPZ_REALLOC (r, r->_mp_size)[r->_mp_size - 1] = x;
+	    }
+	}
     }
   else
     r->_mp_size = 0;
@@ -1537,14 +1550,20 @@ mpz_init_set (mpz_t r, const mpz_t x)
 int
 mpz_fits_slong_p (const mpz_t u)
 {
-  mp_size_t us = u->_mp_size;
+  return (LONG_MAX + LONG_MIN == 0 || mpz_cmp_ui (u, LONG_MAX) <= 0) &&
+    mpz_cmpabs_ui (u, GMP_NEG_CAST (unsigned long int, LONG_MIN)) <= 0;
+}
 
-  if (us == 1)
-    return u->_mp_d[0] < GMP_LIMB_HIGHBIT;
-  else if (us == -1)
-    return u->_mp_d[0] <= GMP_LIMB_HIGHBIT;
-  else
-    return (us == 0);
+static int
+mpn_absfits_ulong_p (mp_srcptr up, mp_size_t un)
+{
+  int ulongsize = GMP_ULONG_BITS / GMP_LIMB_BITS;
+  mp_limb_t ulongrem = 0;
+
+  if (GMP_ULONG_BITS % GMP_LIMB_BITS != 0)
+    ulongrem = (mp_limb_t) (ULONG_MAX >> GMP_LIMB_BITS * ulongsize) + 1;
+
+  return un <= ulongsize || (up[ulongsize] < ulongrem && un == ulongsize + 1);
 }
 
 int
@@ -1552,22 +1571,36 @@ mpz_fits_ulong_p (const mpz_t u)
 {
   mp_size_t us = u->_mp_size;
 
-  return (us == (us > 0));
+  return us >= 0 && mpn_absfits_ulong_p (u->_mp_d, us);
 }
 
 long int
 mpz_get_si (const mpz_t u)
 {
+  unsigned long r = mpz_get_ui (u);
+  unsigned long c = -LONG_MAX - LONG_MIN;
+
   if (u->_mp_size < 0)
-    /* This expression is necessary to properly handle 0x80000000 */
-    return -1 - (long) ((u->_mp_d[0] - 1) & ~GMP_LIMB_HIGHBIT);
+    /* This expression is necessary to properly handle -LONG_MIN */
+    return -(long) c - (long) ((r - c) & LONG_MAX);
   else
-    return (long) (mpz_get_ui (u) & ~GMP_LIMB_HIGHBIT);
+    return (long) (r & LONG_MAX);
 }
 
 unsigned long int
 mpz_get_ui (const mpz_t u)
 {
+  if (GMP_LIMB_BITS < GMP_ULONG_BITS)
+    {
+      int LOCAL_GMP_LIMB_BITS = GMP_LIMB_BITS;
+      unsigned long r = 0;
+      mp_size_t n = GMP_ABS (u->_mp_size);
+      n = GMP_MIN (n, 1 + (GMP_ULONG_BITS - 1) / GMP_LIMB_BITS);
+      while (--n >= 0)
+	r = (r << LOCAL_GMP_LIMB_BITS) + u->_mp_d[n];
+      return r;
+    }
+
   return u->_mp_size == 0 ? 0 : u->_mp_d[0];
 }
 
@@ -1665,7 +1698,7 @@ mpz_set_d (mpz_t r, double x)
       r->_mp_size = 0;
       return;
     }
-  B = 2.0 * (double) GMP_LIMB_HIGHBIT;
+  B = 4.0 * (double) (GMP_LIMB_HIGHBIT >> 1);
   Bi = 1.0 / B;
   for (rn = 1; x >= B; rn++)
     x *= Bi;
@@ -1703,7 +1736,7 @@ mpz_get_d (const mpz_t u)
   mp_limb_t l;
   mp_size_t un;
   double x;
-  double B = 2.0 * (double) GMP_LIMB_HIGHBIT;
+  double B = 4.0 * (double) (GMP_LIMB_HIGHBIT >> 1);
 
   un = GMP_ABS (u->_mp_size);
 
@@ -1748,7 +1781,7 @@ mpz_cmpabs_d (const mpz_t x, double d)
     {
       xn = GMP_ABS (xn);
 
-      B = 2.0 * (double) GMP_LIMB_HIGHBIT;
+      B = 4.0 * (double) (GMP_LIMB_HIGHBIT >> 1);
       Bi = 1.0 / B;
 
       /* Scale d so it can be compared with the top limb. */
@@ -1807,14 +1840,12 @@ mpz_cmp_si (const mpz_t u, long v)
 {
   mp_size_t usize = u->_mp_size;
 
-  if (usize < -1)
-    return -1;
-  else if (v >= 0)
+  if (v >= 0)
     return mpz_cmp_ui (u, v);
   else if (usize >= 0)
     return 1;
-  else /* usize == -1 */
-    return GMP_CMP (GMP_NEG_CAST (mp_limb_t, v), u->_mp_d[0]);
+  else
+    return - mpz_cmpabs_ui (u, GMP_NEG_CAST (unsigned long int, v));
 }
 
 int
@@ -1822,12 +1853,10 @@ mpz_cmp_ui (const mpz_t u, unsigned long v)
 {
   mp_size_t usize = u->_mp_size;
 
-  if (usize > 1)
-    return 1;
-  else if (usize < 0)
+  if (usize < 0)
     return -1;
   else
-    return GMP_CMP (mpz_get_ui (u), v);
+    return mpz_cmpabs_ui (u, v);
 }
 
 int
@@ -1847,10 +1876,15 @@ mpz_cmp (const mpz_t a, const mpz_t b)
 int
 mpz_cmpabs_ui (const mpz_t u, unsigned long v)
 {
-  if (GMP_ABS (u->_mp_size) > 1)
+  mp_size_t un = GMP_ABS (u->_mp_size);
+
+  if (! mpn_absfits_ulong_p (u->_mp_d, un))
     return 1;
   else
-    return GMP_CMP (mpz_get_ui (u), v);
+    {
+      unsigned long uu = mpz_get_ui (u);
+      return GMP_CMP(uu, v);
+    }
 }
 
 int
@@ -1885,81 +1919,28 @@ mpz_swap (mpz_t u, mpz_t v)
 
 /* MPZ addition and subtraction */
 
-/* Adds to the absolute value. Returns new size, but doesn't store it. */
-static mp_size_t
-mpz_abs_add_ui (mpz_t r, const mpz_t a, unsigned long b)
-{
-  mp_size_t an;
-  mp_ptr rp;
-  mp_limb_t cy;
-
-  an = GMP_ABS (a->_mp_size);
-  if (an == 0)
-    {
-      MPZ_REALLOC (r, 1)[0] = b;
-      return b > 0;
-    }
-
-  rp = MPZ_REALLOC (r, an + 1);
-
-  cy = mpn_add_1 (rp, a->_mp_d, an, b);
-  rp[an] = cy;
-  an += cy;
-
-  return an;
-}
-
-/* Subtract from the absolute value. Returns new size, (or -1 on underflow),
-   but doesn't store it. */
-static mp_size_t
-mpz_abs_sub_ui (mpz_t r, const mpz_t a, unsigned long b)
-{
-  mp_size_t an = GMP_ABS (a->_mp_size);
-  mp_ptr rp;
-
-  if (an == 0)
-    {
-      MPZ_REALLOC (r, 1)[0] = b;
-      return -(b > 0);
-    }
-  rp = MPZ_REALLOC (r, an);
-  if (an == 1 && a->_mp_d[0] < b)
-    {
-      rp[0] = b - a->_mp_d[0];
-      return -1;
-    }
-  else
-    {
-      gmp_assert_nocarry (mpn_sub_1 (rp, a->_mp_d, an, b));
-      return mpn_normalized_size (rp, an);
-    }
-}
 
 void
 mpz_add_ui (mpz_t r, const mpz_t a, unsigned long b)
 {
-  if (a->_mp_size >= 0)
-    r->_mp_size = mpz_abs_add_ui (r, a, b);
-  else
-    r->_mp_size = -mpz_abs_sub_ui (r, a, b);
+  mpz_t bb;
+  mpz_init_set_ui (bb, b);
+  mpz_add (r, a, bb);
+  mpz_clear (bb);
 }
 
 void
 mpz_sub_ui (mpz_t r, const mpz_t a, unsigned long b)
 {
-  if (a->_mp_size < 0)
-    r->_mp_size = -mpz_abs_add_ui (r, a, b);
-  else
-    r->_mp_size = mpz_abs_sub_ui (r, a, b);
+  mpz_ui_sub (r, b, a);
+  mpz_neg (r, r);
 }
 
 void
 mpz_ui_sub (mpz_t r, unsigned long a, const mpz_t b)
 {
-  if (b->_mp_size < 0)
-    r->_mp_size = mpz_abs_add_ui (r, b, a);
-  else
-    r->_mp_size = -mpz_abs_sub_ui (r, b, a);
+  mpz_neg (r, b);
+  mpz_add_ui (r, r, a);
 }
 
 static mp_size_t
@@ -2046,32 +2027,17 @@ mpz_mul_si (mpz_t r, const mpz_t u, long int v)
       mpz_neg (r, r);
     }
   else
-    mpz_mul_ui (r, u, (unsigned long int) v);
+    mpz_mul_ui (r, u, v);
 }
 
 void
 mpz_mul_ui (mpz_t r, const mpz_t u, unsigned long int v)
 {
-  mp_size_t un, us;
-  mp_ptr tp;
-  mp_limb_t cy;
-
-  us = u->_mp_size;
-
-  if (us == 0 || v == 0)
-    {
-      r->_mp_size = 0;
-      return;
-    }
-
-  un = GMP_ABS (us);
-
-  tp = MPZ_REALLOC (r, un + 1);
-  cy = mpn_mul_1 (tp, u->_mp_d, un, v);
-  tp[un] = cy;
-
-  un += (cy > 0);
-  r->_mp_size = (us < 0) ? - un : un;
+  mpz_t vv;
+  mpz_init_set_ui (vv, v);
+  mpz_mul (r, u, vv);
+  mpz_clear (vv);
+  return;
 }
 
 void
@@ -2150,8 +2116,8 @@ void
 mpz_addmul_ui (mpz_t r, const mpz_t u, unsigned long int v)
 {
   mpz_t t;
-  mpz_init (t);
-  mpz_mul_ui (t, u, v);
+  mpz_init_set_ui (t, v);
+  mpz_mul (t, u, t);
   mpz_add (r, r, t);
   mpz_clear (t);
 }
@@ -2160,8 +2126,8 @@ void
 mpz_submul_ui (mpz_t r, const mpz_t u, unsigned long int v)
 {
   mpz_t t;
-  mpz_init (t);
-  mpz_mul_ui (t, u, v);
+  mpz_init_set_ui (t, v);
+  mpz_mul (t, u, t);
   mpz_sub (r, r, t);
   mpz_clear (t);
 }
@@ -2557,56 +2523,20 @@ static unsigned long
 mpz_div_qr_ui (mpz_t q, mpz_t r,
 	       const mpz_t n, unsigned long d, enum mpz_div_round_mode mode)
 {
-  mp_size_t ns, qn;
-  mp_ptr qp;
-  mp_limb_t rl;
-  mp_size_t rs;
-
-  ns = n->_mp_size;
-  if (ns == 0)
-    {
-      if (q)
-	q->_mp_size = 0;
-      if (r)
-	r->_mp_size = 0;
-      return 0;
-    }
-
-  qn = GMP_ABS (ns);
-  if (q)
-    qp = MPZ_REALLOC (q, qn);
-  else
-    qp = NULL;
+  unsigned long ret;
+  mpz_t rr, dd;
 
-  rl = mpn_div_qr_1 (qp, n->_mp_d, qn, d);
-  assert (rl < d);
-
-  rs = rl > 0;
-  rs = (ns < 0) ? -rs : rs;
-
-  if (rl > 0 && ( (mode == GMP_DIV_FLOOR && ns < 0)
-		  || (mode == GMP_DIV_CEIL && ns >= 0)))
-    {
-      if (q)
-	gmp_assert_nocarry (mpn_add_1 (qp, qp, qn, 1));
-      rl = d - rl;
-      rs = -rs;
-    }
+  mpz_init (rr);
+  mpz_init_set_ui (dd, d);
+  mpz_div_qr (q, rr, n, dd, mode);
+  mpz_clear (dd);
+  ret = mpz_get_ui (rr);
 
   if (r)
-    {
-      MPZ_REALLOC (r, 1)[0] = rl;
-      r->_mp_size = rs;
-    }
-  if (q)
-    {
-      qn -= (qp[qn-1] == 0);
-      assert (qn == 0 || qp[qn-1] > 0);
-
-      q->_mp_size = (ns < 0) ? - qn : qn;
-    }
+    mpz_swap (r, rr);
+  mpz_clear (rr);
 
-  return rl;
+  return ret;
 }
 
 unsigned long
@@ -2745,22 +2675,16 @@ mpn_gcd_11 (mp_limb_t u, mp_limb_t v)
 unsigned long
 mpz_gcd_ui (mpz_t g, const mpz_t u, unsigned long v)
 {
-  mp_size_t un;
+  mpz_t t;
+  mpz_init_set_ui(t, v);
+  mpz_gcd (t, u, t);
+  if (v > 0)
+    v = mpz_get_ui (t);
 
-  if (v == 0)
-    {
-      if (g)
-	mpz_abs (g, u);
-    }
-  else
-    {
-      un = GMP_ABS (u->_mp_size);
-      if (un != 0)
-	v = mpn_gcd_11 (mpn_div_qr_1 (NULL, u->_mp_d, un, v), v);
+  if (g)
+    mpz_swap (t, g);
 
-      if (g)
-	mpz_set_ui (g, v);
-    }
+  mpz_clear (t);
 
   return v;
 }
@@ -2854,7 +2778,7 @@ mpz_gcdext (mpz_t g, mpz_t s, mpz_t t, const mpz_t u, const mpz_t v)
       signed long sign = mpz_sgn (v);
       mpz_abs (g, v);
       if (s)
-	mpz_set_ui (s, 0);
+	s->_mp_size = 0;
       if (t)
 	mpz_set_si (t, sign);
       return;
@@ -2868,7 +2792,7 @@ mpz_gcdext (mpz_t g, mpz_t s, mpz_t t, const mpz_t u, const mpz_t v)
       if (s)
 	mpz_set_si (s, sign);
       if (t)
-	mpz_set_ui (t, 0);
+	t->_mp_size = 0;
       return;
     }
 
@@ -2993,8 +2917,9 @@ mpz_gcdext (mpz_t g, mpz_t s, mpz_t t, const mpz_t u, const mpz_t v)
 	  mpz_sub (s0, s0, s1);
 	  mpz_add (t0, t0, t1);
 	}
-      mpz_divexact_ui (s0, s0, 2);
-      mpz_divexact_ui (t0, t0, 2);
+      assert (mpz_even_p (t0) && mpz_even_p (s0));
+      mpz_tdiv_q_2exp (s0, s0, 1);
+      mpz_tdiv_q_2exp (t0, t0, 1);
     }
 
   /* Arrange so that |s| < |u| / 2g */
@@ -3119,7 +3044,10 @@ void
 mpz_ui_pow_ui (mpz_t r, unsigned long blimb, unsigned long e)
 {
   mpz_t b;
-  mpz_pow_ui (r, mpz_roinit_normal_n (b, &blimb, blimb != 0), e);
+
+  mpz_init_set_ui (b, blimb);
+  mpz_pow_ui (r, b, e);
+  mpz_clear (b);
 }
 
 void
@@ -3231,7 +3159,10 @@ void
 mpz_powm_ui (mpz_t r, const mpz_t b, unsigned long elimb, const mpz_t m)
 {
   mpz_t e;
-  mpz_powm (r, b, mpz_roinit_normal_n (e, &elimb, elimb != 0), m);
+
+  mpz_init_set_ui (e, elimb);
+  mpz_powm (r, b, e, m);
+  mpz_clear (e);
 }
 
 /* x=trunc(y^(1/z)), r=y-x^z */
@@ -3409,6 +3340,177 @@ mpz_bin_uiui (mpz_t r, unsigned long n, unsigned long k)
 
 
 /* Primality testing */
+
+/* Computes Kronecker (a/b) with odd b, a!=0 and GCD(a,b) = 1 */
+/* Adapted from JACOBI_BASE_METHOD==4 in mpn/generic/jacbase.c */
+static int
+gmp_jacobi_coprime (mp_limb_t a, mp_limb_t b)
+{
+  int c, bit = 0;
+
+  assert (b & 1);
+  assert (a != 0);
+  /* assert (mpn_gcd_11 (a, b) == 1); */
+
+  /* Below, we represent a and b shifted right so that the least
+     significant one bit is implicit. */
+  b >>= 1;
+
+  gmp_ctz(c, a);
+  a >>= 1;
+
+  do
+    {
+      a >>= c;
+      /* (2/b) = -1 if b = 3 or 5 mod 8 */
+      bit ^= c & (b ^ (b >> 1));
+      if (a < b)
+	{
+	  bit ^= a & b;
+	  a = b - a;
+	  b -= a;
+	}
+      else
+	{
+	  a -= b;
+	  assert (a != 0);
+	}
+
+      gmp_ctz(c, a);
+      ++c;
+    }
+  while (b > 0);
+
+  return bit & 1 ? -1 : 1;
+}
+
+static void
+gmp_lucas_step_k_2k (mpz_t V, mpz_t Qk, const mpz_t n)
+{
+  mpz_mod (Qk, Qk, n);
+  /* V_{2k} <- V_k ^ 2 - 2Q^k */
+  mpz_mul (V, V, V);
+  mpz_submul_ui (V, Qk, 2);
+  mpz_tdiv_r (V, V, n);
+  /* Q^{2k} = (Q^k)^2 */
+  mpz_mul (Qk, Qk, Qk);
+}
+
+/* Computes V_k, Q^k (mod n) for the Lucas' sequence */
+/* with P=1, Q=Q; k = (n>>b0)|1. */
+/* Requires an odd n > 4; b0 > 0; -2*Q must not overflow a long */
+/* Returns (U_k == 0) and sets V=V_k and Qk=Q^k. */
+static int
+gmp_lucas_mod (mpz_t V, mpz_t Qk, long Q,
+	       mp_bitcnt_t b0, const mpz_t n)
+{
+  mp_bitcnt_t bs;
+  mpz_t U;
+  int res;
+
+  assert (b0 > 0);
+  assert (Q <= - (LONG_MIN / 2));
+  assert (Q >= - (LONG_MAX / 2));
+  assert (mpz_cmp_ui (n, 4) > 0);
+  assert (mpz_odd_p (n));
+
+  mpz_init_set_ui (U, 1); /* U1 = 1 */
+  mpz_set_ui (V, 1); /* V1 = 1 */
+  mpz_set_si (Qk, Q);
+
+  for (bs = mpz_sizeinbase (n, 2) - 1; --bs >= b0;)
+    {
+      /* U_{2k} <- U_k * V_k */
+      mpz_mul (U, U, V);
+      /* V_{2k} <- V_k ^ 2 - 2Q^k */
+      /* Q^{2k} = (Q^k)^2 */
+      gmp_lucas_step_k_2k (V, Qk, n);
+
+      /* A step k->k+1 is performed if the bit in $n$ is 1	*/
+      /* mpz_tstbit(n,bs) or the the bit is 0 in $n$ but	*/
+      /* should be 1 in $n+1$ (bs == b0)			*/
+      if (b0 == bs || mpz_tstbit (n, bs))
+	{
+	  /* Q^{k+1} <- Q^k * Q */
+	  mpz_mul_si (Qk, Qk, Q);
+	  /* U_{k+1} <- (U_k + V_k) / 2 */
+	  mpz_swap (U, V); /* Keep in V the old value of U_k */
+	  mpz_add (U, U, V);
+	  /* We have to compute U/2, so we need an even value, */
+	  /* equivalent (mod n) */
+	  if (mpz_odd_p (U))
+	    mpz_add (U, U, n);
+	  mpz_tdiv_q_2exp (U, U, 1);
+	  /* V_{k+1} <-(D*U_k + V_k) / 2 =
+			U_{k+1} + (D-1)/2*U_k = U_{k+1} - 2Q*U_k */
+	  mpz_mul_si (V, V, -2*Q);
+	  mpz_add (V, U, V);
+	  mpz_tdiv_r (V, V, n);
+	}
+      mpz_tdiv_r (U, U, n);
+    }
+
+  res = U->_mp_size == 0;
+  mpz_clear (U);
+  return res;
+}
+
+/* Performs strong Lucas' test on x, with parameters suggested */
+/* for the BPSW test. Qk is only passed to recycle a variable. */
+/* Requires GCD (x,6) = 1.*/
+static int
+gmp_stronglucas (const mpz_t x, mpz_t Qk)
+{
+  mp_bitcnt_t b0;
+  mpz_t V, n;
+  mp_limb_t maxD, D; /* The absolute value is stored. */
+  long Q;
+  mp_limb_t tl;
+
+  /* Test on the absolute value. */
+  mpz_roinit_normal_n (n, x->_mp_d, GMP_ABS (x->_mp_size));
+
+  assert (mpz_odd_p (n));
+  /* assert (mpz_gcd_ui (NULL, n, 6) == 1); */
+  if (mpz_root (Qk, n, 2))
+    return 0; /* A square is composite. */
+
+  /* Check Ds up to square root (in case, n is prime)
+     or avoid overflows */
+  maxD = (Qk->_mp_size == 1) ? Qk->_mp_d [0] - 1 : GMP_LIMB_MAX;
+
+  D = 3;
+  /* Search a D such that (D/n) = -1 in the sequence 5,-7,9,-11,.. */
+  /* For those Ds we have (D/n) = (n/|D|) */
+  do
+    {
+      if (D >= maxD)
+	return 1 + (D != GMP_LIMB_MAX); /* (1 + ! ~ D) */
+      D += 2;
+      tl = mpz_tdiv_ui (n, D);
+      if (tl == 0)
+	return 0;
+    }
+  while (gmp_jacobi_coprime (tl, D) == 1);
+
+  mpz_init (V);
+
+  /* n-(D/n) = n+1 = d*2^{b0}, with d = (n>>b0) | 1 */
+  b0 = mpz_scan0 (n, 0);
+
+  /* D= P^2 - 4Q; P = 1; Q = (1-D)/4 */
+  Q = (D & 2) ? (D >> 2) + 1 : -(long) (D >> 2);
+
+  if (! gmp_lucas_mod (V, Qk, Q, b0, n))	/* If Ud != 0 */
+    while (V->_mp_size != 0 && --b0 != 0)	/* while Vk != 0 */
+      /* V <- V ^ 2 - 2Q^k */
+      /* Q^{2k} = (Q^k)^2 */
+      gmp_lucas_step_k_2k (V, Qk, n);
+
+  mpz_clear (V);
+  return (b0 != 0);
+}
+
 static int
 gmp_millerrabin (const mpz_t n, const mpz_t nm1, mpz_t y,
 		 const mpz_t q, mp_bitcnt_t k)
@@ -3470,21 +3572,26 @@ mpz_probab_prime_p (const mpz_t n, int reps)
   if (mpz_cmpabs_ui (n, 31*31) < 0)
     return 2;
 
-  /* Use Miller-Rabin, with a deterministic sequence of bases, a[j] =
-     j^2 + j + 41 using Euler's polynomial. We potentially stop early,
-     if a[j] >= n - 1. Since n >= 31*31, this can happen only if reps >
-     30 (a[30] == 971 > 31*31 == 961). */
-
   mpz_init (nm1);
   mpz_init (q);
-  mpz_init (y);
 
   /* Find q and k, where q is odd and n = 1 + 2**k * q.  */
-  nm1->_mp_size = mpz_abs_sub_ui (nm1, n, 1);
+  mpz_abs (nm1, n);
+  nm1->_mp_d[0] -= 1;
   k = mpz_scan1 (nm1, 0);
   mpz_tdiv_q_2exp (q, nm1, k);
 
-  for (j = 0, is_prime = 1; is_prime & (j < reps); j++)
+  /* BPSW test */
+  mpz_init_set_ui (y, 2);
+  is_prime = gmp_millerrabin (n, nm1, y, q, k) && gmp_stronglucas (n, y);
+  reps -= 24; /* skip the first 24 repetitions */
+
+  /* Use Miller-Rabin, with a deterministic sequence of bases, a[j] =
+     j^2 + j + 41 using Euler's polynomial. We potentially stop early,
+     if a[j] >= n - 1. Since n >= 31*31, this can happen only if reps >
+     30 (a[30] == 971 > 31*31 == 961). */
+
+  for (j = 0; is_prime & (j < reps); j++)
     {
       mpz_set_ui (y, (unsigned long) j*j+j+41);
       if (mpz_cmp (y, nm1) >= 0)
@@ -3552,7 +3659,7 @@ mpz_tstbit (const mpz_t d, mp_bitcnt_t bit_index)
     {
       /* d < 0. Check if any of the bits below is set: If so, our bit
 	 must be complemented. */
-      if (shift > 0 && (w << (GMP_LIMB_BITS - shift)) > 0)
+      if (shift > 0 && (mp_limb_t) (w << (GMP_LIMB_BITS - shift)) > 0)
 	return bit ^ 1;
       while (--limb_index >= 0)
 	if (d->_mp_d[limb_index] > 0)
@@ -3659,8 +3766,8 @@ mpz_combit (mpz_t d, mp_bitcnt_t bit_index)
 void
 mpz_com (mpz_t r, const mpz_t u)
 {
-  mpz_neg (r, u);
-  mpz_sub_ui (r, r, 1);
+  mpz_add_ui (r, u, 1);
+  mpz_neg (r, r);
 }
 
 void
@@ -4000,7 +4107,7 @@ mpz_scan1 (const mpz_t u, mp_bitcnt_t starting_bit)
 	}
 
       /* Mask to 0 all bits before starting_bit, thus ignoring them. */
-      limb &= (GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS));
+      limb &= GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS);
     }
 
   return mpn_common_scan (limb, i, up, un, ux);
@@ -4030,7 +4137,7 @@ mpz_scan0 (const mpz_t u, mp_bitcnt_t starting_bit)
     limb -= mpn_zero_p (up, i); /* limb = ~(~limb + zero_p) */
 
   /* Mask all bits before starting_bit, thus ignoring them. */
-  limb &= (GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS));
+  limb &= GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS);
 
   return mpn_common_scan (limb, i, up, un, ux);
 }
diff --git a/src/mini-gmp.h b/src/mini-gmp.h
index 2586d32db9..27e0c0671a 100644
--- a/src/mini-gmp.h
+++ b/src/mini-gmp.h
@@ -1,6 +1,6 @@
 /* mini-gmp, a minimalistic implementation of a GNU GMP subset.
 
-Copyright 2011-2015, 2017, 2019 Free Software Foundation, Inc.
+Copyright 2011-2015, 2017 Free Software Foundation, Inc.
 
 This file is part of the GNU MP Library.
 
diff --git a/src/minibuf.c b/src/minibuf.c
index 10fd5e56ac..2bf6bc2594 100644
--- a/src/minibuf.c
+++ b/src/minibuf.c
@@ -1062,7 +1062,8 @@ Optional second arg DEF is value to return if user enters an empty line,
 Optional third arg REQUIRE-MATCH has the same meaning as the
  REQUIRE-MATCH argument of `completing-read'.
 Optional arg PREDICATE, if non-nil, is a function limiting the buffers that
-can be considered.  It will be called with each potential candidate, and
+can be considered.  It will be called with each potential candidate, in
+the form of either a string or a cons cell whose `car' is a string, and
 should return non-nil to accept the candidate for completion, nil otherwise.
 If `read-buffer-completion-ignore-case' is non-nil, completion ignores
 case while reading the buffer name.
diff --git a/src/module-env-27.h b/src/module-env-27.h
index b491b60fbb..00de300900 100644
--- a/src/module-env-27.h
+++ b/src/module-env-27.h
@@ -2,3 +2,17 @@
      function should quit.  */
   enum emacs_process_input_result (*process_input) (emacs_env *env)
     EMACS_ATTRIBUTE_NONNULL (1);
+
+  struct timespec (*extract_time) (emacs_env *env, emacs_value value)
+    EMACS_ATTRIBUTE_NONNULL (1);
+
+  emacs_value (*make_time) (emacs_env *env, struct timespec time)
+    EMACS_ATTRIBUTE_NONNULL (1);
+
+  void (*extract_big_integer) (emacs_env *env, emacs_value value,
+                               struct emacs_mpz *result)
+    EMACS_ATTRIBUTE_NONNULL (1, 3);
+
+  emacs_value (*make_big_integer) (emacs_env *env,
+                                   const struct emacs_mpz *value)
+    EMACS_ATTRIBUTE_NONNULL (1, 2);
diff --git a/src/msdos.c b/src/msdos.c
index 7dd5f5747a..d13f230485 100644
--- a/src/msdos.c
+++ b/src/msdos.c
@@ -420,6 +420,9 @@ static unsigned short outside_cursor;
 /* The only display since MS-DOS does not support multiple ones.  */
 struct tty_display_info the_only_display_info;
 
+/* The only tty_output, since MS-DOS supports only 1 display.  */
+struct tty_output the_only_tty_output;
+
 /* Support for DOS/V (allows Japanese characters to be displayed on
    standard, non-Japanese, ATs).  Only supported for DJGPP v2 and later.  */
 
diff --git a/src/msdos.h b/src/msdos.h
index ff756f8f63..3614c94dd0 100644
--- a/src/msdos.h
+++ b/src/msdos.h
@@ -86,15 +86,14 @@ typedef int GC;
 typedef int Pixmap;
 typedef int Display;
 typedef int Window;
-typedef int XRectangle;
 #define PIX_TYPE unsigned long
 #define XDISPLAY
 
 typedef struct tty_display_info Display_Info;
 
 extern struct tty_display_info the_only_display_info;
+extern struct tty_output the_only_tty_output;
 
-#define FRAME_X_DISPLAY(f) ((Display *) 0)
 #define FRAME_FONT(f) ((f)->output_data.tty->font)
 #define FRAME_DISPLAY_INFO(f) (&the_only_display_info)
 
diff --git a/src/nsfns.m b/src/nsfns.m
index ee7598a1c7..2470c05c4b 100644
--- a/src/nsfns.m
+++ b/src/nsfns.m
@@ -233,7 +233,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
 
 static void
-x_set_foreground_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+ns_set_foreground_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   NSColor *col;
   EmacsCGFloat r, g, b, alpha;
@@ -269,7 +269,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
 
 static void
-x_set_background_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+ns_set_background_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   struct face *face;
   NSColor *col;
@@ -325,7 +325,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
 
 static void
-x_set_cursor_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+ns_set_cursor_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   NSColor *col;
 
@@ -342,8 +342,8 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
   if (FRAME_VISIBLE_P (f))
     {
-      x_update_cursor (f, 0);
-      x_update_cursor (f, 1);
+      gui_update_cursor (f, 0);
+      gui_update_cursor (f, 1);
     }
   update_face_from_frame_parameter (f, Qcursor_color, arg);
   unblock_input ();
@@ -351,10 +351,10 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
 
 static void
-x_set_icon_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+ns_set_icon_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   NSView *view = FRAME_NS_VIEW (f);
-  NSTRACE ("x_set_icon_name");
+  NSTRACE ("ns_set_icon_name");
 
   /* See if it's changed.  */
   if (STRINGP (arg))
@@ -508,9 +508,9 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
    specified a name for the frame; the name will override any set by the
    redisplay code.  */
 static void
-x_explicitly_set_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+ns_explicitly_set_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
-  NSTRACE ("x_explicitly_set_name");
+  NSTRACE ("ns_explicitly_set_name");
   ns_set_name (f, arg, 1);
 }
 
@@ -519,9 +519,9 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
    name; names set this way will never override names set by the user's
    lisp code.  */
 void
-x_implicitly_set_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+ns_implicitly_set_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
-  NSTRACE ("x_implicitly_set_name");
+  NSTRACE ("ns_implicitly_set_name");
 
   if (ns_use_proxy_icon)
     ns_set_represented_filename (f);
@@ -534,9 +534,9 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
    If NAME is nil, use the frame name as the title.  */
 
 static void
-x_set_title (struct frame *f, Lisp_Object name, Lisp_Object old_name)
+ns_set_title (struct frame *f, Lisp_Object name, Lisp_Object old_name)
 {
-  NSTRACE ("x_set_title");
+  NSTRACE ("ns_set_title");
   /* Don't change the title if it's already NAME.  */
   if (EQ (name, f->title))
     return;
@@ -582,7 +582,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
 
 static void
-x_set_menu_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
+ns_set_menu_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
 {
   int nlines;
   if (FRAME_MINIBUF_ONLY_P (f))
@@ -612,7 +612,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
 /* toolbar support */
 static void
-x_set_tool_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
+ns_set_tool_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
 {
   /* Currently, when the tool bar changes state, the frame is resized.
 
@@ -621,7 +621,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
      `frame-inhibit-implied-resize'.  */
   int nlines;
 
-  NSTRACE ("x_set_tool_bar_lines");
+  NSTRACE ("ns_set_tool_bar_lines");
 
   if (FRAME_MINIBUF_ONLY_P (f))
     return;
@@ -680,7 +680,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
 
 static void
-x_set_internal_border_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+ns_set_internal_border_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   int old_width = FRAME_INTERNAL_BORDER_WIDTH (f);
 
@@ -692,7 +692,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   if (FRAME_INTERNAL_BORDER_WIDTH (f) == old_width)
     return;
 
-  if (FRAME_X_WINDOW (f) != 0)
+  if (FRAME_NATIVE_WINDOW (f) != 0)
     adjust_frame_size (f, -1, -1, 3, 0, Qinternal_border_width);
 
   SET_FRAME_GARBAGED (f);
@@ -771,13 +771,13 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
 
 static void
-x_set_icon_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+ns_set_icon_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   EmacsView *view = FRAME_NS_VIEW (f);
   id image = nil;
   BOOL setMini = YES;
 
-  NSTRACE ("x_set_icon_type");
+  NSTRACE ("ns_set_icon_type");
 
   if (!NILP (arg) && SYMBOLP (arg))
     {
@@ -811,7 +811,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
 /* This is the same as the xfns.c definition.  */
 static void
-x_set_cursor_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+ns_set_cursor_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   set_frame_cursor_types (f, arg);
 }
@@ -819,7 +819,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 /* called to set mouse pointer color, but all other terms use it to
    initialize pointer types (and don't set the color ;) */
 static void
-x_set_mouse_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+ns_set_mouse_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   /* Don't think we can do this on Nextstep.  */
 }
@@ -864,7 +864,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
 
 static void
-x_icon (struct frame *f, Lisp_Object parms)
+ns_icon (struct frame *f, Lisp_Object parms)
 /* --------------------------------------------------------------------------
    Strangely-named function to set icon position parameters in frame.
    This is irrelevant under macOS, but might be needed under GNUstep,
@@ -879,8 +879,10 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   f->output_data.ns->icon_left = -1;
 
   /* Set the position of the icon.  */
-  icon_x = x_get_arg (dpyinfo, parms, Qicon_left, 0, 0, RES_TYPE_NUMBER);
-  icon_y = x_get_arg (dpyinfo, parms, Qicon_top, 0, 0,  RES_TYPE_NUMBER);
+  icon_x = gui_display_get_arg (dpyinfo, parms, Qicon_left, 0, 0,
+                                RES_TYPE_NUMBER);
+  icon_y = gui_display_get_arg (dpyinfo, parms, Qicon_top, 0, 0,
+                                RES_TYPE_NUMBER);
   if (!EQ (icon_x, Qunbound) && !EQ (icon_y, Qunbound))
     {
       CHECK_FIXNUM (icon_x);
@@ -897,56 +899,56 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
    implemented.  */
 frame_parm_handler ns_frame_parm_handlers[] =
 {
-  x_set_autoraise, /* generic OK */
-  x_set_autolower, /* generic OK */
-  x_set_background_color,
+  gui_set_autoraise, /* generic OK */
+  gui_set_autolower, /* generic OK */
+  ns_set_background_color,
   0, /* x_set_border_color,  may be impossible under Nextstep */
   0, /* x_set_border_width,  may be impossible under Nextstep */
-  x_set_cursor_color,
-  x_set_cursor_type,
-  x_set_font, /* generic OK */
-  x_set_foreground_color,
-  x_set_icon_name,
-  x_set_icon_type,
-  x_set_internal_border_width, /* generic OK */
-  x_set_right_divider_width,
-  x_set_bottom_divider_width,
-  x_set_menu_bar_lines,
-  x_set_mouse_color,
-  x_explicitly_set_name,
-  x_set_scroll_bar_width, /* generic OK */
-  x_set_scroll_bar_height, /* generic OK */
-  x_set_title,
-  x_set_unsplittable, /* generic OK */
-  x_set_vertical_scroll_bars, /* generic OK */
-  x_set_horizontal_scroll_bars, /* generic OK */
-  x_set_visibility, /* generic OK */
-  x_set_tool_bar_lines,
+  ns_set_cursor_color,
+  ns_set_cursor_type,
+  gui_set_font, /* generic OK */
+  ns_set_foreground_color,
+  ns_set_icon_name,
+  ns_set_icon_type,
+  ns_set_internal_border_width,
+  gui_set_right_divider_width, /* generic OK */
+  gui_set_bottom_divider_width, /* generic OK */
+  ns_set_menu_bar_lines,
+  ns_set_mouse_color,
+  ns_explicitly_set_name,
+  gui_set_scroll_bar_width, /* generic OK */
+  gui_set_scroll_bar_height, /* generic OK */
+  ns_set_title,
+  gui_set_unsplittable, /* generic OK */
+  gui_set_vertical_scroll_bars, /* generic OK */
+  gui_set_horizontal_scroll_bars, /* generic OK */
+  gui_set_visibility, /* generic OK */
+  ns_set_tool_bar_lines,
   0, /* x_set_scroll_bar_foreground, will ignore (not possible on NS) */
   0, /* x_set_scroll_bar_background,  will ignore (not possible on NS) */
-  x_set_screen_gamma, /* generic OK */
-  x_set_line_spacing, /* generic OK, sets f->extra_line_spacing to int */
-  x_set_left_fringe, /* generic OK */
-  x_set_right_fringe, /* generic OK */
+  gui_set_screen_gamma, /* generic OK */
+  gui_set_line_spacing, /* generic OK, sets f->extra_line_spacing to int */
+  gui_set_left_fringe, /* generic OK */
+  gui_set_right_fringe, /* generic OK */
   0, /* x_set_wait_for_wm, will ignore */
-  x_set_fullscreen, /* generic OK */
-  x_set_font_backend, /* generic OK */
-  x_set_alpha,
+  gui_set_fullscreen, /* generic OK */
+  gui_set_font_backend, /* generic OK */
+  gui_set_alpha,
   0, /* x_set_sticky */
   0, /* x_set_tool_bar_position */
   0, /* x_set_inhibit_double_buffering */
 #ifdef NS_IMPL_COCOA
-  x_set_undecorated,
+  ns_set_undecorated,
 #else
-  0, /* x_set_undecorated */
+  0, /* ns_set_undecorated */
 #endif
-  x_set_parent_frame,
+  ns_set_parent_frame,
   0, /* x_set_skip_taskbar */
-  x_set_no_focus_on_map,
-  x_set_no_accept_focus,
-  x_set_z_group, /* x_set_z_group */
+  ns_set_no_focus_on_map,
+  ns_set_no_accept_focus,
+  ns_set_z_group,
   0, /* x_set_override_redirect */
-  x_set_no_special_glyphs,
+  gui_set_no_special_glyphs,
 #ifdef NS_IMPL_COCOA
   ns_set_appearance,
   ns_set_transparent_titlebar,
@@ -979,14 +981,14 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 	 private shadow variable, it means we are unwinding a frame
 	 for which we didn't yet call init_frame_faces, where the
 	 refcount is incremented.  Therefore, we increment it here, so
-	 that free_frame_faces, called in x_free_frame_resources
+	 that free_frame_faces, called in ns_free_frame_resources
 	 below, will not mistakenly decrement the counter that was not
 	 incremented yet to account for this new frame.  */
       if (FRAME_IMAGE_CACHE (f) != NULL
 	  && FRAME_IMAGE_CACHE (f)->refcount == image_cache_refcount)
 	FRAME_IMAGE_CACHE (f)->refcount++;
 
-      x_free_frame_resources (f);
+      ns_free_frame_resources (f);
       free_glyphs (f);
 
 #if defined GLYPH_DEBUG && defined ENABLE_CHECKING
@@ -1022,8 +1024,8 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
       if (NILP (Fassq (r[i].tem, parms)))
         {
           Lisp_Object value
-            = x_get_arg (dpyinfo, parms, r[i].tem, r[i].val, r[i].cls,
-                         RES_TYPE_NUMBER);
+            = gui_display_get_arg (dpyinfo, parms, r[i].tem, r[i].val, r[i].cls,
+                                   RES_TYPE_NUMBER);
           if (! EQ (value, Qunbound))
             parms = Fcons (Fcons (r[i].tem, value), parms);
         }
@@ -1056,14 +1058,15 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   static int desc_ctr = 1;
   int x_width = 0, x_height = 0;
 
-  /* x_get_arg modifies parms.  */
+  /* gui_display_get_arg modifies parms.  */
   parms = Fcopy_alist (parms);
 
   /* Use this general default value to start with
      until we know if this frame has a specified name.  */
   Vx_resource_name = Vinvocation_name;
 
-  display = x_get_arg (dpyinfo, parms, Qterminal, 0, 0, RES_TYPE_STRING);
+  display = gui_display_get_arg (dpyinfo, parms, Qterminal, 0, 0,
+                                 RES_TYPE_STRING);
   if (EQ (display, Qunbound))
     display = Qnil;
   dpyinfo = check_ns_display_info (display);
@@ -1072,7 +1075,8 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   if (!dpyinfo->terminal->name)
     error ("Terminal is not live, can't create new frames on it");
 
-  name = x_get_arg (dpyinfo, parms, Qname, 0, 0, RES_TYPE_STRING);
+  name = gui_display_get_arg (dpyinfo, parms, Qname, 0, 0,
+                              RES_TYPE_STRING);
   if (!STRINGP (name)
       && ! EQ (name, Qunbound)
       && ! NILP (name))
@@ -1081,7 +1085,8 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   if (STRINGP (name))
     Vx_resource_name = name;
 
-  parent = x_get_arg (dpyinfo, parms, Qparent_id, 0, 0, RES_TYPE_NUMBER);
+  parent = gui_display_get_arg (dpyinfo, parms, Qparent_id, 0, 0,
+                                RES_TYPE_NUMBER);
   if (EQ (parent, Qunbound))
     parent = Qnil;
   if (! NILP (parent))
@@ -1091,8 +1096,9 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   /* No need to protect DISPLAY because that's not used after passing
      it to make_frame_without_minibuffer.  */
   frame = Qnil;
-  tem = x_get_arg (dpyinfo, parms, Qminibuffer, "minibuffer", "Minibuffer",
-                  RES_TYPE_SYMBOL);
+  tem = gui_display_get_arg (dpyinfo, parms, Qminibuffer,
+                             "minibuffer", "Minibuffer",
+                             RES_TYPE_SYMBOL);
   if (EQ (tem, Qnone) || NILP (tem))
       f = make_frame_without_minibuffer (Qnil, kb, display);
   else if (EQ (tem, Qonly))
@@ -1114,9 +1120,9 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
   FRAME_FONTSET (f) = -1;
 
-  fset_icon_name (f, x_get_arg (dpyinfo, parms, Qicon_name,
-				"iconName", "Title",
-				RES_TYPE_STRING));
+  fset_icon_name (f, gui_display_get_arg (dpyinfo, parms, Qicon_name,
+                                          "iconName", "Title",
+                                          RES_TYPE_STRING));
   if (! STRINGP (f->icon_name))
     fset_icon_name (f, Qnil);
 
@@ -1162,35 +1168,35 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   image_cache_refcount =
     FRAME_IMAGE_CACHE (f) ? FRAME_IMAGE_CACHE (f)->refcount : 0;
 
-  x_default_parameter (f, parms, Qfont_backend, Qnil,
-			"fontBackend", "FontBackend", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qfont_backend, Qnil,
+                         "fontBackend", "FontBackend", RES_TYPE_STRING);
 
   {
     /* use for default font name */
     id font = [NSFont userFixedPitchFontOfSize: -1.0]; /* default */
-    x_default_parameter (f, parms, Qfontsize,
-                                    make_fixnum (0 /* (int)[font pointSize] */),
-                                    "fontSize", "FontSize", RES_TYPE_NUMBER);
+    gui_default_parameter (f, parms, Qfontsize,
+                           make_fixnum (0 /* (int)[font pointSize] */),
+                           "fontSize", "FontSize", RES_TYPE_NUMBER);
     // Remove ' Regular', not handled by backends.
     char *fontname = xstrdup ([[font displayName] UTF8String]);
     int len = strlen (fontname);
     if (len > 8 && strcmp (fontname + len - 8, " Regular") == 0)
       fontname[len-8] = '\0';
-    x_default_parameter (f, parms, Qfont,
-                                 build_string (fontname),
-                                 "font", "Font", RES_TYPE_STRING);
+    gui_default_parameter (f, parms, Qfont,
+                           build_string (fontname),
+                           "font", "Font", RES_TYPE_STRING);
     xfree (fontname);
   }
   unblock_input ();
 
-  x_default_parameter (f, parms, Qborder_width, make_fixnum (0),
-		       "borderwidth", "BorderWidth", RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qinternal_border_width, make_fixnum (2),
-                      "internalBorderWidth", "InternalBorderWidth",
-                      RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qright_divider_width, make_fixnum (0),
+  gui_default_parameter (f, parms, Qborder_width, make_fixnum (0),
+                         "borderwidth", "BorderWidth", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qinternal_border_width, make_fixnum (2),
+                         "internalBorderWidth", "InternalBorderWidth",
+                         RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qright_divider_width, make_fixnum (0),
 		       NULL, NULL, RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qbottom_divider_width, make_fixnum (0),
+  gui_default_parameter (f, parms, Qbottom_divider_width, make_fixnum (0),
 		       NULL, NULL, RES_TYPE_NUMBER);
 
   /* default vertical scrollbars on right on Mac */
@@ -1201,57 +1207,61 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 #else
           = Qright;
 #endif
-      x_default_parameter (f, parms, Qvertical_scroll_bars, spos,
-			   "verticalScrollBars", "VerticalScrollBars",
-			   RES_TYPE_SYMBOL);
+      gui_default_parameter (f, parms, Qvertical_scroll_bars, spos,
+                             "verticalScrollBars", "VerticalScrollBars",
+                             RES_TYPE_SYMBOL);
   }
-  x_default_parameter (f, parms, Qhorizontal_scroll_bars, Qnil,
-		       "horizontalScrollBars", "HorizontalScrollBars",
-		       RES_TYPE_SYMBOL);
-  x_default_parameter (f, parms, Qforeground_color, build_string ("Black"),
-                      "foreground", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qbackground_color, build_string ("White"),
-                      "background", "Background", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qline_spacing, Qnil,
-		       "lineSpacing", "LineSpacing", RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qleft_fringe, Qnil,
-		       "leftFringe", "LeftFringe", RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qright_fringe, Qnil,
-		       "rightFringe", "RightFringe", RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qno_special_glyphs, Qnil,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qhorizontal_scroll_bars, Qnil,
+                         "horizontalScrollBars", "HorizontalScrollBars",
+                         RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qforeground_color, build_string ("Black"),
+                         "foreground", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qbackground_color, build_string ("White"),
+                         "background", "Background", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qline_spacing, Qnil,
+                         "lineSpacing", "LineSpacing", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qleft_fringe, Qnil,
+                         "leftFringe", "LeftFringe", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qright_fringe, Qnil,
+                         "rightFringe", "RightFringe", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qno_special_glyphs, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
 
   init_frame_faces (f);
 
   /* Read comment about this code in corresponding place in xfns.c.  */
-  tem = x_get_arg (dpyinfo, parms, Qmin_width, NULL, NULL, RES_TYPE_NUMBER);
+  tem = gui_display_get_arg (dpyinfo, parms, Qmin_width, NULL, NULL,
+                             RES_TYPE_NUMBER);
   if (FIXNUMP (tem))
     store_frame_param (f, Qmin_width, tem);
-  tem = x_get_arg (dpyinfo, parms, Qmin_height, NULL, NULL, RES_TYPE_NUMBER);
+  tem = gui_display_get_arg (dpyinfo, parms, Qmin_height, NULL, NULL,
+                             RES_TYPE_NUMBER);
   if (FIXNUMP (tem))
     store_frame_param (f, Qmin_height, tem);
   adjust_frame_size (f, FRAME_COLS (f) * FRAME_COLUMN_WIDTH (f),
 		     FRAME_LINES (f) * FRAME_LINE_HEIGHT (f), 5, 1,
 		     Qx_create_frame_1);
 
-  tem = x_get_arg (dpyinfo, parms, Qundecorated, NULL, NULL, RES_TYPE_BOOLEAN);
+  tem = gui_display_get_arg (dpyinfo, parms, Qundecorated, NULL, NULL,
+                             RES_TYPE_BOOLEAN);
   FRAME_UNDECORATED (f) = !NILP (tem) && !EQ (tem, Qunbound);
   store_frame_param (f, Qundecorated, FRAME_UNDECORATED (f) ? Qt : Qnil);
 
 #ifdef NS_IMPL_COCOA
-  tem = x_get_arg (dpyinfo, parms, Qns_appearance, NULL, NULL, RES_TYPE_SYMBOL);
+  tem = gui_display_get_arg (dpyinfo, parms, Qns_appearance, NULL, NULL,
+                             RES_TYPE_SYMBOL);
   FRAME_NS_APPEARANCE (f) = EQ (tem, Qdark)
     ? ns_appearance_vibrant_dark : ns_appearance_aqua;
   store_frame_param (f, Qns_appearance, tem);
 
-  tem = x_get_arg (dpyinfo, parms, Qns_transparent_titlebar,
-                   NULL, NULL, RES_TYPE_BOOLEAN);
+  tem = gui_display_get_arg (dpyinfo, parms, Qns_transparent_titlebar,
+                             NULL, NULL, RES_TYPE_BOOLEAN);
   FRAME_NS_TRANSPARENT_TITLEBAR (f) = !NILP (tem) && !EQ (tem, Qunbound);
   store_frame_param (f, Qns_transparent_titlebar, tem);
 #endif
 
-  parent_frame = x_get_arg (dpyinfo, parms, Qparent_frame, NULL, NULL,
-			    RES_TYPE_SYMBOL);
+  parent_frame = gui_display_get_arg (dpyinfo, parms, Qparent_frame, NULL, NULL,
+                                      RES_TYPE_SYMBOL);
   /* Accept parent-frame iff parent-id was not specified.  */
   if (!NILP (parent)
       || EQ (parent_frame, Qunbound)
@@ -1263,33 +1273,35 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   fset_parent_frame (f, parent_frame);
   store_frame_param (f, Qparent_frame, parent_frame);
 
-  x_default_parameter (f, parms, Qz_group, Qnil, NULL, NULL, RES_TYPE_SYMBOL);
-  x_default_parameter (f, parms, Qno_focus_on_map, Qnil,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qno_accept_focus, Qnil,
-                       NULL, NULL, RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qz_group, Qnil, NULL, NULL, RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qno_focus_on_map, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qno_accept_focus, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
 
   /* The resources controlling the menu-bar and tool-bar are
      processed specially at startup, and reflected in the mode
      variables; ignore them here.  */
-  x_default_parameter (f, parms, Qmenu_bar_lines,
-		       NILP (Vmenu_bar_mode)
-		       ? make_fixnum (0) : make_fixnum (1),
-		       NULL, NULL, RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qtool_bar_lines,
-		       NILP (Vtool_bar_mode)
-		       ? make_fixnum (0) : make_fixnum (1),
-		       NULL, NULL, RES_TYPE_NUMBER);
-
-  x_default_parameter (f, parms, Qbuffer_predicate, Qnil, "bufferPredicate",
-                       "BufferPredicate", RES_TYPE_SYMBOL);
-  x_default_parameter (f, parms, Qtitle, Qnil, "title", "Title",
-                       RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qmenu_bar_lines,
+                         NILP (Vmenu_bar_mode)
+                         ? make_fixnum (0) : make_fixnum (1),
+                         NULL, NULL, RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qtool_bar_lines,
+                         NILP (Vtool_bar_mode)
+                         ? make_fixnum (0) : make_fixnum (1),
+                         NULL, NULL, RES_TYPE_NUMBER);
+
+  gui_default_parameter (f, parms, Qbuffer_predicate, Qnil, "bufferPredicate",
+                         "BufferPredicate", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qtitle, Qnil, "title", "Title",
+                         RES_TYPE_STRING);
 
   parms = get_geometry_from_preferences (dpyinfo, parms);
-  window_prompting = x_figure_window_size (f, parms, true, &x_width, &x_height);
+  window_prompting = gui_figure_window_size (f, parms, true,
+                                             &x_width, &x_height);
 
-  tem = x_get_arg (dpyinfo, parms, Qunsplittable, 0, 0, RES_TYPE_BOOLEAN);
+  tem = gui_display_get_arg (dpyinfo, parms, Qunsplittable, 0, 0,
+                             RES_TYPE_BOOLEAN);
   f->no_split = minibuffer_only || (!EQ (tem, Qunbound) && !NILP (tem));
 
   /* NOTE: on other terms, this is done in set_mouse_color, however this
@@ -1320,7 +1332,7 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
 
   [[EmacsView alloc] initFrameFromEmacs: f];
 
-  x_icon (f, parms);
+  ns_icon (f, parms);
 
   /* ns_display_info does not have a reference_count.  */
   f->terminal->reference_count++;
@@ -1330,28 +1342,28 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
      won't work.  */
   Vframe_list = Fcons (frame, Vframe_list);
 
-  x_default_parameter (f, parms, Qicon_type, Qnil,
-                       "bitmapIcon", "BitmapIcon", RES_TYPE_SYMBOL);
-
-  x_default_parameter (f, parms, Qauto_raise, Qnil,
-                       "autoRaise", "AutoRaiseLower", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qauto_lower, Qnil,
-                       "autoLower", "AutoLower", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qcursor_type, Qbox,
-                       "cursorType", "CursorType", RES_TYPE_SYMBOL);
-  x_default_parameter (f, parms, Qscroll_bar_width, Qnil,
-                       "scrollBarWidth", "ScrollBarWidth",
-                       RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qscroll_bar_height, Qnil,
-                       "scrollBarHeight", "ScrollBarHeight",
-                       RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qalpha, Qnil,
-                       "alpha", "Alpha", RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qfullscreen, Qnil,
-                       "fullscreen", "Fullscreen", RES_TYPE_SYMBOL);
-
-  /* Allow x_set_window_size, now.  */
-  f->can_x_set_window_size = true;
+  gui_default_parameter (f, parms, Qicon_type, Qnil,
+                         "bitmapIcon", "BitmapIcon", RES_TYPE_SYMBOL);
+
+  gui_default_parameter (f, parms, Qauto_raise, Qnil,
+                         "autoRaise", "AutoRaiseLower", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qauto_lower, Qnil,
+                         "autoLower", "AutoLower", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qcursor_type, Qbox,
+                         "cursorType", "CursorType", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qscroll_bar_width, Qnil,
+                         "scrollBarWidth", "ScrollBarWidth",
+                         RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qscroll_bar_height, Qnil,
+                         "scrollBarHeight", "ScrollBarHeight",
+                         RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qalpha, Qnil,
+                         "alpha", "Alpha", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qfullscreen, Qnil,
+                         "fullscreen", "Fullscreen", RES_TYPE_SYMBOL);
+
+  /* Allow set_window_size_hook, now.  */
+  f->can_set_window_size = true;
 
   if (x_width > 0)
     SET_FRAME_WIDTH (f, x_width);
@@ -1365,16 +1377,16 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
     {
       Lisp_Object visibility;
 
-      visibility = x_get_arg (dpyinfo, parms, Qvisibility, 0, 0,
-                              RES_TYPE_SYMBOL);
+      visibility = gui_display_get_arg (dpyinfo, parms, Qvisibility, 0, 0,
+                                        RES_TYPE_SYMBOL);
       if (EQ (visibility, Qunbound))
 	visibility = Qt;
 
       if (EQ (visibility, Qicon))
-	x_iconify_frame (f);
+	ns_iconify_frame (f);
       else if (! NILP (visibility))
 	{
-	  x_make_frame_visible (f);
+	  ns_make_frame_visible (f);
 	  [[FRAME_NS_VIEW (f) window] makeKeyWindow];
 	}
       else
@@ -1388,14 +1400,15 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
           || !FRAME_LIVE_P (XFRAME (KVAR (kb, Vdefault_minibuffer_frame)))))
     kset_default_minibuffer_frame (kb, frame);
 
-  /* All remaining specified parameters, which have not been "used"
-     by x_get_arg and friends, now go in the misc. alist of the frame.  */
+  /* All remaining specified parameters, which have not been "used" by
+     gui_display_get_arg and friends, now go in the misc. alist of the
+     frame.  */
   for (tem = parms; CONSP (tem); tem = XCDR (tem))
     if (CONSP (XCAR (tem)) && !NILP (XCAR (XCAR (tem))))
       fset_param_alist (f, Fcons (XCAR (tem), f->param_alist));
 
   if (window_prompting & USPosition)
-    x_set_offset (f, f->left_pos, f->top_pos, 1);
+    ns_set_offset (f, f->left_pos, f->top_pos, 1);
 
   /* Make sure windows on this frame appear in calls to next-window
      and similar functions.  */
@@ -1404,21 +1417,6 @@ Turn the input menu (an NSMenu) into a lisp list for tracking on lisp side.
   return unbind_to (count, frame);
 }
 
-void
-x_focus_frame (struct frame *f, bool noactivate)
-{
-  struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
-
-  if (dpyinfo->x_focus_frame != f)
-    {
-      EmacsView *view = FRAME_NS_VIEW (f);
-      block_input ();
-      [NSApp activateIgnoringOtherApps: YES];
-      [[view window] makeKeyAndOrderFront: view];
-      unblock_input ();
-    }
-}
-
 static BOOL
 ns_window_is_ancestor (NSWindow *win, NSWindow *candidate)
 /* Test whether CANDIDATE is an ancestor window of WIN.  */
@@ -1790,7 +1788,7 @@ Frames are listed from topmost (first) to bottommost (last).  */)
 {
   struct ns_display_info *dpyinfo = check_ns_display_info (terminal);
 
-  return make_fixnum (x_display_pixel_height (dpyinfo) / (92.0/25.4));
+  return make_fixnum (ns_display_pixel_height (dpyinfo) / (92.0/25.4));
 }
 
 
@@ -1800,7 +1798,7 @@ Frames are listed from topmost (first) to bottommost (last).  */)
 {
   struct ns_display_info *dpyinfo = check_ns_display_info (terminal);
 
-  return make_fixnum (x_display_pixel_width (dpyinfo) / (92.0/25.4));
+  return make_fixnum (ns_display_pixel_width (dpyinfo) / (92.0/25.4));
 }
 
 
@@ -2230,7 +2228,7 @@ Frames are listed from topmost (first) to bottommost (last).  */)
 
 
 void
-x_set_scroll_bar_default_width (struct frame *f)
+ns_set_scroll_bar_default_width (struct frame *f)
 {
   int wid = FRAME_COLUMN_WIDTH (f);
   FRAME_CONFIG_SCROLL_BAR_WIDTH (f) = NS_SCROLL_BAR_WIDTH_DEFAULT;
@@ -2239,7 +2237,7 @@ Frames are listed from topmost (first) to bottommost (last).  */)
 }
 
 void
-x_set_scroll_bar_default_height (struct frame *f)
+ns_set_scroll_bar_default_height (struct frame *f)
 {
   int height = FRAME_LINE_HEIGHT (f);
   FRAME_CONFIG_SCROLL_BAR_HEIGHT (f) = NS_SCROLL_BAR_WIDTH_DEFAULT;
@@ -2248,8 +2246,8 @@ Frames are listed from topmost (first) to bottommost (last).  */)
 }
 
 /* Terms implement this instead of x-get-resource directly.  */
-char *
-x_get_string_resource (XrmDatabase rdb, const char *name, const char *class)
+const char *
+ns_get_string_resource (void *_rdb, const char *name, const char *class)
 {
   /* remove appname prefix; TODO: allow for !="Emacs" */
   const char *res, *toCheck = class + (!strncmp (class, "Emacs.", 6) ? 6 : 0);
@@ -2261,24 +2259,10 @@ Frames are listed from topmost (first) to bottommost (last).  */)
     return NULL;
 
   res = ns_get_defaults_value (toCheck);
-  return (char *) (!res ? NULL
-		   : !c_strncasecmp (res, "YES", 3) ? "true"
-		   : !c_strncasecmp (res, "NO", 2) ? "false"
-		   : res);
-}
-
-
-Lisp_Object
-x_get_focus_frame (struct frame *frame)
-{
-  struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (frame);
-  Lisp_Object nsfocus;
-
-  if (!dpyinfo->x_focus_frame)
-    return Qnil;
-
-  XSETFRAME (nsfocus, dpyinfo->x_focus_frame);
-  return nsfocus;
+  return (const char *) (!res ? NULL
+                         : !c_strncasecmp (res, "YES", 3) ? "true"
+                         : !c_strncasecmp (res, "NO", 2) ? "false"
+                         : res);
 }
 
 /* ==========================================================================
@@ -2361,7 +2345,7 @@ Frames are listed from topmost (first) to bottommost (last).  */)
 {
   struct ns_display_info *dpyinfo = check_ns_display_info (terminal);
 
-  return make_fixnum (x_display_pixel_width (dpyinfo));
+  return make_fixnum (ns_display_pixel_width (dpyinfo));
 }
 
 
@@ -2372,7 +2356,7 @@ Frames are listed from topmost (first) to bottommost (last).  */)
 {
   struct ns_display_info *dpyinfo = check_ns_display_info (terminal);
 
-  return make_fixnum (x_display_pixel_height (dpyinfo));
+  return make_fixnum (ns_display_pixel_height (dpyinfo));
 }
 
 #ifdef NS_IMPL_COCOA
@@ -2659,7 +2643,7 @@ Frames are listed from topmost (first) to bottommost (last).  */)
     {
       /* Absolute coordinates.  */
       pt.x = FIXNUMP (left) ? XFIXNUM (left) : XFIXNUM (right);
-      pt.y = (x_display_pixel_height (FRAME_DISPLAY_INFO (f))
+      pt.y = (ns_display_pixel_height (FRAME_DISPLAY_INFO (f))
 	      - (FIXNUMP (top) ? XFIXNUM (top) : XFIXNUM (bottom))
 	      - height);
     }
@@ -2748,11 +2732,13 @@ Frames are listed from topmost (first) to bottommost (last).  */)
   else
     Fx_hide_tip ();
 
-  t = x_get_arg (NULL, parms, Qbackground_color, NULL, NULL, RES_TYPE_STRING);
+  t = gui_display_get_arg (NULL, parms, Qbackground_color, NULL, NULL,
+                           RES_TYPE_STRING);
   if (ns_lisp_to_color (t, &color) == 0)
     [ns_tooltip setBackgroundColor: color];
 
-  t = x_get_arg (NULL, parms, Qforeground_color, NULL, NULL, RES_TYPE_STRING);
+  t = gui_display_get_arg (NULL, parms, Qforeground_color, NULL, NULL,
+                           RES_TYPE_STRING);
   if (ns_lisp_to_color (t, &color) == 0)
     [ns_tooltip setForegroundColor: color];
 
diff --git a/src/nsfont.m b/src/nsfont.m
index 9721e48935..eca97ab86c 100644
--- a/src/nsfont.m
+++ b/src/nsfont.m
@@ -945,7 +945,7 @@ when setting family in ns_spec_to_descriptor().  */
    of METRICS.  The glyphs are specified by their glyph codes in
    CODE (length NGLYPHS).  */
 static void
-nsfont_text_extents (struct font *font, unsigned int *code,
+nsfont_text_extents (struct font *font, const unsigned int *code,
 		     int nglyphs, struct font_metrics *metrics)
 {
   struct nsfont_info *font_info = (struct nsfont_info *)font;
diff --git a/src/nsgui.h b/src/nsgui.h
index c857d77d9c..c21953593a 100644
--- a/src/nsgui.h
+++ b/src/nsgui.h
@@ -58,75 +58,22 @@ typedef struct _XCharStruct
   int descent;
 } XCharStruct;
 
-/* Fake structure from Xlib.h to represent two-byte characters.  */
-#ifndef __OBJC__
-typedef unsigned short unichar;
-#endif
-typedef unichar XChar2b;
-
-#define STORE_XCHAR2B(chp, b1, b2) \
-  (*(chp) = ((XChar2b)((((b1) & 0x00ff) << 8) | ((b2) & 0x00ff))))
-
-#define XCHAR2B_BYTE1(chp) \
-  ((*(chp) & 0xff00) >> 8)
-
-#define XCHAR2B_BYTE2(chp) \
-  (*(chp) & 0x00ff)
-
 /* Used in xdisp.c when comparing faces and frame colors.  */
 extern unsigned long ns_color_index_to_rgba(int idx, struct frame *f);
 
-/* XXX: xfaces requires these structures, but the question is are we
-        forced to use them?  */
-typedef struct _XGCValues
-{
-  unsigned long foreground;
-  unsigned long background;
-#ifdef __OBJC__
-  struct ns_font *font;
-#else
-  void *font;
-#endif
-} XGCValues;
-
-typedef XGCValues * GC;
-
-#define GCForeground 0x01
-#define GCBackground 0x02
-#define GCFont 0x03
-
 #ifdef __OBJC__
-typedef id Pixmap;
+typedef id Emacs_Pixmap;
 #else
-typedef void *Pixmap;
+typedef void *Emacs_Pixmap;
 #endif
 
 #ifdef __OBJC__
-typedef NSCursor * Cursor;
+typedef NSCursor *Emacs_Cursor;
 #else
-typedef void *Cursor;
+typedef void *Emacs_Cursor;
 #endif
 
-#define No_Cursor (0)
-
-#ifdef __OBJC__
-typedef NSColor * Color;
-#else
-typedef void * Color;
-#endif
 typedef int Window;
-typedef int Display;
-
-/* Xism */
-typedef Lisp_Object XrmDatabase;
-
-
-/* Some sort of attempt to normalize rectangle handling.  Seems a bit
-   much for what is accomplished.  */
-typedef struct {
-      int x, y;
-      unsigned width, height;
-} XRectangle;
 
 #ifndef __OBJC__
 #if defined (__LP64__) && __LP64__
@@ -141,13 +88,13 @@ typedef struct _NSRect  { NSPoint origin; NSSize size; } NSRect;
 
 #define NativeRectangle NSRect
 
-#define CONVERT_TO_XRECT(xr, nr)		\
+#define CONVERT_TO_EMACS_RECT(xr, nr)		\
   ((xr).x     = (nr).origin.x,			\
    (xr).y     = (nr).origin.y,			\
    (xr).width = (nr).size.width,		\
    (xr).height = (nr).size.height)
 
-#define CONVERT_FROM_XRECT(xr, nr)		\
+#define CONVERT_FROM_EMACS_RECT(xr, nr)		\
   ((nr).origin.x    = (xr).x,			\
    (nr).origin.y    = (xr).y,			\
    (nr).size.width  = (xr).width,		\
diff --git a/src/nsimage.m b/src/nsimage.m
index f16910de08..7268e66263 100644
--- a/src/nsimage.m
+++ b/src/nsimage.m
@@ -76,9 +76,8 @@ Updated by Christian Limpach (chris@nice.ch)
 {
   EmacsImage *eImg = nil;
   NSSize size;
-  Lisp_Object lisp_index, lisp_rotation;
+  Lisp_Object lisp_index;
   unsigned int index;
-  double rotation;
 
   NSTRACE ("ns_load_image");
 
@@ -87,9 +86,6 @@ Updated by Christian Limpach (chris@nice.ch)
   lisp_index = Fplist_get (XCDR (img->spec), QCindex);
   index = FIXNUMP (lisp_index) ? XFIXNAT (lisp_index) : 0;
 
-  lisp_rotation = Fplist_get (XCDR (img->spec), QCrotation);
-  rotation = NUMBERP (lisp_rotation) ? XFLOATINT (lisp_rotation) : 0;
-
   if (STRINGP (spec_file))
     {
       eImg = [EmacsImage allocInitFromFile: spec_file];
@@ -119,13 +115,6 @@ Updated by Christian Limpach (chris@nice.ch)
 
   img->lisp_data = [eImg getMetadata];
 
-  if (rotation != 0)
-    {
-      EmacsImage *temp = [eImg rotate:rotation];
-      [eImg release];
-      eImg = temp;
-    }
-
   size = [eImg size];
   img->width = size.width;
   img->height = size.height;
@@ -155,6 +144,12 @@ Updated by Christian Limpach (chris@nice.ch)
   [(EmacsImage *)img setSize:NSMakeSize (width, height)];
 }
 
+void
+ns_image_set_transform (void *img, double m[3][3])
+{
+  [(EmacsImage *)img setTransform:m];
+}
+
 unsigned long
 ns_get_pixel (void *img, int x, int y)
 {
@@ -193,7 +188,7 @@ + (instancetype)allocInitFromFile: (Lisp_Object)file
   EmacsImage *image;
 
   /* Search bitmap-file-path for the file, if appropriate.  */
-  found = x_find_image_file (file);
+  found = image_find_image_file (file);
   if (!STRINGP (found))
     return nil;
   found = ENCODE_FILE (found);
@@ -225,6 +220,7 @@ - (void)dealloc
 {
   [stippleMask release];
   [bmRep release];
+  [transform release];
   [super dealloc];
 }
 
@@ -313,8 +309,8 @@ - (instancetype)setXBMColor: (NSColor *)color
   if (bmRep == nil || color == nil)
     return self;
 
-  if ([color colorSpaceName] != NSCalibratedRGBColorSpace)
-    rgbColor = [color colorUsingColorSpaceName: NSCalibratedRGBColorSpace];
+  if ([color colorSpace] != [NSColorSpace deviceRGBColorSpace])
+    rgbColor = [color colorUsingColorSpace:[NSColorSpace deviceRGBColorSpace]];
   else
     rgbColor = color;
 
@@ -528,42 +524,16 @@ - (BOOL)setFrame: (unsigned int) index
   return YES;
 }
 
-- (instancetype)rotate: (double)rotation
+- (void)setTransform: (double[3][3]) m
 {
-  EmacsImage *new_image;
-  NSPoint new_origin;
-  NSSize new_size, size = [self size];
-  NSRect rect = { NSZeroPoint, [self size] };
-
-  /* Create a bezier path of the outline of the image and do the
-   * rotation on it.  */
-  NSBezierPath *bounds_path = [NSBezierPath bezierPathWithRect:rect];
-  NSAffineTransform *transform = [NSAffineTransform transform];
-  [transform rotateByDegrees: rotation * -1];
-  [bounds_path transformUsingAffineTransform:transform];
-
-  /* Now we can find out how large the rotated image needs to be.  */
-  new_size = [bounds_path bounds].size;
-  new_image = [[EmacsImage alloc] initWithSize:new_size];
-
-  new_origin = NSMakePoint((new_size.width - size.width)/2,
-                           (new_size.height - size.height)/2);
-
-  [new_image lockFocus];
-
-  /* Create the final transform.  */
-  transform = [NSAffineTransform transform];
-  [transform translateXBy:new_size.width/2 yBy:new_size.height/2];
-  [transform rotateByDegrees: rotation * -1];
-  [transform translateXBy:-new_size.width/2 yBy:-new_size.height/2];
-
-  [transform concat];
-  [self drawAtPoint:new_origin fromRect:NSZeroRect
-          operation:NSCompositingOperationCopy fraction:1];
-
-  [new_image unlockFocus];
-
-  return new_image;
+  transform = [[NSAffineTransform transform] retain];
+  NSAffineTransformStruct tm
+    = { m[0][0], m[0][1], m[1][0], m[1][1], m[2][0], m[2][1]};
+  [transform setTransformStruct:tm];
+
+  /* Because the transform is applied to the drawing surface, and not
+     the image itself, we need to invert it.  */
+  [transform invert];
 }
 
 @end
diff --git a/src/nsmenu.m b/src/nsmenu.m
index 34ec980856..3fe06cda02 100644
--- a/src/nsmenu.m
+++ b/src/nsmenu.m
@@ -470,7 +470,7 @@
 }
 
 void
-x_activate_menubar (struct frame *f)
+ns_activate_menubar (struct frame *f)
 {
 #ifdef NS_IMPL_COCOA
   ns_update_menubar (f, true, nil);
@@ -668,9 +668,9 @@ - (NSMenuItem *)addItemWithWidgetValue: (void *)wvptr
       /* Draw radio buttons and tickboxes.  */
       if (wv->selected && (wv->button_type == BUTTON_TYPE_TOGGLE ||
                            wv->button_type == BUTTON_TYPE_RADIO))
-        [item setState: NSOnState];
+        [item setState: NSControlStateValueOn];
       else
-        [item setState: NSOffState];
+        [item setState: NSControlStateValueOff];
 
       [item setTag: (NSInteger)wv->call_data];
     }
@@ -1594,7 +1594,7 @@ - (instancetype)initWithContentRect: (NSRect)contentRect styleMask: (NSWindowSty
   [cell setBordered: NO];
   [cell setEnabled: NO];
   [cell setCellAttribute: NSCellIsInsetButton to: 8];
-  [cell setBezelStyle: NSRoundedBezelStyle];
+  [cell setBezelStyle: NSBezelStyleRounded];
 
   matrix = [[NSMatrix alloc] initWithFrame: contentRect
                                       mode: NSHighlightModeMatrix
@@ -1607,7 +1607,6 @@ - (instancetype)initWithContentRect: (NSRect)contentRect styleMask: (NSWindowSty
   [matrix autorelease];
 
   [[self contentView] addSubview: matrix];
-  [self setOneShot: YES];
   [self setReleasedWhenClosed: YES];
   [self setHidesOnDeactivate: YES];
   return self;
diff --git a/src/nsselect.m b/src/nsselect.m
index cf36c869eb..b044fe6f32 100644
--- a/src/nsselect.m
+++ b/src/nsselect.m
@@ -57,7 +57,7 @@ Updated by Christian Limpach (chris@nice.ch)
   if (EQ (sym, QCLIPBOARD))   return NSPasteboardNameGeneral;
   if (EQ (sym, QPRIMARY))     return NXPrimaryPboard;
   if (EQ (sym, QSECONDARY))   return NXSecondaryPboard;
-  if (EQ (sym, QTEXT))        return NSStringPboardType;
+  if (EQ (sym, QTEXT))        return NSPasteboardTypeString;
   return [NSString stringWithUTF8String: SSDATA (SYMBOL_NAME (sym))];
 }
 
@@ -76,11 +76,11 @@ Updated by Christian Limpach (chris@nice.ch)
     return QPRIMARY;
   if ([t isEqualToString: NXSecondaryPboard])
     return QSECONDARY;
-  if ([t isEqualToString: NSStringPboardType])
+  if ([t isEqualToString: NSPasteboardTypeString])
     return QTEXT;
   if ([t isEqualToString: NSFilenamesPboardType])
     return QFILE_NAME;
-  if ([t isEqualToString: NSTabularTextPboardType])
+  if ([t isEqualToString: NSPasteboardTypeTabularText])
     return QTEXT;
   return intern ([t UTF8String]);
 }
@@ -193,7 +193,7 @@ Updated by Christian Limpach (chris@nice.ch)
       else
         {
 	  // Used for ns-own-selection-internal.
-	  eassert (gtype == NSStringPboardType);
+	  eassert (gtype == NSPasteboardTypeString);
           [pb setString: nsStr forType: gtype];
         }
       [nsStr release];
@@ -345,7 +345,7 @@ Updated by Christian Limpach (chris@nice.ch)
   }
 
   /* We only support copy of text.  */
-  type = NSStringPboardType;
+  type = NSPasteboardTypeString;
   target_symbol = ns_string_to_symbol (type);
   if (STRINGP (value))
     {
@@ -472,9 +472,9 @@ Updated by Christian Limpach (chris@nice.ch)
 	     [NSNumber numberWithLong:0], NSPasteboardNameGeneral,
 	     [NSNumber numberWithLong:0], NXPrimaryPboard,
 	     [NSNumber numberWithLong:0], NXSecondaryPboard,
-	     [NSNumber numberWithLong:0], NSStringPboardType,
+	     [NSNumber numberWithLong:0], NSPasteboardTypeString,
 	     [NSNumber numberWithLong:0], NSFilenamesPboardType,
-	     [NSNumber numberWithLong:0], NSTabularTextPboardType,
+	     [NSNumber numberWithLong:0], NSPasteboardTypeTabularText,
 	 nil] retain];
 }
 
diff --git a/src/nsterm.h b/src/nsterm.h
index 78ce608554..567f462ec6 100644
--- a/src/nsterm.h
+++ b/src/nsterm.h
@@ -632,6 +632,8 @@ typedef id instancetype;
   unsigned char *pixmapData[5]; /* shortcut to access pixel data */
   NSColor *stippleMask;
   unsigned long xbm_fg;
+@public
+  NSAffineTransform *transform;
 }
 + (instancetype)allocInitFromFile: (Lisp_Object)file;
 - (void)dealloc;
@@ -648,7 +650,7 @@ typedef id instancetype;
 - (NSColor *)stippleMask;
 - (Lisp_Object)getMetadata;
 - (BOOL)setFrame: (unsigned int) index;
-- (instancetype)rotate: (double)rotation;
+- (void)setTransform: (double[3][3]) m;
 @end
 
 
@@ -869,20 +871,20 @@ struct ns_display_info
   Window root_window;
 
   /* Xism */
-  XrmDatabase xrdb;
+  Lisp_Object rdb;
 
   /* The cursor to use for vertical scroll bars.  */
-  Cursor vertical_scroll_bar_cursor;
+  Emacs_Cursor vertical_scroll_bar_cursor;
 
   /* The cursor to use for horizontal scroll bars.  */
-  Cursor horizontal_scroll_bar_cursor;
+  Emacs_Cursor horizontal_scroll_bar_cursor;
 
   /* Information about the range of text currently shown in
      mouse-face.  */
   Mouse_HLInfo mouse_highlight;
 
-  struct frame *x_highlight_frame;
-  struct frame *x_focus_frame;
+  struct frame *highlight_frame;
+  struct frame *ns_focus_frame;
 
   /* The frame where the mouse was last time we reported a mouse event.  */
   struct frame *last_mouse_frame;
@@ -931,24 +933,24 @@ struct ns_output
 #endif
 
   /* NSCursors are initialized in initFrameFromEmacs.  */
-  Cursor text_cursor;
-  Cursor nontext_cursor;
-  Cursor modeline_cursor;
-  Cursor hand_cursor;
-  Cursor hourglass_cursor;
-  Cursor horizontal_drag_cursor;
-  Cursor vertical_drag_cursor;
-  Cursor left_edge_cursor;
-  Cursor top_left_corner_cursor;
-  Cursor top_edge_cursor;
-  Cursor top_right_corner_cursor;
-  Cursor right_edge_cursor;
-  Cursor bottom_right_corner_cursor;
-  Cursor bottom_edge_cursor;
-  Cursor bottom_left_corner_cursor;
+  Emacs_Cursor text_cursor;
+  Emacs_Cursor nontext_cursor;
+  Emacs_Cursor modeline_cursor;
+  Emacs_Cursor hand_cursor;
+  Emacs_Cursor hourglass_cursor;
+  Emacs_Cursor horizontal_drag_cursor;
+  Emacs_Cursor vertical_drag_cursor;
+  Emacs_Cursor left_edge_cursor;
+  Emacs_Cursor top_left_corner_cursor;
+  Emacs_Cursor top_edge_cursor;
+  Emacs_Cursor top_right_corner_cursor;
+  Emacs_Cursor right_edge_cursor;
+  Emacs_Cursor bottom_right_corner_cursor;
+  Emacs_Cursor bottom_edge_cursor;
+  Emacs_Cursor bottom_left_corner_cursor;
 
   /* NS-specific */
-  Cursor current_pointer;
+  Emacs_Cursor current_pointer;
 
   /* lord knows why Emacs needs to know about our Window ids.. */
   Window window_desc, parent_desc;
@@ -993,15 +995,9 @@ struct x_output
 
 /* This gives the ns_display_info structure for the display F is on.  */
 #define FRAME_DISPLAY_INFO(f) ((f)->output_data.ns->display_info)
-#define FRAME_X_OUTPUT(f) ((f)->output_data.ns)
+#define FRAME_OUTPUT_DATA(f) ((f)->output_data.ns)
 #define FRAME_NS_WINDOW(f) ((f)->output_data.ns->window_desc)
-#define FRAME_X_WINDOW(f) ((f)->output_data.ns->window_desc)
-
-/* This is the `Display *' which frame F is on.  */
-#define FRAME_NS_DISPLAY(f) (0)
-#define FRAME_X_DISPLAY(f) (0)
-#define FRAME_X_SCREEN(f) (0)
-#define FRAME_X_VISUAL(f) FRAME_DISPLAY_INFO(f)->visual
+#define FRAME_NATIVE_WINDOW(f) FRAME_NS_WINDOW (f)
 
 #define FRAME_FOREGROUND_COLOR(f) ((f)->output_data.ns->foreground_color)
 #define FRAME_BACKGROUND_COLOR(f) ((f)->output_data.ns->background_color)
@@ -1122,6 +1118,9 @@ extern Lisp_Object ns_list_fonts (struct frame *f, Lisp_Object pattern,
                                   int size, int maxnames);
 extern void ns_clear_frame (struct frame *f);
 
+extern void ns_set_offset (struct frame *f, int xoff, int yoff,
+                           int change_grav);
+
 extern const char *ns_xlfd_to_fontname (const char *xlfd);
 
 extern Lisp_Object ns_map_event_to_object (void);
@@ -1137,10 +1136,10 @@ extern void ns_set_doc_edited (void);
 extern bool
 ns_defined_color (struct frame *f,
                   const char *name,
-                  XColor *color_def, bool alloc,
+                  Emacs_Color *color_def, bool alloc,
                   bool makeIndex);
 extern void
-ns_query_color (void *col, XColor *color_def, int setPixel);
+ns_query_color (void *col, Emacs_Color *color_def, bool setPixel);
 
 #ifdef __OBJC__
 extern int ns_lisp_to_color (Lisp_Object color, NSColor **col);
@@ -1151,6 +1150,15 @@ extern void ns_check_menu_open (NSMenu *menu);
 extern void ns_check_pending_open_menu (void);
 #endif
 
+/* Implemented in nsfns, published in nsterm.  */
+extern void ns_implicitly_set_name (struct frame *f, Lisp_Object arg,
+                                    Lisp_Object oldval);
+extern void ns_set_scroll_bar_default_width (struct frame *f);
+extern void ns_set_scroll_bar_default_height (struct frame *f);
+extern const char *ns_get_string_resource (void *_rdb,
+                                           const char *name,
+                                           const char *class);
+
 /* C access to ObjC functionality */
 extern void  ns_release_object (void *obj);
 extern void  ns_retain_object (void *obj);
@@ -1159,10 +1167,6 @@ extern void ns_release_autorelease_pool (void *);
 extern const char *ns_get_defaults_value (const char *key);
 extern void ns_init_locale (void);
 
-#ifdef NS_IMPL_COCOA
-extern void ns_enable_screen_updates (void);
-#endif
-
 /* in nsmenu */
 extern void update_frame_tool_bar (struct frame *f);
 extern void free_frame_tool_bar (struct frame *f);
@@ -1172,6 +1176,8 @@ extern Lisp_Object find_and_return_menu_selection (struct frame *f,
 extern Lisp_Object ns_popup_dialog (struct frame *, Lisp_Object header,
                                     Lisp_Object contents);
 
+extern void ns_free_frame_resources (struct frame *);
+
 #define NSAPP_DATA2_RUNASSCRIPT 10
 extern void ns_run_ascript (void);
 
@@ -1197,26 +1203,28 @@ extern bool ns_load_image (struct frame *f, struct image *img,
 extern int ns_image_width (void *img);
 extern int ns_image_height (void *img);
 extern void ns_image_set_size (void *img, int width, int height);
+extern void ns_image_set_transform (void *img, double m[3][3]);
 extern unsigned long ns_get_pixel (void *img, int x, int y);
 extern void ns_put_pixel (void *img, int x, int y, unsigned long argb);
 extern void ns_set_alpha (void *img, int x, int y, unsigned char a);
 
-extern int x_display_pixel_height (struct ns_display_info *);
-extern int x_display_pixel_width (struct ns_display_info *);
+extern int ns_display_pixel_height (struct ns_display_info *);
+extern int ns_display_pixel_width (struct ns_display_info *);
 
 /* This in nsterm.m */
 extern float ns_antialias_threshold;
-extern void x_destroy_window (struct frame *f);
-extern void x_set_undecorated (struct frame *f, Lisp_Object new_value,
-                               Lisp_Object old_value);
-extern void x_set_parent_frame (struct frame *f, Lisp_Object new_value,
+extern void ns_make_frame_visible (struct frame *f);
+extern void ns_iconify_frame (struct frame *f);
+extern void ns_set_undecorated (struct frame *f, Lisp_Object new_value,
                                 Lisp_Object old_value);
-extern void x_set_no_focus_on_map (struct frame *f, Lisp_Object new_value,
-                                   Lisp_Object old_value);
-extern void x_set_no_accept_focus (struct frame *f, Lisp_Object new_value,
-                                   Lisp_Object old_value);
-extern void x_set_z_group (struct frame *f, Lisp_Object new_value,
-                           Lisp_Object old_value);
+extern void ns_set_parent_frame (struct frame *f, Lisp_Object new_value,
+                                 Lisp_Object old_value);
+extern void ns_set_no_focus_on_map (struct frame *f, Lisp_Object new_value,
+                                    Lisp_Object old_value);
+extern void ns_set_no_accept_focus (struct frame *f, Lisp_Object new_value,
+                                    Lisp_Object old_value);
+extern void ns_set_z_group (struct frame *f, Lisp_Object new_value,
+                            Lisp_Object old_value);
 #ifdef NS_IMPL_COCOA
 extern void ns_set_appearance (struct frame *f, Lisp_Object new_value,
                                Lisp_Object old_value);
@@ -1327,4 +1335,14 @@ enum NSWindowTabbingMode
 /* Deprecated in macOS 10.13.  */
 #define NSPasteboardNameGeneral NSGeneralPboard
 #endif
+
+#if !defined (NS_IMPL_COCOA) || !defined (MAC_OS_X_VERSION_10_14)
+/* Deprecated in macOS 10.14.  */
+#define NSPasteboardTypeString NSStringPboardType
+#define NSPasteboardTypeTabularText NSTabularTextPboardType
+#define NSPasteboardTypeURL NSURLPboardType
+#define NSControlStateValueOn NSOnState
+#define NSControlStateValueOff NSOffState
+#define NSBezelStyleRounded NSRoundedBezelStyle
+#endif
 #endif	/* HAVE_NS */
diff --git a/src/nsterm.m b/src/nsterm.m
index c293e1e45b..32aa1182fc 100644
--- a/src/nsterm.m
+++ b/src/nsterm.m
@@ -161,20 +161,28 @@ + (NSColor *)colorForEmacsRed:(CGFloat)red green:(CGFloat)green
 
 - (NSColor *)colorUsingDefaultColorSpace
 {
-  /* FIXMES: We're checking for colorWithSRGBRed here so this will
-     only work in the same place as in the method above.  It should
-     really be a check whether we're on macOS 10.7 or above.  */
+  /* FIXME: We're checking for colorWithSRGBRed here so this will only
+     work in the same place as in the method above.  It should really
+     be a check whether we're on macOS 10.7 or above.  */
 #if defined (NS_IMPL_COCOA) \
   && MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
-  if (ns_use_srgb_colorspace
 #if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
-      && [NSColor respondsToSelector:
-                    @selector(colorWithSRGBRed:green:blue:alpha:)]
+  if ([NSColor respondsToSelector:
+                 @selector(colorWithSRGBRed:green:blue:alpha:)])
 #endif
-      )
-    return [self colorUsingColorSpace: [NSColorSpace sRGBColorSpace]];
+    {
+      if (ns_use_srgb_colorspace)
+        return [self colorUsingColorSpace: [NSColorSpace sRGBColorSpace]];
+      else
+        return [self colorUsingColorSpace: [NSColorSpace deviceRGBColorSpace]];
+    }
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+  else
 #endif
+#endif /* NS_IMPL_COCOA && MAC_OS_X_VERSION_MAX_ALLOWED >= 1070  */
+#if defined (NS_IMPL_GNUSTEP) || MAC_OS_X_VERSION_MIN_REQUIRED < 1070
   return [self colorUsingColorSpaceName: NSCalibratedRGBColorSpace];
+#endif
 }
 
 @end
@@ -284,9 +292,6 @@ - (NSColor *)colorUsingDefaultColorSpace
 static BOOL ns_fake_keydown = NO;
 #ifdef NS_IMPL_COCOA
 static BOOL ns_menu_bar_is_hidden = NO;
-
-/* The number of times NSDisableScreenUpdates has been called.  */
-static int disable_screen_updates_count = 0;
 #endif
 /* static int debug_lock = 0; */
 
@@ -689,40 +694,6 @@ Free a pool and temporary objects it refers to (callable from C)
 }
 
 
-#ifdef NS_IMPL_COCOA
-/* Disabling screen updates can be used to make several actions appear
-   "atomic" to the end user.  It seems some actions can still update
-   the display, though.
-
-   When we re-enable screen updates the number of calls to
-   NSEnableScreenUpdates should match the number to
-   NSDisableScreenUpdates.
-
-   We use these functions to prevent the user seeing a blank frame
-   after it has been resized.  x_set_window_size disables updates and
-   when redisplay completes unwind_redisplay enables them again
-   (bug#30699).  */
-
-static void
-ns_disable_screen_updates (void)
-{
-  NSDisableScreenUpdates ();
-  disable_screen_updates_count++;
-}
-
-void
-ns_enable_screen_updates (void)
-/* Re-enable screen updates.  Called from unwind_redisplay.  */
-{
-  while (disable_screen_updates_count > 0)
-    {
-      NSEnableScreenUpdates ();
-      disable_screen_updates_count--;
-    }
-}
-#endif
-
-
 static BOOL
 ns_menu_bar_should_be_hidden (void)
 /* True, if the menu bar should be hidden.  */
@@ -1107,7 +1078,7 @@ static NSRect constrain_frame_rect(NSRect frameRect, bool isFullscreen)
 ns_update_begin (struct frame *f)
 /* --------------------------------------------------------------------------
    Prepare for a grouped sequence of drawing calls
-   external (RIF) call; whole frame, called before update_window_begin
+   external (RIF) call; whole frame, called before gui_update_window_begin
    -------------------------------------------------------------------------- */
 {
 #ifdef NS_IMPL_COCOA
@@ -1126,80 +1097,6 @@ static NSRect constrain_frame_rect(NSRect frameRect, bool isFullscreen)
       [toolbar setVisible: tbar_visible];
   }
 #endif
-
-#ifdef NS_IMPL_GNUSTEP
-  uRect = NSMakeRect (0, 0, 0, 0);
-#endif
-}
-
-
-static void
-ns_update_window_begin (struct window *w)
-/* --------------------------------------------------------------------------
-   Prepare for a grouped sequence of drawing calls
-   external (RIF) call; for one window, called after update_begin
-   -------------------------------------------------------------------------- */
-{
-  struct frame *f = XFRAME (WINDOW_FRAME (w));
-  Mouse_HLInfo *hlinfo = MOUSE_HL_INFO (f);
-
-  NSTRACE_WHEN (NSTRACE_GROUP_UPDATES, "ns_update_window_begin");
-  w->output_cursor = w->cursor;
-
-  block_input ();
-
-  if (f == hlinfo->mouse_face_mouse_frame)
-    {
-      /* Don't do highlighting for mouse motion during the update.  */
-      hlinfo->mouse_face_defer = 1;
-
-        /* If the frame needs to be redrawn,
-           simply forget about any prior mouse highlighting.  */
-      if (FRAME_GARBAGED_P (f))
-        hlinfo->mouse_face_window = Qnil;
-
-      /* (further code for mouse faces ifdef'd out in other terms elided) */
-    }
-
-  unblock_input ();
-}
-
-
-static void
-ns_update_window_end (struct window *w, bool cursor_on_p,
-                      bool mouse_face_overwritten_p)
-/* --------------------------------------------------------------------------
-   Finished a grouped sequence of drawing calls
-   external (RIF) call; for one window called before update_end
-   -------------------------------------------------------------------------- */
-{
-  NSTRACE_WHEN (NSTRACE_GROUP_UPDATES, "ns_update_window_end");
-
-  /* note: this fn is nearly identical in all terms */
-  if (!w->pseudo_window_p)
-    {
-      block_input ();
-
-      if (cursor_on_p)
-	display_and_set_cursor (w, 1,
-				w->output_cursor.hpos, w->output_cursor.vpos,
-				w->output_cursor.x, w->output_cursor.y);
-
-      if (draw_window_fringes (w, 1))
-	{
-	  if (WINDOW_RIGHT_DIVIDER_WIDTH (w))
-	    x_draw_right_divider (w);
-	  else
-	    x_draw_vertical_border (w);
-	}
-
-      unblock_input ();
-    }
-
-  /* If a row with mouse-face was overwritten, arrange for
-     frame_up_to_date to redisplay the mouse highlight.  */
-  if (mouse_face_overwritten_p)
-    reset_mouse_highlight (MOUSE_HL_INFO (XFRAME (w->frame)));
 }
 
 
@@ -1207,7 +1104,7 @@ static NSRect constrain_frame_rect(NSRect frameRect, bool isFullscreen)
 ns_update_end (struct frame *f)
 /* --------------------------------------------------------------------------
    Finished a grouped sequence of drawing calls
-   external (RIF) call; for whole frame, called after update_window_end
+   external (RIF) call; for whole frame, called after gui_update_window_end
    -------------------------------------------------------------------------- */
 {
   NSTRACE_WHEN (NSTRACE_GROUP_UPDATES, "ns_update_end");
@@ -1449,6 +1346,40 @@ -(void)remove
 
    ========================================================================== */
 
+static Lisp_Object
+ns_get_focus_frame (struct frame *f)
+/* --------------------------------------------------------------------------
+     External (hook)
+   -------------------------------------------------------------------------- */
+{
+  Lisp_Object lisp_focus;
+
+  struct frame *focus =  FRAME_DISPLAY_INFO (f)->ns_focus_frame;
+
+  if (!focus)
+    return Qnil;
+
+  XSETFRAME (lisp_focus, focus);
+  return lisp_focus;
+}
+
+static void
+ns_focus_frame (struct frame *f, bool noactivate)
+/* --------------------------------------------------------------------------
+     External (hook)
+   -------------------------------------------------------------------------- */
+{
+  struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
+
+  if (dpyinfo->ns_focus_frame != f)
+    {
+      EmacsView *view = FRAME_NS_VIEW (f);
+      block_input ();
+      [NSApp activateIgnoringOtherApps: YES];
+      [[view window] makeKeyAndOrderFront: view];
+      unblock_input ();
+    }
+}
 
 static void
 ns_raise_frame (struct frame *f, BOOL make_key)
@@ -1502,6 +1433,7 @@ -(void)remove
     ns_lower_frame (f);
 }
 
+static void ns_set_frame_alpha (struct frame *f);
 
 static void
 ns_frame_rehighlight (struct frame *frame)
@@ -1510,48 +1442,48 @@ -(void)remove
    -------------------------------------------------------------------------- */
 {
   struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (frame);
-  struct frame *old_highlight = dpyinfo->x_highlight_frame;
+  struct frame *old_highlight = dpyinfo->highlight_frame;
 
   NSTRACE ("ns_frame_rehighlight");
-  if (dpyinfo->x_focus_frame)
+  if (dpyinfo->ns_focus_frame)
     {
-      dpyinfo->x_highlight_frame
-	= (FRAMEP (FRAME_FOCUS_FRAME (dpyinfo->x_focus_frame))
-           ? XFRAME (FRAME_FOCUS_FRAME (dpyinfo->x_focus_frame))
-           : dpyinfo->x_focus_frame);
-      if (!FRAME_LIVE_P (dpyinfo->x_highlight_frame))
+      dpyinfo->highlight_frame
+	= (FRAMEP (FRAME_FOCUS_FRAME (dpyinfo->ns_focus_frame))
+           ? XFRAME (FRAME_FOCUS_FRAME (dpyinfo->ns_focus_frame))
+           : dpyinfo->ns_focus_frame);
+      if (!FRAME_LIVE_P (dpyinfo->highlight_frame))
         {
-          fset_focus_frame (dpyinfo->x_focus_frame, Qnil);
-          dpyinfo->x_highlight_frame = dpyinfo->x_focus_frame;
+          fset_focus_frame (dpyinfo->ns_focus_frame, Qnil);
+          dpyinfo->highlight_frame = dpyinfo->ns_focus_frame;
         }
     }
   else
-      dpyinfo->x_highlight_frame = 0;
+      dpyinfo->highlight_frame = 0;
 
-  if (dpyinfo->x_highlight_frame &&
-         dpyinfo->x_highlight_frame != old_highlight)
+  if (dpyinfo->highlight_frame &&
+         dpyinfo->highlight_frame != old_highlight)
     {
       if (old_highlight)
 	{
-          x_update_cursor (old_highlight, 1);
-	  x_set_frame_alpha (old_highlight);
+          gui_update_cursor (old_highlight, 1);
+	  ns_set_frame_alpha (old_highlight);
 	}
-      if (dpyinfo->x_highlight_frame)
+      if (dpyinfo->highlight_frame)
 	{
-          x_update_cursor (dpyinfo->x_highlight_frame, 1);
-          x_set_frame_alpha (dpyinfo->x_highlight_frame);
+          gui_update_cursor (dpyinfo->highlight_frame, 1);
+          ns_set_frame_alpha (dpyinfo->highlight_frame);
 	}
     }
 }
 
 
 void
-x_make_frame_visible (struct frame *f)
+ns_make_frame_visible (struct frame *f)
 /* --------------------------------------------------------------------------
      External: Show the window (X11 semantics)
    -------------------------------------------------------------------------- */
 {
-  NSTRACE ("x_make_frame_visible");
+  NSTRACE ("ns_make_frame_visible");
   /* XXX: at some points in past this was not needed, as the only place that
      called this (frame.c:Fraise_frame ()) also called raise_lower;
      if this ends up the case again, comment this out again.  */
@@ -1590,20 +1522,20 @@ -(void)remove
           /* If the parent frame moved while the child frame was
              invisible, the child frame's position won't have been
              updated.  Make sure it's in the right place now.  */
-          x_set_offset(f, f->left_pos, f->top_pos, 0);
+          ns_set_offset(f, f->left_pos, f->top_pos, 0);
         }
     }
 }
 
 
-void
-x_make_frame_invisible (struct frame *f)
+static void
+ns_make_frame_invisible (struct frame *f)
 /* --------------------------------------------------------------------------
-     External: Hide the window (X11 semantics)
+     Hide the window (X11 semantics)
    -------------------------------------------------------------------------- */
 {
   NSView *view;
-  NSTRACE ("x_make_frame_invisible");
+  NSTRACE ("ns_make_frame_invisible");
   check_window_system (f);
   view = FRAME_NS_VIEW (f);
   [[view window] orderOut: NSApp];
@@ -1611,23 +1543,34 @@ -(void)remove
   SET_FRAME_ICONIFIED (f, 0);
 }
 
+static void
+ns_make_frame_visible_invisible (struct frame *f, bool visible)
+/* --------------------------------------------------------------------------
+     External (hook)
+   -------------------------------------------------------------------------- */
+{
+  if (visible)
+    ns_make_frame_visible (f);
+  else
+    ns_make_frame_invisible (f);
+}
 
 void
-x_iconify_frame (struct frame *f)
+ns_iconify_frame (struct frame *f)
 /* --------------------------------------------------------------------------
-     External: Iconify window
+     External (hook): Iconify window
    -------------------------------------------------------------------------- */
 {
   NSView *view;
   struct ns_display_info *dpyinfo;
 
-  NSTRACE ("x_iconify_frame");
+  NSTRACE ("ns_iconify_frame");
   check_window_system (f);
   view = FRAME_NS_VIEW (f);
   dpyinfo = FRAME_DISPLAY_INFO (f);
 
-  if (dpyinfo->x_highlight_frame == f)
-    dpyinfo->x_highlight_frame = 0;
+  if (dpyinfo->highlight_frame == f)
+    dpyinfo->highlight_frame = 0;
 
   if ([[view window] windowNumber] <= 0)
     {
@@ -1649,16 +1592,16 @@ -(void)remove
   unblock_input();
 }
 
-/* Free X resources of frame F.  */
+/* Free resources of frame F.  */
 
 void
-x_free_frame_resources (struct frame *f)
+ns_free_frame_resources (struct frame *f)
 {
   NSView *view;
   struct ns_display_info *dpyinfo;
   Mouse_HLInfo *hlinfo;
 
-  NSTRACE ("x_free_frame_resources");
+  NSTRACE ("ns_free_frame_resources");
   check_window_system (f);
   view = FRAME_NS_VIEW (f);
   dpyinfo = FRAME_DISPLAY_INFO (f);
@@ -1671,10 +1614,10 @@ -(void)remove
   free_frame_menubar (f);
   free_frame_faces (f);
 
-  if (f == dpyinfo->x_focus_frame)
-    dpyinfo->x_focus_frame = 0;
-  if (f == dpyinfo->x_highlight_frame)
-    dpyinfo->x_highlight_frame = 0;
+  if (f == dpyinfo->ns_focus_frame)
+    dpyinfo->ns_focus_frame = 0;
+  if (f == dpyinfo->highlight_frame)
+    dpyinfo->highlight_frame = 0;
   if (f == hlinfo->mouse_face_mouse_frame)
     reset_mouse_highlight (hlinfo);
 
@@ -1689,13 +1632,13 @@ -(void)remove
   unblock_input ();
 }
 
-void
-x_destroy_window (struct frame *f)
+static void
+ns_destroy_window (struct frame *f)
 /* --------------------------------------------------------------------------
      External: Delete the window
    -------------------------------------------------------------------------- */
 {
-  NSTRACE ("x_destroy_window");
+  NSTRACE ("ns_destroy_window");
 
   /* If this frame has a parent window, detach it as not doing so can
      cause a crash in GNUStep.  */
@@ -1708,13 +1651,13 @@ -(void)remove
     }
 
   check_window_system (f);
-  x_free_frame_resources (f);
+  ns_free_frame_resources (f);
   ns_window_num--;
 }
 
 
 void
-x_set_offset (struct frame *f, int xoff, int yoff, int change_grav)
+ns_set_offset (struct frame *f, int xoff, int yoff, int change_grav)
 /* --------------------------------------------------------------------------
      External: Position the window
    -------------------------------------------------------------------------- */
@@ -1722,7 +1665,7 @@ -(void)remove
   NSView *view = FRAME_NS_VIEW (f);
   NSScreen *screen = [[view window] screen];
 
-  NSTRACE ("x_set_offset");
+  NSTRACE ("ns_set_offset");
 
   block_input ();
 
@@ -1779,12 +1722,12 @@ -(void)remove
 }
 
 
-void
-x_set_window_size (struct frame *f,
-                   bool change_gravity,
-                   int width,
-                   int height,
-                   bool pixelwise)
+static void
+ns_set_window_size (struct frame *f,
+                    bool change_gravity,
+                    int width,
+                    int height,
+                    bool pixelwise)
 /* --------------------------------------------------------------------------
      Adjust window pixel size based on given character grid size
      Impl is a bit more complex than other terms, need to do some
@@ -1797,7 +1740,7 @@ -(void)remove
   int pixelwidth, pixelheight;
   int orig_height = wr.size.height;
 
-  NSTRACE ("x_set_window_size");
+  NSTRACE ("ns_set_window_size");
 
   if (view == nil)
     return;
@@ -1808,15 +1751,6 @@ -(void)remove
 
   block_input ();
 
-#ifdef NS_IMPL_COCOA
-  /* To prevent showing the user a blank frame, stop updates being
-     flushed to the screen until after redisplay has completed.  This
-     breaks live resize (resizing with a mouse), so don't do it if
-     we're in a live resize loop.  */
-  if (![view inLiveResize])
-    ns_disable_screen_updates ();
-#endif
-
   if (pixelwise)
     {
       pixelwidth = FRAME_TEXT_TO_PIXEL_WIDTH (f, width);
@@ -1858,7 +1792,7 @@ breaks live resize (resizing with a mouse), so don't do it if
 
 #ifdef NS_IMPL_COCOA
 void
-x_set_undecorated (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+ns_set_undecorated (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 /* --------------------------------------------------------------------------
      Set frame F's `undecorated' parameter.  If non-nil, F's window-system
      window is drawn without decorations, title, minimize/maximize boxes
@@ -1873,7 +1807,7 @@ breaks live resize (resizing with a mouse), so don't do it if
   EmacsView *view = (EmacsView *)FRAME_NS_VIEW (f);
   NSWindow *window = [view window];
 
-  NSTRACE ("x_set_undecorated");
+  NSTRACE ("ns_set_undecorated");
 
   if (!EQ (new_value, old_value))
     {
@@ -1908,7 +1842,7 @@ so some key presses (TAB) are swallowed by the system.  */
 #endif /* NS_IMPL_COCOA */
 
 void
-x_set_parent_frame (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+ns_set_parent_frame (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 /* --------------------------------------------------------------------------
      Set frame F's `parent-frame' parameter.  If non-nil, make F a child
      frame of the frame specified by that parameter.  Technically, this
@@ -1934,7 +1868,7 @@ so some key presses (TAB) are swallowed by the system.  */
   struct frame *p = NULL;
   NSWindow *parent, *child;
 
-  NSTRACE ("x_set_parent_frame");
+  NSTRACE ("ns_set_parent_frame");
 
   if (!NILP (new_value)
       && (!FRAMEP (new_value)
@@ -1982,7 +1916,7 @@ so some key presses (TAB) are swallowed by the system.  */
 }
 
 void
-x_set_no_focus_on_map (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+ns_set_no_focus_on_map (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 /* Set frame F's `no-focus-on-map' parameter which, if non-nil, means
  * that F's window-system window does not want to receive input focus
  * when it is mapped.  (A frame's window is mapped when the frame is
@@ -1991,7 +1925,7 @@ so some key presses (TAB) are swallowed by the system.  */
  *
  * Some window managers may not honor this parameter.  */
 {
-  NSTRACE ("x_set_no_focus_on_map");
+  NSTRACE ("ns_set_no_focus_on_map");
 
   if (!EQ (new_value, old_value))
     {
@@ -2000,7 +1934,7 @@ so some key presses (TAB) are swallowed by the system.  */
 }
 
 void
-x_set_no_accept_focus (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+ns_set_no_accept_focus (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 /*  Set frame F's `no-accept-focus' parameter which, if non-nil, hints
  * that F's window-system window does not want to receive input focus
  * via mouse clicks or by moving the mouse into it.
@@ -2010,14 +1944,14 @@ so some key presses (TAB) are swallowed by the system.  */
  *
  * Some window managers may not honor this parameter.  */
 {
-  NSTRACE ("x_set_no_accept_focus");
+  NSTRACE ("ns_set_no_accept_focus");
 
   if (!EQ (new_value, old_value))
     FRAME_NO_ACCEPT_FOCUS (f) = !NILP (new_value);
 }
 
 void
-x_set_z_group (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+ns_set_z_group (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 /* Set frame F's `z-group' parameter.  If `above', F's window-system
    window is displayed above all windows that do not have the `above'
    property set.  If nil, F's window is shown below all windows that
@@ -2030,7 +1964,7 @@ so some key presses (TAB) are swallowed by the system.  */
   EmacsView *view = (EmacsView *)FRAME_NS_VIEW (f);
   NSWindow *window = [view window];
 
-  NSTRACE ("x_set_z_group");
+  NSTRACE ("ns_set_z_group");
 
   if (NILP (new_value))
     {
@@ -2356,7 +2290,7 @@ so some key presses (TAB) are swallowed by the system.  */
 }
 
 void
-ns_query_color(void *col, XColor *color_def, int setPixel)
+ns_query_color(void *col, Emacs_Color *color_def, bool setPixel)
 /* --------------------------------------------------------------------------
          Get ARGB values out of NSColor col and put them into color_def.
          If setPixel, set the pixel to a concatenated version.
@@ -2376,11 +2310,10 @@ so some key presses (TAB) are swallowed by the system.  */
 		      (int)(r*255), (int)(g*255), (int)(b*255));
 }
 
-
 bool
 ns_defined_color (struct frame *f,
                   const char *name,
-                  XColor *color_def,
+                  Emacs_Color *color_def,
                   bool alloc,
                   bool makeIndex)
 /* --------------------------------------------------------------------------
@@ -2407,9 +2340,17 @@ so some key presses (TAB) are swallowed by the system.  */
   return 1;
 }
 
+static void
+ns_query_frame_background_color (struct frame *f, Emacs_Color *bgcolor)
+/* --------------------------------------------------------------------------
+     External (hook): Store F's background color into *BGCOLOR
+   -------------------------------------------------------------------------- */
+{
+  ns_query_color (FRAME_BACKGROUND_COLOR (f), bgcolor, true);
+}
 
-void
-x_set_frame_alpha (struct frame *f)
+static void
+ns_set_frame_alpha (struct frame *f)
 /* --------------------------------------------------------------------------
      change the entire-frame transparency
    -------------------------------------------------------------------------- */
@@ -2418,9 +2359,9 @@ so some key presses (TAB) are swallowed by the system.  */
   double alpha = 1.0;
   double alpha_min = 1.0;
 
-  NSTRACE ("x_set_frame_alpha");
+  NSTRACE ("ns_set_frame_alpha");
 
-  if (dpyinfo->x_highlight_frame == f)
+  if (dpyinfo->highlight_frame == f)
     alpha = f->alpha[0];
   else
     alpha = f->alpha[1];
@@ -2472,7 +2413,7 @@ so some key presses (TAB) are swallowed by the system.  */
 }
 
 static int
-note_mouse_movement (struct frame *frame, CGFloat x, CGFloat y, BOOL dragging)
+ns_note_mouse_movement (struct frame *frame, CGFloat x, CGFloat y, BOOL dragging)
 /*   ------------------------------------------------------------------------
      Called by EmacsView on mouseMovement events.  Passes on
      to emacs mainstream code if we moved off of a rect of interest
@@ -2544,8 +2485,7 @@ so some key presses (TAB) are swallowed by the system.  */
 
   /* Clear the mouse-moved flag for every frame on this display.  */
   FOR_EACH_FRAME (tail, frame)
-    if (FRAME_NS_P (XFRAME (frame))
-        && FRAME_NS_DISPLAY (XFRAME (frame)) == FRAME_NS_DISPLAY (*fp))
+    if (FRAME_NS_P (XFRAME (frame)))
       XFRAME (frame)->mouse_moved = 0;
 
   dpyinfo->last_mouse_scroll_bar = nil;
@@ -2553,7 +2493,7 @@ so some key presses (TAB) are swallowed by the system.  */
       && FRAME_LIVE_P (dpyinfo->last_mouse_frame))
     f = dpyinfo->last_mouse_frame;
   else
-    f = dpyinfo->x_focus_frame ? dpyinfo->x_focus_frame : SELECTED_FRAME ();
+    f = dpyinfo->ns_focus_frame ? dpyinfo->ns_focus_frame : SELECTED_FRAME ();
 
   if (f && FRAME_NS_P (f))
     {
@@ -2606,7 +2546,7 @@ so some key presses (TAB) are swallowed by the system.  */
 
 
 static void
-ns_define_frame_cursor (struct frame *f, Cursor cursor)
+ns_define_frame_cursor (struct frame *f, Emacs_Cursor cursor)
 /* --------------------------------------------------------------------------
     External (RIF): set frame mouse pointer type.
    -------------------------------------------------------------------------- */
@@ -2619,7 +2559,7 @@ so some key presses (TAB) are swallowed by the system.  */
       [[view window] invalidateCursorRectsForView: view];
       /* Redisplay assumes this function also draws the changed frame
          cursor, but this function doesn't, so do it explicitly.  */
-      x_update_cursor (f, 1);
+      gui_update_cursor (f, 1);
     }
 }
 
@@ -2651,14 +2591,14 @@ so some key presses (TAB) are swallowed by the system.  */
 
 
 char *
-x_get_keysym_name (int keysym)
+get_keysym_name (int keysym)
 /* --------------------------------------------------------------------------
     Called by keyboard.c.  Not sure if the return val is important, except
     that it be unique.
    -------------------------------------------------------------------------- */
 {
   static char value[16];
-  NSTRACE ("x_get_keysym_name");
+  NSTRACE ("get_keysym_name");
   sprintf (value, "%d", keysym);
   return value;
 }
@@ -2897,7 +2837,7 @@ so some key presses (TAB) are swallowed by the system.  */
 
   block_input ();
 
-  x_clear_cursor (w);
+  gui_clear_cursor (w);
 
   {
     NSRect srcRect = NSMakeRect (x, from_y, width, height);
@@ -3881,21 +3821,34 @@ Function modeled after x_draw_glyph_string_box ().
   /* Draw the image... do we need to draw placeholder if img == nil?  */
   if (img != nil)
     {
-#ifdef NS_IMPL_COCOA
+      /* The idea here is that the clipped area is set in the normal
+         view coordinate system, then we transform the coordinate
+         system so that when we draw the image it is rotated, resized
+         or whatever as required.  This is kind of backwards, but
+         there's no way to apply the transform to the image without
+         creating a whole new bitmap.  */
       NSRect dr = NSMakeRect (x, y, s->slice.width, s->slice.height);
-      NSRect ir = NSMakeRect (s->slice.x,
-                              s->img->height - s->slice.y - s->slice.height,
-                              s->slice.width, s->slice.height);
-      [img drawInRect: dr
-             fromRect: ir
-             operation: NSCompositingOperationSourceOver
-              fraction: 1.0
-           respectFlipped: YES
-                hints: nil];
-#else
-      [img compositeToPoint: NSMakePoint (x, y + s->slice.height)
-                  operation: NSCompositingOperationSourceOver];
-#endif
+      NSRect ir = NSMakeRect (0, 0, [img size].width, [img size].height);
+
+      NSAffineTransform *setOrigin = [NSAffineTransform transform];
+
+      [[NSGraphicsContext currentContext] saveGraphicsState];
+
+      /* Because of the transforms it's far too difficult to work out
+         what portion of the original, untransformed, image will be
+         drawn, so the clipping area will ensure we draw only the
+         correct bit.  */
+      NSRectClip (dr);
+
+      [setOrigin translateXBy:x - s->slice.x yBy:y - s->slice.y];
+      [setOrigin concat];
+      [img->transform concat];
+
+      [img drawInRect:ir fromRect:ir
+            operation:NSCompositingOperationSourceOver
+             fraction:1.0 respectFlipped:YES hints:nil];
+
+      [[NSGraphicsContext currentContext] restoreGraphicsState];
     }
 
   if (s->hl == DRAW_CURSOR)
@@ -5002,6 +4955,18 @@ in certain situations (rapid incoming events).
     [eview updateFrameSize: NO];
 }
 
+/* ==========================================================================
+
+    Image Hooks
+
+   ========================================================================== */
+
+static void
+ns_free_pixmap (struct frame *_f, Emacs_Pixmap pixmap)
+{
+  ns_release_object (pixmap);
+}
+
 /* ==========================================================================
 
     Initialization
@@ -5009,7 +4974,7 @@ in certain situations (rapid incoming events).
    ========================================================================== */
 
 int
-x_display_pixel_height (struct ns_display_info *dpyinfo)
+ns_display_pixel_height (struct ns_display_info *dpyinfo)
 {
   NSArray *screens = [NSScreen screens];
   NSEnumerator *enumerator = [screens objectEnumerator];
@@ -5024,7 +4989,7 @@ in certain situations (rapid incoming events).
 }
 
 int
-x_display_pixel_width (struct ns_display_info *dpyinfo)
+ns_display_pixel_width (struct ns_display_info *dpyinfo)
 {
   NSArray *screens = [NSScreen screens];
   NSEnumerator *enumerator = [screens objectEnumerator];
@@ -5108,7 +5073,7 @@ static Lisp_Object ns_string_to_lispmod (const char *s)
     dpyinfo->color_table = xmalloc (sizeof *dpyinfo->color_table);
     dpyinfo->color_table->colors = NULL;
     dpyinfo->root_window = 42; /* A placeholder.  */
-    dpyinfo->x_highlight_frame = dpyinfo->x_focus_frame = NULL;
+    dpyinfo->highlight_frame = dpyinfo->ns_focus_frame = NULL;
     dpyinfo->n_fonts = 0;
     dpyinfo->smallest_font_height = 1;
     dpyinfo->smallest_char_width = 1;
@@ -5118,7 +5083,7 @@ static Lisp_Object ns_string_to_lispmod (const char *s)
 
 
 /* This and next define (many of the) public functions in this file.  */
-/* x_... are generic versions in xdisp.c that we, and other terms, get away
+/* gui_* are generic versions in xdisp.c that we, and other terms, get away
          with using despite presence in the "system dependent" redisplay
          interface.  In addition, many of the ns_ methods have code that is
          shared with all terms, indicating need for further refactoring.  */
@@ -5126,18 +5091,18 @@ static Lisp_Object ns_string_to_lispmod (const char *s)
 static struct redisplay_interface ns_redisplay_interface =
 {
   ns_frame_parm_handlers,
-  x_produce_glyphs,
-  x_write_glyphs,
-  x_insert_glyphs,
-  x_clear_end_of_line,
+  gui_produce_glyphs,
+  gui_write_glyphs,
+  gui_insert_glyphs,
+  gui_clear_end_of_line,
   ns_scroll_run,
   ns_after_update_window_line,
-  ns_update_window_begin,
-  ns_update_window_end,
+  NULL, /* update_window_begin */
+  NULL, /* update_window_end   */
   0, /* flush_display */
-  x_clear_window_mouse_face,
-  x_get_glyph_overhangs,
-  x_fix_overlapping_area,
+  gui_clear_window_mouse_face,
+  gui_get_glyph_overhangs,
+  gui_fix_overlapping_area,
   ns_draw_fringe_bitmap,
   0, /* define_fringe_bitmap */ /* FIXME: simplify ns_draw_fringe_bitmap */
   0, /* destroy_fringe_bitmap */
@@ -5145,6 +5110,7 @@ static Lisp_Object ns_string_to_lispmod (const char *s)
   ns_draw_glyph_string,
   ns_define_frame_cursor,
   ns_clear_frame_area,
+  0, /* clear_under_internal_border */
   ns_draw_window_cursor,
   ns_draw_vertical_window_border,
   ns_draw_window_divider,
@@ -5176,11 +5142,13 @@ static Lisp_Object ns_string_to_lispmod (const char *s)
 
   block_input ();
 
-  x_destroy_all_bitmaps (dpyinfo);
+  image_destroy_all_bitmaps (dpyinfo);
   ns_delete_display (dpyinfo);
   unblock_input ();
 }
 
+static Lisp_Object ns_new_font (struct frame *f, Lisp_Object font_object,
+                                int fontset);
 
 static struct terminal *
 ns_create_terminal (struct ns_display_info *dpyinfo)
@@ -5203,18 +5171,34 @@ static Lisp_Object ns_string_to_lispmod (const char *s)
   terminal->update_end_hook = ns_update_end;
   terminal->read_socket_hook = ns_read_socket;
   terminal->frame_up_to_date_hook = ns_frame_up_to_date;
+  terminal->defined_color_hook = ns_defined_color;
+  terminal->query_frame_background_color = ns_query_frame_background_color;
   terminal->mouse_position_hook = ns_mouse_position;
+  terminal->get_focus_frame = ns_get_focus_frame;
+  terminal->focus_frame_hook = ns_focus_frame;
   terminal->frame_rehighlight_hook = ns_frame_rehighlight;
   terminal->frame_raise_lower_hook = ns_frame_raise_lower;
+  terminal->frame_visible_invisible_hook = ns_make_frame_visible_invisible;
   terminal->fullscreen_hook = ns_fullscreen_hook;
+  terminal->iconify_frame_hook = ns_iconify_frame;
+  terminal->set_window_size_hook = ns_set_window_size;
+  terminal->set_frame_offset_hook = ns_set_offset;
+  terminal->set_frame_alpha_hook = ns_set_frame_alpha;
+  terminal->set_new_font_hook = ns_new_font;
+  terminal->implicit_set_name_hook = ns_implicitly_set_name;
   terminal->menu_show_hook = ns_menu_show;
+  terminal->activate_menubar_hook = ns_activate_menubar;
   terminal->popup_dialog_hook = ns_popup_dialog;
   terminal->set_vertical_scroll_bar_hook = ns_set_vertical_scroll_bar;
   terminal->set_horizontal_scroll_bar_hook = ns_set_horizontal_scroll_bar;
+  terminal->set_scroll_bar_default_width_hook = ns_set_scroll_bar_default_width;
+  terminal->set_scroll_bar_default_height_hook = ns_set_scroll_bar_default_height;
   terminal->condemn_scroll_bars_hook = ns_condemn_scroll_bars;
   terminal->redeem_scroll_bar_hook = ns_redeem_scroll_bar;
   terminal->judge_scroll_bars_hook = ns_judge_scroll_bars;
-  terminal->delete_frame_hook = x_destroy_window;
+  terminal->get_string_resource_hook = ns_get_string_resource;
+  terminal->free_pixmap = ns_free_pixmap;
+  terminal->delete_frame_hook = ns_destroy_window;
   terminal->delete_terminal_hook = ns_delete_terminal;
   /* Other hooks are NULL by default.  */
 
@@ -5465,14 +5449,14 @@ Needs to be here because ns_initialize_display_info () uses AppKit classes.
 
   NSTRACE_MSG ("Input/output types");
 
-  ns_send_types = [[NSArray arrayWithObjects: NSStringPboardType, nil] retain];
-  ns_return_types = [[NSArray arrayWithObjects: NSStringPboardType, nil]
+  ns_send_types = [[NSArray arrayWithObjects: NSPasteboardTypeString, nil] retain];
+  ns_return_types = [[NSArray arrayWithObjects: NSPasteboardTypeString, nil]
                       retain];
   ns_drag_types = [[NSArray arrayWithObjects:
-                            NSStringPboardType,
-                            NSTabularTextPboardType,
+                            NSPasteboardTypeString,
+                            NSPasteboardTypeTabularText,
                             NSFilenamesPboardType,
-                            NSURLPboardType, nil] retain];
+                            NSPasteboardTypeURL, nil] retain];
 
   /* If fullscreen is in init/default-frame-alist, focus isn't set
      right for fullscreen windows, so set this.  */
@@ -5677,7 +5661,7 @@ - (void)sendEvent: (NSEvent *)theEvent
       struct ns_display_info *di;
       BOOL has_focus = NO;
       for (di = x_display_list; ! has_focus && di; di = di->next)
-        has_focus = di->x_focus_frame != 0;
+        has_focus = di->ns_focus_frame != 0;
       if (! has_focus)
         return;
     }
@@ -6911,7 +6895,7 @@ - (void)mouseMoved: (NSEvent *)e
     }
 
   dragging = (e.type == NSEventTypeLeftMouseDragged);
-  if (!note_mouse_movement (emacsframe, pt.x, pt.y, dragging))
+  if (!ns_note_mouse_movement (emacsframe, pt.x, pt.y, dragging))
     help_echo_string = previous_help_echo_string;
 
   XSETFRAME (frame, emacsframe);
@@ -6919,7 +6903,7 @@ - (void)mouseMoved: (NSEvent *)e
     {
       /* NOTE: help_echo_{window,pos,object} are set in xdisp.c
          (note_mouse_highlight), which is called through the
-         note_mouse_movement () call above.  */
+         ns_note_mouse_movement () call above.  */
       any_help_event_p = YES;
       gen_help_event (help_echo_string, frame, help_echo_window,
                       help_echo_object, help_echo_pos);
@@ -7236,12 +7220,12 @@ - (void)windowDidBecomeKey: (NSNotification *)notification
 - (void)windowDidBecomeKey      /* for direct calls */
 {
   struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (emacsframe);
-  struct frame *old_focus = dpyinfo->x_focus_frame;
+  struct frame *old_focus = dpyinfo->ns_focus_frame;
 
   NSTRACE ("[EmacsView windowDidBecomeKey]");
 
   if (emacsframe != old_focus)
-    dpyinfo->x_focus_frame = emacsframe;
+    dpyinfo->ns_focus_frame = emacsframe;
 
   ns_frame_rehighlight (emacsframe);
 
@@ -7257,11 +7241,11 @@ - (void)windowDidResignKey: (NSNotification *)notification
 /* cf. x_detect_focus_change(), x_focus_changed(), x_new_focus_frame() */
 {
   struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (emacsframe);
-  BOOL is_focus_frame = dpyinfo->x_focus_frame == emacsframe;
+  BOOL is_focus_frame = dpyinfo->ns_focus_frame == emacsframe;
   NSTRACE ("[EmacsView windowDidResignKey:]");
 
   if (is_focus_frame)
-    dpyinfo->x_focus_frame = 0;
+    dpyinfo->ns_focus_frame = 0;
 
   emacsframe->mouse_moved = 0;
   ns_frame_rehighlight (emacsframe);
@@ -7270,8 +7254,8 @@ - (void)windowDidResignKey: (NSNotification *)notification
             from sole-frame Emacs to get hollow box to show.  */
   if (!windowClosing && [[self window] isVisible] == YES)
     {
-      x_update_cursor (emacsframe, 1);
-      x_set_frame_alpha (emacsframe);
+      gui_update_cursor (emacsframe, 1);
+      ns_set_frame_alpha (emacsframe);
     }
 
   if (any_help_event_p)
@@ -7540,7 +7524,7 @@ - (void)windowDidMove: sender
 
 
 /* Called AFTER method below, but before our windowWillResize call there leads
-   to windowDidResize -> x_set_window_size.  Update emacs' notion of frame
+   to windowDidResize -> ns_set_window_size.  Update emacs' notion of frame
    location so set_window_size moves the frame.  */
 - (BOOL)windowShouldZoom: (NSWindow *)sender toFrame: (NSRect)newFrame
 {
@@ -8284,6 +8268,9 @@ -(BOOL)performDragOperation: (id <NSDraggingInfo>) sender
     {
       return NO;
     }
+  /* FIXME: NSFilenamesPboardType is deprecated in 10.14, but the
+     NSURL method can only handle one file at a time.  Stick with the
+     existing code at the moment.  */
   else if ([type isEqualToString: NSFilenamesPboardType])
     {
       NSArray *files;
@@ -8378,8 +8365,8 @@ - (BOOL) writeSelectionToPasteboard: (NSPasteboard *)pb types: (NSArray *)types
 
   NSTRACE ("[EmacsView writeSelectionToPasteboard:types:]");
 
-  /* We only support NSStringPboardType.  */
-  if ([types containsObject:NSStringPboardType] == NO) {
+  /* We only support NSPasteboardTypeString.  */
+  if ([types containsObject:NSPasteboardTypeString] == NO) {
     return NO;
   }
 
@@ -8393,7 +8380,7 @@ - (BOOL) writeSelectionToPasteboard: (NSPasteboard *)pb types: (NSArray *)types
   if (! STRINGP (val))
     return NO;
 
-  typesDeclared = [NSArray arrayWithObject:NSStringPboardType];
+  typesDeclared = [NSArray arrayWithObject:NSPasteboardTypeString];
   [pb declareTypes:typesDeclared owner:nil];
   ns_string_to_pasteboard (pb, val);
   return YES;
@@ -9055,10 +9042,12 @@ - (void)mouseDown: (NSEvent *)e
       last_hit_part = horizontal ? scroll_bar_before_handle : scroll_bar_above_handle; break;
     case NSScrollerIncrementPage:
       last_hit_part = horizontal ? scroll_bar_after_handle : scroll_bar_below_handle; break;
+#if defined (NS_IMPL_GNUSTEP) || MAC_OS_X_VERSION_MIN_REQUIRED < 1070
     case NSScrollerDecrementLine:
       last_hit_part = horizontal ? scroll_bar_left_arrow : scroll_bar_up_arrow; break;
     case NSScrollerIncrementLine:
       last_hit_part = horizontal ? scroll_bar_right_arrow : scroll_bar_down_arrow; break;
+#endif
     case NSScrollerKnob:
       last_hit_part = horizontal ? scroll_bar_horizontal_handle : scroll_bar_handle; break;
     case NSScrollerKnobSlot:  /* GNUstep-only */
@@ -9243,9 +9232,12 @@ @implementation EmacsDocument
    ========================================================================== */
 
 
-Lisp_Object
-x_new_font (struct frame *f, Lisp_Object font_object, int fontset)
+static Lisp_Object
+ns_new_font (struct frame *f, Lisp_Object font_object, int fontset)
 {
+  /* --------------------------------------------------------------------------
+     External (hook)
+     -------------------------------------------------------------------------- */
   struct font *font = XFONT_OBJECT (font_object);
   EmacsView *view = FRAME_NS_VIEW (f);
   int font_ascent, font_descent;
diff --git a/src/pdumper.c b/src/pdumper.c
index 600c5b3ca3..28045d1959 100644
--- a/src/pdumper.c
+++ b/src/pdumper.c
@@ -70,18 +70,18 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #ifdef HAVE_PDUMPER
 
-#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)
+#if GNUC_PREREQ (4, 7, 0)
 # pragma GCC diagnostic error "-Wconversion"
+# pragma GCC diagnostic ignored "-Wsign-conversion"
 # pragma GCC diagnostic error "-Wshadow"
 # define ALLOW_IMPLICIT_CONVERSION                       \
   _Pragma ("GCC diagnostic push")                        \
   _Pragma ("GCC diagnostic ignored \"-Wconversion\"")
-  _Pragma ("GCC diagnostic ignored \"-Wsign-conversion\"")
 # define DISALLOW_IMPLICIT_CONVERSION \
   _Pragma ("GCC diagnostic pop")
 #else
-# define ALLOW_IMPLICIT_CONVERSION ((void)0)
-# define DISALLOW_IMPLICIT_CONVERSION ((void)0)
+# define ALLOW_IMPLICIT_CONVERSION ((void) 0)
+# define DISALLOW_IMPLICIT_CONVERSION ((void) 0)
 #endif
 
 #define VM_POSIX 1
@@ -124,7 +124,7 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
    general-purpose computer made after 1990.  */
 verify (sizeof (ptrdiff_t) == sizeof (void *));
 verify (sizeof (intptr_t) == sizeof (ptrdiff_t));
-verify (sizeof (void (*)(void)) == sizeof (void *));
+verify (sizeof (void (*) (void)) == sizeof (void *));
 verify (sizeof (ptrdiff_t) <= sizeof (Lisp_Object));
 verify (sizeof (ptrdiff_t) <= sizeof (EMACS_INT));
 verify (CHAR_BIT == 8);
@@ -151,8 +151,7 @@ typedef int_least32_t dump_off;
 #define DUMP_OFF_MIN INT_LEAST32_MIN
 #define DUMP_OFF_MAX INT_LEAST32_MAX
 
-__attribute__((format (printf,1,2)))
-static void
+static void ATTRIBUTE_FORMAT ((printf, 1, 2))
 dump_trace (const char *fmt, ...)
 {
   if (0)
@@ -680,8 +679,7 @@ static void dump_remember_cold_op (struct dump_context *ctx,
                                    enum cold_op op,
                                    Lisp_Object arg);
 
-_Noreturn
-static void
+static AVOID
 error_unsupported_dump_object (struct dump_context *ctx,
                                Lisp_Object object,
 			       const char *msg)
@@ -735,11 +733,7 @@ dump_builtin_symbol_p (Lisp_Object object)
 static bool
 dump_object_self_representing_p (Lisp_Object object)
 {
-  bool result;
-  ALLOW_IMPLICIT_CONVERSION;
-  result =  FIXNUMP (object) || dump_builtin_symbol_p (object);
-  DISALLOW_IMPLICIT_CONVERSION;
-  return result;
+  return FIXNUMP (object) || dump_builtin_symbol_p (object);
 }
 
 #define DEFINE_FROMLISP_FUNC(fn, type)          \
@@ -750,10 +744,13 @@ dump_object_self_representing_p (Lisp_Object object)
     if (FIXNUMP (value))                        \
       return XFIXNUM (value);                   \
     eassert (BIGNUMP (value));                  \
-    return TYPE_SIGNED (type)                   \
-      ? bignum_to_intmax (value)                \
-      : bignum_to_uintmax (value);              \
+    type result;				\
+    if (TYPE_SIGNED (type))			\
+      result = bignum_to_intmax (value);	\
+    else					\
+      result = bignum_to_uintmax (value);	\
     DISALLOW_IMPLICIT_CONVERSION;               \
+    return result;				\
   }
 
 #define DEFINE_TOLISP_FUNC(fn, type) \
@@ -763,10 +760,10 @@ dump_object_self_representing_p (Lisp_Object object)
     return INT_TO_INTEGER (value);   \
   }
 
-DEFINE_FROMLISP_FUNC (intmax_t_from_lisp, intmax_t);
-DEFINE_TOLISP_FUNC (intmax_t_to_lisp, intmax_t);
-DEFINE_FROMLISP_FUNC (dump_off_from_lisp, dump_off);
-DEFINE_TOLISP_FUNC (dump_off_to_lisp, dump_off);
+DEFINE_FROMLISP_FUNC (intmax_t_from_lisp, intmax_t)
+DEFINE_TOLISP_FUNC (intmax_t_to_lisp, intmax_t)
+DEFINE_FROMLISP_FUNC (dump_off_from_lisp, dump_off)
+DEFINE_TOLISP_FUNC (dump_off_to_lisp, dump_off)
 
 static void
 dump_write (struct dump_context *ctx, const void *buf, dump_off nbyte)
@@ -798,8 +795,7 @@ dump_tailq_length (const struct dump_tailq *tailq)
   return tailq->length;
 }
 
-__attribute__((unused))
-static void
+static void ATTRIBUTE_UNUSED
 dump_tailq_prepend (struct dump_tailq *tailq, Lisp_Object value)
 {
   Lisp_Object link = Fcons (value, tailq->head);
@@ -809,8 +805,7 @@ dump_tailq_prepend (struct dump_tailq *tailq, Lisp_Object value)
   tailq->length += 1;
 }
 
-__attribute__((unused))
-static void
+static void ATTRIBUTE_UNUSED
 dump_tailq_append (struct dump_tailq *tailq, Lisp_Object value)
 {
   Lisp_Object link = Fcons (value, Qnil);
@@ -1594,11 +1589,11 @@ dump_emacs_reloc_immediate (struct dump_context *ctx,
       ctx, emacs_ptr, &value, sizeof (value));                          \
   }
 
-DEFINE_EMACS_IMMEDIATE_FN (dump_emacs_reloc_immediate_lv, Lisp_Object);
-DEFINE_EMACS_IMMEDIATE_FN (dump_emacs_reloc_immediate_ptrdiff_t, ptrdiff_t);
-DEFINE_EMACS_IMMEDIATE_FN (dump_emacs_reloc_immediate_intmax_t, intmax_t);
-DEFINE_EMACS_IMMEDIATE_FN (dump_emacs_reloc_immediate_int, int);
-DEFINE_EMACS_IMMEDIATE_FN (dump_emacs_reloc_immediate_bool, bool);
+DEFINE_EMACS_IMMEDIATE_FN (dump_emacs_reloc_immediate_lv, Lisp_Object)
+DEFINE_EMACS_IMMEDIATE_FN (dump_emacs_reloc_immediate_ptrdiff_t, ptrdiff_t)
+DEFINE_EMACS_IMMEDIATE_FN (dump_emacs_reloc_immediate_intmax_t, intmax_t)
+DEFINE_EMACS_IMMEDIATE_FN (dump_emacs_reloc_immediate_int, int)
+DEFINE_EMACS_IMMEDIATE_FN (dump_emacs_reloc_immediate_bool, bool)
 
 /* Add an emacs relocation that makes a raw pointer in Emacs point
    into the dump.  */
@@ -2012,8 +2007,10 @@ finish_dump_pvec (struct dump_context *ctx,
                   union vectorlike_header *out_hdr)
 {
   ALLOW_IMPLICIT_CONVERSION;
-  return dump_object_finish (ctx, out_hdr, vectorlike_nbytes (out_hdr));
+  dump_off result = dump_object_finish (ctx, out_hdr,
+					vectorlike_nbytes (out_hdr));
   DISALLOW_IMPLICIT_CONVERSION;
+  return result;
 }
 
 static void
@@ -2952,7 +2949,7 @@ dump_vectorlike (struct dump_context *ctx,
                  Lisp_Object lv,
                  dump_off offset)
 {
-#if CHECK_STRUCTS && !defined (HASH_pvec_type_549C833A54)
+#if CHECK_STRUCTS && !defined HASH_pvec_type_E55BD36F8E
 # error "pvec_type changed. See CHECK_STRUCTS comment."
 #endif
   const struct Lisp_Vector *v = XVECTOR (lv);
@@ -3014,9 +3011,7 @@ dump_vectorlike (struct dump_context *ctx,
     case PVEC_XWIDGET_VIEW:
       error_unsupported_dump_object (ctx, lv, "xwidget view");
     case PVEC_MISC_PTR:
-#ifdef HAVE_MODULES
     case PVEC_USER_PTR:
-#endif
       error_unsupported_dump_object (ctx, lv, "smuggled pointers");
     case PVEC_THREAD:
       if (main_thread_p (v))
@@ -3170,7 +3165,7 @@ dump_charset (struct dump_context *ctx, int cs_i)
 #if CHECK_STRUCTS && !defined (HASH_charset_317C49E291)
 # error "charset changed. See CHECK_STRUCTS comment."
 #endif
-  dump_align_output (ctx, alignof (int));
+  dump_align_output (ctx, alignof (struct charset));
   const struct charset *cs = charset_table + cs_i;
   struct charset out;
   dump_object_start (ctx, &out, sizeof (out));
@@ -3240,7 +3235,8 @@ static void
 dump_metadata_for_pdumper (struct dump_context *ctx)
 {
   for (int i = 0; i < nr_dump_hooks; ++i)
-    dump_emacs_reloc_to_emacs_ptr_raw (ctx, &dump_hooks[i], dump_hooks[i]);
+    dump_emacs_reloc_to_emacs_ptr_raw (ctx, &dump_hooks[i],
+				       (void const *) dump_hooks[i]);
   dump_emacs_reloc_immediate_int (ctx, &nr_dump_hooks, nr_dump_hooks);
 
   for (int i = 0; i < nr_remembered_data; ++i)
@@ -3804,8 +3800,8 @@ dump_merge_emacs_relocs (Lisp_Object lreloc_a, Lisp_Object lreloc_b)
                 dump_off_to_lisp (reloc_a.length));
 }
 
-typedef void (*drain_reloc_handler)(struct dump_context *, Lisp_Object);
-typedef Lisp_Object (*drain_reloc_merger)(Lisp_Object a, Lisp_Object b);
+typedef void (*drain_reloc_handler) (struct dump_context *, Lisp_Object);
+typedef Lisp_Object (*drain_reloc_merger) (Lisp_Object a, Lisp_Object b);
 
 static void
 drain_reloc_list (struct dump_context *ctx,
@@ -3819,7 +3815,8 @@ drain_reloc_list (struct dump_context *ctx,
   Lisp_Object relocs = Fsort (Fnreverse (*reloc_list),
                               Qdump_emacs_portable__sort_predicate);
   *reloc_list = Qnil;
-  dump_align_output (ctx, sizeof (dump_off));
+  dump_align_output (ctx, max (alignof (struct dump_reloc),
+			       alignof (struct emacs_reloc)));
   struct dump_table_locator locator;
   memset (&locator, 0, sizeof (locator));
   locator.offset = ctx->offset;
@@ -4042,7 +4039,7 @@ types.  */)
   ctx->deferred_symbols = Qnil;
 
   ctx->fixups = Qnil;
-  ctx->staticpro_table = CALLN (Fmake_hash_table);
+  ctx->staticpro_table = Fmake_hash_table (0, NULL);
   ctx->symbol_aux = Qnil;
   ctx->copied_queue = Qnil;
   ctx->cold_queue = Qnil;
@@ -4551,7 +4548,7 @@ dump_map_file (void *base, int fd, off_t offset, size_t size,
   return dump_map_file_w32 (base, fd, offset, size, protection);
 #else
   errno = ENOSYS;
-  return ret;
+  return NULL;
 #endif
 }
 
@@ -4589,7 +4586,7 @@ struct dump_memory_map
 {
   struct dump_memory_map_spec spec;
   void *mapping;  /* Actual mapped memory.  */
-  void (*release)(struct dump_memory_map *);
+  void (*release) (struct dump_memory_map *);
   void *private;
 };
 
@@ -4626,9 +4623,7 @@ dump_mmap_reset (struct dump_memory_map *map)
 {
   map->mapping = NULL;
   map->release = NULL;
-  void *private = map->private;
   map->private = NULL;
-  free (private);
 }
 
 static void
@@ -4651,7 +4646,10 @@ dump_mm_heap_cb_release (struct dump_memory_map_heap_control_block *cb)
 {
   eassert (cb->refcount > 0);
   if (--cb->refcount == 0)
-    free (cb->mem);
+    {
+      free (cb->mem);
+      free (cb);
+    }
 }
 
 static void
@@ -4666,7 +4664,12 @@ dump_mmap_contiguous_heap (struct dump_memory_map *maps, int nr_maps,
 			   size_t total_size)
 {
   bool ret = false;
+
+  /* FIXME: This storage sometimes is never freed.
+     Beware: the simple patch 2019-03-11T15:20:54Z!eggert@cs.ucla.edu
+     is worse, as it sometimes frees this storage twice.  */
   struct dump_memory_map_heap_control_block *cb = calloc (1, sizeof (*cb));
+
   char *mem;
   if (!cb)
     goto out;
@@ -4920,7 +4923,8 @@ static void
 dump_bitset_clear (struct dump_bitset *bitset)
 {
   int xword_size = sizeof (bitset->bits[0]);
-  memset (bitset->bits, 0, bitset->number_words * xword_size);
+  if (bitset->number_words)
+    memset (bitset->bits, 0, bitset->number_words * xword_size);
 }
 
 struct pdumper_loaded_dump_private
diff --git a/src/print.c b/src/print.c
index 67c4ed03ee..406abbf4a3 100644
--- a/src/print.c
+++ b/src/print.c
@@ -1361,6 +1361,19 @@ print_prune_string_charset (Lisp_Object string)
   return string;
 }
 
+#ifdef HAVE_MODULES
+/* Return a data pointer equal to FUNCPTR.  */
+
+static void const *
+data_from_funcptr (void (*funcptr) (void))
+{
+  /* The module code, and the POSIX API for dynamic linking, already
+     assume that function and data pointers are represented
+     interchangeably, so it's OK to assume that here too.  */
+  return (void const *) funcptr;
+}
+#endif
+
 static bool
 print_vectorlike (Lisp_Object obj, Lisp_Object printcharfun, bool escapeflag,
 		  char *buf)
@@ -1410,7 +1423,6 @@ print_vectorlike (Lisp_Object obj, Lisp_Object printcharfun, bool escapeflag,
       printchar ('>', printcharfun);
       break;
 
-#ifdef HAVE_MODULES
     case PVEC_USER_PTR:
       {
 	print_c_string ("#<user-ptr ", printcharfun);
@@ -1421,7 +1433,6 @@ print_vectorlike (Lisp_Object obj, Lisp_Object printcharfun, bool escapeflag,
 	printchar ('>', printcharfun);
       }
       break;
-#endif
 
     case PVEC_FINALIZER:
       print_c_string ("#<finalizer", printcharfun);
@@ -1789,24 +1800,21 @@ print_vectorlike (Lisp_Object obj, Lisp_Object printcharfun, bool escapeflag,
     case PVEC_MODULE_FUNCTION:
       {
 	print_c_string ("#<module function ", printcharfun);
-	void *ptr = XMODULE_FUNCTION (obj)->subr;
-	const char *file = NULL;
-	const char *symbol = NULL;
+        module_funcptr ptr = module_function_address (XMODULE_FUNCTION (obj));
+	char const *file;
+	char const *symbol;
 	dynlib_addr (ptr, &file, &symbol);
 
 	if (symbol == NULL)
 	  {
-	    print_c_string ("at ", printcharfun);
-	    enum { pointer_bufsize = sizeof ptr * 16 / CHAR_BIT + 2 + 1 };
-	    char buffer[pointer_bufsize];
-	    int needed = snprintf (buffer, sizeof buffer, "%p", ptr);
-	    const char p0x[] = "0x";
-	    eassert (needed <= sizeof buffer);
-	    /* ANSI C doesn't guarantee that %p produces a string that
-	       begins with a "0x".  */
-	    if (c_strncasecmp (buffer, p0x, sizeof (p0x) - 1) != 0)
-	      print_c_string (p0x, printcharfun);
-	    print_c_string (buffer, printcharfun);
+	    uintptr_t ui = (uintptr_t) data_from_funcptr (ptr);
+
+	    /* In theory this assignment could lose info on pre-C99
+	       hosts, but in practice it doesn't.  */
+	    uprintmax_t up = ui;
+
+	    int len = sprintf (buf, "at 0x%"pMx, up);
+	    strout (buf, len, len, printcharfun);
 	  }
 	else
 	  print_c_string (symbol, printcharfun);
@@ -1834,7 +1842,9 @@ print_object (Lisp_Object obj, Lisp_Object printcharfun, bool escapeflag)
 {
   char buf[max (sizeof "from..to..in " + 2 * INT_STRLEN_BOUND (EMACS_INT),
 		max (sizeof " . #" + INT_STRLEN_BOUND (printmax_t),
-		     40))];
+		     max ((sizeof "at 0x"
+			   + (sizeof (uprintmax_t) * CHAR_BIT + 4 - 1) / 4),
+			  40)))];
   current_thread->stack_top = buf;
   maybe_quit ();
 
diff --git a/src/process.c b/src/process.c
index 6770a5ed88..6717ccb418 100644
--- a/src/process.c
+++ b/src/process.c
@@ -1643,10 +1643,11 @@ ENCODING is used for writing.
 :noquery BOOL -- When exiting Emacs, query the user if BOOL is nil and
 the process is running.  If BOOL is not given, query before exiting.
 
-:stop BOOL -- Start process in the `stopped' state if BOOL non-nil.
-In the stopped state, a process does not accept incoming data, but you
-can send outgoing data.  The stopped state is cleared by
-`continue-process' and set by `stop-process'.
+:stop BOOL -- BOOL must be nil.  The `:stop' key is ignored otherwise
+and is retained for compatibility with other process types such as
+pipe processes.  Asynchronous subprocesses never start in the
+`stopped' state.  Use `stop-process' and `continue-process' to send
+signals to stop and continue a process.
 
 :connection-type TYPE -- TYPE is control type of device used to
 communicate with subprocesses.  Values are `pipe' to use a pipe, `pty'
@@ -1746,8 +1747,10 @@ usage: (make-process &rest ARGS)  */)
 
   if (!query_on_exit)
     XPROCESS (proc)->kill_without_query = 1;
-  if (tem = Fplist_get (contact, QCstop), !NILP (tem))
-    pset_command (XPROCESS (proc), Qt);
+  tem = Fplist_get (contact, QCstop);
+  /* Normal processes can't be started in a stopped state, see
+     Bug#30460.  */
+  CHECK_TYPE (NILP (tem), Qnull, tem);
 
   tem = Fplist_get (contact, QCconnection_type);
   if (EQ (tem, Qpty))
@@ -2233,7 +2236,7 @@ create_process (Lisp_Object process, char **new_argv, Lisp_Object current_dir)
   unblock_input ();
 
   if (pid < 0)
-    report_file_errno ("Doing vfork", Qnil, vfork_errno);
+    report_file_errno (CHILD_SETUP_ERROR_DESC, Qnil, vfork_errno);
   else
     {
       /* vfork succeeded.  */
@@ -8300,6 +8303,8 @@ returns non-`nil'.  */);
 	  "internal-default-interrupt-process");
   DEFSYM (Qinterrupt_process_functions, "interrupt-process-functions");
 
+  DEFSYM (Qnull, "null");
+
   defsubr (&Sprocessp);
   defsubr (&Sget_process);
   defsubr (&Sdelete_process);
diff --git a/src/puresize.h b/src/puresize.h
index f120a4b330..f5fad8b42b 100644
--- a/src/puresize.h
+++ b/src/puresize.h
@@ -77,7 +77,7 @@ INLINE_HEADER_BEGIN
 #define PURESIZE  (BASE_PURESIZE * PURESIZE_RATIO * PURESIZE_CHECKING_RATIO)
 #endif
 
-extern _Noreturn void pure_write_error (Lisp_Object);
+extern AVOID pure_write_error (Lisp_Object);
 
 extern EMACS_INT pure[];
 
diff --git a/src/regex-emacs.c b/src/regex-emacs.c
index 8dc6980502..4cb17037c2 100644
--- a/src/regex-emacs.c
+++ b/src/regex-emacs.c
@@ -3432,7 +3432,7 @@ static bool bcmp_translate (re_char *, re_char *, ptrdiff_t,
      {									\
        d = string2;							\
        dend = end_match_2;						\
-     }									\
+     }
 
 /* Test if at very beginning or at very end of the virtual concatenation
    of STRING1 and STRING2.  If only one string, it's STRING2.  */
diff --git a/src/search.c b/src/search.c
index a450e920b0..8a0f707b72 100644
--- a/src/search.c
+++ b/src/search.c
@@ -73,7 +73,7 @@ static EMACS_INT search_buffer (Lisp_Object, ptrdiff_t, ptrdiff_t,
 
 Lisp_Object re_match_object;
 
-static _Noreturn void
+static AVOID
 matcher_overflow (void)
 {
   error ("Stack overflow in regexp matcher");
@@ -1324,12 +1324,7 @@ search_buffer_non_re (Lisp_Object string, ptrdiff_t pos,
     }
   else
     {
-      /* Converting multibyte to single-byte.
-
-         ??? Perhaps this conversion should be done in a special way
-         by subtracting nonascii-insert-offset from each non-ASCII char,
-         so that only the multibyte chars which really correspond to
-         the chosen single-byte character set can possibly match.  */
+      /* Converting multibyte to single-byte.  */
       raw_pattern_size = SCHARS (string);
       raw_pattern_size_byte = SCHARS (string);
       raw_pattern = SAFE_ALLOCA (raw_pattern_size + 1);
@@ -3387,12 +3382,6 @@ syms_of_search (void)
   Fput (Qinvalid_regexp, Qerror_message,
 	build_pure_c_string ("Invalid regexp"));
 
-  last_thing_searched = Qnil;
-  staticpro (&last_thing_searched);
-
-  saved_last_thing_searched = Qnil;
-  staticpro (&saved_last_thing_searched);
-
   re_match_object = Qnil;
   staticpro (&re_match_object);
 
diff --git a/src/sound.c b/src/sound.c
index 2b8715010e..4ba826e82c 100644
--- a/src/sound.c
+++ b/src/sound.c
@@ -297,7 +297,7 @@ static int do_play_sound (const char *, unsigned long);
 #ifndef WINDOWSNT
 /* Like perror, but signals an error.  */
 
-static _Noreturn void
+static AVOID
 sound_perror (const char *msg)
 {
   int saved_errno = errno;
@@ -874,7 +874,7 @@ vox_write (struct sound_device *sd, const char *buffer, ptrdiff_t nbytes)
 #define DEFAULT_ALSA_SOUND_DEVICE "default"
 #endif
 
-static _Noreturn void
+static AVOID
 alsa_sound_perror (const char *msg, int err)
 {
   error ("%s: %s", msg, snd_strerror (err));
diff --git a/src/sysdep.c b/src/sysdep.c
index 57ea8220ca..bc88e70dcb 100644
--- a/src/sysdep.c
+++ b/src/sysdep.c
@@ -1805,7 +1805,7 @@ deliver_fatal_thread_signal (int sig)
   deliver_thread_signal (sig, handle_fatal_signal);
 }
 
-static _Noreturn void
+static AVOID
 handle_arith_signal (int sig)
 {
   pthread_sigmask (SIG_SETMASK, &empty_mask, 0);
diff --git a/src/systhread.h b/src/systhread.h
index a1d2746721..8070bcde75 100644
--- a/src/systhread.h
+++ b/src/systhread.h
@@ -21,12 +21,8 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include <stdbool.h>
 
-#ifndef __has_attribute
-# define __has_attribute(a) false
-#endif
-
-#if __has_attribute (__warn_unused_result__)
-# define ATTRIBUTE_WARN_UNUSED_RESULT __attribute__ ((__warn_unused_result__))
+#if __has_attribute (warn_unused_result)
+# define ATTRIBUTE_WARN_UNUSED_RESULT __attribute__ ((warn_unused_result))
 #else
 # define ATTRIBUTE_WARN_UNUSED_RESULT
 #endif
diff --git a/src/systime.h b/src/systime.h
index 9080cd2bba..125b2f1385 100644
--- a/src/systime.h
+++ b/src/systime.h
@@ -89,10 +89,11 @@ struct lisp_time
 /* defined in timefns.c */
 extern struct timeval make_timeval (struct timespec) ATTRIBUTE_CONST;
 extern Lisp_Object make_lisp_time (struct timespec);
+extern Lisp_Object timespec_to_lisp (struct timespec);
 extern bool list4_to_timespec (Lisp_Object, Lisp_Object, Lisp_Object,
 			       Lisp_Object, struct timespec *);
 extern struct timespec lisp_time_argument (Lisp_Object);
-extern _Noreturn void time_overflow (void);
+extern AVOID time_overflow (void);
 extern void init_timefns (void);
 extern void syms_of_timefns (void);
 
diff --git a/src/term.c b/src/term.c
index a492276c88..6a8fc2ee93 100644
--- a/src/term.c
+++ b/src/term.c
@@ -73,11 +73,10 @@ static void clear_tty_hooks (struct terminal *terminal);
 static void set_tty_hooks (struct terminal *terminal);
 static void dissociate_if_controlling_tty (int fd);
 static void delete_tty (struct terminal *);
-static _Noreturn void maybe_fatal (bool, struct terminal *,
-				   const char *, const char *, ...)
+static AVOID maybe_fatal (bool, struct terminal *, const char *, const char *,
+			  ...)
   ATTRIBUTE_FORMAT_PRINTF (3, 5) ATTRIBUTE_FORMAT_PRINTF (4, 5);
-static _Noreturn void vfatal (const char *str, va_list ap)
-  ATTRIBUTE_FORMAT_PRINTF (1, 0);
+static AVOID vfatal (const char *, va_list) ATTRIBUTE_FORMAT_PRINTF (1, 0);
 
 
 #define OUTPUT(tty, a)                                          \
@@ -3839,6 +3838,7 @@ clear_tty_hooks (struct terminal *terminal)
   terminal->update_begin_hook = 0;
   terminal->update_end_hook = 0;
   terminal->set_terminal_window_hook = 0;
+  terminal->defined_color_hook = 0;
   terminal->mouse_position_hook = 0;
   terminal->frame_rehighlight_hook = 0;
   terminal->frame_raise_lower_hook = 0;
@@ -3882,6 +3882,7 @@ set_tty_hooks (struct terminal *terminal)
   terminal->menu_show_hook = &tty_menu_show;
 #endif
   terminal->set_terminal_window_hook = &tty_set_terminal_window;
+  terminal->defined_color_hook = &tty_defined_color; /* xfaces.c */
   terminal->read_socket_hook = &tty_read_avail_input; /* keyboard.c */
   terminal->delete_frame_hook = &tty_free_frame_resources;
   terminal->delete_terminal_hook = &delete_tty;
diff --git a/src/termhooks.h b/src/termhooks.h
index a92b981110..f1827128f1 100644
--- a/src/termhooks.h
+++ b/src/termhooks.h
@@ -24,6 +24,7 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 /* Miscellanea.   */
 
 #include "lisp.h"
+#include "dispextern.h"
 #include "systime.h" /* for Time */
 
 struct glyph;
@@ -488,8 +489,40 @@ struct terminal
   void (*update_end_hook) (struct frame *);
   void (*set_terminal_window_hook) (struct frame *, int);
 
+  /* Decide if color named COLOR_NAME is valid for the display
+   associated with the frame F; if so, return the RGB values in
+   COLOR_DEF.  If ALLOC (and MAKEINDEX for NS), allocate a new
+   colormap cell.
+
+   If MAKEINDEX (on NS), set COLOR_DEF pixel to ARGB.  */
+  bool (*defined_color_hook) (struct frame *f, const char *color_name,
+                              Emacs_Color *color_def,
+                              bool alloc,
+                              bool makeIndex);
+
   /* Multi-frame and mouse support hooks.  */
 
+  /* Graphical window systems are expected to define all of the
+     following hooks with the possible exception of:
+
+   * query_colors
+   * activate_menubar_hook
+   * change_tool_bar_height_hook
+   * set_bitmap_icon_hook
+   * buffer_flipping_unblocked_hook
+
+   */
+
+  /* This hook is called to store the frame's background color into
+     BGCOLOR.  */
+  void (*query_frame_background_color) (struct frame *f, Emacs_Color *bgcolor);
+
+#if defined (HAVE_X_WINDOWS) || defined (HAVE_NTGUI)
+  /* On frame F, translate pixel colors to RGB values for the NCOLORS
+     colors in COLORS.  Use cached information, if available.  */
+
+  void (*query_colors) (struct frame *f, Emacs_Color *colors, int ncolors);
+#endif
   /* Return the current position of the mouse.
 
      Set *f to the frame the mouse is in, or zero if the mouse is in no
@@ -512,6 +545,12 @@ struct terminal
                                Lisp_Object *y,
                                Time *);
 
+  /* This hook is called to get the focus frame.  */
+  Lisp_Object (*get_focus_frame) (struct frame *f);
+
+  /* This hook is called to shift frame focus.  */
+  void (*focus_frame_hook) (struct frame *f, bool noactivate);
+
   /* When a frame's focus redirection is changed, this hook tells the
      window system code to re-decide where to put the highlight.  Under
      X, this means that Emacs lies about where the focus is.  */
@@ -529,19 +568,65 @@ struct terminal
      windows.  */
   void (*frame_raise_lower_hook) (struct frame *f, bool raise_flag);
 
+  /* This hook is called to make the frame F visible if VISIBLE is
+     true, or invisible otherwise. */
+  void (*frame_visible_invisible_hook) (struct frame *f, bool visible);
+
   /* If the value of the frame parameter changed, this hook is called.
      For example, if going from fullscreen to not fullscreen this hook
      may do something OS dependent, like extended window manager hints on X11.  */
   void (*fullscreen_hook) (struct frame *f);
 
+  /* This hook is called to iconify the frame.  */
+  void (*iconify_frame_hook) (struct frame *f);
+
+  /* This hook is called to change the size of frame F's native
+   (underlying) window.  If CHANGE_GRAVITY, change to top-left-corner
+   window gravity for this size change and subsequent size changes.
+   Otherwise we leave the window gravity unchanged.  */
+  void (*set_window_size_hook) (struct frame *f, bool change_gravity,
+                                int width, int height, bool pixelwise);
+
+  /* CHANGE_GRAVITY is 1 when calling from Fset_frame_position,
+   to really change the position, and 0 when calling from
+   *_make_frame_visible (in that case, XOFF and YOFF are the current
+   position values).  It is -1 when calling from gui_set_frame_parameters,
+   which means, do adjust for borders but don't change the gravity.  */
+
+  void (*set_frame_offset_hook) (struct frame *f, register int xoff,
+                                 register int yoff, int change_gravity);
+
+  /* This hook is called to set the frame's transparency.  */
+  void (*set_frame_alpha_hook) (struct frame *f);
+
+  /* This hook is called to set a new font for the frame.  */
+  Lisp_Object (*set_new_font_hook) (struct frame *f, Lisp_Object font_object,
+                                    int fontset);
+
+  /* This hook is called to set the GUI window icon of F using FILE.  */
+  bool (*set_bitmap_icon_hook) (struct frame *f, Lisp_Object file);
+
+  /* This hook is called to set the name of the GUI window of F by
+     redisplay unless another name was explicitly requested.  */
+  void (*implicit_set_name_hook) (struct frame *f, Lisp_Object arg,
+                                  Lisp_Object oldval);
+
   /* This hook is called to display menus.  */
   Lisp_Object (*menu_show_hook) (struct frame *f, int x, int y, int menuflags,
 				 Lisp_Object title, const char **error_name);
 
+#ifdef HAVE_EXT_MENU_BAR
+  /* This hook is called to activate the menu bar.  */
+  void (*activate_menubar_hook) (struct frame *f);
+#endif
+
   /* This hook is called to display popup dialog.  */
   Lisp_Object (*popup_dialog_hook) (struct frame *f, Lisp_Object header,
 				    Lisp_Object contents);
 
+  /* This hook is called to change the frame's (internal) tool-bar.  */
+  void (*change_tool_bar_height_hook) (struct frame *f, int height);
+
   /* Scroll bar hooks.  */
 
   /* The representation of scroll bars is determined by the code which
@@ -583,6 +668,11 @@ struct terminal
 					  int portion, int whole,
 					  int position);
 
+  /* Set the default scroll bar width on FRAME.  */
+  void (*set_scroll_bar_default_width_hook) (struct frame *frame);
+
+  /* Set the default scroll bar height on FRAME.  */
+  void (*set_scroll_bar_default_height_hook) (struct frame *frame);
 
   /* The following three hooks are used when we're doing a thorough
      redisplay of the frame.  We don't explicitly know which scroll bars
@@ -645,7 +735,21 @@ struct terminal
      while it runs.  */
   void (*buffer_flipping_unblocked_hook) (struct frame *);
 
+  /* Retrieve the string resource specified by NAME with CLASS from
+     database RDB. */
+  const char * (*get_string_resource_hook) (void *rdb,
+                                            const char *name,
+                                            const char *class);
 
+  /* Image hooks */
+#ifdef HAVE_WINDOW_SYSTEM
+  /* Free the pixmap PIXMAP on F.  */
+  void (*free_pixmap) (struct frame *f, Emacs_Pixmap pixmap);
+
+#endif
+
+  /* Deletion hooks */
+
   /* Called to delete the device-specific portions of a frame that is
      on this terminal device. */
   void (*delete_frame_hook) (struct frame *);
diff --git a/src/textprop.c b/src/textprop.c
index bb063d3eaa..ae42c44185 100644
--- a/src/textprop.c
+++ b/src/textprop.c
@@ -65,7 +65,7 @@ static Lisp_Object interval_insert_in_front_hooks;
 /* Signal a `text-read-only' error.  This function makes it easier
    to capture that error in GDB by putting a breakpoint on it.  */
 
-static _Noreturn void
+static AVOID
 text_read_only (Lisp_Object propval)
 {
   if (STRINGP (propval))
diff --git a/src/thread.c b/src/thread.c
index 670680f2b0..e2deadd7a8 100644
--- a/src/thread.c
+++ b/src/thread.c
@@ -35,7 +35,21 @@ union aligned_thread_state
 };
 verify (GCALIGNED (union aligned_thread_state));
 
-static union aligned_thread_state main_thread;
+static union aligned_thread_state main_thread
+  = {{
+      .header.size = PVECHEADERSIZE (PVEC_THREAD,
+				     PSEUDOVECSIZE (struct thread_state,
+						    event_object),
+				     VECSIZE (struct thread_state)),
+      .m_last_thing_searched = LISPSYM_INITIALLY (Qnil),
+      .m_saved_last_thing_searched = LISPSYM_INITIALLY (Qnil),
+      .name = LISPSYM_INITIALLY (Qnil),
+      .function = LISPSYM_INITIALLY (Qnil),
+      .result = LISPSYM_INITIALLY (Qnil),
+      .error_symbol = LISPSYM_INITIALLY (Qnil),
+      .error_data = LISPSYM_INITIALLY (Qnil),
+      .event_object = LISPSYM_INITIALLY (Qnil),
+    }};
 
 struct thread_state *current_thread = &main_thread.s;
 
@@ -261,19 +275,15 @@ NAME, if given, is used as the name of the mutex.  The name is
 informational only.  */)
   (Lisp_Object name)
 {
-  struct Lisp_Mutex *mutex;
-  Lisp_Object result;
-
   if (!NILP (name))
     CHECK_STRING (name);
 
-  mutex = ALLOCATE_PSEUDOVECTOR (struct Lisp_Mutex, name, PVEC_MUTEX);
-  memset ((char *) mutex + offsetof (struct Lisp_Mutex, mutex),
-	  0, sizeof (struct Lisp_Mutex) - offsetof (struct Lisp_Mutex,
-						    mutex));
+  struct Lisp_Mutex *mutex
+    = ALLOCATE_ZEROED_PSEUDOVECTOR (struct Lisp_Mutex, name, PVEC_MUTEX);
   mutex->name = name;
   lisp_mutex_init (&mutex->mutex);
 
+  Lisp_Object result;
   XSETMUTEX (result, mutex);
   return result;
 }
@@ -379,21 +389,17 @@ NAME, if given, is the name of this condition variable.  The name is
 informational only.  */)
   (Lisp_Object mutex, Lisp_Object name)
 {
-  struct Lisp_CondVar *condvar;
-  Lisp_Object result;
-
   CHECK_MUTEX (mutex);
   if (!NILP (name))
     CHECK_STRING (name);
 
-  condvar = ALLOCATE_PSEUDOVECTOR (struct Lisp_CondVar, name, PVEC_CONDVAR);
-  memset ((char *) condvar + offsetof (struct Lisp_CondVar, cond),
-	  0, sizeof (struct Lisp_CondVar) - offsetof (struct Lisp_CondVar,
-						      cond));
+  struct Lisp_CondVar *condvar
+    = ALLOCATE_ZEROED_PSEUDOVECTOR (struct Lisp_CondVar, name, PVEC_CONDVAR);
   condvar->mutex = mutex;
   condvar->name = name;
   sys_cond_init (&condvar->cond);
 
+  Lisp_Object result;
   XSETCONDVAR (result, condvar);
   return result;
 }
@@ -637,10 +643,8 @@ mark_one_thread (struct thread_state *thread)
       mark_object (tem);
     }
 
-  mark_object (thread->m_last_thing_searched);
-
-  if (!NILP (thread->m_saved_last_thing_searched))
-    mark_object (thread->m_saved_last_thing_searched);
+  /* No need to mark Lisp_Object members like m_last_thing_searched,
+     as mark_threads_callback does that by calling mark_object.  */
 }
 
 static void
@@ -792,12 +796,6 @@ When the function exits, the thread dies.
 If NAME is given, it must be a string; it names the new thread.  */)
   (Lisp_Object function, Lisp_Object name)
 {
-  sys_thread_t thr;
-  struct thread_state *new_thread;
-  Lisp_Object result;
-  const char *c_name = NULL;
-  size_t offset = offsetof (struct thread_state, m_stack_bottom);
-
   /* Can't start a thread in temacs.  */
   if (!initialized)
     emacs_abort ();
@@ -805,20 +803,13 @@ If NAME is given, it must be a string; it names the new thread.  */)
   if (!NILP (name))
     CHECK_STRING (name);
 
-  new_thread = ALLOCATE_PSEUDOVECTOR (struct thread_state, event_object,
-				      PVEC_THREAD);
-  memset ((char *) new_thread + offset, 0,
-	  sizeof (struct thread_state) - offset);
-
+  struct thread_state *new_thread
+    = ALLOCATE_ZEROED_PSEUDOVECTOR (struct thread_state, event_object,
+				    PVEC_THREAD);
   new_thread->function = function;
   new_thread->name = name;
-  new_thread->m_last_thing_searched = Qnil; /* copy from parent? */
-  new_thread->m_saved_last_thing_searched = Qnil;
+  /* Perhaps copy m_last_thing_searched from parent?  */
   new_thread->m_current_buffer = current_thread->m_current_buffer;
-  new_thread->result = Qnil;
-  new_thread->error_symbol = Qnil;
-  new_thread->error_data = Qnil;
-  new_thread->event_object = Qnil;
 
   new_thread->m_specpdl_size = 50;
   new_thread->m_specpdl = xmalloc ((1 + new_thread->m_specpdl_size)
@@ -833,9 +824,8 @@ If NAME is given, it must be a string; it names the new thread.  */)
   new_thread->next_thread = all_threads;
   all_threads = new_thread;
 
-  if (!NILP (name))
-    c_name = SSDATA (ENCODE_UTF_8 (name));
-
+  char const *c_name = !NILP (name) ? SSDATA (ENCODE_UTF_8 (name)) : NULL;
+  sys_thread_t thr;
   if (! sys_thread_create (&thr, c_name, run_thread, new_thread))
     {
       /* Restore the previous situation.  */
@@ -848,6 +838,7 @@ If NAME is given, it must be a string; it names the new thread.  */)
     }
 
   /* FIXME: race here where new thread might not be filled in?  */
+  Lisp_Object result;
   XSETTHREAD (result, new_thread);
   return result;
 }
@@ -1060,22 +1051,6 @@ thread_check_current_buffer (struct buffer *buffer)
 
 
 
-static void
-init_main_thread (void)
-{
-  main_thread.s.header.size
-    = PSEUDOVECSIZE (struct thread_state, event_object);
-  XSETPVECTYPE (&main_thread.s, PVEC_THREAD);
-  main_thread.s.m_last_thing_searched = Qnil;
-  main_thread.s.m_saved_last_thing_searched = Qnil;
-  main_thread.s.name = Qnil;
-  main_thread.s.function = Qnil;
-  main_thread.s.result = Qnil;
-  main_thread.s.error_symbol = Qnil;
-  main_thread.s.error_data = Qnil;
-  main_thread.s.event_object = Qnil;
-}
-
 bool
 main_thread_p (const void *ptr)
 {
@@ -1090,16 +1065,9 @@ in_current_thread (void)
   return sys_thread_equal (sys_thread_self (), current_thread->thread_id);
 }
 
-void
-init_threads_once (void)
-{
-  init_main_thread ();
-}
-
 void
 init_threads (void)
 {
-  init_main_thread ();
   sys_cond_init (&main_thread.s.thread_condvar);
   sys_mutex_init (&global_lock);
   sys_mutex_lock (&global_lock);
diff --git a/src/thread.h b/src/thread.h
index 0514669a87..498b9909c9 100644
--- a/src/thread.h
+++ b/src/thread.h
@@ -287,7 +287,6 @@ extern void finalize_one_mutex (struct Lisp_Mutex *);
 extern void finalize_one_condvar (struct Lisp_CondVar *);
 extern void maybe_reacquire_global_lock (void);
 
-extern void init_threads_once (void);
 extern void init_threads (void);
 extern void syms_of_threads (void);
 extern bool main_thread_p (const void *);
diff --git a/src/timefns.c b/src/timefns.c
index 514fa24f8b..7b5af6a5d2 100644
--- a/src/timefns.c
+++ b/src/timefns.c
@@ -172,7 +172,7 @@ emacs_localtime_rz (timezone_t tz, time_t const *t, struct tm *tm)
   return tm;
 }
 
-static _Noreturn void
+static AVOID
 invalid_time_zone_specification (Lisp_Object zone)
 {
   xsignal2 (Qerror, build_string ("Invalid time zone specification"), zone);
@@ -337,7 +337,7 @@ time_overflow (void)
   error ("Specified time is not representable");
 }
 
-static _Noreturn void
+static AVOID
 time_error (int err)
 {
   switch (err)
@@ -348,7 +348,7 @@ time_error (int err)
     }
 }
 
-static _Noreturn void
+static AVOID
 invalid_hz (Lisp_Object hz)
 {
   xsignal2 (Qerror, build_string ("Invalid time frequency"), hz);
@@ -528,7 +528,14 @@ make_lisp_time (struct timespec t)
 		    make_fixnum (ns / 1000), make_fixnum (ns % 1000 * 1000));
     }
   else
-    return Fcons (timespec_ticks (t), timespec_hz);
+    return timespec_to_lisp (t);
+}
+
+/* Return (TICKS . HZ) for time T.  */
+Lisp_Object
+timespec_to_lisp (struct timespec t)
+{
+  return Fcons (timespec_ticks (t), timespec_hz);
 }
 
 /* Convert T to a Lisp timestamp.  FORM specifies the timestamp format.  */
@@ -1481,10 +1488,11 @@ usage: (encode-time &optional TIME FORM &rest OBSOLESCENT-ARGUMENTS)  */)
       tm.tm_mon  = check_tm_member (XCAR (a), 1); a = XCDR (a);
       tm.tm_year = check_tm_member (XCAR (a), TM_YEAR_BASE); a = XCDR (a);
       a = XCDR (a);
-      if (SYMBOLP (XCAR (a)))
-	tm.tm_isdst = !NILP (XCAR (a));
+      Lisp_Object dstflag = XCAR (a);
       a = XCDR (a);
       zone = XCAR (a);
+      if (SYMBOLP (dstflag) && !FIXNUMP (zone) && !CONSP (zone))
+	tm.tm_isdst = !NILP (dstflag);
     }
   else if (nargs < 6)
     xsignal2 (Qwrong_number_of_arguments, Qencode_time, make_fixnum (nargs));
diff --git a/src/unexelf.c b/src/unexelf.c
index c63a8d03c2..6d19bf1fb9 100644
--- a/src/unexelf.c
+++ b/src/unexelf.c
@@ -304,6 +304,7 @@ unexec (const char *new_name, const char *old_name)
 	      || seg->p_vaddr > old_bss_seg->p_vaddr))
 	old_bss_seg = seg;
     }
+  eassume (old_bss_seg);
 
   /* Note that old_bss_addr may be lower than the first bss section
      address, since the section may need aligning.  */
diff --git a/src/w32.c b/src/w32.c
index 082a66b738..833ff4c7e4 100644
--- a/src/w32.c
+++ b/src/w32.c
@@ -2003,6 +2003,13 @@ getloadavg (double loadavg[], int nelem)
       loadavg[elem] = avg;
     }
 
+  /* Always return at least one element, otherwise load-average
+     returns nil, and Lisp programs might decide we cannot measure
+     system load.  For example, jit-lock-stealth-load's defcustom
+     might decide that feature is "unsupported".  */
+  if (elem == 0)
+    loadavg[elem++] = 0.09;	/* < display-time-load-average-threshold */
+
   return elem;
 }
 
@@ -2644,7 +2651,7 @@ unsetenv (const char *name)
   /* It is safe to use 'alloca' with 32K size, since the stack is at
      least 2MB, and we set it to 8MB in the link command line.  */
   var = alloca (name_len + 2);
-  strncpy (var, name, name_len);
+  memcpy (var, name, name_len);
   var[name_len++] = '=';
   var[name_len] = '\0';
   return _putenv (var);
@@ -6054,7 +6061,7 @@ readlink (const char *name, char *buf, size_t buf_size)
 	  lname_size = strlen (resolved) + 1;
 	  if (lname_size <= buf_size)
 	    size_to_copy = lname_size;
-	  strncpy (buf, resolved, size_to_copy);
+	  memcpy (buf, resolved, size_to_copy);
 	  /* Success!  */
 	  retval = size_to_copy;
 	}
diff --git a/src/w32console.c b/src/w32console.c
index df232ecd1a..8575c930a8 100644
--- a/src/w32console.c
+++ b/src/w32console.c
@@ -30,6 +30,7 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include "lisp.h"
 #include "coding.h"
 #include "termchar.h"	/* for FRAME_TTY */
+#include "dispextern.h"	/* for tty_defined_color */
 #include "menu.h"	/* for tty_menu_show */
 #include "w32term.h"
 #include "w32common.h"	/* for os_subtype */
@@ -673,6 +674,7 @@ initialize_w32_display (struct terminal *term, int *width, int *height)
   term->update_begin_hook	= w32con_update_begin;
   term->update_end_hook		= w32con_update_end;
 
+  term->defined_color_hook = &tty_defined_color; /* xfaces.c */
   term->read_socket_hook = w32_console_read_socket;
   term->mouse_position_hook = w32_console_mouse_position;
   term->menu_show_hook = tty_menu_show;
diff --git a/src/w32fns.c b/src/w32fns.c
index af82b46305..bb74fcc164 100644
--- a/src/w32fns.c
+++ b/src/w32fns.c
@@ -288,6 +288,8 @@ typedef BOOL (WINAPI *IsDebuggerPresent_Proc) (void);
 /* stdin, from w32console.c */
 extern HANDLE keyboard_handle;
 
+static struct w32_display_info *w32_display_info_for_name (Lisp_Object);
+
 /* Let the user specify a display with a frame.
    nil stands for the selected frame--or, if that is not a w32 frame,
    the first display on the list.  */
@@ -314,7 +316,7 @@ check_x_display_info (Lisp_Object object)
       return t->display_info.w32;
     }
   else if (STRINGP (object))
-    return x_display_info_for_name (object);
+    return w32_display_info_for_name (object);
   else
     {
       struct frame *f;
@@ -331,7 +333,7 @@ check_x_display_info (Lisp_Object object)
    It could be the frame's main window or an icon window.  */
 
 struct frame *
-x_window_to_frame (struct w32_display_info *dpyinfo, HWND wdesc)
+w32_window_to_frame (struct w32_display_info *dpyinfo, HWND wdesc)
 {
   Lisp_Object tail, frame;
   struct frame *f;
@@ -355,16 +357,16 @@ static void my_create_window (struct frame *);
 static void my_create_tip_window (struct frame *);
 
 /* TODO: Native Input Method support; see x_create_im.  */
-void x_set_foreground_color (struct frame *, Lisp_Object, Lisp_Object);
-void x_set_background_color (struct frame *, Lisp_Object, Lisp_Object);
-void x_set_mouse_color (struct frame *, Lisp_Object, Lisp_Object);
-void x_set_cursor_color (struct frame *, Lisp_Object, Lisp_Object);
-void x_set_border_color (struct frame *, Lisp_Object, Lisp_Object);
-void x_set_cursor_type (struct frame *, Lisp_Object, Lisp_Object);
-void x_set_icon_type (struct frame *, Lisp_Object, Lisp_Object);
-void x_set_icon_name (struct frame *, Lisp_Object, Lisp_Object);
-void x_explicitly_set_name (struct frame *, Lisp_Object, Lisp_Object);
-void x_set_title (struct frame *, Lisp_Object, Lisp_Object);
+static void w32_set_foreground_color (struct frame *, Lisp_Object, Lisp_Object);
+static void w32_set_background_color (struct frame *, Lisp_Object, Lisp_Object);
+static void w32_set_mouse_color (struct frame *, Lisp_Object, Lisp_Object);
+static void w32_set_border_color (struct frame *, Lisp_Object, Lisp_Object);
+static void w32_set_cursor_color (struct frame *, Lisp_Object, Lisp_Object);
+static void w32_set_cursor_type (struct frame *, Lisp_Object, Lisp_Object);
+static void w32_set_icon_type (struct frame *, Lisp_Object, Lisp_Object);
+static void w32_set_icon_name (struct frame *, Lisp_Object, Lisp_Object);
+static void w32_explicitly_set_name (struct frame *, Lisp_Object, Lisp_Object);
+static void w32_set_title (struct frame *, Lisp_Object, Lisp_Object);
 
 
 /* Store the screen positions of frame F into XPTR and YPTR.
@@ -372,7 +374,7 @@ void x_set_title (struct frame *, Lisp_Object, Lisp_Object);
    not Emacs's own window.  */
 
 void
-x_real_positions (struct frame *f, int *xptr, int *yptr)
+w32_real_positions (struct frame *f, int *xptr, int *yptr)
 {
   RECT rect;
 
@@ -1171,9 +1173,9 @@ gamma_correct (struct frame *f, COLORREF *color)
    the selected frame; if so, return the rgb values in COLOR_DEF.
    If ALLOC is nonzero, allocate a new colormap cell.  */
 
-int
-w32_defined_color (struct frame *f, const char *color, XColor *color_def,
-		   bool alloc_p)
+bool
+w32_defined_color (struct frame *f, const char *color, Emacs_Color *color_def,
+		   bool alloc_p, bool _makeIndex)
 {
   register Lisp_Object tem;
   COLORREF w32_color_ref;
@@ -1244,9 +1246,9 @@ w32_defined_color (struct frame *f, const char *color, XColor *color_def,
    ARG says.  */
 
 static int
-x_decode_color (struct frame *f, Lisp_Object arg, int def)
+w32_decode_color (struct frame *f, Lisp_Object arg, int def)
 {
-  XColor cdef;
+  Emacs_Color cdef;
 
   CHECK_STRING (arg);
 
@@ -1260,7 +1262,7 @@ x_decode_color (struct frame *f, Lisp_Object arg, int def)
 
   /* w32_defined_color is responsible for coping with failures
      by looking for a near-miss.  */
-  if (w32_defined_color (f, SSDATA (arg), &cdef, true))
+  if (w32_defined_color (f, SSDATA (arg), &cdef, true, false))
     return cdef.pixel;
 
   /* defined_color failed; return an ultimate default.  */
@@ -1269,7 +1271,7 @@ x_decode_color (struct frame *f, Lisp_Object arg, int def)
 
 
 
-/* Functions called only from `x_set_frame_param'
+/* Functions called only from `gui_set_frame_parameters'
    to set individual parameters.
 
    If FRAME_W32_WINDOW (f) is 0,
@@ -1277,13 +1279,13 @@ x_decode_color (struct frame *f, Lisp_Object arg, int def)
    In that case, just record the parameter's new value
    in the standard place; do not attempt to change the window.  */
 
-void
-x_set_foreground_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+static void
+w32_set_foreground_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   struct w32_output *x = f->output_data.w32;
   PIX_TYPE fg, old_fg;
 
-  fg = x_decode_color (f, arg, BLACK_PIX_DEFAULT (f));
+  fg = w32_decode_color (f, arg, BLACK_PIX_DEFAULT (f));
   old_fg = FRAME_FOREGROUND_PIXEL (f);
   FRAME_FOREGROUND_PIXEL (f) = fg;
 
@@ -1301,11 +1303,11 @@ x_set_foreground_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
     }
 }
 
-void
-x_set_background_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+static void
+w32_set_background_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   FRAME_BACKGROUND_PIXEL (f)
-    = x_decode_color (f, arg, WHITE_PIX_DEFAULT (f));
+    = w32_decode_color (f, arg, WHITE_PIX_DEFAULT (f));
 
   if (FRAME_W32_WINDOW (f) != 0)
     {
@@ -1319,8 +1321,8 @@ x_set_background_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
     }
 }
 
-void
-x_set_mouse_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+static void
+w32_set_mouse_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
 #if 0
   Cursor cursor, nontext_cursor, mode_cursor, hand_cursor;
@@ -1330,7 +1332,7 @@ x_set_mouse_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 
   if (!EQ (Qnil, arg))
     f->output_data.w32->mouse_pixel
-      = x_decode_color (f, arg, BLACK_PIX_DEFAULT (f));
+      = w32_decode_color (f, arg, BLACK_PIX_DEFAULT (f));
   mask_color = FRAME_BACKGROUND_PIXEL (f);
 
   /* Don't let pointers be invisible.  */
@@ -1479,18 +1481,18 @@ x_set_mouse_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 #endif /* TODO */
 }
 
-void
-x_set_cursor_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+static void
+w32_set_cursor_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   unsigned long fore_pixel, pixel;
 
   if (!NILP (Vx_cursor_fore_pixel))
-    fore_pixel = x_decode_color (f, Vx_cursor_fore_pixel,
+    fore_pixel = w32_decode_color (f, Vx_cursor_fore_pixel,
 				 WHITE_PIX_DEFAULT (f));
   else
     fore_pixel = FRAME_BACKGROUND_PIXEL (f);
 
-  pixel = x_decode_color (f, arg, BLACK_PIX_DEFAULT (f));
+  pixel = w32_decode_color (f, arg, BLACK_PIX_DEFAULT (f));
 
   /* Make sure that the cursor color differs from the background color.  */
   if (pixel == FRAME_BACKGROUND_PIXEL (f))
@@ -1514,8 +1516,8 @@ x_set_cursor_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 
       if (FRAME_VISIBLE_P (f))
 	{
-	  x_update_cursor (f, 0);
-	  x_update_cursor (f, 1);
+	  gui_update_cursor (f, 0);
+	  gui_update_cursor (f, 1);
 	}
     }
 
@@ -1527,7 +1529,7 @@ x_set_cursor_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
    F has a window.  */
 
 static void
-x_set_border_pixel (struct frame *f, int pix)
+w32_set_border_pixel (struct frame *f, int pix)
 {
 
   f->output_data.w32->border_pixel = pix;
@@ -1545,26 +1547,26 @@ x_set_border_pixel (struct frame *f, int pix)
    Note that this does not fully take effect if done before
    F has a window; it must be redone when the window is created.  */
 
-void
-x_set_border_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+static void
+w32_set_border_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   int pix;
 
   CHECK_STRING (arg);
-  pix = x_decode_color (f, arg, BLACK_PIX_DEFAULT (f));
-  x_set_border_pixel (f, pix);
+  pix = w32_decode_color (f, arg, BLACK_PIX_DEFAULT (f));
+  w32_set_border_pixel (f, pix);
   update_face_from_frame_parameter (f, Qborder_color, arg);
 }
 
 
-void
-x_set_cursor_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+static void
+w32_set_cursor_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   set_frame_cursor_types (f, arg);
 }
 
-void
-x_set_icon_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+static void
+w32_set_icon_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   bool result;
 
@@ -1580,7 +1582,7 @@ x_set_icon_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 
   block_input ();
 
-  result = x_bitmap_icon (f, arg);
+  result = FRAME_TERMINAL (f)->set_bitmap_icon_hook (f, arg);
   if (result)
     {
       unblock_input ();
@@ -1590,8 +1592,8 @@ x_set_icon_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
   unblock_input ();
 }
 
-void
-x_set_icon_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+static void
+w32_set_icon_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   if (STRINGP (arg))
     {
@@ -1638,13 +1640,13 @@ x_set_icon_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 }
 
 /**
- * x_clear_under_internal_border:
+ * w32_clear_under_internal_border:
  *
  * Clear area of frame F's internal border.  If the internal border face
  * of F has been specified (is not null), fill the area with that face.
  */
 void
-x_clear_under_internal_border (struct frame *f)
+w32_clear_under_internal_border (struct frame *f)
 {
   int border = FRAME_INTERNAL_BORDER_WIDTH (f);
 
@@ -1685,13 +1687,13 @@ x_clear_under_internal_border (struct frame *f)
 
 
 /**
- * x_set_internal_border_width:
+ * w32_set_internal_border_width:
  *
  * Set width of frame F's internal border to ARG pixels.  ARG < 0 is
  * treated like ARG = 0.
  */
-void
-x_set_internal_border_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+static void
+w32_set_internal_border_width (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
   int border;
 
@@ -1702,27 +1704,27 @@ x_set_internal_border_width (struct frame *f, Lisp_Object arg, Lisp_Object oldva
     {
       f->internal_border_width = border;
 
-      if (FRAME_X_WINDOW (f) != 0)
+      if (FRAME_NATIVE_WINDOW (f) != 0)
 	{
 	  adjust_frame_size (f, -1, -1, 3, false, Qinternal_border_width);
 
 	  if (FRAME_VISIBLE_P (f))
-	    x_clear_under_internal_border (f);
+	    w32_clear_under_internal_border (f);
 	}
     }
 }
 
 
 /**
- * x_set_menu_bar_lines:
+ * w32_set_menu_bar_lines:
  *
  * Set number of lines of frame F's menu bar to VALUE.  An integer
  * greater zero specifies 1 line and turns the menu bar on if it was off
  * before.  Any other value specifies 0 lines and turns the menu bar off
  * if it was on before.
  */
-void
-x_set_menu_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
+static void
+w32_set_menu_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
 {
   /* Right now, menu bars don't work properly in minibuf-only frames;
      most of the commands try to apply themselves to the minibuffer
@@ -1761,7 +1763,7 @@ x_set_menu_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
 	    }
 
 	  if (FRAME_W32_WINDOW (f))
-	    x_clear_under_internal_border (f);
+	    w32_clear_under_internal_border (f);
 
 	  /* Don't store anything but 1 or 0 in the parameter.  */
 	  store_frame_param (f, Qmenu_bar_lines, make_fixnum (new ? 1 : 0));
@@ -1777,8 +1779,8 @@ x_set_menu_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
    height.  By design, the frame's height doesn't change (but maybe it
    should if we don't get enough space otherwise).  */
 
-void
-x_set_tool_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
+static void
+w32_set_tool_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
 {
   int nlines;
 
@@ -1792,13 +1794,13 @@ x_set_tool_bar_lines (struct frame *f, Lisp_Object value, Lisp_Object oldval)
   else
     nlines = 0;
 
-  x_change_tool_bar_height (f, nlines * FRAME_LINE_HEIGHT (f));
+  w32_change_tool_bar_height (f, nlines * FRAME_LINE_HEIGHT (f));
 }
 
 
 /* Set the pixel height of the tool bar of frame F to HEIGHT.  */
 void
-x_change_tool_bar_height (struct frame *f, int height)
+w32_change_tool_bar_height (struct frame *f, int height)
 {
   int unit = FRAME_LINE_HEIGHT (f);
   int old_height = FRAME_TOOL_BAR_HEIGHT (f);
@@ -1849,7 +1851,7 @@ x_change_tool_bar_height (struct frame *f, int height)
   adjust_frame_glyphs (f);
   SET_FRAME_GARBAGED (f);
   if (FRAME_W32_WINDOW (f))
-    x_clear_under_internal_border (f);
+    w32_clear_under_internal_border (f);
 }
 
 static void
@@ -1909,7 +1911,7 @@ w32_set_title_bar_text (struct frame *f, Lisp_Object name)
        F->explicit_name is set, ignore the new name; otherwise, set it.  */
 
 static void
-x_set_name (struct frame *f, Lisp_Object name, bool explicit)
+w32_set_name (struct frame *f, Lisp_Object name, bool explicit)
 {
   /* Make sure that requests from lisp code override requests from
      Emacs redisplay code.  */
@@ -1955,26 +1957,26 @@ x_set_name (struct frame *f, Lisp_Object name, bool explicit)
 /* This function should be called when the user's lisp code has
    specified a name for the frame; the name will override any set by the
    redisplay code.  */
-void
-x_explicitly_set_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+static void
+w32_explicitly_set_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
-  x_set_name (f, arg, true);
+  w32_set_name (f, arg, true);
 }
 
 /* This function should be called by Emacs redisplay code to set the
    name; names set this way will never override names set by the user's
    lisp code.  */
 void
-x_implicitly_set_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
+w32_implicitly_set_name (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 {
-  x_set_name (f, arg, false);
+  w32_set_name (f, arg, false);
 }
 
 /* Change the title of frame F to NAME.
    If NAME is nil, use the frame name as the title.  */
 
-void
-x_set_title (struct frame *f, Lisp_Object name, Lisp_Object old_name)
+static void
+w32_set_title (struct frame *f, Lisp_Object name, Lisp_Object old_name)
 {
   /* Don't change the title if it's already NAME.  */
   if (EQ (name, f->title))
@@ -1991,7 +1993,7 @@ x_set_title (struct frame *f, Lisp_Object name, Lisp_Object old_name)
 }
 
 void
-x_set_scroll_bar_default_width (struct frame *f)
+w32_set_scroll_bar_default_width (struct frame *f)
 {
   int unit = FRAME_COLUMN_WIDTH (f);
 
@@ -2002,7 +2004,7 @@ x_set_scroll_bar_default_width (struct frame *f)
 
 
 void
-x_set_scroll_bar_default_height (struct frame *f)
+w32_set_scroll_bar_default_height (struct frame *f)
 {
   int unit = FRAME_LINE_HEIGHT (f);
 
@@ -2012,7 +2014,7 @@ x_set_scroll_bar_default_height (struct frame *f)
 }
 
 /**
- * x_set_undecorated:
+ * w32_set_undecorated:
  *
  * Set frame F's `undecorated' parameter.  If non-nil, F's window-system
  * window is drawn without decorations, title, minimize/maximize boxes
@@ -2024,7 +2026,7 @@ x_set_scroll_bar_default_height (struct frame *f)
  * Some window managers may not honor this parameter.
  */
 static void
-x_set_undecorated (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+w32_set_undecorated (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   HWND hwnd = FRAME_W32_WINDOW (f);
   DWORD dwStyle = GetWindowLong (hwnd, GWL_STYLE);
@@ -2055,7 +2057,7 @@ x_set_undecorated (struct frame *f, Lisp_Object new_value, Lisp_Object old_value
 }
 
 /**
- * x_set_parent_frame:
+ * w32_set_parent_frame:
  *
  * Set frame F's `parent-frame' parameter.  If non-nil, make F a child
  * frame of the frame specified by that parameter.  Technically, this
@@ -2083,7 +2085,7 @@ x_set_undecorated (struct frame *f, Lisp_Object new_value, Lisp_Object old_value
  * Some window managers may not honor this parameter.
  */
 static void
-x_set_parent_frame (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+w32_set_parent_frame (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   struct frame *p = NULL;
 
@@ -2117,7 +2119,7 @@ x_set_parent_frame (struct frame *f, Lisp_Object new_value, Lisp_Object old_valu
 }
 
 /**
- * x_set_skip_taskbar:
+ * w32_set_skip_taskbar:
  *
  * Set frame F's `skip-taskbar' parameter.  If non-nil, this should
  * remove F's icon from the taskbar associated with the display of F's
@@ -2128,7 +2130,7 @@ x_set_parent_frame (struct frame *f, Lisp_Object new_value, Lisp_Object old_valu
  * Some window managers may not honor this parameter.
  */
 static void
-x_set_skip_taskbar (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+w32_set_skip_taskbar (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   if (!EQ (new_value, old_value))
     {
@@ -2151,7 +2153,7 @@ x_set_skip_taskbar (struct frame *f, Lisp_Object new_value, Lisp_Object old_valu
 }
 
 /**
- * x_set_no_focus_on_map:
+ * w32_set_no_focus_on_map:
  *
  * Set frame F's `no-focus-on-map' parameter which, if non-nil, means
  * that F's window-system window does not want to receive input focus
@@ -2162,14 +2164,14 @@ x_set_skip_taskbar (struct frame *f, Lisp_Object new_value, Lisp_Object old_valu
  * Some window managers may not honor this parameter.
  */
 static void
-x_set_no_focus_on_map (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+w32_set_no_focus_on_map (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   if (!EQ (new_value, old_value))
     FRAME_NO_FOCUS_ON_MAP (f) = !NILP (new_value);
 }
 
 /**
- * x_set_no_accept_focus:
+ * w32_set_no_accept_focus:
  *
  * Set frame F's `no-accept-focus' parameter which, if non-nil, hints
  * that F's window-system window does not want to receive input focus
@@ -2181,14 +2183,14 @@ x_set_no_focus_on_map (struct frame *f, Lisp_Object new_value, Lisp_Object old_v
  * Some window managers may not honor this parameter.
  */
 static void
-x_set_no_accept_focus (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+w32_set_no_accept_focus (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   if (!EQ (new_value, old_value))
     FRAME_NO_ACCEPT_FOCUS (f) = !NILP (new_value);
 }
 
 /**
- * x_set_z_group:
+ * w32_set_z_group:
  *
  * Set frame F's `z-group' parameter.  If `above', F's window-system
  * window is displayed above all windows that do not have the `above'
@@ -2206,7 +2208,7 @@ x_set_no_accept_focus (struct frame *f, Lisp_Object new_value, Lisp_Object old_v
  * progress.
  */
 static void
-x_set_z_group (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
+w32_set_z_group (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 {
   HWND hwnd = FRAME_W32_WINDOW (f);
 
@@ -2245,15 +2247,15 @@ x_set_z_group (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
 
 /* Subroutines for creating a frame.  */
 
-Cursor w32_load_cursor (LPCTSTR);
+HCURSOR w32_load_cursor (LPCTSTR);
 
-Cursor
+HCURSOR
 w32_load_cursor (LPCTSTR name)
 {
   /* Try first to load cursor from application resource.  */
-  Cursor cursor = LoadImage ((HINSTANCE) GetModuleHandle (NULL),
-			     name, IMAGE_CURSOR, 0, 0,
-			     LR_DEFAULTCOLOR | LR_DEFAULTSIZE | LR_SHARED);
+  HCURSOR cursor = LoadImage ((HINSTANCE) GetModuleHandle (NULL),
+                              name, IMAGE_CURSOR, 0, 0,
+                              LR_DEFAULTCOLOR | LR_DEFAULTSIZE | LR_SHARED);
   if (!cursor)
     {
       /* Then try to load a shared predefined cursor.  */
@@ -3061,7 +3063,7 @@ w32_get_modifiers (void)
    and window input.  */
 
 static int
-construct_console_modifiers (void)
+w32_construct_console_modifiers (void)
 {
   int mods;
 
@@ -3087,7 +3089,7 @@ w32_get_key_modifiers (unsigned int wparam, unsigned int lparam)
   int mods;
 
   /* Convert to emacs modifiers.  */
-  mods = w32_kbd_mods_to_emacs (construct_console_modifiers (), wparam);
+  mods = w32_kbd_mods_to_emacs (w32_construct_console_modifiers (), wparam);
 
   return mods;
 }
@@ -3719,7 +3721,7 @@ deliver_wm_chars (int do_translate, HWND hwnd, UINT msg, UINT wParam,
   if (count)
     {
       W32Msg wmsg;
-      DWORD console_modifiers = construct_console_modifiers ();
+      DWORD console_modifiers = w32_construct_console_modifiers ();
       int *b = buf, strip_ExtraMods = 1, hairy = 0;
       const char *type_CtrlAlt = NULL;
 
@@ -4018,7 +4020,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
   int windows_translate;
   int key;
 
-  /* Note that it is okay to call x_window_to_frame, even though we are
+  /* Note that it is okay to call w32_window_to_frame, even though we are
      not running in the main lisp thread, because frame deletion
      requires the lisp thread to synchronize with this thread.  Thus, if
      a frame struct is returned, it can be used without concern that the
@@ -4037,7 +4039,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
   switch (msg)
     {
     case WM_ERASEBKGND:
-      f = x_window_to_frame (dpyinfo, hwnd);
+      f = w32_window_to_frame (dpyinfo, hwnd);
       if (f)
 	{
 	  HDC hdc = get_frame_dc (f);
@@ -4057,7 +4059,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
       /* ignore our own changes */
       if ((HWND)wParam != hwnd)
 	{
-	  f = x_window_to_frame (dpyinfo, hwnd);
+	  f = w32_window_to_frame (dpyinfo, hwnd);
 	  if (f)
 	    /* get_frame_dc will realize our palette and force all
 	       frames to be redrawn if needed. */
@@ -4070,7 +4072,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 	RECT update_rect;
 	memset (&update_rect, 0, sizeof (update_rect));
 
-	f = x_window_to_frame (dpyinfo, hwnd);
+	f = w32_window_to_frame (dpyinfo, hwnd);
 	if (f == 0)
 	  {
 	    DebPrint (("WM_PAINT received for unknown window %p\n", hwnd));
@@ -4351,7 +4353,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 	  /* If not defined as a function key, change it to a WM_CHAR message.  */
 	  if (wParam > 255 || !lispy_function_keys[wParam])
 	    {
-	      DWORD modifiers = construct_console_modifiers ();
+	      DWORD modifiers = w32_construct_console_modifiers ();
 
 	      if (!NILP (Vw32_recognize_altgr)
 		  && modifier_set (VK_LCONTROL) && modifier_set (VK_RMENU))
@@ -4522,7 +4524,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 	     careful not to move the IME window if the window
 	     described by W was deleted, as indicated by its buffer
 	     field being reset to nil.  */
-	  f = x_window_to_frame (dpyinfo, hwnd);
+	  f = w32_window_to_frame (dpyinfo, hwnd);
 	  if (!(f && FRAME_LIVE_P (f)))
 	    goto dflt;
 	  w = XWINDOW (FRAME_SELECTED_WINDOW (f));
@@ -4698,7 +4700,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 	int button;
 
 	/* Ignore middle and extra buttons as long as the menu is active.  */
-	f = x_window_to_frame (dpyinfo, hwnd);
+	f = w32_window_to_frame (dpyinfo, hwnd);
 	if (f && f->output_data.w32->menubar_active)
 	  return 0;
 
@@ -4740,7 +4742,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
       return (msg == WM_XBUTTONDOWN || msg == WM_XBUTTONUP);
 
     case WM_MOUSEMOVE:
-      f = x_window_to_frame (dpyinfo, hwnd);
+      f = w32_window_to_frame (dpyinfo, hwnd);
       if (f)
 	{
 	  /* Ignore mouse movements as long as the menu is active.
@@ -4878,7 +4880,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 	{
 	  KillTimer (hwnd, menu_free_timer);
 	  menu_free_timer = 0;
-	  f = x_window_to_frame (dpyinfo, hwnd);
+	  f = w32_window_to_frame (dpyinfo, hwnd);
 	  /* If a popup menu is active, don't wipe its strings.  */
 	  if (menubar_in_use
 	      && current_popup_menu == NULL)
@@ -4920,7 +4922,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 	 this (there is no possibility of confusion with real menubar
 	 being active).  */
 
-      f = x_window_to_frame (dpyinfo, hwnd);
+      f = w32_window_to_frame (dpyinfo, hwnd);
       if (f
 	  && (f->output_data.w32->menubar_active
 	      /* We can receive this message even in the absence of a
@@ -4945,7 +4947,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
       }
 
     case WM_EXITMENULOOP:
-      f = x_window_to_frame (dpyinfo, hwnd);
+      f = w32_window_to_frame (dpyinfo, hwnd);
 
       /* If a menu is still active, check again after a short delay,
 	 since Windows often (always?) sends the WM_EXITMENULOOP
@@ -4976,7 +4978,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
       return 0;
 
     case WM_MEASUREITEM:
-      f = x_window_to_frame (dpyinfo, hwnd);
+      f = w32_window_to_frame (dpyinfo, hwnd);
       if (f)
 	{
 	  MEASUREITEMSTRUCT * pMis = (MEASUREITEMSTRUCT *) lParam;
@@ -5022,7 +5024,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
       return 0;
 
     case WM_DRAWITEM:
-      f = x_window_to_frame (dpyinfo, hwnd);
+      f = w32_window_to_frame (dpyinfo, hwnd);
       if (f)
 	{
 	  DRAWITEMSTRUCT * pDis = (DRAWITEMSTRUCT *) lParam;
@@ -5083,7 +5085,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 	 user to click anywhere without changing point (or worse!).
 	 Don't eat mouse clicks on scrollbars though!!  */
 
-      if ((f = x_window_to_frame (dpyinfo, hwnd))
+      if ((f = w32_window_to_frame (dpyinfo, hwnd))
 	  && FRAME_NO_ACCEPT_FOCUS (f)
 	  /* Ignore child frames, they don't accept focus anyway.  */
 	  && !FRAME_PARENT_FRAME (f))
@@ -5132,7 +5134,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
       goto command;
     case WM_COMMAND:
       menubar_in_use = 0;
-      f = x_window_to_frame (dpyinfo, hwnd);
+      f = w32_window_to_frame (dpyinfo, hwnd);
       if (f && HIWORD (wParam) == 0)
 	{
 	  if (menu_free_timer)
@@ -5197,7 +5199,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
     case WM_SETCURSOR:
       if (LOWORD (lParam) == HTCLIENT)
 	{
-	  f = x_window_to_frame (dpyinfo, hwnd);
+	  f = w32_window_to_frame (dpyinfo, hwnd);
 	  if (f)
 	    {
 	      if (f->output_data.w32->hourglass_p
@@ -5215,8 +5217,8 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 
     case WM_EMACS_SETCURSOR:
       {
-	Cursor cursor = (Cursor) wParam;
-	f = x_window_to_frame (dpyinfo, hwnd);
+	HCURSOR cursor = (HCURSOR) wParam;
+	f = w32_window_to_frame (dpyinfo, hwnd);
 	if (f && cursor)
 	  {
 	    f->output_data.w32->current_cursor = cursor;
@@ -5355,7 +5357,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 
 	/* Use menubar_active to indicate that WM_INITMENU is from
 	   TrackPopupMenu below, and should be ignored.  */
-	f = x_window_to_frame (dpyinfo, hwnd);
+	f = w32_window_to_frame (dpyinfo, hwnd);
 	if (f)
 	  f->output_data.w32->menubar_active = 1;
 
@@ -5413,10 +5415,12 @@ my_create_window (struct frame * f)
   Lisp_Object left, top;
   struct w32_display_info *dpyinfo = &one_w32_display_info;
 
-  /* When called with RES_TYPE_NUMBER, x_get_arg will return zero for
-     anything that is not a number and is not Qunbound.  */
-  left = x_get_arg (dpyinfo, Qnil, Qleft, "left", "Left", RES_TYPE_NUMBER);
-  top = x_get_arg (dpyinfo, Qnil, Qtop, "top", "Top", RES_TYPE_NUMBER);
+  /* When called with RES_TYPE_NUMBER, gui_display_get_arg will return
+     zero for anything that is not a number and is not Qunbound.  */
+  left = gui_display_get_arg (dpyinfo, Qnil, Qleft, "left", "Left",
+                              RES_TYPE_NUMBER);
+  top = gui_display_get_arg (dpyinfo, Qnil, Qtop, "top", "Top",
+                             RES_TYPE_NUMBER);
   if (EQ (left, Qunbound))
     coords[0] = CW_USEDEFAULT;
   else
@@ -5496,7 +5500,7 @@ w32_window (struct frame *f, long window_prompting, bool minibuffer_only)
 
   validate_x_resource_name ();
 
-  /* x_set_name normally ignores requests to set the name if the
+  /* w32_set_name normally ignores requests to set the name if the
      requested name is the same as the current name.  This is the one
      place where that assumption isn't correct; f->name is set, but
      the server hasn't been told.  */
@@ -5507,7 +5511,7 @@ w32_window (struct frame *f, long window_prompting, bool minibuffer_only)
     f->explicit_name = 0;
     name = f->name;
     fset_name (f, Qnil);
-    x_set_name (f, name, explicit);
+    w32_set_name (f, name, explicit);
   }
 
   unblock_input ();
@@ -5525,15 +5529,17 @@ w32_window (struct frame *f, long window_prompting, bool minibuffer_only)
    well.  */
 
 static void
-x_icon (struct frame *f, Lisp_Object parms)
+w32_icon (struct frame *f, Lisp_Object parms)
 {
   Lisp_Object icon_x, icon_y;
   struct w32_display_info *dpyinfo = &one_w32_display_info;
 
   /* Set the position of the icon.  Note that Windows 95 groups all
      icons in the tray.  */
-  icon_x = x_get_arg (dpyinfo, parms, Qicon_left, 0, 0, RES_TYPE_NUMBER);
-  icon_y = x_get_arg (dpyinfo, parms, Qicon_top, 0, 0, RES_TYPE_NUMBER);
+  icon_x = gui_display_get_arg (dpyinfo, parms, Qicon_left, 0, 0,
+                                RES_TYPE_NUMBER);
+  icon_y = gui_display_get_arg (dpyinfo, parms, Qicon_top, 0, 0,
+                                RES_TYPE_NUMBER);
   if (!EQ (icon_x, Qunbound) && !EQ (icon_y, Qunbound))
     {
       CHECK_FIXNUM (icon_x);
@@ -5544,41 +5550,28 @@ x_icon (struct frame *f, Lisp_Object parms)
 
   block_input ();
 
-#if 0 /* TODO */
-  /* Start up iconic or window? */
-  x_wm_set_window_state
-    (f, (EQ (x_get_arg (dpyinfo, parms, Qvisibility, 0, 0, RES_TYPE_SYMBOL), Qicon)
-	 ? IconicState
-	 : NormalState));
-
-  x_text_icon (f, SSDATA ((!NILP (f->icon_name)
-			   ? f->icon_name
-			   : f->name)));
-#endif
+  /* TODO: Start up iconic or window? */
 
   unblock_input ();
 }
 
 
 static void
-x_make_gc (struct frame *f)
+w32_make_gc (struct frame *f)
 {
-  XGCValues gc_values;
+  Emacs_GC gc_values;
 
   block_input ();
 
   /* Create the GC's of this frame.
      Note that many default values are used.  */
 
-  /* Normal video */
-  gc_values.font = FRAME_FONT (f);
-
   /* Cursor has cursor-color background, background-color foreground.  */
   gc_values.foreground = FRAME_BACKGROUND_PIXEL (f);
   gc_values.background = f->output_data.w32->cursor_pixel;
   f->output_data.w32->cursor_gc
     = XCreateGC (NULL, FRAME_W32_WINDOW (f),
-		 (GCFont | GCForeground | GCBackground),
+		 (GCForeground | GCBackground),
 		 &gc_values);
 
   /* Reliefs.  */
@@ -5589,8 +5582,8 @@ x_make_gc (struct frame *f)
 }
 
 
-/* Handler for signals raised during x_create_frame and
-   x_create_tip_frame.  FRAME is the frame which is partially
+/* Handler for signals raised during Fx_create_frame and
+   w32_create_tip_frame.  FRAME is the frame which is partially
    constructed.  */
 
 static Lisp_Object
@@ -5608,7 +5601,7 @@ unwind_create_frame (Lisp_Object frame)
 	 private shadow variable, it means we are unwinding a frame
 	 for which we didn't yet call init_frame_faces, where the
 	 refcount is incremented.  Therefore, we increment it here, so
-	 that free_frame_faces, called in x_free_frame_resources
+	 that free_frame_faces, called in w32_free_frame_resources
 	 below, will not mistakenly decrement the counter that was not
 	 incremented yet to account for this new frame.  */
       if (FRAME_IMAGE_CACHE (f) != NULL
@@ -5616,7 +5609,7 @@ unwind_create_frame (Lisp_Object frame)
 	FRAME_IMAGE_CACHE (f)->refcount++;
 #endif
 
-      x_free_frame_resources (f);
+      w32_free_frame_resources (f);
       free_glyphs (f);
 
 #ifdef GLYPH_DEBUG
@@ -5640,16 +5633,18 @@ do_unwind_create_frame (Lisp_Object frame)
 }
 
 static void
-x_default_font_parameter (struct frame *f, Lisp_Object parms)
+w32_default_font_parameter (struct frame *f, Lisp_Object parms)
 {
   struct w32_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
-  Lisp_Object font_param = x_get_arg (dpyinfo, parms, Qfont, NULL, NULL,
-				RES_TYPE_STRING);
+  Lisp_Object font_param = gui_display_get_arg (dpyinfo,
+                                                parms, Qfont, NULL, NULL,
+                                                RES_TYPE_STRING);
   Lisp_Object font;
   if (EQ (font_param, Qunbound))
     font_param = Qnil;
   font = !NILP (font_param) ? font_param
-    : x_get_arg (dpyinfo, parms, Qfont, "font", "Font", RES_TYPE_STRING);
+    : gui_display_get_arg (dpyinfo, parms, Qfont, "font", "Font",
+                           RES_TYPE_STRING);
 
   if (!STRINGP (font))
     {
@@ -5674,10 +5669,10 @@ x_default_font_parameter (struct frame *f, Lisp_Object parms)
     {
       /* Remember the explicit font parameter, so we can re-apply it after
 	 we've applied the `default' face settings.  */
-      x_set_frame_parameters (f, Fcons (Fcons (Qfont_parameter, font_param),
-					Qnil));
+      gui_set_frame_parameters (f, Fcons (Fcons (Qfont_parameter, font_param),
+                                          Qnil));
     }
-  x_default_parameter (f, parms, Qfont, font, "font", "Font", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qfont, font, "font", "Font", RES_TYPE_STRING);
 }
 
 DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
@@ -5709,9 +5704,11 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
      until we know if this frame has a specified name.  */
   Vx_resource_name = Vinvocation_name;
 
-  display = x_get_arg (dpyinfo, parameters, Qterminal, 0, 0, RES_TYPE_NUMBER);
+  display = gui_display_get_arg (dpyinfo, parameters, Qterminal, 0, 0,
+                                 RES_TYPE_NUMBER);
   if (EQ (display, Qunbound))
-    display = x_get_arg (dpyinfo, parameters, Qdisplay, 0, 0, RES_TYPE_STRING);
+    display = gui_display_get_arg (dpyinfo, parameters, Qdisplay, 0, 0,
+                                   RES_TYPE_STRING);
   if (EQ (display, Qunbound))
     display = Qnil;
   dpyinfo = check_x_display_info (display);
@@ -5720,7 +5717,8 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
   if (!dpyinfo->terminal->name)
     error ("Terminal is not live, can't create new frames on it");
 
-  name = x_get_arg (dpyinfo, parameters, Qname, "name", "Name", RES_TYPE_STRING);
+  name = gui_display_get_arg (dpyinfo, parameters, Qname, "name", "Name",
+                              RES_TYPE_STRING);
   if (!STRINGP (name)
       && ! EQ (name, Qunbound)
       && ! NILP (name))
@@ -5730,8 +5728,8 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
     Vx_resource_name = name;
 
   /* See if parent window is specified.  */
-  parent = x_get_arg (dpyinfo, parameters, Qparent_id, NULL, NULL,
-		      RES_TYPE_NUMBER);
+  parent = gui_display_get_arg (dpyinfo, parameters, Qparent_id, NULL, NULL,
+                                RES_TYPE_NUMBER);
   if (EQ (parent, Qunbound))
     parent = Qnil;
   else if (!NILP (parent))
@@ -5741,8 +5739,9 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
   /* No need to protect DISPLAY because that's not used after passing
      it to make_frame_without_minibuffer.  */
   frame = Qnil;
-  tem = x_get_arg (dpyinfo, parameters, Qminibuffer, "minibuffer", "Minibuffer",
-		   RES_TYPE_SYMBOL);
+  tem = gui_display_get_arg (dpyinfo, parameters, Qminibuffer,
+                             "minibuffer", "Minibuffer",
+                             RES_TYPE_SYMBOL);
   if (EQ (tem, Qnone) || NILP (tem))
     f = make_frame_without_minibuffer (Qnil, kb, display);
   else if (EQ (tem, Qonly))
@@ -5757,8 +5756,9 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
 
   XSETFRAME (frame, f);
 
-  parent_frame = x_get_arg (dpyinfo, parameters, Qparent_frame, NULL, NULL,
-			    RES_TYPE_SYMBOL);
+  parent_frame = gui_display_get_arg (dpyinfo, parameters, Qparent_frame,
+                                      NULL, NULL,
+                                      RES_TYPE_SYMBOL);
   /* Apply `parent-frame' parameter only when no `parent-id' was
      specified.  */
   if (!NILP (parent_frame)
@@ -5771,13 +5771,13 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
   fset_parent_frame (f, parent_frame);
   store_frame_param (f, Qparent_frame, parent_frame);
 
-  tem = x_get_arg (dpyinfo, parameters, Qundecorated, NULL, NULL,
-		   RES_TYPE_BOOLEAN);
+  tem = gui_display_get_arg (dpyinfo, parameters, Qundecorated, NULL, NULL,
+                             RES_TYPE_BOOLEAN);
   FRAME_UNDECORATED (f) = !NILP (tem) && !EQ (tem, Qunbound);
   store_frame_param (f, Qundecorated, FRAME_UNDECORATED (f) ? Qt : Qnil);
 
-  tem = x_get_arg (dpyinfo, parameters, Qskip_taskbar, NULL, NULL,
-		   RES_TYPE_BOOLEAN);
+  tem = gui_display_get_arg (dpyinfo, parameters, Qskip_taskbar, NULL, NULL,
+                             RES_TYPE_BOOLEAN);
   FRAME_SKIP_TASKBAR (f) = !NILP (tem) && !EQ (tem, Qunbound);
   store_frame_param (f, Qskip_taskbar,
 		     (NILP (tem) || EQ (tem, Qunbound)) ? Qnil : Qt);
@@ -5792,9 +5792,12 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
   f->output_data.w32 = xzalloc (sizeof (struct w32_output));
   FRAME_FONTSET (f) = -1;
 
-  fset_icon_name
-    (f, x_get_arg (dpyinfo, parameters, Qicon_name, "iconName", "Title",
-		   RES_TYPE_STRING));
+  fset_icon_name (f, gui_display_get_arg (dpyinfo,
+                                          parameters,
+                                          Qicon_name,
+                                          "iconName",
+                                          "Title",
+                                          RES_TYPE_STRING));
   if (! STRINGP (f->icon_name))
     fset_icon_name (f, Qnil);
 
@@ -5844,16 +5847,16 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
     register_font_driver (&uniscribe_font_driver, f);
   register_font_driver (&w32font_driver, f);
 
-  x_default_parameter (f, parameters, Qfont_backend, Qnil,
-		       "fontBackend", "FontBackend", RES_TYPE_STRING);
+  gui_default_parameter (f, parameters, Qfont_backend, Qnil,
+                         "fontBackend", "FontBackend", RES_TYPE_STRING);
 
   /* Extract the window parameters from the supplied values
      that are needed to determine window geometry.  */
-  x_default_font_parameter (f, parameters);
+  w32_default_font_parameter (f, parameters);
 
   /* Default BorderWidth to 0 to match other platforms.  */
-  x_default_parameter (f, parameters, Qborder_width, make_fixnum (0),
-		       "borderWidth", "BorderWidth", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parameters, Qborder_width, make_fixnum (0),
+                         "borderWidth", "BorderWidth", RES_TYPE_NUMBER);
 
   /* We recognize either internalBorderWidth or internalBorder
      (which is what xterm calls it).  */
@@ -5861,53 +5864,54 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
     {
       Lisp_Object value;
 
-      value = x_get_arg (dpyinfo, parameters, Qinternal_border_width,
-			 "internalBorder", "InternalBorder", RES_TYPE_NUMBER);
+      value = gui_display_get_arg (dpyinfo, parameters, Qinternal_border_width,
+                                   "internalBorder", "InternalBorder",
+                                   RES_TYPE_NUMBER);
       if (! EQ (value, Qunbound))
 	parameters = Fcons (Fcons (Qinternal_border_width, value),
 			    parameters);
     }
 
-  x_default_parameter (f, parameters, Qinternal_border_width, make_fixnum (0),
-		       "internalBorderWidth", "InternalBorder", RES_TYPE_NUMBER);
-  x_default_parameter (f, parameters, Qright_divider_width, make_fixnum (0),
-		       NULL, NULL, RES_TYPE_NUMBER);
-  x_default_parameter (f, parameters, Qbottom_divider_width, make_fixnum (0),
-		       NULL, NULL, RES_TYPE_NUMBER);
-  x_default_parameter (f, parameters, Qvertical_scroll_bars, Qright,
-		       "verticalScrollBars", "ScrollBars", RES_TYPE_SYMBOL);
-  x_default_parameter (f, parameters, Qhorizontal_scroll_bars, Qnil,
-		       "horizontalScrollBars", "ScrollBars", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parameters, Qinternal_border_width, make_fixnum (0),
+                         "internalBorderWidth", "InternalBorder", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parameters, Qright_divider_width, make_fixnum (0),
+                         NULL, NULL, RES_TYPE_NUMBER);
+  gui_default_parameter (f, parameters, Qbottom_divider_width, make_fixnum (0),
+                         NULL, NULL, RES_TYPE_NUMBER);
+  gui_default_parameter (f, parameters, Qvertical_scroll_bars, Qright,
+                         "verticalScrollBars", "ScrollBars", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parameters, Qhorizontal_scroll_bars, Qnil,
+                         "horizontalScrollBars", "ScrollBars", RES_TYPE_SYMBOL);
 
   /* Also do the stuff which must be set before the window exists.  */
-  x_default_parameter (f, parameters, Qforeground_color, build_string ("black"),
-		       "foreground", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parameters, Qbackground_color, build_string ("white"),
-		       "background", "Background", RES_TYPE_STRING);
-  x_default_parameter (f, parameters, Qmouse_color, build_string ("black"),
-		       "pointerColor", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parameters, Qborder_color, build_string ("black"),
-		       "borderColor", "BorderColor", RES_TYPE_STRING);
-  x_default_parameter (f, parameters, Qscreen_gamma, Qnil,
-		       "screenGamma", "ScreenGamma", RES_TYPE_FLOAT);
-  x_default_parameter (f, parameters, Qline_spacing, Qnil,
-		       "lineSpacing", "LineSpacing", RES_TYPE_NUMBER);
-  x_default_parameter (f, parameters, Qleft_fringe, Qnil,
-		       "leftFringe", "LeftFringe", RES_TYPE_NUMBER);
-  x_default_parameter (f, parameters, Qright_fringe, Qnil,
-		       "rightFringe", "RightFringe", RES_TYPE_NUMBER);
-  x_default_parameter (f, parameters, Qno_focus_on_map, Qnil,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parameters, Qno_accept_focus, Qnil,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parameters, Qno_special_glyphs, Qnil,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parameters, Qforeground_color, build_string ("black"),
+                         "foreground", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parameters, Qbackground_color, build_string ("white"),
+                         "background", "Background", RES_TYPE_STRING);
+  gui_default_parameter (f, parameters, Qmouse_color, build_string ("black"),
+                         "pointerColor", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parameters, Qborder_color, build_string ("black"),
+                         "borderColor", "BorderColor", RES_TYPE_STRING);
+  gui_default_parameter (f, parameters, Qscreen_gamma, Qnil,
+                         "screenGamma", "ScreenGamma", RES_TYPE_FLOAT);
+  gui_default_parameter (f, parameters, Qline_spacing, Qnil,
+                         "lineSpacing", "LineSpacing", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parameters, Qleft_fringe, Qnil,
+                         "leftFringe", "LeftFringe", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parameters, Qright_fringe, Qnil,
+                         "rightFringe", "RightFringe", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parameters, Qno_focus_on_map, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parameters, Qno_accept_focus, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parameters, Qno_special_glyphs, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
 
   /* Process alpha here (Bug#16619).  On XP this fails with child
      frames.  For `no-focus-on-map' frames delay processing of alpha
      until the frame becomes visible.  */
   if (!FRAME_NO_FOCUS_ON_MAP (f))
-    x_default_parameter (f, parameters, Qalpha, Qnil,
+    gui_default_parameter (f, parameters, Qalpha, Qnil,
 			 "alpha", "Alpha", RES_TYPE_NUMBER);
 
   /* Init faces first since we need the frame's column width/line
@@ -5915,7 +5919,7 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
   init_frame_faces (f);
 
   /* We have to call adjust_frame_size here since otherwise
-     x_set_tool_bar_lines will already work with the character sizes
+     w32_set_tool_bar_lines will already work with the character sizes
      installed by init_frame_faces while the frame's pixel size is still
      calculated from a character size of 1 and we subsequently hit the
      (height >= 0) assertion in window_box_height.
@@ -5926,12 +5930,12 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
 
      Also process `min-width' and `min-height' parameters right here
      because `frame-windows-min-size' needs them.  */
-  tem = x_get_arg (dpyinfo, parameters, Qmin_width, NULL, NULL,
-		   RES_TYPE_NUMBER);
+  tem = gui_display_get_arg (dpyinfo, parameters, Qmin_width, NULL, NULL,
+                             RES_TYPE_NUMBER);
   if (FIXNUMP (tem))
     store_frame_param (f, Qmin_width, tem);
-  tem = x_get_arg (dpyinfo, parameters, Qmin_height, NULL, NULL,
-		   RES_TYPE_NUMBER);
+  tem = gui_display_get_arg (dpyinfo, parameters, Qmin_height, NULL, NULL,
+                             RES_TYPE_NUMBER);
   if (FIXNUMP (tem))
     store_frame_param (f, Qmin_height, tem);
   adjust_frame_size (f, FRAME_COLS (f) * FRAME_COLUMN_WIDTH (f),
@@ -5943,24 +5947,24 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
      variables; ignore them here.  */
   if (NILP (parent_frame))
     {
-      x_default_parameter (f, parameters, Qmenu_bar_lines,
-			   NILP (Vmenu_bar_mode)
-			   ? make_fixnum (0) : make_fixnum (1),
-			   NULL, NULL, RES_TYPE_NUMBER);
+      gui_default_parameter (f, parameters, Qmenu_bar_lines,
+                             NILP (Vmenu_bar_mode)
+                             ? make_fixnum (0) : make_fixnum (1),
+                             NULL, NULL, RES_TYPE_NUMBER);
     }
   else
     /* No menu bar for child frames.  */
     store_frame_param (f, Qmenu_bar_lines, make_fixnum (0));
 
-  x_default_parameter (f, parameters, Qtool_bar_lines,
-		       NILP (Vtool_bar_mode)
-		       ? make_fixnum (0) : make_fixnum (1),
-		       NULL, NULL, RES_TYPE_NUMBER);
+  gui_default_parameter (f, parameters, Qtool_bar_lines,
+                         NILP (Vtool_bar_mode)
+                         ? make_fixnum (0) : make_fixnum (1),
+                         NULL, NULL, RES_TYPE_NUMBER);
 
-  x_default_parameter (f, parameters, Qbuffer_predicate, Qnil,
-		       "bufferPredicate", "BufferPredicate", RES_TYPE_SYMBOL);
-  x_default_parameter (f, parameters, Qtitle, Qnil,
-		       "title", "Title", RES_TYPE_STRING);
+  gui_default_parameter (f, parameters, Qbuffer_predicate, Qnil,
+                         "bufferPredicate", "BufferPredicate", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parameters, Qtitle, Qnil,
+                         "title", "Title", RES_TYPE_STRING);
 
   f->output_data.w32->parent_desc = FRAME_DISPLAY_INFO (f)->root_window;
   f->output_data.w32->text_cursor = w32_load_cursor (IDC_IBEAM);
@@ -5981,15 +5985,17 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
 
   f->output_data.w32->current_cursor = f->output_data.w32->nontext_cursor;
 
-  window_prompting = x_figure_window_size (f, parameters, true, &x_width, &x_height);
+  window_prompting = gui_figure_window_size (f, parameters, true,
+                                             &x_width, &x_height);
 
-  tem = x_get_arg (dpyinfo, parameters, Qunsplittable, 0, 0, RES_TYPE_BOOLEAN);
+  tem = gui_display_get_arg (dpyinfo, parameters, Qunsplittable, 0, 0,
+                             RES_TYPE_BOOLEAN);
   f->no_split = minibuffer_only || EQ (tem, Qt);
 
   w32_window (f, window_prompting, minibuffer_only);
-  x_icon (f, parameters);
+  w32_icon (f, parameters);
 
-  x_make_gc (f);
+  w32_make_gc (f);
 
   /* Now consider the frame official.  */
   f->terminal->reference_count++;
@@ -5998,22 +6004,22 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
 
   /* We need to do this after creating the window, so that the
      icon-creation functions can say whose icon they're describing.  */
-  x_default_parameter (f, parameters, Qicon_type, Qnil,
-		       "bitmapIcon", "BitmapIcon", RES_TYPE_SYMBOL);
-
-  x_default_parameter (f, parameters, Qauto_raise, Qnil,
-		       "autoRaise", "AutoRaiseLower", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parameters, Qauto_lower, Qnil,
-		       "autoLower", "AutoRaiseLower", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parameters, Qcursor_type, Qbox,
-		       "cursorType", "CursorType", RES_TYPE_SYMBOL);
-  x_default_parameter (f, parameters, Qscroll_bar_width, Qnil,
-		       "scrollBarWidth", "ScrollBarWidth", RES_TYPE_NUMBER);
-  x_default_parameter (f, parameters, Qscroll_bar_height, Qnil,
-		       "scrollBarHeight", "ScrollBarHeight", RES_TYPE_NUMBER);
-
-  /* Allow x_set_window_size, now.  */
-  f->can_x_set_window_size = true;
+  gui_default_parameter (f, parameters, Qicon_type, Qnil,
+                         "bitmapIcon", "BitmapIcon", RES_TYPE_SYMBOL);
+
+  gui_default_parameter (f, parameters, Qauto_raise, Qnil,
+                         "autoRaise", "AutoRaiseLower", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parameters, Qauto_lower, Qnil,
+                         "autoLower", "AutoRaiseLower", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parameters, Qcursor_type, Qbox,
+                         "cursorType", "CursorType", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parameters, Qscroll_bar_width, Qnil,
+                         "scrollBarWidth", "ScrollBarWidth", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parameters, Qscroll_bar_height, Qnil,
+                         "scrollBarHeight", "ScrollBarHeight", RES_TYPE_NUMBER);
+
+  /* Allow set_window_size_hook, now.  */
+  f->can_set_window_size = true;
 
   if (x_width > 0)
     SET_FRAME_WIDTH (f, x_width);
@@ -6024,7 +6030,7 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
      badly we want them.  This should be done after we have the menu
      bar so that its size can be taken into account.  */
   block_input ();
-  x_wm_set_size_hint (f, window_prompting, false);
+  w32_wm_set_size_hint (f, window_prompting, false);
   unblock_input ();
 
   adjust_frame_size (f, FRAME_TEXT_WIDTH (f), FRAME_TEXT_HEIGHT (f), 0, true,
@@ -6033,10 +6039,10 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
   /* Process fullscreen parameter here in the hope that normalizing a
      fullheight/fullwidth frame will produce the size set by the last
      adjust_frame_size call.  */
-  x_default_parameter (f, parameters, Qfullscreen, Qnil,
-		       "fullscreen", "Fullscreen", RES_TYPE_SYMBOL);
-  x_default_parameter (f, parameters, Qz_group, Qnil,
-		       NULL, NULL, RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parameters, Qfullscreen, Qnil,
+                         "fullscreen", "Fullscreen", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parameters, Qz_group, Qnil,
+                         NULL, NULL, RES_TYPE_SYMBOL);
 
   /* Make the window appear on the frame and enable display, unless
      the caller says not to.  However, with explicit parent, Emacs
@@ -6044,17 +6050,18 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
   if (!f->output_data.w32->explicit_parent)
     {
       Lisp_Object visibility
-	= x_get_arg (dpyinfo, parameters, Qvisibility, 0, 0, RES_TYPE_SYMBOL);
+	= gui_display_get_arg (dpyinfo, parameters, Qvisibility, 0, 0,
+                               RES_TYPE_SYMBOL);
 
       if (EQ (visibility, Qicon))
-	x_iconify_frame (f);
+	w32_iconify_frame (f);
       else
 	{
 	  if (EQ (visibility, Qunbound))
 	    visibility = Qt;
 
 	  if (!NILP (visibility))
-	    x_make_frame_visible (f);
+	    w32_make_frame_visible (f);
 	}
 
       store_frame_param (f, Qvisibility, visibility);
@@ -6062,8 +6069,8 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
 
   /* For `no-focus-on-map' frames set alpha here.  */
   if (FRAME_NO_FOCUS_ON_MAP (f))
-    x_default_parameter (f, parameters, Qalpha, Qnil,
-			 "alpha", "Alpha", RES_TYPE_NUMBER);
+    gui_default_parameter (f, parameters, Qalpha, Qnil,
+                           "alpha", "Alpha", RES_TYPE_NUMBER);
 
   /* Initialize `default-minibuffer-frame' in case this is the first
      frame on this terminal.  */
@@ -6072,8 +6079,9 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
 	  || !FRAME_LIVE_P (XFRAME (KVAR (kb, Vdefault_minibuffer_frame)))))
     kset_default_minibuffer_frame (kb, frame);
 
-  /* All remaining specified parameters, which have not been "used"
-     by x_get_arg and friends, now go in the misc. alist of the frame.  */
+  /* All remaining specified parameters, which have not been "used" by
+     gui_display_get_arg and friends, now go in the misc. alist of the
+     frame.  */
   for (tem = parameters; CONSP (tem); tem = XCDR (tem))
     if (CONSP (XCAR (tem)) && !NILP (XCAR (XCAR (tem))))
       fset_param_alist (f, Fcons (XCAR (tem), f->param_alist));
@@ -6085,31 +6093,16 @@ DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
   return unbind_to (count, frame);
 }
 
-/* FRAME is used only to get a handle on the X display.  We don't pass the
-   display info directly because we're called from frame.c, which doesn't
-   know about that structure.  */
-Lisp_Object
-x_get_focus_frame (struct frame *frame)
-{
-  struct w32_display_info *dpyinfo = FRAME_DISPLAY_INFO (frame);
-  Lisp_Object xfocus;
-  if (! dpyinfo->w32_focus_frame)
-    return Qnil;
-
-  XSETFRAME (xfocus, dpyinfo->w32_focus_frame);
-  return xfocus;
-}
-
 DEFUN ("xw-color-defined-p", Fxw_color_defined_p, Sxw_color_defined_p, 1, 2, 0,
        doc: /* SKIP: real doc in xfns.c.  */)
   (Lisp_Object color, Lisp_Object frame)
 {
-  XColor foo;
+  Emacs_Color foo;
   struct frame *f = decode_window_system_frame (frame);
 
   CHECK_STRING (color);
 
-  if (w32_defined_color (f, SSDATA (color), &foo, false))
+  if (w32_defined_color (f, SSDATA (color), &foo, false, false))
     return Qt;
   else
     return Qnil;
@@ -6119,12 +6112,12 @@ DEFUN ("xw-color-values", Fxw_color_values, Sxw_color_values, 1, 2, 0,
        doc: /* SKIP: real doc in xfns.c.  */)
   (Lisp_Object color, Lisp_Object frame)
 {
-  XColor foo;
+  Emacs_Color foo;
   struct frame *f = decode_window_system_frame (frame);
 
   CHECK_STRING (color);
 
-  if (w32_defined_color (f, SSDATA (color), &foo, false))
+  if (w32_defined_color (f, SSDATA (color), &foo, false, false))
     return list3i ((GetRValue (foo.pixel) << 8) | GetRValue (foo.pixel),
 		   (GetGValue (foo.pixel) << 8) | GetGValue (foo.pixel),
 		   (GetBValue (foo.pixel) << 8) | GetBValue (foo.pixel));
@@ -6164,7 +6157,7 @@ DEFUN ("x-display-pixel-width", Fx_display_pixel_width,
 {
   struct w32_display_info *dpyinfo = check_x_display_info (display);
 
-  return make_fixnum (x_display_pixel_width (dpyinfo));
+  return make_fixnum (w32_display_pixel_width (dpyinfo));
 }
 
 DEFUN ("x-display-pixel-height", Fx_display_pixel_height,
@@ -6174,7 +6167,7 @@ DEFUN ("x-display-pixel-height", Fx_display_pixel_height,
 {
   struct w32_display_info *dpyinfo = check_x_display_info (display);
 
-  return make_fixnum (x_display_pixel_height (dpyinfo));
+  return make_fixnum (w32_display_pixel_height (dpyinfo));
 }
 
 DEFUN ("x-display-planes", Fx_display_planes, Sx_display_planes,
@@ -6248,7 +6241,7 @@ DEFUN ("x-display-mm-height", Fx_display_mm_height,
 		  / GetDeviceCaps (hdc, VERTRES));
   ReleaseDC (NULL, hdc);
 
-  return make_fixnum (x_display_pixel_height (dpyinfo) * mm_per_pixel + 0.5);
+  return make_fixnum (w32_display_pixel_height (dpyinfo) * mm_per_pixel + 0.5);
 }
 
 DEFUN ("x-display-mm-width", Fx_display_mm_width, Sx_display_mm_width, 0, 1, 0,
@@ -6264,7 +6257,7 @@ DEFUN ("x-display-mm-width", Fx_display_mm_width, Sx_display_mm_width, 0, 1, 0,
 		  / GetDeviceCaps (hdc, HORZRES));
   ReleaseDC (NULL, hdc);
 
-  return make_fixnum (x_display_pixel_width (dpyinfo) * mm_per_pixel + 0.5);
+  return make_fixnum (w32_display_pixel_width (dpyinfo) * mm_per_pixel + 0.5);
 }
 
 DEFUN ("x-display-backing-store", Fx_display_backing_store,
@@ -6438,8 +6431,8 @@ w32_display_monitor_attributes_list_fallback (struct w32_display_info *dpyinfo)
     }
   attributes = Fcons (Fcons (Qframes, frames), attributes);
 
-  pixel_width = x_display_pixel_width (dpyinfo);
-  pixel_height = x_display_pixel_height (dpyinfo);
+  pixel_width = w32_display_pixel_width (dpyinfo);
+  pixel_height = w32_display_pixel_height (dpyinfo);
 
   hdc = GetDC (NULL);
   mm_per_pixel = ((double) GetDeviceCaps (hdc, HORZSIZE)
@@ -6524,19 +6517,12 @@ SOUND is nil to use the normal beep.  */)
   return sound;
 }
 
-#if 0	/* unused */
-int
-x_screen_planes (register struct frame *f)
-{
-  return FRAME_DISPLAY_INFO (f)->n_planes;
-}
-#endif
 
 /* Return the display structure for the display named NAME.
    Open a new connection if necessary.  */
 
-struct w32_display_info *
-x_display_info_for_name (Lisp_Object name)
+static struct w32_display_info *
+w32_display_info_for_name (Lisp_Object name)
 {
   struct w32_display_info *dpyinfo;
 
@@ -6653,9 +6639,9 @@ DEFUN ("x-close-connection", Fx_close_connection,
     error ("Display still has frames on it");
 
   block_input ();
-  x_destroy_all_bitmaps (dpyinfo);
+  image_destroy_all_bitmaps (dpyinfo);
 
-  x_delete_display (dpyinfo);
+  w32_delete_display (dpyinfo);
   unblock_input ();
 
   return Qnil;
@@ -6831,13 +6817,13 @@ unwind_create_tip_frame (Lisp_Object frame)
 /* Create a frame for a tooltip on the display described by DPYINFO.
    PARMS is a list of frame parameters.  Value is the frame.
 
-   Note that functions called here, esp. x_default_parameter can
+   Note that functions called here, esp. gui_default_parameter can
    signal errors, for instance when a specified color name is
    undefined.  We have to make sure that we're in a consistent state
    when this happens.  */
 
 static Lisp_Object
-x_create_tip_frame (struct w32_display_info *dpyinfo, Lisp_Object parms)
+w32_create_tip_frame (struct w32_display_info *dpyinfo, Lisp_Object parms)
 {
   struct frame *f;
   Lisp_Object frame;
@@ -6854,12 +6840,14 @@ x_create_tip_frame (struct w32_display_info *dpyinfo, Lisp_Object parms)
 
   kb = dpyinfo->terminal->kboard;
 
-  /* The calls to x_get_arg remove elements from PARMS, so copy it to
-     avoid destructive changes behind our caller's back.  */
+  /* The calls to gui_display_get_arg remove elements from PARMS, so
+     copy it to avoid destructive changes behind our caller's
+     back.  */
   parms = Fcopy_alist (parms);
 
   /* Get the name of the frame to use for resource lookup.  */
-  name = x_get_arg (dpyinfo, parms, Qname, "name", "Name", RES_TYPE_STRING);
+  name = gui_display_get_arg (dpyinfo, parms, Qname, "name", "Name",
+                              RES_TYPE_STRING);
   if (!STRINGP (name)
       && !EQ (name, Qunbound)
       && !NILP (name))
@@ -6876,7 +6864,7 @@ x_create_tip_frame (struct w32_display_info *dpyinfo, Lisp_Object parms)
 
   /* By setting the output method, we're essentially saying that
      the frame is live, as per FRAME_LIVE_P.  If we get a signal
-     from this point on, x_destroy_window might screw up reference
+     from this point on, w32_destroy_window might screw up reference
      counts etc.  */
   f->terminal = dpyinfo->terminal;
   f->output_method = output_w32;
@@ -6912,15 +6900,15 @@ x_create_tip_frame (struct w32_display_info *dpyinfo, Lisp_Object parms)
     register_font_driver (&uniscribe_font_driver, f);
   register_font_driver (&w32font_driver, f);
 
-  x_default_parameter (f, parms, Qfont_backend, Qnil,
-		       "fontBackend", "FontBackend", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qfont_backend, Qnil,
+                         "fontBackend", "FontBackend", RES_TYPE_STRING);
 
   /* Extract the window parameters from the supplied values
      that are needed to determine window geometry.  */
-  x_default_font_parameter (f, parms);
+  w32_default_font_parameter (f, parms);
 
-  x_default_parameter (f, parms, Qborder_width, make_fixnum (2),
-		       "borderWidth", "BorderWidth", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qborder_width, make_fixnum (2),
+                         "borderWidth", "BorderWidth", RES_TYPE_NUMBER);
   /* This defaults to 2 in order to match xterm.  We recognize either
      internalBorderWidth or internalBorder (which is what xterm calls
      it).  */
@@ -6928,31 +6916,32 @@ x_create_tip_frame (struct w32_display_info *dpyinfo, Lisp_Object parms)
     {
       Lisp_Object value;
 
-      value = x_get_arg (dpyinfo, parms, Qinternal_border_width,
-			 "internalBorder", "internalBorder", RES_TYPE_NUMBER);
+      value = gui_display_get_arg (dpyinfo, parms, Qinternal_border_width,
+                                   "internalBorder", "internalBorder",
+                                   RES_TYPE_NUMBER);
       if (! EQ (value, Qunbound))
 	parms = Fcons (Fcons (Qinternal_border_width, value),
 		       parms);
     }
 
-  x_default_parameter (f, parms, Qinternal_border_width, make_fixnum (1),
-		       "internalBorderWidth", "internalBorderWidth",
-		       RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qinternal_border_width, make_fixnum (1),
+                         "internalBorderWidth", "internalBorderWidth",
+                         RES_TYPE_NUMBER);
   /* Also do the stuff which must be set before the window exists.  */
-  x_default_parameter (f, parms, Qforeground_color, build_string ("black"),
-		       "foreground", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qbackground_color, build_string ("white"),
-		       "background", "Background", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qmouse_color, build_string ("black"),
-		       "pointerColor", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qcursor_color, build_string ("black"),
-		       "cursorColor", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qborder_color, build_string ("black"),
-		       "borderColor", "BorderColor", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qno_special_glyphs, Qt,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
-
-  /* Init faces before x_default_parameter is called for the
+  gui_default_parameter (f, parms, Qforeground_color, build_string ("black"),
+                         "foreground", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qbackground_color, build_string ("white"),
+                         "background", "Background", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qmouse_color, build_string ("black"),
+                         "pointerColor", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qcursor_color, build_string ("black"),
+                         "cursorColor", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qborder_color, build_string ("black"),
+                         "borderColor", "BorderColor", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qno_special_glyphs, Qt,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
+
+  /* Init faces before gui_default_parameter is called for the
      scroll-bar-width parameter because otherwise we end up in
      init_iterator with a null face cache, which should not happen.  */
   init_frame_faces (f);
@@ -6961,7 +6950,7 @@ x_create_tip_frame (struct w32_display_info *dpyinfo, Lisp_Object parms)
   f->output_data.w32->parent_desc = FRAME_DISPLAY_INFO (f)->root_window;
   f->output_data.w32->explicit_parent = false;
 
-  x_figure_window_size (f, parms, true, &x_width, &x_height);
+  gui_figure_window_size (f, parms, true, &x_width, &x_height);
 
   /* No fringes on tip frame.  */
   f->fringe_cols = 0;
@@ -6975,17 +6964,17 @@ x_create_tip_frame (struct w32_display_info *dpyinfo, Lisp_Object parms)
   my_create_tip_window (f);
   unblock_input ();
 
-  x_make_gc (f);
+  w32_make_gc (f);
 
-  x_default_parameter (f, parms, Qauto_raise, Qnil,
-		       "autoRaise", "AutoRaiseLower", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qauto_lower, Qnil,
-		       "autoLower", "AutoRaiseLower", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qcursor_type, Qbox,
-		       "cursorType", "CursorType", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qauto_raise, Qnil,
+                         "autoRaise", "AutoRaiseLower", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qauto_lower, Qnil,
+                         "autoLower", "AutoRaiseLower", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qcursor_type, Qbox,
+                         "cursorType", "CursorType", RES_TYPE_SYMBOL);
   /* Process alpha here (Bug#17344).  */
-  x_default_parameter (f, parms, Qalpha, Qnil,
-		       "alpha", "Alpha", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qalpha, Qnil,
+                         "alpha", "Alpha", RES_TYPE_NUMBER);
 
   /* Dimensions, especially FRAME_LINES (f), must be done via
      change_frame_size.  Change will not be effected unless different
@@ -7035,7 +7024,7 @@ x_create_tip_frame (struct w32_display_info *dpyinfo, Lisp_Object parms)
      below.  And the frame needs to be on Vframe_list or making it
      visible won't work.  */
   Vframe_list = Fcons (frame, Vframe_list);
-  f->can_x_set_window_size = true;
+  f->can_set_window_size = true;
 
   /* Setting attributes of faces of the tooltip frame from resources
      and similar will set face_change, which leads to the
@@ -7079,8 +7068,8 @@ compute_tip_xy (struct frame *f,
       /* Default min and max values.  */
       min_x = 0;
       min_y = 0;
-      max_x = x_display_pixel_width (FRAME_DISPLAY_INFO (f));
-      max_y = x_display_pixel_height (FRAME_DISPLAY_INFO (f));
+      max_x = w32_display_pixel_width (FRAME_DISPLAY_INFO (f));
+      max_y = w32_display_pixel_height (FRAME_DISPLAY_INFO (f));
 
       block_input ();
       GetCursorPos (&pt);
@@ -7145,7 +7134,7 @@ compute_tip_xy (struct frame *f,
 }
 
 /**
- * x_hide_tip:
+ * w32_hide_tip:
  *
  * Hide currently visible tooltip and cancel its timer.
  *
@@ -7156,7 +7145,7 @@ compute_tip_xy (struct frame *f,
  * otherwise.
  */
 static Lisp_Object
-x_hide_tip (bool delete)
+w32_hide_tip (bool delete)
 {
   if (!NILP (tip_timer))
     {
@@ -7187,7 +7176,7 @@ x_hide_tip (bool delete)
 		  tip_frame = Qnil;
 		}
 	      else
-		x_make_frame_invisible (XFRAME (tip_frame));
+		w32_make_frame_invisible (XFRAME (tip_frame));
 
 	      was_open = Qt;
 	    }
@@ -7329,13 +7318,13 @@ DEFUN ("x-show-tip", Fx_show_tip, Sx_show_tip, 1, 6, 0,
 		}
 	    }
 
-	  x_hide_tip (delete);
+	  w32_hide_tip (delete);
 	}
       else
-	x_hide_tip (true);
+	w32_hide_tip (true);
     }
   else
-    x_hide_tip (true);
+    w32_hide_tip (true);
 
   tip_last_frame = frame;
   tip_last_string = string;
@@ -7364,7 +7353,7 @@ DEFUN ("x-show-tip", Fx_show_tip, Sx_show_tip, 1, 6, 0,
       /* Create a frame for the tooltip and record it in the global
 	 variable tip_frame.  */
       struct frame *f;		/* The value is unused.  */
-      if (NILP (tip_frame = x_create_tip_frame (FRAME_DISPLAY_INFO (f), parms)))
+      if (NILP (tip_frame = w32_create_tip_frame (FRAME_DISPLAY_INFO (f), parms)))
 	{
 	  /* Creating the tip frame failed.  */
 	  unblock_input ();
@@ -7485,7 +7474,7 @@ DEFUN ("x-hide-tip", Fx_hide_tip, Sx_hide_tip, 0, 0, 0,
        doc: /* SKIP: real doc in xfns.c.  */)
   (void)
 {
-  return x_hide_tip (!tooltip_reuse_hidden_frame);
+  return w32_hide_tip (!tooltip_reuse_hidden_frame);
 }
 
 /***********************************************************************
@@ -7621,9 +7610,9 @@ w32_dialog_in_progress (Lisp_Object in_progress)
       struct frame *f = XFRAME (frame);
 
       if (!NILP (in_progress) && FRAME_Z_GROUP_ABOVE (f))
-	x_set_z_group (f, Qabove_suspended, Qabove);
+	w32_set_z_group (f, Qabove_suspended, Qabove);
       else if (NILP (in_progress) && FRAME_Z_GROUP_ABOVE_SUSPENDED (f))
-	x_set_z_group (f, Qabove, Qabove_suspended);
+	w32_set_z_group (f, Qabove, Qabove_suspended);
     }
 }
 
@@ -8924,7 +8913,7 @@ w32_frame_list_z_order (struct w32_display_info *dpyinfo, HWND window)
 
   while (window)
     {
-      struct frame *f = x_window_to_frame (dpyinfo, window);
+      struct frame *f = w32_window_to_frame (dpyinfo, window);
 
       if (f)
 	{
@@ -10162,52 +10151,52 @@ to be converted to forward slashes by the caller.  */)
 
 frame_parm_handler w32_frame_parm_handlers[] =
 {
-  x_set_autoraise,
-  x_set_autolower,
-  x_set_background_color,
-  x_set_border_color,
-  x_set_border_width,
-  x_set_cursor_color,
-  x_set_cursor_type,
-  x_set_font,
-  x_set_foreground_color,
-  x_set_icon_name,
-  x_set_icon_type,
-  x_set_internal_border_width,
-  x_set_right_divider_width,
-  x_set_bottom_divider_width,
-  x_set_menu_bar_lines,
-  x_set_mouse_color,
-  x_explicitly_set_name,
-  x_set_scroll_bar_width,
-  x_set_scroll_bar_height,
-  x_set_title,
-  x_set_unsplittable,
-  x_set_vertical_scroll_bars,
-  x_set_horizontal_scroll_bars,
-  x_set_visibility,
-  x_set_tool_bar_lines,
+  gui_set_autoraise,
+  gui_set_autolower,
+  w32_set_background_color,
+  w32_set_border_color,
+  gui_set_border_width,
+  w32_set_cursor_color,
+  w32_set_cursor_type,
+  gui_set_font,
+  w32_set_foreground_color,
+  w32_set_icon_name,
+  w32_set_icon_type,
+  w32_set_internal_border_width,
+  gui_set_right_divider_width,
+  gui_set_bottom_divider_width,
+  w32_set_menu_bar_lines,
+  w32_set_mouse_color,
+  w32_explicitly_set_name,
+  gui_set_scroll_bar_width,
+  gui_set_scroll_bar_height,
+  w32_set_title,
+  gui_set_unsplittable,
+  gui_set_vertical_scroll_bars,
+  gui_set_horizontal_scroll_bars,
+  gui_set_visibility,
+  w32_set_tool_bar_lines,
   0, /* x_set_scroll_bar_foreground, */
   0, /* x_set_scroll_bar_background, */
-  x_set_screen_gamma,
-  x_set_line_spacing,
-  x_set_left_fringe,
-  x_set_right_fringe,
+  gui_set_screen_gamma,
+  gui_set_line_spacing,
+  gui_set_left_fringe,
+  gui_set_right_fringe,
   0, /* x_set_wait_for_wm, */
-  x_set_fullscreen,
-  x_set_font_backend,
-  x_set_alpha,
+  gui_set_fullscreen,
+  gui_set_font_backend,
+  gui_set_alpha,
   0, /* x_set_sticky */
   0, /* x_set_tool_bar_position */
   0, /* x_set_inhibit_double_buffering */
-  x_set_undecorated,
-  x_set_parent_frame,
-  x_set_skip_taskbar,
-  x_set_no_focus_on_map,
-  x_set_no_accept_focus,
-  x_set_z_group,
+  w32_set_undecorated,
+  w32_set_parent_frame,
+  w32_set_skip_taskbar,
+  w32_set_no_focus_on_map,
+  w32_set_no_accept_focus,
+  w32_set_z_group,
   0, /* x_set_override_redirect */
-  x_set_no_special_glyphs,
+  gui_set_no_special_glyphs,
 };
 
 void
diff --git a/src/w32font.c b/src/w32font.c
index 33c89825e9..47a33aec35 100644
--- a/src/w32font.c
+++ b/src/w32font.c
@@ -433,7 +433,7 @@ w32font_encode_char (struct font *font, int c)
    CODE (length NGLYPHS).  Apparently metrics can be NULL, in this
    case just return the overall width.  */
 void
-w32font_text_extents (struct font *font, unsigned *code,
+w32font_text_extents (struct font *font, const unsigned *code,
 		      int nglyphs, struct font_metrics *metrics)
 {
   int i;
@@ -678,7 +678,7 @@ w32font_draw (struct glyph_string *s, int from, int to,
 	 characters, because drawing background with font dimensions
 	 in those cases makes the display illegible.  There's only one
 	 more call to the draw method with with_background set to
-	 true, and that's in x_draw_glyph_string_foreground, when
+	 true, and that's in w32_draw_glyph_string_foreground, when
 	 drawing the cursor, where we have no such heuristics
 	 available.  FIXME.  */
       if (s->first_glyph->type == GLYPHLESS_GLYPH
@@ -704,11 +704,23 @@ w32font_draw (struct glyph_string *s, int from, int to,
       int i;
 
       for (i = 0; i < len; i++)
-	ExtTextOutW (s->hdc, x + i, y, options, NULL,
-		     s->char2b + from + i, 1, NULL);
+	{
+	  WCHAR c = s->char2b[from + i] & 0xFFFF;
+	  ExtTextOutW (s->hdc, x + i, y, options, NULL, &c, 1, NULL);
+	}
     }
   else
-    ExtTextOutW (s->hdc, x, y, options, NULL, s->char2b + from, len, NULL);
+    {
+      /* The number of glyphs in a glyph_string cannot be larger than
+	 the maximum value of the 'used' member of a glyph_row, so we
+	 are OK using alloca here.  */
+      eassert (len <= SHRT_MAX);
+      WCHAR *chars = alloca (len * sizeof (WCHAR));
+      int j;
+      for (j = 0; j < len; j++)
+	chars[j] = s->char2b[from + j] & 0xFFFF;
+      ExtTextOutW (s->hdc, x, y, options, NULL, chars, len, NULL);
+    }
 
   /* Restore clip region.  */
   if (s->num_clips > 0)
diff --git a/src/w32font.h b/src/w32font.h
index 65f42a3178..c7bb7f3057 100644
--- a/src/w32font.h
+++ b/src/w32font.h
@@ -74,7 +74,7 @@ int w32font_open_internal (struct frame *f, Lisp_Object font_entity,
                            int pixel_size, Lisp_Object font_object);
 void w32font_close (struct font *font);
 int w32font_has_char (Lisp_Object entity, int c);
-void w32font_text_extents (struct font *font, unsigned *code, int nglyphs,
+void w32font_text_extents (struct font *font, const unsigned *code, int nglyphs,
 			   struct font_metrics *metrics);
 int w32font_draw (struct glyph_string *s, int from, int to,
                   int x, int y, bool with_background);
diff --git a/src/w32gui.h b/src/w32gui.h
index dbc67993ce..62bad33c19 100644
--- a/src/w32gui.h
+++ b/src/w32gui.h
@@ -27,43 +27,11 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #define local_alloc(n) (HeapAlloc (local_heap, HEAP_ZERO_MEMORY, (n)))
 #define local_free(p) (HeapFree (local_heap, 0, ((LPVOID) (p))))
 
-/* Emulate X GC's by keeping color and font info in a structure.  */
-typedef struct _XGCValues
-{
-  COLORREF foreground;
-  COLORREF background;
-  struct font *font;
-} XGCValues;
-
-#define GCForeground 0x01
-#define GCBackground 0x02
-#define GCFont 0x03
-
-typedef HBITMAP Pixmap;
-typedef HBITMAP Bitmap;
+typedef HBITMAP Emacs_Pixmap;
 
-typedef char * XrmDatabase;
-
-typedef XGCValues * GC;
-typedef COLORREF Color;
 typedef HWND Window;
 typedef HDC Display;  /* HDC so it doesn't conflict with xpm lib.  */
-typedef HCURSOR Cursor;
-
-#define No_Cursor (0)
-
-#define XChar2b wchar_t
-
-/* Dealing with bits of wchar_t as if they were an XChar2b.  */
-#define STORE_XCHAR2B(chp, byte1, byte2) \
-  ((*(chp)) = ((XChar2b)((((byte1) & 0x00ff) << 8) | ((byte2) & 0x00ff))))
-
-#define XCHAR2B_BYTE1(chp) \
-  (((*(chp)) & 0xff00) >> 8)
-
-#define XCHAR2B_BYTE2(chp) \
-  ((*(chp)) & 0x00ff)
-
+typedef HCURSOR Emacs_Cursor;
 
 /* Windows equivalent of XImage.  */
 typedef struct _XImage
@@ -112,20 +80,15 @@ extern HINSTANCE hinst;
 #define PBaseSize	(1L << 8) /* program specified base for incrementing */
 #define PWinGravity	(1L << 9) /* program specified window gravity */
 
-typedef struct {
-    int x, y;
-    unsigned width, height;
-} XRectangle;
-
 #define NativeRectangle RECT
 
-#define CONVERT_TO_XRECT(xr,nr)			\
+#define CONVERT_TO_EMACS_RECT(xr,nr)            \
   ((xr).x = (nr).left,				\
    (xr).y = (nr).top,				\
    (xr).width = ((nr).right - (nr).left),	\
    (xr).height = ((nr).bottom - (nr).top))
 
-#define CONVERT_FROM_XRECT(xr,nr)		\
+#define CONVERT_FROM_EMACS_RECT(xr,nr)		\
   ((nr).left = (xr).x,				\
    (nr).top = (xr).y,				\
    (nr).right = ((xr).x + (xr).width),		\
diff --git a/src/w32inevt.c b/src/w32inevt.c
index ab71c560d6..fc1f90cd02 100644
--- a/src/w32inevt.c
+++ b/src/w32inevt.c
@@ -680,7 +680,7 @@ handle_file_notifications (struct input_event *hold_quit)
 		     already be defined at this point.  */
 		  Lisp_Object fname
 		    = code_convert_string_norecord (utf_16_fn, cs, 0);
-		  Lisp_Object action = lispy_file_action (fni->Action);
+		  Lisp_Object action = w32_lispy_file_action (fni->Action);
 
 		  inev.kind = FILE_NOTIFY_EVENT;
 		  inev.timestamp = GetTickCount ();
diff --git a/src/w32menu.c b/src/w32menu.c
index 38e1b506e0..669161c408 100644
--- a/src/w32menu.c
+++ b/src/w32menu.c
@@ -153,7 +153,7 @@ w32_popup_dialog (struct frame *f, Lisp_Object header, Lisp_Object contents)
    This way we can safely execute Lisp code.  */
 
 void
-x_activate_menubar (struct frame *f)
+w32_activate_menubar (struct frame *f)
 {
   set_frame_menubar (f, false, true);
 
@@ -1469,7 +1469,7 @@ w32_menu_display_help (HWND owner, HMENU menu, UINT item, UINT flags)
 {
   if (get_menu_item_info)
     {
-      struct frame *f = x_window_to_frame (&one_w32_display_info, owner);
+      struct frame *f = w32_window_to_frame (&one_w32_display_info, owner);
       Lisp_Object frame, help;
 
       /* No help echo on owner-draw menu items, or when the keyboard
diff --git a/src/w32reg.c b/src/w32reg.c
index aff131dd37..99b3973d70 100644
--- a/src/w32reg.c
+++ b/src/w32reg.c
@@ -21,8 +21,8 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include <config.h>
 #include "lisp.h"
-#include "w32term.h"	/* for XrmDatabase, xrdb */
 #include "blockinput.h"
+#include "w32term.h"
 
 #include <stdio.h>
 
@@ -73,8 +73,8 @@ w32_get_rdb_resource (const char *rdb, const char *resource)
   return NULL;
 }
 
-static char *
-w32_get_string_resource (const char *name, const char *class, DWORD dwexptype)
+static const char *
+w32_get_string_resource_1 (const char *name, const char *class, DWORD dwexptype)
 {
   LPBYTE lpvalue = NULL;
   HKEY hrootkey = NULL;
@@ -134,15 +134,17 @@ w32_get_string_resource (const char *name, const char *class, DWORD dwexptype)
       /* Check if there are Windows specific defaults defined.  */
       return w32_get_rdb_resource (SYSTEM_DEFAULT_RESOURCES, name);
     }
-  return (char *)lpvalue;
+  return (const char *)lpvalue;
 }
 
 /* Retrieve the string resource specified by NAME with CLASS from
    database RDB. */
 
-char *
-x_get_string_resource (XrmDatabase rdb, const char *name, const char *class)
+const char *
+w32_get_string_resource (void *v_rdb, const char *name, const char *class)
 {
+  const char *rdb = *(char **) v_rdb;
+
   if (rdb)
     {
       char *resource;
@@ -157,5 +159,5 @@ x_get_string_resource (XrmDatabase rdb, const char *name, const char *class)
     /* --quick was passed, so this is a no-op.  */
     return NULL;
 
-  return w32_get_string_resource (name, class, REG_SZ);
+  return w32_get_string_resource_1 (name, class, REG_SZ);
 }
diff --git a/src/w32term.c b/src/w32term.c
index bb1f0bad01..5726124b0e 100644
--- a/src/w32term.c
+++ b/src/w32term.c
@@ -85,10 +85,7 @@ static int any_help_event_p;
 extern unsigned int msh_mousewheel;
 
 extern int w32_codepage_for_font (char *fontname);
-extern Cursor w32_load_cursor (LPCTSTR name);
-
-#define x_any_window_to_frame x_window_to_frame
-#define x_top_window_to_frame x_window_to_frame
+extern HCURSOR w32_load_cursor (LPCTSTR name);
 
 
 /* This is display since w32 does not support multiple ones.  */
@@ -169,29 +166,27 @@ int w32_message_fd = -1;
 
 static void w32_handle_tool_bar_click (struct frame *,
                                        struct input_event *);
-static void w32_define_cursor (Window, Cursor);
+static void w32_define_cursor (Window, Emacs_Cursor);
 
-void x_lower_frame (struct frame *);
-void x_scroll_bar_clear (struct frame *);
-void x_raise_frame (struct frame *);
-void x_wm_set_window_state (struct frame *, int);
-void x_wm_set_icon_pixmap (struct frame *, int);
+static void w32_scroll_bar_clear (struct frame *);
+static void w32_raise_frame (struct frame *);
+static void w32_lower_frame (struct frame *);
 static void w32_initialize (void);
-static void x_update_end (struct frame *);
+static void w32_update_end (struct frame *);
 static void w32_frame_up_to_date (struct frame *);
-static void x_clear_frame (struct frame *);
-static void frame_highlight (struct frame *);
-static void frame_unhighlight (struct frame *);
-static void x_new_focus_frame (struct w32_display_info *,
-                               struct frame *);
-static void x_focus_changed (int, int, struct w32_display_info *,
+static void w32_clear_frame (struct frame *);
+static void w32_frame_highlight (struct frame *);
+static void w32_frame_unhighlight (struct frame *);
+static void w32_new_focus_frame (struct w32_display_info *,
+                                 struct frame *);
+static void w32_focus_changed (int, int, struct w32_display_info *,
                              struct frame *, struct input_event *);
 static void w32_detect_focus_change (struct w32_display_info *,
                                      W32Msg *, struct input_event *);
 static void w32_frame_rehighlight (struct frame *);
-static void x_frame_rehighlight (struct w32_display_info *);
-static void x_draw_hollow_cursor (struct window *, struct glyph_row *);
-static void x_draw_bar_cursor (struct window *, struct glyph_row *, int,
+static void w32_frame_rehighlight_1 (struct w32_display_info *);
+static void w32_draw_hollow_cursor (struct window *, struct glyph_row *);
+static void w32_draw_bar_cursor (struct window *, struct glyph_row *, int,
                                enum text_cursor_kinds);
 static void w32_clip_to_row (struct window *, struct glyph_row *,
 			     enum glyph_row_area, HDC);
@@ -205,7 +200,7 @@ static void my_destroy_window (struct frame *, HWND);
 static void w32fullscreen_hook (struct frame *);
 
 #ifdef GLYPH_DEBUG
-static void x_check_font (struct frame *, struct font *);
+static void w32_check_font (struct frame *, struct font *);
 #endif
 
 
@@ -242,28 +237,26 @@ record_event (char *locus, int type)
 
 
 static void
-XChangeGC (void *ignore, XGCValues *gc, unsigned long mask,
-	   XGCValues *xgcv)
+XChangeGC (void *ignore, Emacs_GC *gc, unsigned long mask,
+	   Emacs_GC *egc)
 {
   if (mask & GCForeground)
-    gc->foreground = xgcv->foreground;
+    gc->foreground = egc->foreground;
   if (mask & GCBackground)
-    gc->background = xgcv->background;
-  if (mask & GCFont)
-    gc->font = xgcv->font;
+    gc->background = egc->background;
 }
 
-XGCValues *
-XCreateGC (void *ignore, HWND wignore, unsigned long mask, XGCValues *xgcv)
+Emacs_GC *
+XCreateGC (void *ignore, HWND wignore, unsigned long mask, Emacs_GC *egc)
 {
-  XGCValues *gc = xzalloc (sizeof (XGCValues));
+  Emacs_GC *gc = xzalloc (sizeof (*gc));
 
-  XChangeGC (ignore, gc, mask, xgcv);
+  XChangeGC (ignore, gc, mask, egc);
 
   return gc;
 }
 
-#if 0	/* unused for now, see x_draw_image_glyph_string below */
+#if 0	/* unused for now, see w32_draw_image_glyph_string below */
 static void
 XGetGCValues (void *ignore, XGCValues *gc,
 	      unsigned long mask, XGCValues *xgcv)
@@ -306,7 +299,7 @@ w32_restore_glyph_string_clip (struct glyph_string *s)
 }
 
 static void
-x_get_scale_factor(struct w32_display_info *dpyinfo, int *scale_x, int *scale_y)
+w32_get_scale_factor(struct w32_display_info *dpyinfo, int *scale_x, int *scale_y)
 {
   const int base_res = 96;
 
@@ -338,11 +331,11 @@ w32_draw_underwave (struct glyph_string *s, COLORREF color)
   struct w32_display_info *dpyinfo = FRAME_DISPLAY_INFO (s->f);
 
   int scale_x, scale_y;
-  x_get_scale_factor (dpyinfo, &scale_x, &scale_y);
+  w32_get_scale_factor (dpyinfo, &scale_x, &scale_y);
 
   int wave_height = 3 * scale_y, wave_length = 2 * scale_x, thickness = scale_y;
   int dx, dy, x0, y0, width, x1, y1, x2, y2, odd, xmax;
-  XRectangle wave_clip, string_clip, final_clip;
+  Emacs_Rectangle wave_clip, string_clip, final_clip;
   RECT w32_final_clip, w32_string_clip;
   HPEN hp, oldhp;
 
@@ -361,14 +354,14 @@ w32_draw_underwave (struct glyph_string *s, COLORREF color)
   wave_clip.height = wave_height;
 
   get_glyph_string_clip_rect (s, &w32_string_clip);
-  CONVERT_TO_XRECT (string_clip, w32_string_clip);
+  CONVERT_TO_EMACS_RECT (string_clip, w32_string_clip);
 
-  if (!x_intersect_rectangles (&wave_clip, &string_clip, &final_clip))
+  if (!gui_intersect_rectangles (&wave_clip, &string_clip, &final_clip))
     return;
 
   hp = CreatePen (PS_SOLID, thickness, color);
   oldhp = SelectObject (s->hdc, hp);
-  CONVERT_FROM_XRECT (final_clip, w32_final_clip);
+  CONVERT_FROM_EMACS_RECT (final_clip, w32_final_clip);
   w32_set_clip_rectangle (s->hdc, &w32_final_clip);
 
   /* Draw the waves */
@@ -401,7 +394,7 @@ w32_draw_underwave (struct glyph_string *s, COLORREF color)
 
 /* Draw a hollow rectangle at the specified position.  */
 static void
-w32_draw_rectangle (HDC hdc, XGCValues *gc, int x, int y,
+w32_draw_rectangle (HDC hdc, Emacs_GC *gc, int x, int y,
                     int width, int height)
 {
   HBRUSH hb, oldhb;
@@ -457,8 +450,8 @@ w32_clear_window (struct frame *f)
 
 #define OPAQUE_FRAME 255
 
-void
-x_set_frame_alpha (struct frame *f)
+static void
+w32_set_frame_alpha (struct frame *f)
 {
   struct w32_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
   double alpha = 1.0;
@@ -504,7 +497,7 @@ x_set_frame_alpha (struct frame *f)
 }
 
 int
-x_display_pixel_height (struct w32_display_info *dpyinfo)
+w32_display_pixel_height (struct w32_display_info *dpyinfo)
 {
   int pixels = GetSystemMetrics (SM_CYVIRTUALSCREEN);
 
@@ -516,7 +509,7 @@ x_display_pixel_height (struct w32_display_info *dpyinfo)
 }
 
 int
-x_display_pixel_width (struct w32_display_info *dpyinfo)
+w32_display_pixel_width (struct w32_display_info *dpyinfo)
 {
   int pixels = GetSystemMetrics (SM_CXVIRTUALSCREEN);
 
@@ -534,11 +527,11 @@ x_display_pixel_width (struct w32_display_info *dpyinfo)
 
 /* Start an update of frame F.  This function is installed as a hook
    for update_begin, i.e. it is called when update_begin is called.
-   This function is called prior to calls to x_update_window_begin for
-   each window being updated.  */
+   This function is called prior to calls to gui_update_window_begin
+   for each window being updated.  */
 
 static void
-x_update_begin (struct frame *f)
+w32_update_begin (struct frame *f)
 {
   struct w32_display_info *display_info = FRAME_DISPLAY_INFO (f);
 
@@ -558,60 +551,14 @@ x_update_begin (struct frame *f)
 /* Start update of window W.  */
 
 static void
-x_update_window_begin (struct window *w)
+w32_update_window_begin (struct window *w)
 {
-  struct frame *f = XFRAME (WINDOW_FRAME (w));
-  Mouse_HLInfo *hlinfo = MOUSE_HL_INFO (f);
-
   /* Hide the system caret during an update.  */
   if (w32_use_visible_system_caret && w32_system_caret_hwnd)
     {
       SendMessageTimeout (w32_system_caret_hwnd, WM_EMACS_HIDE_CARET, 0, 0,
 			  0, 6000, NULL);
     }
-
-  w->output_cursor = w->cursor;
-
-  block_input ();
-
-  if (f == hlinfo->mouse_face_mouse_frame)
-    {
-      /* Don't do highlighting for mouse motion during the update.  */
-      hlinfo->mouse_face_defer = true;
-
-      /* If F needs to be redrawn, simply forget about any prior mouse
-	 highlighting.  */
-      if (FRAME_GARBAGED_P (f))
-	hlinfo->mouse_face_window = Qnil;
-
-#if 0 /* Rows in a current matrix containing glyphs in mouse-face have
-	 their mouse_face_p flag set, which means that they are always
-	 unequal to rows in a desired matrix which never have that
-	 flag set.  So, rows containing mouse-face glyphs are never
-	 scrolled, and we don't have to switch the mouse highlight off
-	 here to prevent it from being scrolled.  */
-
-      /* Can we tell that this update does not affect the window
-	 where the mouse highlight is?  If so, no need to turn off.
-	 Likewise, don't do anything if the frame is garbaged;
-	 in that case, the frame's current matrix that we would use
-	 is all wrong, and we will redisplay that line anyway.  */
-      if (!NILP (hlinfo->mouse_face_window)
-	  && w == XWINDOW (hlinfo->mouse_face_window))
-	{
-	  int i;
-
-          for (i = 0; i < w->desired_matrix->nrows; ++i)
-	    if (MATRIX_ROW_ENABLED_P (w->desired_matrix, i))
-	      break;
-
-	  if (i < w->desired_matrix->nrows)
-	    clear_mouse_face (hlinfo);
-	}
-#endif /* 0 */
-    }
-
-  unblock_input ();
 }
 
 /* Draw a vertical window border from (x,y0) to (x,y1)  */
@@ -698,43 +645,12 @@ w32_draw_window_divider (struct window *w, int x0, int x1, int y0, int y1)
    here. */
 
 static void
-x_update_window_end (struct window *w, bool cursor_on_p,
-		     bool mouse_face_overwritten_p)
+w32_update_window_end (struct window *w, bool cursor_on_p,
+                       bool mouse_face_overwritten_p)
 {
-  if (!w->pseudo_window_p)
-    {
-      block_input ();
-
-      if (cursor_on_p)
-	display_and_set_cursor (w, true,
-				w->output_cursor.hpos, w->output_cursor.vpos,
-				w->output_cursor.x, w->output_cursor.y);
-
-      if (draw_window_fringes (w, true))
-	{
-	  if (WINDOW_RIGHT_DIVIDER_WIDTH (w))
-	    x_draw_right_divider (w);
-	  else
-	    x_draw_vertical_border (w);
-	}
-
-      unblock_input ();
-    }
-
-  /* If a row with mouse-face was overwritten, arrange for
-     XTframe_up_to_date to redisplay the mouse highlight.  */
-  if (mouse_face_overwritten_p)
-    {
-      Mouse_HLInfo *hlinfo = MOUSE_HL_INFO (XFRAME (w->frame));
-
-      hlinfo->mouse_face_beg_row = hlinfo->mouse_face_beg_col = -1;
-      hlinfo->mouse_face_end_row = hlinfo->mouse_face_end_col = -1;
-      hlinfo->mouse_face_window = Qnil;
-    }
-
   /* Unhide the caret.  This won't actually show the cursor, unless it
      was visible before the corresponding call to HideCaret in
-     x_update_window_begin.  */
+     w32_update_window_begin.  */
   if (w32_use_visible_system_caret && w32_system_caret_hwnd)
     {
       SendMessageTimeout (w32_system_caret_hwnd, WM_EMACS_SHOW_CARET, 0, 0,
@@ -747,7 +663,7 @@ x_update_window_end (struct window *w, bool cursor_on_p,
    update_end.  */
 
 static void
-x_update_end (struct frame *f)
+w32_update_end (struct frame *f)
 {
   if (! FRAME_W32_P (f))
     return;
@@ -775,7 +691,7 @@ w32_frame_up_to_date (struct frame *f)
    between bitmaps to be drawn between current row and DESIRED_ROW.  */
 
 static void
-x_after_update_window_line (struct window *w, struct glyph_row *desired_row)
+w32_after_update_window_line (struct window *w, struct glyph_row *desired_row)
 {
   struct frame *f;
   int width, height;
@@ -942,27 +858,27 @@ w32_destroy_fringe_bitmap (int which)
 
 /* Function prototypes of this page.  */
 
-static void x_set_glyph_string_clipping (struct glyph_string *);
-static void x_set_glyph_string_gc (struct glyph_string *);
-static void x_draw_glyph_string_background (struct glyph_string *,
-                                            bool);
-static void x_draw_glyph_string_foreground (struct glyph_string *);
-static void x_draw_composite_glyph_string_foreground (struct glyph_string *);
-static void x_draw_glyph_string_box (struct glyph_string *);
-static void x_draw_glyph_string  (struct glyph_string *);
-static void x_set_cursor_gc (struct glyph_string *);
-static void x_set_mode_line_face_gc (struct glyph_string *);
-static void x_set_mouse_face_gc (struct glyph_string *);
+static void w32_set_glyph_string_clipping (struct glyph_string *);
+static void w32_set_glyph_string_gc (struct glyph_string *);
+static void w32_draw_glyph_string_background (struct glyph_string *,
+                                              bool);
+static void w32_draw_glyph_string_foreground (struct glyph_string *);
+static void w32_draw_composite_glyph_string_foreground (struct glyph_string *);
+static void w32_draw_glyph_string_box (struct glyph_string *);
+static void w32_draw_glyph_string  (struct glyph_string *);
+static void w32_set_cursor_gc (struct glyph_string *);
+static void w32_set_mode_line_face_gc (struct glyph_string *);
+static void w32_set_mouse_face_gc (struct glyph_string *);
 static int w32_alloc_lighter_color (struct frame *, COLORREF *, double, int);
 static void w32_setup_relief_color (struct frame *, struct relief *,
                                     double, int, COLORREF);
-static void x_setup_relief_colors (struct glyph_string *);
-static void x_draw_image_glyph_string (struct glyph_string *);
-static void x_draw_image_relief (struct glyph_string *);
-static void x_draw_image_foreground (struct glyph_string *);
+static void w32_setup_relief_colors (struct glyph_string *);
+static void w32_draw_image_glyph_string (struct glyph_string *);
+static void w32_draw_image_relief (struct glyph_string *);
+static void w32_draw_image_foreground (struct glyph_string *);
 static void w32_draw_image_foreground_1 (struct glyph_string *, HBITMAP);
-static void x_clear_glyph_string_rect (struct glyph_string *, int,
-                                       int, int, int);
+static void w32_clear_glyph_string_rect (struct glyph_string *, int,
+                                         int, int, int);
 static void w32_draw_relief_rect (struct frame *, int, int, int, int,
                                   int, int, int, int, int, int,
                                   RECT *);
@@ -974,7 +890,7 @@ static void w32_draw_box_rect (struct glyph_string *, int, int, int, int,
    face.  */
 
 static void
-x_set_cursor_gc (struct glyph_string *s)
+w32_set_cursor_gc (struct glyph_string *s)
 {
   if (s->font == FRAME_FONT (s->f)
       && s->face->background == FRAME_BACKGROUND_PIXEL (s->f)
@@ -988,38 +904,37 @@ x_set_cursor_gc (struct glyph_string *s)
   else
     {
       /* Cursor on non-default face: must merge.  */
-      XGCValues xgcv;
+      Emacs_GC egc;
       unsigned long mask;
 
-      xgcv.background = s->f->output_data.w32->cursor_pixel;
-      xgcv.foreground = s->face->background;
+      egc.background = s->f->output_data.w32->cursor_pixel;
+      egc.foreground = s->face->background;
 
       /* If the glyph would be invisible, try a different foreground.  */
-      if (xgcv.foreground == xgcv.background)
-	xgcv.foreground = s->face->foreground;
-      if (xgcv.foreground == xgcv.background)
-	xgcv.foreground = s->f->output_data.w32->cursor_foreground_pixel;
-      if (xgcv.foreground == xgcv.background)
-	xgcv.foreground = s->face->foreground;
+      if (egc.foreground == egc.background)
+	egc.foreground = s->face->foreground;
+      if (egc.foreground == egc.background)
+	egc.foreground = s->f->output_data.w32->cursor_foreground_pixel;
+      if (egc.foreground == egc.background)
+	egc.foreground = s->face->foreground;
 
       /* Make sure the cursor is distinct from text in this face.  */
-      if (xgcv.background == s->face->background
-	  && xgcv.foreground == s->face->foreground)
+      if (egc.background == s->face->background
+	  && egc.foreground == s->face->foreground)
 	{
-	  xgcv.background = s->face->foreground;
-	  xgcv.foreground = s->face->background;
+	  egc.background = s->face->foreground;
+	  egc.foreground = s->face->background;
 	}
 
-      IF_DEBUG (x_check_font (s->f, s->font));
-      xgcv.font = s->font;
-      mask = GCForeground | GCBackground | GCFont;
+      IF_DEBUG (w32_check_font (s->f, s->font));
+      mask = GCForeground | GCBackground;
 
       if (FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc)
 	XChangeGC (NULL, FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc,
-		   mask, &xgcv);
+		   mask, &egc);
       else
 	FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc
-	  = XCreateGC (NULL, FRAME_W32_WINDOW (s->f), mask, &xgcv);
+	  = XCreateGC (NULL, FRAME_W32_WINDOW (s->f), mask, &egc);
 
       s->gc = FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc;
     }
@@ -1029,7 +944,7 @@ x_set_cursor_gc (struct glyph_string *s)
 /* Set up S->gc of glyph string S for drawing text in mouse face.  */
 
 static void
-x_set_mouse_face_gc (struct glyph_string *s)
+w32_set_mouse_face_gc (struct glyph_string *s)
 {
   int face_id;
   struct face *face;
@@ -1054,21 +969,20 @@ x_set_mouse_face_gc (struct glyph_string *s)
     {
       /* Otherwise construct scratch_cursor_gc with values from FACE
 	 but font FONT.  */
-      XGCValues xgcv;
+      Emacs_GC egc;
       unsigned long mask;
 
-      xgcv.background = s->face->background;
-      xgcv.foreground = s->face->foreground;
-      IF_DEBUG (x_check_font (s->f, s->font));
-      xgcv.font = s->font;
-      mask = GCForeground | GCBackground | GCFont;
+      egc.background = s->face->background;
+      egc.foreground = s->face->foreground;
+      IF_DEBUG (w32_check_font (s->f, s->font));
+      mask = GCForeground | GCBackground;
 
       if (FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc)
 	XChangeGC (NULL, FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc,
-		   mask, &xgcv);
+		   mask, &egc);
       else
 	FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc
-	  = XCreateGC (NULL, FRAME_W32_WINDOW (s->f), mask, &xgcv);
+	  = XCreateGC (NULL, FRAME_W32_WINDOW (s->f), mask, &egc);
 
       s->gc = FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc;
     }
@@ -1082,7 +996,7 @@ x_set_mouse_face_gc (struct glyph_string *s)
    matrix was built, so there isn't much to do, here.  */
 
 static inline void
-x_set_mode_line_face_gc (struct glyph_string *s)
+w32_set_mode_line_face_gc (struct glyph_string *s)
 {
   s->gc = s->face->gc;
 }
@@ -1093,7 +1007,7 @@ x_set_mode_line_face_gc (struct glyph_string *s)
    pattern.  */
 
 static inline void
-x_set_glyph_string_gc (struct glyph_string *s)
+w32_set_glyph_string_gc (struct glyph_string *s)
 {
   prepare_face_for_display (s->f, s->face);
 
@@ -1104,17 +1018,17 @@ x_set_glyph_string_gc (struct glyph_string *s)
     }
   else if (s->hl == DRAW_INVERSE_VIDEO)
     {
-      x_set_mode_line_face_gc (s);
+      w32_set_mode_line_face_gc (s);
       s->stippled_p = s->face->stipple != 0;
     }
   else if (s->hl == DRAW_CURSOR)
     {
-      x_set_cursor_gc (s);
+      w32_set_cursor_gc (s);
       s->stippled_p = false;
     }
   else if (s->hl == DRAW_MOUSE_FACE)
     {
-      x_set_mouse_face_gc (s);
+      w32_set_mouse_face_gc (s);
       s->stippled_p = s->face->stipple != 0;
     }
   else if (s->hl == DRAW_IMAGE_RAISED
@@ -1135,7 +1049,7 @@ x_set_glyph_string_gc (struct glyph_string *s)
    line or menu if we don't have X toolkit support.  */
 
 static inline void
-x_set_glyph_string_clipping (struct glyph_string *s)
+w32_set_glyph_string_clipping (struct glyph_string *s)
 {
   RECT *r = s->clip;
   int n = get_glyph_string_clip_rects (s, r, 2);
@@ -1159,8 +1073,8 @@ x_set_glyph_string_clipping (struct glyph_string *s)
    the area of SRC.  */
 
 static void
-x_set_glyph_string_clipping_exactly (struct glyph_string *src,
-				     struct glyph_string *dst)
+w32_set_glyph_string_clipping_exactly (struct glyph_string *src,
+                                       struct glyph_string *dst)
 {
   RECT r;
 
@@ -1183,14 +1097,10 @@ w32_compute_glyph_string_overhangs (struct glyph_string *s)
       && s->first_glyph->type == CHAR_GLYPH
       && !s->font_not_found_p)
     {
-      unsigned *code = alloca (sizeof (unsigned) * s->nchars);
       struct font *font = s->font;
       struct font_metrics metrics;
-      int i;
 
-      for (i = 0; i < s->nchars; i++)
-	code[i] = s->char2b[i];
-      font->driver->text_extents (font, code, s->nchars, &metrics);
+      font->driver->text_extents (font, s->char2b, s->nchars, &metrics);
       s->right_overhang = (metrics.rbearing > metrics.width
 			   ? metrics.rbearing - metrics.width : 0);
       s->left_overhang = metrics.lbearing < 0 ? -metrics.lbearing : 0;
@@ -1205,7 +1115,7 @@ w32_compute_glyph_string_overhangs (struct glyph_string *s)
 /* Fill rectangle X, Y, W, H with background color of glyph string S.  */
 
 static inline void
-x_clear_glyph_string_rect (struct glyph_string *s,
+w32_clear_glyph_string_rect (struct glyph_string *s,
 			   int x, int y, int w, int h)
 {
   int real_x = x;
@@ -1236,7 +1146,7 @@ x_clear_glyph_string_rect (struct glyph_string *s,
    contains the first component of a composition.  */
 
 static void
-x_draw_glyph_string_background (struct glyph_string *s, bool force_p)
+w32_draw_glyph_string_background (struct glyph_string *s, bool force_p)
 {
   /* Nothing to do if background has already been drawn or if it
      shouldn't be drawn in the first place.  */
@@ -1268,7 +1178,7 @@ x_draw_glyph_string_background (struct glyph_string *s, bool force_p)
 	       || s->extends_to_end_of_line_p
 	       || force_p)
 	{
-	  x_clear_glyph_string_rect (s, s->x, s->y + box_line_width,
+	  w32_clear_glyph_string_rect (s, s->x, s->y + box_line_width,
 				     s->background_width,
 				     s->height - 2 * box_line_width);
 	  s->background_filled_p = true;
@@ -1280,7 +1190,7 @@ x_draw_glyph_string_background (struct glyph_string *s, bool force_p)
 /* Draw the foreground of glyph string S.  */
 
 static void
-x_draw_glyph_string_foreground (struct glyph_string *s)
+w32_draw_glyph_string_foreground (struct glyph_string *s)
 {
   int i, x;
 
@@ -1337,7 +1247,7 @@ x_draw_glyph_string_foreground (struct glyph_string *s)
 /* Draw the foreground of composite glyph string S.  */
 
 static void
-x_draw_composite_glyph_string_foreground (struct glyph_string *s)
+w32_draw_composite_glyph_string_foreground (struct glyph_string *s)
 {
   int i, j, x;
   struct font *font = s->font;
@@ -1432,10 +1342,10 @@ x_draw_composite_glyph_string_foreground (struct glyph_string *s)
 /* Draw the foreground of glyph string S for glyphless characters.  */
 
 static void
-x_draw_glyphless_glyph_string_foreground (struct glyph_string *s)
+w32_draw_glyphless_glyph_string_foreground (struct glyph_string *s)
 {
   struct glyph *glyph = s->first_glyph;
-  XChar2b char2b[8];
+  unsigned char2b[8];
   int x, i, j;
   bool with_background;
 
@@ -1492,16 +1402,12 @@ x_draw_glyphless_glyph_string_foreground (struct glyph_string *s)
 	{
 	  struct font *font = s->font;
 	  int upper_len = (len + 1) / 2;
-	  unsigned code;
 	  HFONT old_font;
 
 	  old_font = SelectObject (s->hdc, FONT_HANDLE (font));
 	  /* It is certain that all LEN characters in STR are ASCII.  */
 	  for (j = 0; j < len; j++)
-	    {
-	      code = font->driver->encode_char (font, str[j]);
-	      STORE_XCHAR2B (char2b + j, code >> 8, code & 0xFF);
-	    }
+            char2b[j] = font->driver->encode_char (font, str[j]) & 0xFFFF;
 	  font->driver->draw (s, 0, upper_len,
 			      x + glyph->slice.glyphless.upper_xoff,
 			      s->ybase + glyph->slice.glyphless.upper_yoff,
@@ -1598,8 +1504,8 @@ w32_alloc_lighter_color (struct frame *f, COLORREF *color,
 /* On frame F, translate pixel colors to RGB values for the NCOLORS
    colors in COLORS.  On W32, we no longer try to map colors to
    a palette.  */
-void
-x_query_colors (struct frame *f, XColor *colors, int ncolors)
+static void
+w32_query_colors (struct frame *f, Emacs_Color *colors, int ncolors)
 {
   int i;
 
@@ -1613,13 +1519,15 @@ x_query_colors (struct frame *f, XColor *colors, int ncolors)
     }
 }
 
-void
-x_query_color (struct frame *f, XColor *color)
+/* Store F's background color into *BGCOLOR.  */
+
+static void
+w32_query_frame_background_color (struct frame *f, Emacs_Color *bgcolor)
 {
-  x_query_colors (f, color, 1);
+  bgcolor->pixel = FRAME_BACKGROUND_PIXEL (f);
+  w32_query_colors (f, bgcolor, 1);
 }
 
-
 /* Set up the foreground color for drawing relief lines of glyph
    string S.  RELIEF is a pointer to a struct relief containing the GC
    with which lines will be drawn.  Use a color that is FACTOR or
@@ -1631,7 +1539,7 @@ static void
 w32_setup_relief_color (struct frame *f, struct relief *relief, double factor,
 			int delta, COLORREF default_pixel)
 {
-  XGCValues xgcv;
+  Emacs_GC egc;
   struct w32_output *di = f->output_data.w32;
   unsigned long mask = GCForeground;
   COLORREF pixel;
@@ -1643,29 +1551,28 @@ w32_setup_relief_color (struct frame *f, struct relief *relief, double factor,
   /* TODO: Free colors (if using palette)? */
 
   /* Allocate new color.  */
-  xgcv.foreground = default_pixel;
+  egc.foreground = default_pixel;
   pixel = background;
   if (w32_alloc_lighter_color (f, &pixel, factor, delta))
-    xgcv.foreground = relief->pixel = pixel;
+    egc.foreground = relief->pixel = pixel;
 
-  xgcv.font = NULL;	/* avoid compiler warnings */
   if (relief->gc == 0)
     {
 #if 0 /* TODO: stipple */
-      xgcv.stipple = dpyinfo->gray;
+      egc.stipple = dpyinfo->gray;
       mask |= GCStipple;
 #endif
-      relief->gc = XCreateGC (NULL, FRAME_W32_WINDOW (f), mask, &xgcv);
+      relief->gc = XCreateGC (NULL, FRAME_W32_WINDOW (f), mask, &egc);
     }
   else
-    XChangeGC (NULL, relief->gc, mask, &xgcv);
+    XChangeGC (NULL, relief->gc, mask, &egc);
 }
 
 
 /* Set up colors for the relief lines around glyph string S.  */
 
 static void
-x_setup_relief_colors (struct glyph_string *s)
+w32_setup_relief_colors (struct glyph_string *s)
 {
   struct w32_output *di = s->f->output_data.w32;
   COLORREF color;
@@ -1707,7 +1614,7 @@ w32_draw_relief_rect (struct frame *f,
 		      RECT *clip_rect)
 {
   int i;
-  XGCValues gc;
+  Emacs_GC gc;
   HDC hdc = get_frame_dc (f);
 
   if (raised_p)
@@ -1799,7 +1706,7 @@ w32_draw_box_rect (struct glyph_string *s,
 /* Draw a box around glyph string S.  */
 
 static void
-x_draw_glyph_string_box (struct glyph_string *s)
+w32_draw_glyph_string_box (struct glyph_string *s)
 {
   int width, left_x, right_x, top_y, bottom_y, last_x;
   bool left_p, right_p, raised_p;
@@ -1840,7 +1747,7 @@ x_draw_glyph_string_box (struct glyph_string *s)
                        left_p, right_p, &clip_rect);
   else
     {
-      x_setup_relief_colors (s);
+      w32_setup_relief_colors (s);
       w32_draw_relief_rect (s->f, left_x, top_y, right_x, bottom_y,
                             width, raised_p, 1, 1, left_p, right_p, &clip_rect);
     }
@@ -1850,7 +1757,7 @@ x_draw_glyph_string_box (struct glyph_string *s)
 /* Draw foreground of image glyph string S.  */
 
 static void
-x_draw_image_foreground (struct glyph_string *s)
+w32_draw_image_foreground (struct glyph_string *s)
 {
   int x = s->x;
   int y = s->ybase - image_ascent (s->img, s->face, &s->slice);
@@ -1881,7 +1788,7 @@ x_draw_image_foreground (struct glyph_string *s)
       DIBSECTION dib;
       SetBkColor (compat_hdc, RGB (255, 255, 255));
       SetTextColor (s->hdc, RGB (0, 0, 0));
-      x_set_glyph_string_clipping (s);
+      w32_set_glyph_string_clipping (s);
       /* Extract the original dimensions of the bitmap.  */
       if (GetObject (s->img->pixmap, sizeof (dib), &dib) > 0)
 	{
@@ -1891,7 +1798,7 @@ x_draw_image_foreground (struct glyph_string *s)
 	}
       else
 	{
-	  DebPrint (("x_draw_image_foreground: GetObject failed!\n"));
+	  DebPrint (("w32_draw_image_foreground: GetObject failed!\n"));
 	  orig_width = s->slice.width;
 	  orig_height = s->slice.height;
 	}
@@ -2008,7 +1915,7 @@ x_draw_image_foreground (struct glyph_string *s)
 /* Draw a relief around the image glyph string S.  */
 
 static void
-x_draw_image_relief (struct glyph_string *s)
+w32_draw_image_relief (struct glyph_string *s)
 {
   int x1, y1, thick, raised_p, top_p, bot_p, left_p, right_p;
   int extra_x, extra_y;
@@ -2071,7 +1978,7 @@ x_draw_image_relief (struct glyph_string *s)
   if (s->slice.y + s->slice.height == s->img->height)
     y1 += thick + extra_y, bot_p = 1;
 
-  x_setup_relief_colors (s);
+  w32_setup_relief_colors (s);
   get_glyph_string_clip_rect (s, &r);
   w32_draw_relief_rect (s->f, x, y, x1, y1, thick, raised_p,
 			top_p, bot_p, left_p, right_p, &r);
@@ -2104,7 +2011,7 @@ w32_draw_image_foreground_1 (struct glyph_string *s, HBITMAP pixmap)
 
   /* FIXME (maybe): The below doesn't support image scaling.  But it
      seems to never be called, because the conditions for its call in
-     x_draw_image_glyph_string are never fulfilled (they will be if
+     w32_draw_image_glyph_string are never fulfilled (they will be if
      the #ifdef'ed away part of that function is ever activated).  */
   if (s->img->pixmap)
     {
@@ -2172,7 +2079,7 @@ w32_draw_image_foreground_1 (struct glyph_string *s, HBITMAP pixmap)
    give the rectangle to draw.  */
 
 static void
-x_draw_glyph_string_bg_rect (struct glyph_string *s, int x, int y, int w, int h)
+w32_draw_glyph_string_bg_rect (struct glyph_string *s, int x, int y, int w, int h)
 {
 #if 0 /* TODO: stipple */
   if (s->stippled_p)
@@ -2184,7 +2091,7 @@ x_draw_glyph_string_bg_rect (struct glyph_string *s, int x, int y, int w, int h)
     }
   else
 #endif
-    x_clear_glyph_string_rect (s, x, y, w, h);
+    w32_clear_glyph_string_rect (s, x, y, w, h);
 }
 
 
@@ -2203,7 +2110,7 @@ x_draw_glyph_string_bg_rect (struct glyph_string *s, int x, int y, int w, int h)
  */
 
 static void
-x_draw_image_glyph_string (struct glyph_string *s)
+w32_draw_image_glyph_string (struct glyph_string *s)
 {
   int x, y;
   int box_line_hwidth = eabs (s->face->box_line_width);
@@ -2281,7 +2188,7 @@ x_draw_image_glyph_string (struct glyph_string *s)
 	}
       else
 #endif
-	x_draw_glyph_string_bg_rect (s, x, y, width, height);
+	w32_draw_glyph_string_bg_rect (s, x, y, width, height);
 
       s->background_filled_p = true;
     }
@@ -2290,7 +2197,7 @@ x_draw_image_glyph_string (struct glyph_string *s)
   if (pixmap != 0)
     {
       w32_draw_image_foreground_1 (s, pixmap);
-      x_set_glyph_string_clipping (s);
+      w32_set_glyph_string_clipping (s);
       {
         HDC compat_hdc = CreateCompatibleDC (s->hdc);
         HBRUSH fg_brush = CreateSolidBrush (s->gc->foreground);
@@ -2311,20 +2218,20 @@ x_draw_image_glyph_string (struct glyph_string *s)
       pixmap = 0;
     }
   else
-    x_draw_image_foreground (s);
+    w32_draw_image_foreground (s);
 
   /* If we must draw a relief around the image, do it.  */
   if (s->img->relief
       || s->hl == DRAW_IMAGE_RAISED
       || s->hl == DRAW_IMAGE_SUNKEN)
-    x_draw_image_relief (s);
+    w32_draw_image_relief (s);
 }
 
 
 /* Draw stretch glyph string S.  */
 
 static void
-x_draw_stretch_glyph_string (struct glyph_string *s)
+w32_draw_stretch_glyph_string (struct glyph_string *s)
 {
   eassert (s->first_glyph->type == STRETCH_GLYPH);
 
@@ -2361,12 +2268,12 @@ x_draw_stretch_glyph_string (struct glyph_string *s)
 	x -= width;
 
       /* Draw cursor.  */
-      x_draw_glyph_string_bg_rect (s, x, s->y, width, s->height);
+      w32_draw_glyph_string_bg_rect (s, x, s->y, width, s->height);
 
       /* Clear rest using the GC of the original non-cursor face.  */
       if (width < background_width)
 	{
-	  XGCValues *gc = s->face->gc;
+	  Emacs_GC *gc = s->face->gc;
 	  int y = s->y;
 	  int w = background_width - width, h = s->height;
 	  RECT r;
@@ -2379,7 +2286,7 @@ x_draw_stretch_glyph_string (struct glyph_string *s)
 	  if (s->row->mouse_face_p
 	      && cursor_in_mouse_face_p (s->w))
 	    {
-	      x_set_mouse_face_gc (s);
+	      w32_set_mouse_face_gc (s);
 	      gc = s->gc;
 	    }
 	  else
@@ -2416,7 +2323,7 @@ x_draw_stretch_glyph_string (struct glyph_string *s)
 	  x = left_x;
 	}
       if (background_width > 0)
-	x_draw_glyph_string_bg_rect (s, x, s->y, background_width, s->height);
+	w32_draw_glyph_string_bg_rect (s, x, s->y, background_width, s->height);
     }
 
   s->background_filled_p = true;
@@ -2426,7 +2333,7 @@ x_draw_stretch_glyph_string (struct glyph_string *s)
 /* Draw glyph string S.  */
 
 static void
-x_draw_glyph_string (struct glyph_string *s)
+w32_draw_glyph_string (struct glyph_string *s)
 {
   bool relief_drawn_p = 0;
 
@@ -2442,18 +2349,18 @@ x_draw_glyph_string (struct glyph_string *s)
            width += next->width, next = next->next)
         if (next->first_glyph->type != IMAGE_GLYPH)
           {
-            x_set_glyph_string_gc (next);
-            x_set_glyph_string_clipping (next);
+            w32_set_glyph_string_gc (next);
+            w32_set_glyph_string_clipping (next);
 	    if (next->first_glyph->type == STRETCH_GLYPH)
-	      x_draw_stretch_glyph_string (next);
+	      w32_draw_stretch_glyph_string (next);
 	    else
-	      x_draw_glyph_string_background (next, true);
+	      w32_draw_glyph_string_background (next, true);
             next->num_clips = 0;
           }
     }
 
   /* Set up S->gc, set clipping and draw S.  */
-  x_set_glyph_string_gc (s);
+  w32_set_glyph_string_gc (s);
 
   /* Draw relief (if any) in advance for char/composition so that the
      glyph string can be drawn over it.  */
@@ -2463,10 +2370,10 @@ x_draw_glyph_string (struct glyph_string *s)
 	  || s->first_glyph->type == COMPOSITE_GLYPH))
 
     {
-      x_set_glyph_string_clipping (s);
-      x_draw_glyph_string_background (s, true);
-      x_draw_glyph_string_box (s);
-      x_set_glyph_string_clipping (s);
+      w32_set_glyph_string_clipping (s);
+      w32_draw_glyph_string_background (s, true);
+      w32_draw_glyph_string_box (s);
+      w32_set_glyph_string_clipping (s);
       relief_drawn_p = 1;
     }
   else if (!s->clip_head /* draw_glyphs didn't specify a clip mask.  */
@@ -2476,26 +2383,26 @@ x_draw_glyph_string (struct glyph_string *s)
     /* We must clip just this glyph.  left_overhang part has already
        drawn when s->prev was drawn, and right_overhang part will be
        drawn later when s->next is drawn. */
-    x_set_glyph_string_clipping_exactly (s, s);
+    w32_set_glyph_string_clipping_exactly (s, s);
   else
-    x_set_glyph_string_clipping (s);
+    w32_set_glyph_string_clipping (s);
 
   switch (s->first_glyph->type)
     {
     case IMAGE_GLYPH:
-      x_draw_image_glyph_string (s);
+      w32_draw_image_glyph_string (s);
       break;
 
     case STRETCH_GLYPH:
-      x_draw_stretch_glyph_string (s);
+      w32_draw_stretch_glyph_string (s);
       break;
 
     case CHAR_GLYPH:
       if (s->for_overlaps)
 	s->background_filled_p = true;
       else
-        x_draw_glyph_string_background (s, false);
-      x_draw_glyph_string_foreground (s);
+        w32_draw_glyph_string_background (s, false);
+      w32_draw_glyph_string_foreground (s);
       break;
 
     case COMPOSITE_GLYPH:
@@ -2503,16 +2410,16 @@ x_draw_glyph_string (struct glyph_string *s)
 			      && ! s->first_glyph->u.cmp.automatic))
 	s->background_filled_p = true;
       else
-	x_draw_glyph_string_background (s, true);
-      x_draw_composite_glyph_string_foreground (s);
+	w32_draw_glyph_string_background (s, true);
+      w32_draw_composite_glyph_string_foreground (s);
       break;
 
     case GLYPHLESS_GLYPH:
       if (s->for_overlaps)
 	s->background_filled_p = true;
       else
-	x_draw_glyph_string_background (s, false);
-      x_draw_glyphless_glyph_string_foreground (s);
+	w32_draw_glyph_string_background (s, false);
+      w32_draw_glyphless_glyph_string_foreground (s);
       break;
 
     default:
@@ -2665,7 +2572,7 @@ x_draw_glyph_string (struct glyph_string *s)
 
       /* Draw relief if not yet drawn.  */
       if (!relief_drawn_p && s->face->box != FACE_NO_BOX)
-        x_draw_glyph_string_box (s);
+        w32_draw_glyph_string_box (s);
 
       if (s->prev)
         {
@@ -2680,12 +2587,12 @@ x_draw_glyph_string (struct glyph_string *s)
 		enum draw_glyphs_face save = prev->hl;
 
 		prev->hl = s->hl;
-		x_set_glyph_string_gc (prev);
-		x_set_glyph_string_clipping_exactly (s, prev);
+		w32_set_glyph_string_gc (prev);
+		w32_set_glyph_string_clipping_exactly (s, prev);
 		if (prev->first_glyph->type == CHAR_GLYPH)
-		  x_draw_glyph_string_foreground (prev);
+		  w32_draw_glyph_string_foreground (prev);
 		else
-		  x_draw_composite_glyph_string_foreground (prev);
+		  w32_draw_composite_glyph_string_foreground (prev);
                 w32_set_clip_rectangle (prev->hdc, NULL);
 		prev->hl = save;
 		prev->num_clips = 0;
@@ -2705,12 +2612,12 @@ x_draw_glyph_string (struct glyph_string *s)
 		enum draw_glyphs_face save = next->hl;
 
 		next->hl = s->hl;
-		x_set_glyph_string_gc (next);
-		x_set_glyph_string_clipping_exactly (s, next);
+		w32_set_glyph_string_gc (next);
+		w32_set_glyph_string_clipping_exactly (s, next);
 		if (next->first_glyph->type == CHAR_GLYPH)
-		  x_draw_glyph_string_foreground (next);
+		  w32_draw_glyph_string_foreground (next);
 		else
-		  x_draw_composite_glyph_string_foreground (next);
+		  w32_draw_composite_glyph_string_foreground (next);
                 w32_set_clip_rectangle (next->hdc, NULL);
 		next->hl = save;
 		next->num_clips = 0;
@@ -2745,7 +2652,7 @@ w32_shift_glyphs_for_insert (struct frame *f, int x, int y,
    for X frames.  */
 
 static void
-x_delete_glyphs (struct frame *f, register int n)
+w32_delete_glyphs (struct frame *f, register int n)
 {
   if (! FRAME_W32_P (f))
     return;
@@ -2757,7 +2664,7 @@ x_delete_glyphs (struct frame *f, register int n)
 /* Clear entire frame.  */
 
 static void
-x_clear_frame (struct frame *f)
+w32_clear_frame (struct frame *f)
 {
   if (! FRAME_W32_P (f))
     return;
@@ -2772,7 +2679,7 @@ x_clear_frame (struct frame *f)
 
   /* We have to clear the scroll bars, too.  If we have changed
      colors or something like that, then they should be notified.  */
-  x_scroll_bar_clear (f);
+  w32_scroll_bar_clear (f);
 
   unblock_input ();
 }
@@ -2811,7 +2718,7 @@ w32_ring_bell (struct frame *f)
    lines or deleting -N lines at vertical position VPOS.  */
 
 static void
-x_ins_del_lines (struct frame *f, int vpos, int n)
+w32_ins_del_lines (struct frame *f, int vpos, int n)
 {
   if (! FRAME_W32_P (f))
     return;
@@ -2823,7 +2730,7 @@ x_ins_del_lines (struct frame *f, int vpos, int n)
 /* Scroll part of the display as described by RUN.  */
 
 static void
-x_scroll_run (struct window *w, struct run *run)
+w32_scroll_run (struct window *w, struct run *run)
 {
   struct frame *f = XFRAME (w->frame);
   int x, y, width, height, from_y, to_y, bottom_y;
@@ -2862,8 +2769,8 @@ x_scroll_run (struct window *w, struct run *run)
 
   block_input ();
 
-  /* Cursor off.  Will be switched on again in x_update_window_end.  */
-  x_clear_cursor (w);
+  /* Cursor off.  Will be switched on again in gui_update_window_end.  */
+  gui_clear_cursor (w);
 
   {
     RECT from;
@@ -2904,17 +2811,17 @@ x_scroll_run (struct window *w, struct run *run)
  ***********************************************************************/
 
 static void
-frame_highlight (struct frame *f)
+w32_frame_highlight (struct frame *f)
 {
-  x_update_cursor (f, 1);
-  x_set_frame_alpha (f);
+  gui_update_cursor (f, 1);
+  w32_set_frame_alpha (f);
 }
 
 static void
-frame_unhighlight (struct frame *f)
+w32_frame_unhighlight (struct frame *f)
 {
-  x_update_cursor (f, 1);
-  x_set_frame_alpha (f);
+  gui_update_cursor (f, 1);
+  w32_set_frame_alpha (f);
 }
 
 /* The focus has changed.  Update the frames as necessary to reflect
@@ -2924,7 +2831,7 @@ frame_unhighlight (struct frame *f)
    Lisp code can tell when the switch took place by examining the events.  */
 
 static void
-x_new_focus_frame (struct w32_display_info *dpyinfo, struct frame *frame)
+w32_new_focus_frame (struct w32_display_info *dpyinfo, struct frame *frame)
 {
   struct frame *old_focus = dpyinfo->w32_focus_frame;
 
@@ -2935,7 +2842,7 @@ x_new_focus_frame (struct w32_display_info *dpyinfo, struct frame *frame)
       dpyinfo->w32_focus_frame = frame;
 
       if (old_focus && old_focus->auto_lower)
-	x_lower_frame (old_focus);
+	w32_lower_frame (old_focus);
 
       if (dpyinfo->w32_focus_frame && dpyinfo->w32_focus_frame->auto_raise)
 	dpyinfo->w32_pending_autoraise_frame = dpyinfo->w32_focus_frame;
@@ -2943,7 +2850,7 @@ x_new_focus_frame (struct w32_display_info *dpyinfo, struct frame *frame)
 	dpyinfo->w32_pending_autoraise_frame = NULL;
     }
 
-  x_frame_rehighlight (dpyinfo);
+  w32_frame_rehighlight_1 (dpyinfo);
 }
 
 
@@ -2952,14 +2859,14 @@ x_new_focus_frame (struct w32_display_info *dpyinfo, struct frame *frame)
    a FOCUS_IN_EVENT into *BUFP.  */
 
 static void
-x_focus_changed (int type, int state, struct w32_display_info *dpyinfo,
+w32_focus_changed (int type, int state, struct w32_display_info *dpyinfo,
 		 struct frame *frame, struct input_event *bufp)
 {
   if (type == WM_SETFOCUS)
     {
       if (dpyinfo->w32_focus_event_frame != frame)
         {
-          x_new_focus_frame (dpyinfo, frame);
+          w32_new_focus_frame (dpyinfo, frame);
           dpyinfo->w32_focus_event_frame = frame;
           bufp->kind = FOCUS_IN_EVENT;
           XSETFRAME (bufp->frame_or_window, frame);
@@ -2976,7 +2883,7 @@ x_focus_changed (int type, int state, struct w32_display_info *dpyinfo,
       if (dpyinfo->w32_focus_event_frame == frame)
         {
           dpyinfo->w32_focus_event_frame = 0;
-          x_new_focus_frame (dpyinfo, 0);
+          w32_new_focus_frame (dpyinfo, 0);
 
           bufp->kind = FOCUS_OUT_EVENT;
           XSETFRAME (bufp->frame_or_window, frame);
@@ -2998,15 +2905,15 @@ w32_detect_focus_change (struct w32_display_info *dpyinfo, W32Msg *event,
 {
   struct frame *frame;
 
-  frame = x_any_window_to_frame (dpyinfo, event->msg.hwnd);
+  frame = w32_window_to_frame (dpyinfo, event->msg.hwnd);
   if (! frame)
     return;
 
   /* On w32, this is only called from focus events, so no switch needed.  */
-  x_focus_changed (event->msg.message,
-		   (event->msg.message == WM_KILLFOCUS ?
-		    FOCUS_IMPLICIT : FOCUS_EXPLICIT),
-		   dpyinfo, frame, bufp);
+  w32_focus_changed (event->msg.message,
+                     (event->msg.message == WM_KILLFOCUS ?
+                      FOCUS_IMPLICIT : FOCUS_EXPLICIT),
+                     dpyinfo, frame, bufp);
 }
 
 
@@ -3014,9 +2921,9 @@ w32_detect_focus_change (struct w32_display_info *dpyinfo, W32Msg *event,
 /* Handle an event saying the mouse has moved out of an Emacs frame.  */
 
 static void
-x_mouse_leave (struct w32_display_info *dpyinfo)
+w32_mouse_leave (struct w32_display_info *dpyinfo)
 {
-  x_new_focus_frame (dpyinfo, dpyinfo->w32_focus_event_frame);
+  w32_new_focus_frame (dpyinfo, dpyinfo->w32_focus_event_frame);
 }
 #endif
 
@@ -3033,35 +2940,35 @@ w32_frame_rehighlight (struct frame *frame)
 {
   if (! FRAME_W32_P (frame))
     return;
-  x_frame_rehighlight (FRAME_DISPLAY_INFO (frame));
+  w32_frame_rehighlight_1 (FRAME_DISPLAY_INFO (frame));
 }
 
 static void
-x_frame_rehighlight (struct w32_display_info *dpyinfo)
+w32_frame_rehighlight_1 (struct w32_display_info *dpyinfo)
 {
-  struct frame *old_highlight = dpyinfo->x_highlight_frame;
+  struct frame *old_highlight = dpyinfo->highlight_frame;
 
   if (dpyinfo->w32_focus_frame)
     {
-      dpyinfo->x_highlight_frame
+      dpyinfo->highlight_frame
 	= ((FRAMEP (FRAME_FOCUS_FRAME (dpyinfo->w32_focus_frame)))
 	   ? XFRAME (FRAME_FOCUS_FRAME (dpyinfo->w32_focus_frame))
 	   : dpyinfo->w32_focus_frame);
-      if (! FRAME_LIVE_P (dpyinfo->x_highlight_frame))
+      if (! FRAME_LIVE_P (dpyinfo->highlight_frame))
 	{
 	  fset_focus_frame (dpyinfo->w32_focus_frame, Qnil);
-	  dpyinfo->x_highlight_frame = dpyinfo->w32_focus_frame;
+	  dpyinfo->highlight_frame = dpyinfo->w32_focus_frame;
 	}
     }
   else
-    dpyinfo->x_highlight_frame = 0;
+    dpyinfo->highlight_frame = 0;
 
-  if (dpyinfo->x_highlight_frame != old_highlight)
+  if (dpyinfo->highlight_frame != old_highlight)
     {
       if (old_highlight)
-	frame_unhighlight (old_highlight);
-      if (dpyinfo->x_highlight_frame)
-	frame_highlight (dpyinfo->x_highlight_frame);
+	w32_frame_unhighlight (old_highlight);
+      if (dpyinfo->highlight_frame)
+	w32_frame_highlight (dpyinfo->highlight_frame);
     }
 }
 
@@ -3070,7 +2977,7 @@ x_frame_rehighlight (struct w32_display_info *dpyinfo)
 /* Convert a keysym to its name.  */
 
 char *
-x_get_keysym_name (int keysym)
+get_keysym_name (int keysym)
 {
   /* Make static so we can always return it */
   static char value[100];
@@ -3168,7 +3075,8 @@ parse_button (int message, int xbutton, int * pbutton, int * pup)
    the mouse.  */
 
 static Lisp_Object
-construct_mouse_click (struct input_event *result, W32Msg *msg, struct frame *f)
+w32_construct_mouse_click (struct input_event *result, W32Msg *msg,
+                           struct frame *f)
 {
   int button = 0;
   int up = 0;
@@ -3194,7 +3102,8 @@ construct_mouse_click (struct input_event *result, W32Msg *msg, struct frame *f)
 }
 
 static Lisp_Object
-construct_mouse_wheel (struct input_event *result, W32Msg *msg, struct frame *f)
+w32_construct_mouse_wheel (struct input_event *result, W32Msg *msg,
+                           struct frame *f)
 {
   POINT p;
   int delta;
@@ -3228,7 +3137,8 @@ construct_mouse_wheel (struct input_event *result, W32Msg *msg, struct frame *f)
 }
 
 static Lisp_Object
-construct_drag_n_drop (struct input_event *result, W32Msg *msg, struct frame *f)
+w32_construct_drag_n_drop (struct input_event *result, W32Msg *msg,
+                           struct frame *f)
 {
   Lisp_Object files;
   Lisp_Object frame;
@@ -3307,7 +3217,7 @@ construct_drag_n_drop (struct input_event *result, W32Msg *msg, struct frame *f)
 /* File event notifications (see w32notify.c).  */
 
 Lisp_Object
-lispy_file_action (DWORD action)
+w32_lispy_file_action (DWORD action)
 {
   static char unknown_fmt[] = "unknown-action(%d)";
   Lisp_Object retval;
@@ -3347,8 +3257,8 @@ lispy_file_action (DWORD action)
    function runs when the WM_EMACS_FILENOTIFY message arrives from a
    watcher thread.  */
 static void
-queue_notifications (struct input_event *event, W32Msg *msg, struct frame *f,
-		     int *evcount)
+w32_queue_notifications (struct input_event *event, W32Msg *msg,
+                         struct frame *f, int *evcount)
 {
   struct notifications_set *ns = NULL;
   Lisp_Object frame;
@@ -3407,7 +3317,7 @@ queue_notifications (struct input_event *event, W32Msg *msg, struct frame *f,
 		     already be defined at this point.  */
 		  Lisp_Object fname
 		    = code_convert_string_norecord (utf_16_fn, cs, 0);
-		  Lisp_Object action = lispy_file_action (fni->Action);
+		  Lisp_Object action = w32_lispy_file_action (fni->Action);
 
 		  event->kind = FILE_NOTIFY_EVENT;
 		  event->timestamp = msg->msg.time;
@@ -3445,14 +3355,14 @@ queue_notifications (struct input_event *event, W32Msg *msg, struct frame *f,
    another motion event, so we can check again the next time it moves.  */
 
 static int
-note_mouse_movement (struct frame *frame, MSG *msg)
+w32_note_mouse_movement (struct frame *frame, MSG *msg)
 {
   struct w32_display_info *dpyinfo;
   int mouse_x = LOWORD (msg->lParam);
   int mouse_y = HIWORD (msg->lParam);
   RECT *r;
 
-  if (!FRAME_X_OUTPUT (frame))
+  if (!FRAME_OUTPUT_DATA (frame))
     return 0;
 
   dpyinfo = FRAME_DISPLAY_INFO (frame);
@@ -3496,17 +3406,17 @@ note_mouse_movement (struct frame *frame, MSG *msg)
 			      Mouse Face
  ************************************************************************/
 
-static struct scroll_bar *x_window_to_scroll_bar (Window, int);
-static void x_scroll_bar_report_motion (struct frame **, Lisp_Object *,
-					enum scroll_bar_part *,
-					Lisp_Object *, Lisp_Object *,
-					Time *);
-static void x_horizontal_scroll_bar_report_motion (struct frame **, Lisp_Object *,
-						   enum scroll_bar_part *,
-						   Lisp_Object *, Lisp_Object *,
-						   Time *);
+static struct scroll_bar *w32_window_to_scroll_bar (Window, int);
+static void w32_scroll_bar_report_motion (struct frame **, Lisp_Object *,
+                                          enum scroll_bar_part *,
+                                          Lisp_Object *, Lisp_Object *,
+                                          Time *);
+static void w32_horizontal_scroll_bar_report_motion (struct frame **, Lisp_Object *,
+                                                     enum scroll_bar_part *,
+                                                     Lisp_Object *, Lisp_Object *,
+                                                     Time *);
 static void
-w32_define_cursor (Window window, Cursor cursor)
+w32_define_cursor (Window window, Emacs_Cursor cursor)
 {
   PostMessage (window, WM_EMACS_SETCURSOR, (WPARAM) cursor, 0);
 }
@@ -3545,9 +3455,9 @@ w32_mouse_position (struct frame **fp, int insist, Lisp_Object *bar_window,
       struct scroll_bar *bar = dpyinfo->last_mouse_scroll_bar;
 
       if (bar->horizontal)
-	x_horizontal_scroll_bar_report_motion (fp, bar_window, part, x, y, time);
+	w32_horizontal_scroll_bar_report_motion (fp, bar_window, part, x, y, time);
       else
-	x_scroll_bar_report_motion (fp, bar_window, part, x, y, time);
+	w32_scroll_bar_report_motion (fp, bar_window, part, x, y, time);
     }
   else
     {
@@ -3569,7 +3479,7 @@ w32_mouse_position (struct frame **fp, int insist, Lisp_Object *bar_window,
 	/* If mouse was grabbed on a frame, give coords for that
 	   frame even if the mouse is now outside it.  Otherwise
 	   check for window under mouse on one of our frames.  */
-	if (x_mouse_grabbed (dpyinfo))
+	if (gui_mouse_grabbed (dpyinfo))
 	  f1 = dpyinfo->last_mouse_frame;
 	else
 	  {
@@ -3577,14 +3487,14 @@ w32_mouse_position (struct frame **fp, int insist, Lisp_Object *bar_window,
 
 	    if (wfp)
 	      {
-		f1 = x_any_window_to_frame (dpyinfo, wfp);
+		f1 = w32_window_to_frame (dpyinfo, wfp);
 		if (f1)
 		  {
 		    HWND cwfp = ChildWindowFromPoint (wfp, pt);
 
 		    if (cwfp)
 		      {
-			struct frame *f2 = x_any_window_to_frame (dpyinfo, cwfp);
+			struct frame *f2 = w32_window_to_frame (dpyinfo, cwfp);
 
 			/* If a child window was found, make sure that its
 			   frame is a child frame (Bug#26615, maybe).  */
@@ -3599,7 +3509,7 @@ w32_mouse_position (struct frame **fp, int insist, Lisp_Object *bar_window,
 	if (! f1)
 	  {
 	    struct scroll_bar *bar
-              = x_window_to_scroll_bar (WindowFromPoint (pt), 2);
+              = w32_window_to_scroll_bar (WindowFromPoint (pt), 2);
 
 	    if (bar)
 	      f1 = XFRAME (WINDOW_FRAME (XWINDOW (bar->window)));
@@ -3671,7 +3581,7 @@ w32_handle_tool_bar_click (struct frame *f, struct input_event *button_event)
    strip off mark bits.  */
 
 static struct scroll_bar *
-x_window_to_scroll_bar (Window window_id, int type)
+w32_window_to_scroll_bar (Window window_id, int type)
 {
   Lisp_Object tail, frame;
 
@@ -3890,7 +3800,8 @@ my_bring_window_to_top (HWND hwnd)
    scroll bar. */
 
 static struct scroll_bar *
-x_scroll_bar_create (struct window *w, int left, int top, int width, int height, bool horizontal)
+w32_scroll_bar_create (struct window *w, int left, int top,
+                       int width, int height, bool horizontal)
 {
   struct frame *f = XFRAME (WINDOW_FRAME (w));
   HWND hwnd;
@@ -3952,7 +3863,7 @@ x_scroll_bar_create (struct window *w, int left, int top, int width, int height,
    nil. */
 
 static void
-x_scroll_bar_remove (struct scroll_bar *bar)
+w32_scroll_bar_remove (struct scroll_bar *bar)
 {
   struct frame *f = XFRAME (WINDOW_FRAME (XWINDOW (bar->window)));
 
@@ -4006,7 +3917,7 @@ w32_set_vertical_scroll_bar (struct window *w,
 	}
       unblock_input ();
 
-      bar = x_scroll_bar_create (w, left, top, width, height, false);
+      bar = w32_scroll_bar_create (w, left, top, width, height, false);
     }
   else
     {
@@ -4039,7 +3950,7 @@ w32_set_vertical_scroll_bar (struct window *w,
 		 for them on the frame, we have to clear "under" them.  */
 	      w32_clear_area (f, hdc, left, top, width, height);
 	      release_frame_dc (f, hdc);
-	      x_clear_under_internal_border (f);
+	      w32_clear_under_internal_border (f);
 	    }
           /* Make sure scroll bar is "visible" before moving, to ensure the
              area of the parent window now exposed will be refreshed.  */
@@ -4110,7 +4021,7 @@ w32_set_horizontal_scroll_bar (struct window *w,
 	}
       unblock_input ();
 
-      bar = x_scroll_bar_create (w, left, top, width, height, true);
+      bar = w32_scroll_bar_create (w, left, top, width, height, true);
     }
   else
     {
@@ -4141,7 +4052,7 @@ w32_set_horizontal_scroll_bar (struct window *w,
 		 for them on the frame, we have to clear "under" them.  */
 	      w32_clear_area (f, hdc, clear_left, top, clear_width, height);
 	      release_frame_dc (f, hdc);
-	      x_clear_under_internal_border (f);
+	      w32_clear_under_internal_border (f);
 	    }
           /* Make sure scroll bar is "visible" before moving, to ensure the
              area of the parent window now exposed will be refreshed.  */
@@ -4316,7 +4227,7 @@ w32_judge_scroll_bars (struct frame *f)
     {
       struct scroll_bar *b = XSCROLL_BAR (bar);
 
-      x_scroll_bar_remove (b);
+      w32_scroll_bar_remove (b);
 
       next = b->next;
       b->next = b->prev = Qnil;
@@ -4560,7 +4471,7 @@ w32_horizontal_scroll_bar_handle_click (struct scroll_bar *bar, W32Msg *msg,
 /* Return information to the user about the current position of the mouse
    on the vertical scroll bar.  */
 static void
-x_scroll_bar_report_motion (struct frame **fp, Lisp_Object *bar_window,
+w32_scroll_bar_report_motion (struct frame **fp, Lisp_Object *bar_window,
 			    enum scroll_bar_part *part,
 			    Lisp_Object *x, Lisp_Object *y,
 			    Time *time)
@@ -4610,10 +4521,10 @@ x_scroll_bar_report_motion (struct frame **fp, Lisp_Object *bar_window,
 /* Return information to the user about the current position of the mouse
    on the horizontal scroll bar.  */
 static void
-x_horizontal_scroll_bar_report_motion (struct frame **fp, Lisp_Object *bar_window,
-				       enum scroll_bar_part *part,
-				       Lisp_Object *x, Lisp_Object *y,
-				       Time *time)
+w32_horizontal_scroll_bar_report_motion (struct frame **fp, Lisp_Object *bar_window,
+                                         enum scroll_bar_part *part,
+                                         Lisp_Object *x, Lisp_Object *y,
+                                         Time *time)
 {
   struct w32_display_info *dpyinfo = FRAME_DISPLAY_INFO (*fp);
   struct scroll_bar *bar = dpyinfo->last_mouse_scroll_bar;
@@ -4664,8 +4575,8 @@ x_horizontal_scroll_bar_report_motion (struct frame **fp, Lisp_Object *bar_windo
    Clear out the scroll bars, and ask for expose events, so we can
    redraw them.  */
 
-void
-x_scroll_bar_clear (struct frame *f)
+static void
+w32_scroll_bar_clear (struct frame *f)
 {
   Lisp_Object bar;
 
@@ -4688,7 +4599,7 @@ x_scroll_bar_clear (struct frame *f)
         GetClientRect (window, &rect);
         select_palette (f, hdc);
         w32_clear_rect (f, hdc, &rect);
-	x_clear_under_internal_border (f);
+	w32_clear_under_internal_border (f);
         deselect_palette (f, hdc);
 
         ReleaseDC (window, hdc);
@@ -4760,7 +4671,7 @@ w32_read_socket (struct terminal *terminal,
       switch (msg.msg.message)
 	{
 	case WM_EMACS_PAINT:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f)
 	    {
@@ -4815,14 +4726,14 @@ w32_read_socket (struct terminal *terminal,
 				msg.rect.top,
 				msg.rect.right - msg.rect.left,
 				msg.rect.bottom - msg.rect.top);
-		  x_clear_under_internal_border (f);
+		  w32_clear_under_internal_border (f);
 		}
 	    }
 	  break;
 
 	case WM_INPUTLANGCHANGE:
 	  /* Generate a language change event.  */
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  /* lParam contains the input language ID in its low 16 bits.
 	     Use it to update our record of the keyboard codepage.  */
@@ -4840,7 +4751,7 @@ w32_read_socket (struct terminal *terminal,
 
 	case WM_KEYDOWN:
 	case WM_SYSKEYDOWN:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f && !FRAME_ICONIFIED_P (f))
 	    {
@@ -4865,7 +4776,7 @@ w32_read_socket (struct terminal *terminal,
         case WM_UNICHAR:
 	case WM_SYSCHAR:
 	case WM_CHAR:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f && !FRAME_ICONIFIED_P (f))
 	    {
@@ -4943,7 +4854,7 @@ w32_read_socket (struct terminal *terminal,
 	  break;
 
         case WM_APPCOMMAND:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f && !FRAME_ICONIFIED_P (f))
 	    {
@@ -4979,8 +4890,8 @@ w32_read_socket (struct terminal *terminal,
           previous_help_echo_string = help_echo_string;
 	  help_echo_string = Qnil;
 
-	  f = (x_mouse_grabbed (dpyinfo) ? dpyinfo->last_mouse_frame
-	       : x_window_to_frame (dpyinfo, msg.msg.hwnd));
+	  f = (gui_mouse_grabbed (dpyinfo) ? dpyinfo->last_mouse_frame
+	       : w32_window_to_frame (dpyinfo, msg.msg.hwnd));
 
 	  if (hlinfo->mouse_face_hidden)
 	    {
@@ -5020,7 +4931,7 @@ w32_read_socket (struct terminal *terminal,
 		  last_mouse_window = window;
 		}
 
-	      if (!note_mouse_movement (f, &msg.msg))
+	      if (!w32_note_mouse_movement (f, &msg.msg))
 		help_echo_string = previous_help_echo_string;
 	    }
 	  else
@@ -5059,12 +4970,12 @@ w32_read_socket (struct terminal *terminal,
 	    int button = 0;
 	    int up = 0;
 
-	    f = (x_mouse_grabbed (dpyinfo) ? dpyinfo->last_mouse_frame
-		 : x_window_to_frame (dpyinfo, msg.msg.hwnd));
+	    f = (gui_mouse_grabbed (dpyinfo) ? dpyinfo->last_mouse_frame
+		 : w32_window_to_frame (dpyinfo, msg.msg.hwnd));
 
 	    if (f)
 	      {
-                construct_mouse_click (&inev, &msg, f);
+                w32_construct_mouse_click (&inev, &msg, f);
 
                 /* Is this in the tool-bar?  */
                 if (WINDOWP (f->tool_bar_window)
@@ -5120,8 +5031,8 @@ w32_read_socket (struct terminal *terminal,
 	case WM_MOUSEWHEEL:
         case WM_MOUSEHWHEEL:
 	  {
-	    f = (x_mouse_grabbed (dpyinfo) ? dpyinfo->last_mouse_frame
-		 : x_window_to_frame (dpyinfo, msg.msg.hwnd));
+	    f = (gui_mouse_grabbed (dpyinfo) ? dpyinfo->last_mouse_frame
+		 : w32_window_to_frame (dpyinfo, msg.msg.hwnd));
 
 	    if (f)
 	      {
@@ -5129,7 +5040,7 @@ w32_read_socket (struct terminal *terminal,
 		    || f == dpyinfo->w32_focus_frame)
 		  /* Emit an Emacs wheel-up/down event.  */
 		  {
-		    construct_mouse_wheel (&inev, &msg, f);
+		    w32_construct_mouse_wheel (&inev, &msg, f);
 
 		    /* Ignore any mouse motion that happened before this
 		       event; any subsequent mouse-movement Emacs events
@@ -5139,14 +5050,14 @@ w32_read_socket (struct terminal *terminal,
 		    dpyinfo->last_mouse_frame = f;
 		  }
 		else if (FRAME_NO_ACCEPT_FOCUS (f)
-			 && !x_mouse_grabbed (dpyinfo))
+			 && !gui_mouse_grabbed (dpyinfo))
 		  {
 		    Lisp_Object frame1 = get_frame_param (f, Qmouse_wheel_frame);
 		    struct frame *f1 = FRAMEP (frame1) ? XFRAME (frame1) : NULL;
 
 		    if (f1 && FRAME_LIVE_P (f1) && FRAME_W32_P (f1))
 		      {
-			construct_mouse_wheel (&inev, &msg, f1);
+			w32_construct_mouse_wheel (&inev, &msg, f1);
 			f1->mouse_moved = false;
 			f1->last_tool_bar_item = -1;
 			dpyinfo->last_mouse_frame = f1;
@@ -5163,16 +5074,16 @@ w32_read_socket (struct terminal *terminal,
 	  break;
 
 	case WM_DROPFILES:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f)
-	    construct_drag_n_drop (&inev, &msg, f);
+	    w32_construct_drag_n_drop (&inev, &msg, f);
 	  break;
 
 	case WM_HSCROLL:
 	  {
 	    struct scroll_bar *bar =
-	      x_window_to_scroll_bar ((HWND)msg.msg.lParam, 1);
+	      w32_window_to_scroll_bar ((HWND)msg.msg.lParam, 1);
 
 	    if (bar)
 	      w32_horizontal_scroll_bar_handle_click (bar, &msg, &inev);
@@ -5182,7 +5093,7 @@ w32_read_socket (struct terminal *terminal,
 	case WM_VSCROLL:
 	  {
 	    struct scroll_bar *bar =
-	      x_window_to_scroll_bar ((HWND)msg.msg.lParam, 0);
+	      w32_window_to_scroll_bar ((HWND)msg.msg.lParam, 0);
 
 	    if (bar)
 	      w32_scroll_bar_handle_click (bar, &msg, &inev);
@@ -5190,7 +5101,7 @@ w32_read_socket (struct terminal *terminal,
 	  }
 
 	case WM_WINDOWPOSCHANGED:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f)
 	    {
@@ -5237,13 +5148,13 @@ w32_read_socket (struct terminal *terminal,
 
 	case WM_ACTIVATE:
 	case WM_ACTIVATEAPP:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 	  if (f)
 	    {
 	      /* Run the full-screen hook function also when we are
 		 being activated, to actually install the required
 		 size in effect, if the WAIT flag is set.  This is
-		 because when the hook is run from x_set_fullscreen,
+		 because when the hook is run from gui_set_fullscreen,
 		 the frame might not yet be visible, if that call is a
 		 result of make-frame, and in that case the hook just
 		 sets the WAIT flag.  */
@@ -5261,11 +5172,11 @@ w32_read_socket (struct terminal *terminal,
 	  break;
 
 	case WM_MOVE:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f && FRAME_VISIBLE_P (f) && !FRAME_ICONIFIED_P(f))
 	    {
-	      x_real_positions (f, &f->left_pos, &f->top_pos);
+	      w32_real_positions (f, &f->left_pos, &f->top_pos);
 	      inev.kind = MOVE_FRAME_EVENT;
 	      XSETFRAME (inev.frame_or_window, f);
 	    }
@@ -5280,7 +5191,7 @@ w32_read_socket (struct terminal *terminal,
 	  if (!msg.msg.wParam && msg.msg.hwnd == tip_window)
 	    {
 	      tip_window = NULL;
-	      x_redo_mouse_highlight (dpyinfo);
+	      gui_redo_mouse_highlight (dpyinfo);
 	    }
 
 	  /* If window has been obscured or exposed by another window
@@ -5292,20 +5203,20 @@ w32_read_socket (struct terminal *terminal,
 	    check_visibility = 1;
 	  else
 	    {
-	      f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	      f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 	      f->async_visible = msg.msg.wParam;
 	    }
 #endif
 
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 	  if (f)
-	    x_clear_under_internal_border (f);
+	    w32_clear_under_internal_border (f);
 
 	  check_visibility = 1;
 	  break;
 
 	case WM_SIZE:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  /* Inform lisp of whether frame has been iconified etc. */
 	  if (f)
@@ -5341,7 +5252,7 @@ w32_read_socket (struct terminal *terminal,
 			   BEFORE telling us the Window is minimized
 			   when the Window is iconified, with 3000,3000
 			   as the co-ords. */
-			x_real_positions (f, &x, &y);
+			w32_real_positions (f, &x, &y);
 			f->left_pos = x;
 			f->top_pos = y;
 
@@ -5365,7 +5276,7 @@ w32_read_socket (struct terminal *terminal,
 		      {
 			int x, y;
 
-			x_real_positions (f, &x, &y);
+			w32_real_positions (f, &x, &y);
 			if (x < 0 && y < 0)
 			  store_frame_param (f, Qfullscreen, Qmaximized);
 		      }
@@ -5396,7 +5307,7 @@ w32_read_socket (struct terminal *terminal,
 			   BEFORE telling us the Window is minimized
 			   when the Window is iconified, with 3000,3000
 			   as the co-ords.  */
-			x_real_positions (f, &f->left_pos, &f->top_pos);
+			w32_real_positions (f, &f->left_pos, &f->top_pos);
 
 			inev.kind = DEICONIFY_EVENT;
 			XSETFRAME (inev.frame_or_window, f);
@@ -5460,7 +5371,7 @@ w32_read_socket (struct terminal *terminal,
 	  break;
 
 	case WM_MOUSELEAVE:
-	  f = x_any_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 	  if (f)
 	    {
 	      if (f == hlinfo->mouse_face_mouse_frame)
@@ -5489,7 +5400,7 @@ w32_read_socket (struct terminal *terminal,
 
 	case WM_KILLFOCUS:
 	  w32_detect_focus_change (dpyinfo, &msg, &inev);
-	  f = x_top_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
           if (f)
             {
@@ -5514,7 +5425,7 @@ w32_read_socket (struct terminal *terminal,
 	  break;
 
 	case WM_CLOSE:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f)
 	    {
@@ -5528,7 +5439,7 @@ w32_read_socket (struct terminal *terminal,
 	  break;
 
 	case WM_INITMENU:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f)
 	    {
@@ -5538,7 +5449,7 @@ w32_read_socket (struct terminal *terminal,
 	  break;
 
 	case WM_COMMAND:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f)
 	    {
@@ -5549,7 +5460,7 @@ w32_read_socket (struct terminal *terminal,
 	  break;
 
 	case WM_DISPLAYCHANGE:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 
 	  if (f)
 	    {
@@ -5561,7 +5472,7 @@ w32_read_socket (struct terminal *terminal,
 		 The following code is untested yet.  */
 	      if (!NILP (fullscreen))
 		{
-		  x_set_fullscreen (f, fullscreen, fullscreen);
+		  gui_set_fullscreen (f, fullscreen, fullscreen);
 		  w32fullscreen_hook (f);
 		}
 
@@ -5575,9 +5486,9 @@ w32_read_socket (struct terminal *terminal,
 
 #if HAVE_W32NOTIFY
 	case WM_EMACS_FILENOTIFY:
-	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
 	  if (f)
-	    queue_notifications (&inev, &msg, f, &count);
+	    w32_queue_notifications (&inev, &msg, f, &count);
 	  break;
 #endif
 
@@ -5633,7 +5544,7 @@ w32_read_socket (struct terminal *terminal,
      raise it now.  FIXME: handle more than one such frame.  */
   if (dpyinfo->w32_pending_autoraise_frame)
     {
-      x_raise_frame (dpyinfo->w32_pending_autoraise_frame);
+      w32_raise_frame (dpyinfo->w32_pending_autoraise_frame);
       dpyinfo->w32_pending_autoraise_frame = NULL;
     }
 
@@ -5745,7 +5656,7 @@ w32_clip_to_row (struct window *w, struct glyph_row *row,
 /* Draw a hollow box cursor on window W in glyph row ROW.  */
 
 static void
-x_draw_hollow_cursor (struct window *w, struct glyph_row *row)
+w32_draw_hollow_cursor (struct window *w, struct glyph_row *row)
 {
   struct frame *f = XFRAME (WINDOW_FRAME (w));
   HDC hdc;
@@ -5794,7 +5705,7 @@ x_draw_hollow_cursor (struct window *w, struct glyph_row *row)
    --gerd.  */
 
 static void
-x_draw_bar_cursor (struct window *w, struct glyph_row *row,
+w32_draw_bar_cursor (struct window *w, struct glyph_row *row,
 		   int width, enum text_cursor_kinds kind)
 {
   struct frame *f = XFRAME (w->frame);
@@ -5882,7 +5793,7 @@ x_draw_bar_cursor (struct window *w, struct glyph_row *row,
 /* RIF: Define cursor CURSOR on frame F.  */
 
 static void
-w32_define_frame_cursor (struct frame *f, Cursor cursor)
+w32_define_frame_cursor (struct frame *f, Emacs_Cursor cursor)
 {
   w32_define_cursor (FRAME_W32_WINDOW (f), cursor);
 }
@@ -5973,7 +5884,7 @@ w32_draw_window_cursor (struct window *w, struct glyph_row *glyph_row,
       switch (cursor_type)
 	{
 	case HOLLOW_BOX_CURSOR:
-	  x_draw_hollow_cursor (w, glyph_row);
+	  w32_draw_hollow_cursor (w, glyph_row);
 	  break;
 
 	case FILLED_BOX_CURSOR:
@@ -5981,11 +5892,11 @@ w32_draw_window_cursor (struct window *w, struct glyph_row *glyph_row,
 	  break;
 
 	case BAR_CURSOR:
-	  x_draw_bar_cursor (w, glyph_row, cursor_width, BAR_CURSOR);
+	  w32_draw_bar_cursor (w, glyph_row, cursor_width, BAR_CURSOR);
 	  break;
 
 	case HBAR_CURSOR:
-	  x_draw_bar_cursor (w, glyph_row, cursor_width, HBAR_CURSOR);
+	  w32_draw_bar_cursor (w, glyph_row, cursor_width, HBAR_CURSOR);
 	  break;
 
 	case NO_CURSOR:
@@ -6002,8 +5913,8 @@ w32_draw_window_cursor (struct window *w, struct glyph_row *glyph_row,
 
 /* Icons.  */
 
-bool
-x_bitmap_icon (struct frame *f, Lisp_Object icon)
+static bool
+w32_bitmap_icon (struct frame *f, Lisp_Object icon)
 {
   HANDLE main_icon;
   HANDLE small_icon = NULL;
@@ -6090,8 +6001,8 @@ x_io_error_quitter (display)
 
 /* Changing the font of the frame.  */
 
-Lisp_Object
-x_new_font (struct frame *f, Lisp_Object font_object, int fontset)
+static Lisp_Object
+w32_new_font (struct frame *f, Lisp_Object font_object, int fontset)
 {
   struct font *font = XFONT_OBJECT (font_object);
   int unit, font_ascent, font_descent;
@@ -6123,7 +6034,7 @@ x_new_font (struct frame *f, Lisp_Object font_object, int fontset)
     }
 
   /* Now make the frame display the given font.  */
-  if (FRAME_X_WINDOW (f) != 0)
+  if (FRAME_NATIVE_WINDOW (f) != 0)
     {
       /* Don't change the size of a tip frame; there's no point in
 	 doing it because it's done in Fx_show_tip, and it leads to
@@ -6159,7 +6070,7 @@ xim_close_dpy (dpyinfo)
    from its current recorded position values and gravity.  */
 
 static void
-x_calc_absolute_position (struct frame *f)
+w32_calc_absolute_position (struct frame *f)
 {
   int flags = f->size_hint_flags;
 
@@ -6242,7 +6153,7 @@ x_calc_absolute_position (struct frame *f)
 		       + f->left_pos
 		       - left_right_borders_width);
       else
-	f->left_pos = (x_display_pixel_width (FRAME_DISPLAY_INFO (f))
+	f->left_pos = (w32_display_pixel_width (FRAME_DISPLAY_INFO (f))
 		       + display_left
 		       - FRAME_PIXEL_WIDTH (f)
 		       + f->left_pos
@@ -6257,7 +6168,7 @@ x_calc_absolute_position (struct frame *f)
 		      + f->top_pos
 		      - top_bottom_borders_height);
       else
-	f->top_pos = (x_display_pixel_height (FRAME_DISPLAY_INFO (f))
+	f->top_pos = (w32_display_pixel_height (FRAME_DISPLAY_INFO (f))
 		      + display_top
 		      - FRAME_PIXEL_HEIGHT (f)
 		      + f->top_pos
@@ -6271,13 +6182,13 @@ x_calc_absolute_position (struct frame *f)
 
 /* CHANGE_GRAVITY is 1 when calling from Fset_frame_position,
    to really change the position, and 0 when calling from
-   x_make_frame_visible (in that case, XOFF and YOFF are the current
-   position values).  It is -1 when calling from x_set_frame_parameters,
+   w32_make_frame_visible (in that case, XOFF and YOFF are the current
+   position values).  It is -1 when calling from gui_set_frame_parameters,
    which means, do adjust for borders but don't change the gravity.  */
 
-void
-x_set_offset (struct frame *f, register int xoff, register int yoff,
-	      int change_gravity)
+static void
+w32_set_offset (struct frame *f, register int xoff, register int yoff,
+                int change_gravity)
 {
   int modified_top, modified_left;
 
@@ -6292,10 +6203,10 @@ x_set_offset (struct frame *f, register int xoff, register int yoff,
 	f->size_hint_flags |= YNegative;
       f->win_gravity = NorthWestGravity;
     }
-  x_calc_absolute_position (f);
+  w32_calc_absolute_position (f);
 
   block_input ();
-  x_wm_set_size_hint (f, (long) 0, false);
+  w32_wm_set_size_hint (f, (long) 0, false);
 
   modified_left = f->left_pos;
   modified_top = f->top_pos;
@@ -6414,13 +6325,13 @@ w32fullscreen_hook (struct frame *f)
     f->want_fullscreen |= FULLSCREEN_WAIT;
 }
 
-/* Call this to change the size of frame F's x-window.
+/* Call this to change the size of frame F's native window.
    If CHANGE_GRAVITY, change to top-left-corner window gravity
    for this size change and subsequent size changes.
    Otherwise we leave the window gravity unchanged.  */
 
-void
-x_set_window_size (struct frame *f, bool change_gravity,
+static void
+w32_set_window_size (struct frame *f, bool change_gravity,
 		   int width, int height, bool pixelwise)
 {
   int pixelwidth, pixelheight;
@@ -6469,7 +6380,7 @@ x_set_window_size (struct frame *f, bool change_gravity,
     }
 
   f->win_gravity = NorthWestGravity;
-  x_wm_set_size_hint (f, (long) 0, false);
+  w32_wm_set_size_hint (f, (long) 0, false);
 
   rect.left = rect.top = 0;
   rect.right = pixelwidth;
@@ -6579,6 +6490,20 @@ frame_set_mouse_pixel_position (struct frame *f, int pix_x, int pix_y)
   unblock_input ();
 }
 
+static Lisp_Object
+w32_get_focus_frame (struct frame *f)
+{
+  Lisp_Object lisp_focus;
+
+  struct frame *focus = FRAME_DISPLAY_INFO (f)->w32_focus_frame;
+
+  if (!focus)
+    return Qnil;
+
+  XSETFRAME (lisp_focus, focus);
+  return lisp_focus;
+}
+
 
 /* Focus shifting, raising and lowering.  */
 
@@ -6586,8 +6511,8 @@ frame_set_mouse_pixel_position (struct frame *f, int pix_x, int pix_y)
    Windows API: An application cannot activate an inactive window
    without also bringing it to the top of the Z order.  */
 
-void
-x_focus_frame (struct frame *f, bool noactivate)
+static void
+w32_focus_frame (struct frame *f, bool noactivate)
 {
 #if 0
   struct w32_display_info *dpyinfo = &one_w32_display_info;
@@ -6597,7 +6522,7 @@ x_focus_frame (struct frame *f, bool noactivate)
   block_input ();
 #if 0
   /* Try not to change its Z-order if possible.  */
-  if (x_window_to_frame (dpyinfo, GetForegroundWindow ()))
+  if (w32_window_to_frame (dpyinfo, GetForegroundWindow ()))
     my_set_focus (f, FRAME_W32_WINDOW (f));
   else
 #endif
@@ -6606,8 +6531,8 @@ x_focus_frame (struct frame *f, bool noactivate)
 }
 
 /* Raise frame F.  */
-void
-x_raise_frame (struct frame *f)
+static void
+w32_raise_frame (struct frame *f)
 {
   block_input ();
 
@@ -6668,8 +6593,8 @@ x_raise_frame (struct frame *f)
 }
 
 /* Lower frame F.  */
-void
-x_lower_frame (struct frame *f)
+static void
+w32_lower_frame (struct frame *f)
 {
   block_input ();
   my_set_window_pos (FRAME_W32_WINDOW (f),
@@ -6686,9 +6611,9 @@ w32_frame_raise_lower (struct frame *f, bool raise_flag)
     return;
 
   if (raise_flag)
-    x_raise_frame (f);
+    w32_raise_frame (f);
   else
-    x_lower_frame (f);
+    w32_lower_frame (f);
 }
 
 /* Change of visibility.  */
@@ -6702,17 +6627,17 @@ w32_frame_raise_lower (struct frame *f, bool raise_flag)
    finishes with it.  */
 
 void
-x_make_frame_visible (struct frame *f)
+w32_make_frame_visible (struct frame *f)
 {
   block_input ();
 
-  x_set_bitmap_icon (f);
+  gui_set_bitmap_icon (f);
 
   if (! FRAME_VISIBLE_P (f))
     {
       /* We test FRAME_GARBAGED_P here to make sure we don't
-	 call x_set_offset a second time
-	 if we get to x_make_frame_visible a second time
+	 call w32_set_offset a second time
+	 if we get to w32_make_frame_visible a second time
 	 before the window gets really visible.  */
       if (! FRAME_ICONIFIED_P (f)
 	  && ! f->output_data.w32->asked_for_visible)
@@ -6733,7 +6658,7 @@ x_make_frame_visible (struct frame *f)
 				  workarea_rect.top);
 	    }
 
-	  x_set_offset (f, f->left_pos, f->top_pos, 0);
+	  w32_set_offset (f, f->left_pos, f->top_pos, 0);
 	}
 
       f->output_data.w32->asked_for_visible = 1;
@@ -6804,11 +6729,11 @@ x_make_frame_visible (struct frame *f)
 /* Make the frame visible (mapped and not iconified).  */
 
 void
-x_make_frame_invisible (struct frame *f)
+w32_make_frame_invisible (struct frame *f)
 {
   /* Don't keep the highlight on an invisible frame.  */
-  if (FRAME_DISPLAY_INFO (f)->x_highlight_frame == f)
-    FRAME_DISPLAY_INFO (f)->x_highlight_frame = 0;
+  if (FRAME_DISPLAY_INFO (f)->highlight_frame == f)
+    FRAME_DISPLAY_INFO (f)->highlight_frame = 0;
 
   block_input ();
 
@@ -6825,21 +6750,30 @@ x_make_frame_invisible (struct frame *f)
   unblock_input ();
 }
 
+static void
+w32_make_frame_visible_invisible (struct frame *f, bool visible)
+{
+  if (visible)
+    w32_make_frame_visible (f);
+  else
+    w32_make_frame_invisible (f);
+}
+
 /* Change window state from mapped to iconified. */
 
 void
-x_iconify_frame (struct frame *f)
+w32_iconify_frame (struct frame *f)
 {
   /* Don't keep the highlight on an invisible frame.  */
-  if (FRAME_DISPLAY_INFO (f)->x_highlight_frame == f)
-    FRAME_DISPLAY_INFO (f)->x_highlight_frame = 0;
+  if (FRAME_DISPLAY_INFO (f)->highlight_frame == f)
+    FRAME_DISPLAY_INFO (f)->highlight_frame = 0;
 
   if (FRAME_ICONIFIED_P (f))
     return;
 
   block_input ();
 
-  x_set_bitmap_icon (f);
+  gui_set_bitmap_icon (f);
 
   /* Simulate the user minimizing the frame.  */
   SendMessageTimeout (FRAME_W32_WINDOW (f), WM_SYSCOMMAND, SC_MINIMIZE, 0,
@@ -6852,10 +6786,10 @@ x_iconify_frame (struct frame *f)
 }
 
 
-/* Free X resources of frame F.  */
+/* Free resources of frame F.  */
 
 void
-x_free_frame_resources (struct frame *f)
+w32_free_frame_resources (struct frame *f)
 {
   struct w32_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
   Mouse_HLInfo *hlinfo = MOUSE_HL_INFO (f);
@@ -6879,8 +6813,8 @@ x_free_frame_resources (struct frame *f)
     dpyinfo->w32_focus_frame = 0;
   if (f == dpyinfo->w32_focus_event_frame)
     dpyinfo->w32_focus_event_frame = 0;
-  if (f == dpyinfo->x_highlight_frame)
-    dpyinfo->x_highlight_frame = 0;
+  if (f == dpyinfo->highlight_frame)
+    dpyinfo->highlight_frame = 0;
   if (f == hlinfo->mouse_face_mouse_frame)
     reset_mouse_highlight (hlinfo);
 
@@ -6890,11 +6824,11 @@ x_free_frame_resources (struct frame *f)
 
 /* Destroy the window of frame F.  */
 static void
-x_destroy_window (struct frame *f)
+w32_destroy_window (struct frame *f)
 {
   struct w32_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
 
-  x_free_frame_resources (f);
+  w32_free_frame_resources (f);
   dpyinfo->reference_count--;
 }
 
@@ -6907,7 +6841,7 @@ x_destroy_window (struct frame *f)
    If USER_POSITION, set the USPosition
    flag (this is useful when FLAGS is 0).  */
 void
-x_wm_set_size_hint (struct frame *f, long flags, bool user_position)
+w32_wm_set_size_hint (struct frame *f, long flags, bool user_position)
 {
   Window window = FRAME_W32_WINDOW (f);
 
@@ -6922,6 +6856,7 @@ x_wm_set_size_hint (struct frame *f, long flags, bool user_position)
   leave_crit ();
 }
 
+
 /***********************************************************************
 				Fonts
  ***********************************************************************/
@@ -6932,7 +6867,7 @@ x_wm_set_size_hint (struct frame *f, long flags, bool user_position)
    font table.  */
 
 static void
-x_check_font (struct frame *f, struct font *font)
+w32_check_font (struct frame *f, struct font *font)
 {
   eassert (font != NULL && ! NILP (font->props[FONT_TYPE_INDEX]));
   if (font->driver->check)
@@ -6948,7 +6883,7 @@ w32_show_hourglass (struct frame *f)
 {
   if (!menubar_in_use && !current_popup_menu)
     {
-      struct w32_output *w32 = FRAME_X_OUTPUT (f);
+      struct w32_output *w32 = FRAME_OUTPUT_DATA (f);
 
       w32->hourglass_p = 1;
       SetCursor (w32->hourglass_cursor);
@@ -6960,7 +6895,7 @@ w32_show_hourglass (struct frame *f)
 static void
 w32_hide_hourglass (struct frame *f)
 {
-  struct w32_output *w32 = FRAME_X_OUTPUT (f);
+  struct w32_output *w32 = FRAME_OUTPUT_DATA (f);
 
   w32->hourglass_p = 0;
   if (f->pointer_invisible)
@@ -6993,6 +6928,18 @@ w32_toggle_invisible_pointer (struct frame *f, bool invisible)
   unblock_input ();
 }
 
+
+/***********************************************************************
+			     Image Hooks
+ ***********************************************************************/
+
+static void
+w32_free_pixmap (struct frame *_f, Emacs_Pixmap pixmap)
+{
+  DeleteObject (pixmap);
+}
+
+
 /***********************************************************************
 			    Initialization
  ***********************************************************************/
@@ -7092,25 +7039,26 @@ extern frame_parm_handler w32_frame_parm_handlers[];
 static struct redisplay_interface w32_redisplay_interface =
 {
   w32_frame_parm_handlers,
-  x_produce_glyphs,
-  x_write_glyphs,
-  x_insert_glyphs,
-  x_clear_end_of_line,
-  x_scroll_run,
-  x_after_update_window_line,
-  x_update_window_begin,
-  x_update_window_end,
+  gui_produce_glyphs,
+  gui_write_glyphs,
+  gui_insert_glyphs,
+  gui_clear_end_of_line,
+  w32_scroll_run,
+  w32_after_update_window_line,
+  w32_update_window_begin,
+  w32_update_window_end,
   0, /* flush_display */
-  x_clear_window_mouse_face,
-  x_get_glyph_overhangs,
-  x_fix_overlapping_area,
+  gui_clear_window_mouse_face,
+  gui_get_glyph_overhangs,
+  gui_fix_overlapping_area,
   w32_draw_fringe_bitmap,
   w32_define_fringe_bitmap,
   w32_destroy_fringe_bitmap,
   w32_compute_glyph_string_overhangs,
-  x_draw_glyph_string,
+  w32_draw_glyph_string,
   w32_define_frame_cursor,
   w32_clear_frame_area,
+  w32_clear_under_internal_border,
   w32_draw_window_cursor,
   w32_draw_vertical_window_border,
   w32_draw_window_divider,
@@ -7119,7 +7067,7 @@ static struct redisplay_interface w32_redisplay_interface =
   w32_hide_hourglass
 };
 
-static void x_delete_terminal (struct terminal *term);
+static void w32_delete_terminal (struct terminal *term);
 
 static struct terminal *
 w32_create_terminal (struct w32_display_info *dpyinfo)
@@ -7133,28 +7081,47 @@ w32_create_terminal (struct w32_display_info *dpyinfo)
 
   /* MSVC does not type K&R functions with no arguments correctly, and
      so we must explicitly cast them.  */
-  terminal->clear_frame_hook = x_clear_frame;
-  terminal->ins_del_lines_hook = x_ins_del_lines;
-  terminal->delete_glyphs_hook = x_delete_glyphs;
+  terminal->clear_frame_hook = w32_clear_frame;
+  terminal->ins_del_lines_hook = w32_ins_del_lines;
+  terminal->delete_glyphs_hook = w32_delete_glyphs;
   terminal->ring_bell_hook = w32_ring_bell;
   terminal->toggle_invisible_pointer_hook = w32_toggle_invisible_pointer;
-  terminal->update_begin_hook = x_update_begin;
-  terminal->update_end_hook = x_update_end;
+  terminal->update_begin_hook = w32_update_begin;
+  terminal->update_end_hook = w32_update_end;
   terminal->read_socket_hook = w32_read_socket;
   terminal->frame_up_to_date_hook = w32_frame_up_to_date;
+  terminal->defined_color_hook = w32_defined_color;
+  terminal->query_frame_background_color = w32_query_frame_background_color;
+  terminal->query_colors = w32_query_colors;
   terminal->mouse_position_hook = w32_mouse_position;
+  terminal->get_focus_frame = w32_get_focus_frame;
+  terminal->focus_frame_hook = w32_focus_frame;
   terminal->frame_rehighlight_hook = w32_frame_rehighlight;
   terminal->frame_raise_lower_hook = w32_frame_raise_lower;
+  terminal->frame_visible_invisible_hook = w32_make_frame_visible_invisible;
   terminal->fullscreen_hook = w32fullscreen_hook;
+  terminal->iconify_frame_hook = w32_iconify_frame;
+  terminal->set_window_size_hook = w32_set_window_size;
+  terminal->set_frame_offset_hook = w32_set_offset;
+  terminal->set_frame_alpha_hook = w32_set_frame_alpha;
+  terminal->set_new_font_hook = w32_new_font;
+  terminal->set_bitmap_icon_hook = w32_bitmap_icon;
+  terminal->implicit_set_name_hook = w32_implicitly_set_name;
   terminal->menu_show_hook = w32_menu_show;
+  terminal->activate_menubar_hook = w32_activate_menubar;
   terminal->popup_dialog_hook = w32_popup_dialog;
+  terminal->change_tool_bar_height_hook = w32_change_tool_bar_height;
   terminal->set_vertical_scroll_bar_hook = w32_set_vertical_scroll_bar;
   terminal->set_horizontal_scroll_bar_hook = w32_set_horizontal_scroll_bar;
+  terminal->set_scroll_bar_default_width_hook = w32_set_scroll_bar_default_width;
+  terminal->set_scroll_bar_default_height_hook = w32_set_scroll_bar_default_height;
   terminal->condemn_scroll_bars_hook = w32_condemn_scroll_bars;
   terminal->redeem_scroll_bar_hook = w32_redeem_scroll_bar;
   terminal->judge_scroll_bars_hook = w32_judge_scroll_bars;
-  terminal->delete_frame_hook = x_destroy_window;
-  terminal->delete_terminal_hook = x_delete_terminal;
+  terminal->get_string_resource_hook = w32_get_string_resource;
+  terminal->free_pixmap = w32_free_pixmap;
+  terminal->delete_frame_hook = w32_destroy_window;
+  terminal->delete_terminal_hook = w32_delete_terminal;
   /* Other hooks are NULL by default.  */
 
   /* We don't yet support separate terminals on W32, so don't try to share
@@ -7172,7 +7139,7 @@ w32_create_terminal (struct w32_display_info *dpyinfo)
 }
 
 static void
-x_delete_terminal (struct terminal *terminal)
+w32_delete_terminal (struct terminal *terminal)
 {
   struct w32_display_info *dpyinfo = terminal->display_info.w32;
 
@@ -7183,7 +7150,7 @@ x_delete_terminal (struct terminal *terminal)
 
   block_input ();
 
-  x_delete_display (dpyinfo);
+  w32_delete_display (dpyinfo);
   unblock_input ();
 }
 
@@ -7210,7 +7177,7 @@ w32_term_init (Lisp_Object display_name, char *xrm_option, char *resource_name)
   /* Set the name of the terminal. */
   terminal->name = xlispstrdup (display_name);
 
-  dpyinfo->xrdb = xrm_option ? w32_make_rdb (xrm_option) : NULL;
+  dpyinfo->rdb = xrm_option ? w32_make_rdb (xrm_option) : NULL;
 
   /* Put this display on the chain.  */
   dpyinfo->next = x_display_list;
@@ -7228,9 +7195,9 @@ w32_term_init (Lisp_Object display_name, char *xrm_option, char *resource_name)
 
   /* initialize palette with white and black */
   {
-    XColor color;
-    w32_defined_color (0, "white", &color, 1);
-    w32_defined_color (0, "black", &color, 1);
+    Emacs_Color color;
+    w32_defined_color (0, "white", &color, true, false);
+    w32_defined_color (0, "black", &color, true, false);
   }
 
 #ifdef WINDOWSNT
@@ -7259,7 +7226,7 @@ w32_term_init (Lisp_Object display_name, char *xrm_option, char *resource_name)
 
 /* Get rid of display DPYINFO, assuming all frames are already gone.  */
 void
-x_delete_display (struct w32_display_info *dpyinfo)
+w32_delete_display (struct w32_display_info *dpyinfo)
 {
   /* FIXME: the only display info apparently can't be deleted.  */
   /* free palette table */
diff --git a/src/w32term.h b/src/w32term.h
index 4c496e97e4..729e8d0fd4 100644
--- a/src/w32term.h
+++ b/src/w32term.h
@@ -56,7 +56,7 @@ extern BOOL bUseDflt;
 
 struct w32_bitmap_record
 {
-  Pixmap pixmap;
+  Emacs_Pixmap pixmap;
   char *file;
   HINSTANCE hinst; /* Used to load the file */
   int refcount;
@@ -114,13 +114,13 @@ struct w32_display_info
   Window root_window;
 
   /* The cursor to use for vertical scroll bars.  */
-  Cursor vertical_scroll_bar_cursor;
+  HCURSOR vertical_scroll_bar_cursor;
 
   /* The cursor to use for horizontal scroll bars.  */
-  Cursor horizontal_scroll_bar_cursor;
+  HCURSOR horizontal_scroll_bar_cursor;
 
   /* Resource data base */
-  XrmDatabase xrdb;
+  const char *rdb;
 
   /* color palette information.  */
   int has_palette;
@@ -142,7 +142,7 @@ struct w32_display_info
   int smallest_font_height;
 
   /* Reusable Graphics Context for drawing a cursor in a non-default face. */
-  XGCValues *scratch_cursor_gc;
+  Emacs_GC *scratch_cursor_gc;
 
   /* Information about the range of text currently shown in
      mouse-face.  */
@@ -182,7 +182,7 @@ struct w32_display_info
      event).  It points to the focus frame's selected window's
      frame.  It differs from w32_focus_frame when we're using a global
      minibuffer.  */
-  struct frame *x_highlight_frame;
+  struct frame *highlight_frame;
 
   /* The frame waiting to be auto-raised in w32_read_socket.  */
   struct frame *w32_pending_autoraise_frame;
@@ -227,28 +227,33 @@ extern struct w32_display_info one_w32_display_info;
 extern HMENU current_popup_menu;
 extern int menubar_in_use;
 
-extern struct frame *x_window_to_frame (struct w32_display_info *, HWND);
+extern struct frame *w32_window_to_frame (struct w32_display_info *, HWND);
 
-struct w32_display_info *x_display_info_for_name (Lisp_Object);
+extern void w32_real_positions (struct frame *f, int *xptr, int *yptr);
+
+extern void w32_clear_under_internal_border (struct frame *);
+
+extern void w32_change_tool_bar_height (struct frame *, int);
+extern void w32_implicitly_set_name (struct frame *, Lisp_Object, Lisp_Object);
+extern void w32_set_scroll_bar_default_width (struct frame *);
+extern void w32_set_scroll_bar_default_height (struct frame *);
 
-/* also defined in xterm.h XXX: factor out to common header */
 
 extern struct w32_display_info *w32_term_init (Lisp_Object,
 					       char *, char *);
-extern int w32_defined_color (struct frame *f, const char *color,
-                              XColor *color_def, bool alloc_p);
-extern int x_display_pixel_height (struct w32_display_info *);
-extern int x_display_pixel_width (struct w32_display_info *);
-extern void x_set_menu_bar_lines (struct frame *, Lisp_Object, Lisp_Object);
-extern void x_set_tool_bar_lines (struct frame *f,
-                                  Lisp_Object value,
-                                  Lisp_Object oldval);
-extern void x_set_internal_border_width (struct frame *f,
-					 Lisp_Object value,
-					 Lisp_Object oldval);
+extern bool w32_defined_color (struct frame *, const char *, Emacs_Color *,
+                               bool, bool);
+extern int w32_display_pixel_height (struct w32_display_info *);
+extern int w32_display_pixel_width (struct w32_display_info *);
 extern void initialize_frame_menubar (struct frame *);
 extern void w32_dialog_in_progress (Lisp_Object in_progress);
 
+extern void w32_make_frame_visible (struct frame *f);
+extern void w32_make_frame_invisible (struct frame *f);
+extern void w32_iconify_frame (struct frame *f);
+extern void w32_free_frame_resources (struct frame *);
+extern void w32_wm_set_size_hint (struct frame *, long, bool);
+
 /* w32inevt.c */
 extern int w32_kbd_patch_key (KEY_EVENT_RECORD *event, int cpId);
 extern int w32_kbd_mods_to_emacs (DWORD mods, WORD key);
@@ -257,6 +262,10 @@ extern int w32_kbd_mods_to_emacs (DWORD mods, WORD key);
 extern void w32con_hide_cursor (void);
 extern void w32con_show_cursor (void);
 
+/* w32reg.c */
+extern const char *w32_get_string_resource (void *v_rdb,
+                                            const char *name,
+                                            const char *class);
 
 #define PIX_TYPE COLORREF
 
@@ -299,7 +308,7 @@ struct w32_output
   HPALETTE old_palette;
 
   /* Here are the Graphics Contexts for the default font.  */
-  XGCValues *cursor_gc;				/* cursor drawing */
+  Emacs_GC *cursor_gc;			/* cursor drawing */
 
   /* The window used for this frame.
      May be zero while the frame object is being created
@@ -339,27 +348,27 @@ struct w32_output
   COLORREF scroll_bar_background_pixel;
 
   /* Descriptor for the cursor in use for this window.  */
-  Cursor text_cursor;
-  Cursor nontext_cursor;
-  Cursor modeline_cursor;
-  Cursor hand_cursor;
-  Cursor hourglass_cursor;
-  Cursor horizontal_drag_cursor;
-  Cursor vertical_drag_cursor;
-  Cursor left_edge_cursor;
-  Cursor top_left_corner_cursor;
-  Cursor top_edge_cursor;
-  Cursor top_right_corner_cursor;
-  Cursor right_edge_cursor;
-  Cursor bottom_right_corner_cursor;
-  Cursor bottom_edge_cursor;
-  Cursor bottom_left_corner_cursor;
+  HCURSOR text_cursor;
+  HCURSOR nontext_cursor;
+  HCURSOR modeline_cursor;
+  HCURSOR hand_cursor;
+  HCURSOR hourglass_cursor;
+  HCURSOR horizontal_drag_cursor;
+  HCURSOR vertical_drag_cursor;
+  HCURSOR left_edge_cursor;
+  HCURSOR top_left_corner_cursor;
+  HCURSOR top_edge_cursor;
+  HCURSOR top_right_corner_cursor;
+  HCURSOR right_edge_cursor;
+  HCURSOR bottom_right_corner_cursor;
+  HCURSOR bottom_edge_cursor;
+  HCURSOR bottom_left_corner_cursor;
 
   /* Non-zero means hourglass cursor is currently displayed.  */
   unsigned hourglass_p : 1;
 
   /* Non-hourglass cursor that is currently active.  */
-  Cursor current_cursor;
+  HCURSOR current_cursor;
 
   DWORD dwStyle;
 
@@ -379,7 +388,7 @@ struct w32_output
   /* Relief GCs, colors etc.  */
   struct relief
   {
-    XGCValues *gc;
+    Emacs_GC *gc;
     unsigned long pixel;
   }
   black_relief, white_relief;
@@ -397,12 +406,12 @@ struct w32_output
 
 extern struct w32_output w32term_display;
 
-/* Return the X output data for frame F.  */
-#define FRAME_X_OUTPUT(f) ((f)->output_data.w32)
+/* Return the output data for frame F.  */
+#define FRAME_OUTPUT_DATA(f) ((f)->output_data.w32)
 
 /* Return the window associated with the frame F.  */
 #define FRAME_W32_WINDOW(f) ((f)->output_data.w32->window_desc)
-#define FRAME_X_WINDOW(f) FRAME_W32_WINDOW (f)
+#define FRAME_NATIVE_WINDOW(f) FRAME_W32_WINDOW (f)
 
 #define FRAME_FONT(f) ((f)->output_data.w32->font)
 #define FRAME_FONTSET(f) ((f)->output_data.w32->fontset)
@@ -411,9 +420,6 @@ extern struct w32_output w32term_display;
 /* This gives the w32_display_info structure for the display F is on.  */
 #define FRAME_DISPLAY_INFO(f) ((void) (f), (&one_w32_display_info))
 
-/* This is the `Display *' which frame F is on.  */
-#define FRAME_X_DISPLAY(f) (0)
-
 #define FRAME_NORMAL_PLACEMENT(F) ((F)->output_data.w32->normal_placement)
 #define FRAME_PREV_FSMODE(F)      ((F)->output_data.w32->prev_fsmode)
 
@@ -715,9 +721,8 @@ extern void complete_deferred_msg (HWND hwnd, UINT msg, LRESULT result);
 extern BOOL parse_button (int, int, int *, int *);
 
 extern void w32_sys_ring_bell (struct frame *f);
-extern void x_delete_display (struct w32_display_info *dpyinfo);
-extern void x_clear_under_internal_border (struct frame *f);
-extern void x_query_color (struct frame *, XColor *);
+extern void w32_query_color (struct frame *, Emacs_Color *);
+extern void w32_delete_display (struct w32_display_info *dpyinfo);
 
 #define FILE_NOTIFICATIONS_SIZE 16384
 /* Notifications come in sets.  We use a doubly linked list with a
@@ -732,7 +737,7 @@ struct notifications_set {
 };
 extern struct notifications_set *notifications_set_head;
 extern Lisp_Object w32_get_watch_object (void *);
-extern Lisp_Object lispy_file_action (DWORD);
+extern Lisp_Object w32_lispy_file_action (DWORD);
 extern int handle_file_notifications (struct input_event *);
 
 extern void w32_initialize_display_info (Lisp_Object);
@@ -800,7 +805,7 @@ typedef struct tagTRACKMOUSEEVENT
 struct image;
 struct face;
 
-XGCValues *XCreateGC (void *, HWND, unsigned long, XGCValues *);
+Emacs_GC *XCreateGC (void *, HWND, unsigned long, Emacs_GC *);
 
 typedef DWORD (WINAPI * ClipboardSequence_Proc) (void);
 typedef BOOL (WINAPI * AppendMenuW_Proc) (
diff --git a/src/widget.c b/src/widget.c
index 508974dd46..e662dd3ecd 100644
--- a/src/widget.c
+++ b/src/widget.c
@@ -434,21 +434,20 @@ EmacsFrameResize (Widget widget)
 }
 
 static XtGeometryResult
-EmacsFrameQueryGeometry (Widget widget, XtWidgetGeometry *request, XtWidgetGeometry *result)
+EmacsFrameQueryGeometry (Widget widget, XtWidgetGeometry *request,
+			 XtWidgetGeometry *result)
 {
-  EmacsFrame ew = (EmacsFrame) widget;
-
   int mask = request->request_mode;
-  Dimension ok_width, ok_height;
 
-  if (mask & (CWWidth | CWHeight))
+  if (mask & (CWWidth | CWHeight) && !frame_resize_pixelwise)
     {
-      if (!frame_resize_pixelwise)
-	round_size_to_char (ew,
-			    (mask & CWWidth) ? request->width : ew->core.width,
-			    ((mask & CWHeight) ? request->height
-			     : ew->core.height),
-			    &ok_width, &ok_height);
+      EmacsFrame ew = (EmacsFrame) widget;
+      Dimension ok_width, ok_height;
+
+      round_size_to_char (ew,
+			  mask & CWWidth ? request->width : ew->core.width,
+			  mask & CWHeight ? request->height : ew->core.height,
+			  &ok_width, &ok_height);
       if ((mask & CWWidth) && (ok_width != request->width))
 	{
 	  result->request_mode |= CWWidth;
diff --git a/src/window.c b/src/window.c
index ef2ed63850..deeb4f63fe 100644
--- a/src/window.c
+++ b/src/window.c
@@ -220,7 +220,7 @@ static void
 wset_update_mode_line (struct window *w)
 {
   /* If this window is the selected window on its frame, set the
-     global variable update_mode_lines, so that x_consider_frame_title
+     global variable update_mode_lines, so that gui_consider_frame_title
      will consider this frame's title for redisplay.  */
   Lisp_Object fselected_window = XFRAME (WINDOW_FRAME (w))->selected_window;
 
@@ -3434,7 +3434,7 @@ run_window_configuration_change_hook (struct frame *f)
   XSETFRAME (frame, f);
 
   if (NILP (Vrun_hooks)
-      || !f->can_x_set_window_size
+      || !f->can_set_window_size
       || !f->after_make_frame)
     return;
 
@@ -3763,7 +3763,7 @@ run_window_change_functions (void)
       ptrdiff_t number_of_windows;
 
       if (!FRAME_LIVE_P (f)
-	  || !f->can_x_set_window_size
+	  || !f->can_set_window_size
 	  || !f->after_make_frame
 	  || FRAME_TOOLTIP_P (f)
 	  || !(frame_window_change
@@ -3947,8 +3947,8 @@ set_window_buffer (Lisp_Object window, Lisp_Object buffer,
   b->display_error_modiff = 0;
 
   /* Update time stamps of buffer display.  */
-  if (FIXNUMP (BVAR (b, display_count)))
-    bset_display_count (b, make_fixnum (XFIXNUM (BVAR (b, display_count)) + 1));
+  if (INTEGERP (BVAR (b, display_count)))
+    bset_display_count (b, Fadd1 (BVAR (b, display_count)));
   bset_display_time (b, Fcurrent_time ());
 
   w->window_end_pos = 0;
@@ -4089,7 +4089,7 @@ displaying that buffer.  */)
       return Qt;
     }
 
-  if (WINDOWP (object))
+  if (WINDOW_LIVE_P (object))
     {
       struct window *w = XWINDOW (object);
       mark_window_display_accurate (object, false);
@@ -4683,7 +4683,7 @@ resize_frame_windows (struct frame *f, int size, bool horflag, bool pixelwise)
   int unit = horflag ? FRAME_COLUMN_WIDTH (f) : FRAME_LINE_HEIGHT (f);
 
   /* Don't let the size drop below one unit.  This is more comforting
-     when we are called from x_set_tool_bar_lines since the latter may
+     when we are called from *_set_tool_bar_lines since the latter may
      have implicitly given us a zero or negative height.  */
   if (pixelwise)
     {
@@ -6867,8 +6867,8 @@ the return value is nil.  Otherwise the value is t.  */)
 	    call1 (Qrecord_window_buffer, window);
 	}
 
-      /* Disallow x_set_window_size, temporarily.  */
-      f->can_x_set_window_size = false;
+      /* Disallow set_window_size_hook, temporarily.  */
+      f->can_set_window_size = false;
       /* The mouse highlighting code could get screwed up
 	 if it runs during this.  */
       block_input ();
@@ -7072,9 +7072,9 @@ the return value is nil.  Otherwise the value is t.  */)
 	if (NILP (leaf_windows[i]->contents))
 	  free_window_matrices (leaf_windows[i]);
 
-      /* Allow x_set_window_size again and apply frame size changes if
-	 needed.  */
-      f->can_x_set_window_size = true;
+      /* Allow set_window_size_hook again and apply frame size changes
+	 if needed.  */
+      f->can_set_window_size = true;
       adjust_frame_size (f, -1, -1, 1, false, Qset_window_configuration);
 
       adjust_frame_glyphs (f);
diff --git a/src/window.h b/src/window.h
index fdef407041..6b0f0e5d07 100644
--- a/src/window.h
+++ b/src/window.h
@@ -595,7 +595,7 @@ wset_next_buffers (struct window *w, Lisp_Object val)
 #define WINDOW_BUFFER(W)			\
   (WINDOW_LEAF_P(W)				\
    ? (W)->contents				\
-   : Qnil)					\
+   : Qnil)
 
 /* Return the canonical column width of the frame of window W.  */
 #define WINDOW_FRAME_COLUMN_WIDTH(W) \
@@ -649,7 +649,7 @@ wset_next_buffers (struct window *w, Lisp_Object val)
 #define WINDOW_RIGHTMOST_P(W)					\
   (WINDOW_RIGHT_PIXEL_EDGE (W)					\
    == (WINDOW_RIGHT_PIXEL_EDGE					\
-       (XWINDOW (FRAME_ROOT_WINDOW (WINDOW_XFRAME (W))))))	\
+       (XWINDOW (FRAME_ROOT_WINDOW (WINDOW_XFRAME (W))))))
 
 /* True if window W has no other windows below it on its frame (the
    minibuffer window is not counted in this respect unless W itself is a
@@ -657,13 +657,13 @@ wset_next_buffers (struct window *w, Lisp_Object val)
 #define WINDOW_BOTTOMMOST_P(W)					\
   (WINDOW_BOTTOM_PIXEL_EDGE (W)					\
    == (WINDOW_BOTTOM_PIXEL_EDGE					\
-       (XWINDOW (FRAME_ROOT_WINDOW (WINDOW_XFRAME (W))))))	\
+       (XWINDOW (FRAME_ROOT_WINDOW (WINDOW_XFRAME (W))))))
 
 /* True if window W takes up the full width of its frame.  */
 #define WINDOW_FULL_WIDTH_P(W)					\
   (WINDOW_PIXEL_WIDTH (W)					\
    == (WINDOW_PIXEL_WIDTH					\
-       (XWINDOW (FRAME_ROOT_WINDOW (WINDOW_XFRAME (W))))))	\
+       (XWINDOW (FRAME_ROOT_WINDOW (WINDOW_XFRAME (W))))))
 
 /* Width of right divider of window W.  */
 #define WINDOW_RIGHT_DIVIDER_WIDTH(W)				\
@@ -1122,7 +1122,7 @@ struct glyph *get_phys_cursor_glyph (struct window *w);
 
 /* True if WINDOW is a valid window.  */
 #define WINDOW_VALID_P(WINDOW)					\
-  (WINDOWP (WINDOW) && !NILP (XWINDOW (WINDOW)->contents))	\
+  (WINDOWP (WINDOW) && !NILP (XWINDOW (WINDOW)->contents))
 
 /* A window of any sort, leaf or interior, is "valid" if its
    contents slot is non-nil.  */
diff --git a/src/xdisp.c b/src/xdisp.c
index a88fc698b8..5f43815234 100644
--- a/src/xdisp.c
+++ b/src/xdisp.c
@@ -336,8 +336,8 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include TERM_HEADER
 #endif /* HAVE_WINDOW_SYSTEM */
 
-#ifndef FRAME_X_OUTPUT
-#define FRAME_X_OUTPUT(f) ((f)->output_data.x)
+#ifndef FRAME_OUTPUT_DATA
+#define FRAME_OUTPUT_DATA(f) (NULL)
 #endif
 
 #define DISP_INFINITY 10000000
@@ -376,7 +376,26 @@ static Lisp_Object list_of_error;
 	       || it->s[IT_BYTEPOS (*it)] == '\t'))			\
        || (IT_BYTEPOS (*it) < ZV_BYTE					\
 	   && (*BYTE_POS_ADDR (IT_BYTEPOS (*it)) == ' '			\
-	       || *BYTE_POS_ADDR (IT_BYTEPOS (*it)) == '\t'))))		\
+	       || *BYTE_POS_ADDR (IT_BYTEPOS (*it)) == '\t'))))
+
+/* If all the conditions needed to print the fill column indicator are
+   met, return the (nonnegative) column number, else return a negative
+   value.  */
+static int
+fill_column_indicator_column (struct it *it)
+{
+  if (Vdisplay_fill_column_indicator
+      && it->continuation_lines_width == 0
+      && CHARACTERP (Vdisplay_fill_column_indicator_character))
+    {
+      Lisp_Object col = (EQ (Vdisplay_fill_column_indicator_column, Qt)
+			 ? BVAR (current_buffer, fill_column)
+			 : Vdisplay_fill_column_indicator_column);
+      if (RANGED_FIXNUMP (0, col, INT_MAX))
+	return XFIXNUM (col);
+    }
+  return -1;
+}
 
 /* True means print newline to stdout before next mini-buffer message.  */
 
@@ -491,7 +510,7 @@ int windows_or_buffers_changed;
 
    Since the frame title uses the same %-constructs as the mode line
    (except %c, %C, and %l), if this variable is non-zero, we also consider
-   redisplaying the title of each frame, see x_consider_frame_title.
+   redisplaying the title of each frame, see gui_consider_frame_title.
 
    The `redisplay' bits are the same as those used for
    windows_or_buffers_changed, and setting windows_or_buffers_changed also
@@ -900,7 +919,7 @@ static int underlying_face_id (struct it *);
 #ifdef HAVE_WINDOW_SYSTEM
 
 static void update_tool_bar (struct frame *, bool);
-static void x_draw_bottom_divider (struct window *w);
+static void gui_draw_bottom_divider (struct window *w);
 static void notice_overwritten_cursor (struct window *,
                                        enum glyph_row_area,
                                        int, int, int, int);
@@ -1623,6 +1642,12 @@ pos_visible_p (struct window *w, ptrdiff_t charpos, int *x, int *y,
 		      set_iterator_to_next (&it3, false);
 		    }
 		  top_x = it3.current_x - it3.pixel_width;
+		  /* Account for line-number display, if IT3 still
+		     didn't.  This can happen if START - 1 is the
+		     first character on its display line.  */
+		  if (!it3.line_number_produced_p
+		      && it.line_number_produced_p)
+		    top_x += it.lnum_pixel_width;
 		  /* Normally, we would exit the above loop because we
 		     found the display element whose character
 		     position is CHARPOS.  For the contingency that we
@@ -2064,7 +2089,7 @@ frame_to_window_pixel_xy (struct window *w, int *x, int *y)
 int
 get_glyph_string_clip_rects (struct glyph_string *s, NativeRectangle *rects, int n)
 {
-  XRectangle r;
+  Emacs_Rectangle r;
 
   if (n <= 0)
     return 0;
@@ -2126,14 +2151,14 @@ get_glyph_string_clip_rects (struct glyph_string *s, NativeRectangle *rects, int
 	 take the intersection with the rectangle of the cursor.  */
       if (s->for_overlaps & OVERLAPS_ERASED_CURSOR)
 	{
-	  XRectangle rc, r_save = r;
+	  Emacs_Rectangle rc, r_save = r;
 
 	  rc.x = WINDOW_TEXT_TO_FRAME_PIXEL_X (s->w, s->w->phys_cursor.x);
 	  rc.y = s->w->phys_cursor.y;
 	  rc.width = s->w->phys_cursor_width;
 	  rc.height = s->w->phys_cursor_height;
 
-	  x_intersect_rectangles (&r_save, &rc, &r);
+	  gui_intersect_rectangles (&r_save, &rc, &r);
 	}
     }
   else
@@ -2192,17 +2217,17 @@ get_glyph_string_clip_rects (struct glyph_string *s, NativeRectangle *rects, int
 
   if (s->row->clip)
     {
-      XRectangle r_save = r;
+      Emacs_Rectangle r_save = r;
 
-      if (! x_intersect_rectangles (&r_save, s->row->clip, &r))
+      if (! gui_intersect_rectangles (&r_save, s->row->clip, &r))
 	r.width = 0;
     }
 
   if ((s->for_overlaps & OVERLAPS_BOTH) == 0
       || ((s->for_overlaps & OVERLAPS_BOTH) == OVERLAPS_BOTH && n == 1))
     {
-#ifdef CONVERT_FROM_XRECT
-      CONVERT_FROM_XRECT (r, *rects);
+#ifdef CONVERT_FROM_EMACS_RECT
+      CONVERT_FROM_EMACS_RECT (r, *rects);
 #else
       *rects = r;
 #endif
@@ -2214,10 +2239,10 @@ get_glyph_string_clip_rects (struct glyph_string *s, NativeRectangle *rects, int
 	 multiple clipping rectangles, we exclude the row of the glyph
 	 string from the clipping rectangle.  This is to avoid drawing
 	 the same text on the environment with anti-aliasing.  */
-#ifdef CONVERT_FROM_XRECT
-      XRectangle rs[2];
+#ifdef CONVERT_FROM_EMACS_RECT
+      Emacs_Rectangle rs[2];
 #else
-      XRectangle *rs = rects;
+      Emacs_Rectangle *rs = rects;
 #endif
       int i = 0, row_y = WINDOW_TO_FRAME_PIXEL_Y (s->w, s->row->y);
 
@@ -2250,9 +2275,9 @@ get_glyph_string_clip_rects (struct glyph_string *s, NativeRectangle *rects, int
 	}
 
       n = i;
-#ifdef CONVERT_FROM_XRECT
+#ifdef CONVERT_FROM_EMACS_RECT
       for (i = 0; i < n; i++)
-	CONVERT_FROM_XRECT (rs[i], rects[i]);
+	CONVERT_FROM_EMACS_RECT (rs[i], rects[i]);
 #endif
       return n;
     }
@@ -6926,7 +6951,7 @@ static next_element_function const get_next_element[NUM_IT_METHODS] =
    method symbol.  By side-effect, update it->what and
    it->glyphless_method.  This function is called from
    get_next_display_element for each character element, and from
-   x_produce_glyphs when no suitable font was found.  */
+   gui_produce_glyphs when no suitable font was found.  */
 
 Lisp_Object
 lookup_glyphless_char_display (int c, struct it *it)
@@ -9624,7 +9649,7 @@ move_it_to (struct it *it, ptrdiff_t to_charpos, int to_x, int to_y, int to_vpos
 		      /* When display_line produces a continued line
 			 that ends in a TAB, it skips a tab stop that
 			 is closer than the font's space character
-			 width (see x_produce_glyphs where it produces
+			 width (see gui_produce_glyphs where it produces
 			 the stretch glyph which represents a TAB).
 			 We need to reproduce the same logic here.  */
 		      eassert (face_font);
@@ -11275,7 +11300,7 @@ resize_mini_window (struct window *w, bool exact_p)
   /* Nil means don't try to resize.  */
   if ((NILP (Vresize_mini_windows)
        && (NILP (resize_mini_frames) || !FRAME_MINIBUF_ONLY_P (f)))
-      || (FRAME_X_P (f) && FRAME_X_OUTPUT (f) == NULL))
+      || (FRAME_X_P (f) && FRAME_OUTPUT_DATA (f) == NULL))
     return false;
 
   /* By default, start display at the beginning.  */
@@ -11592,10 +11617,11 @@ clear_garbaged_frames (void)
 	      else
 		clear_current_matrices (f);
 
-#if defined (HAVE_WINDOW_SYSTEM) && !defined (HAVE_NS)
-	      x_clear_under_internal_border (f);
-#endif /* HAVE_WINDOW_SYSTEM && !HAVE_NS */
-
+#ifdef HAVE_WINDOW_SYSTEM
+              if (FRAME_WINDOW_P (f)
+                  && FRAME_RIF (f)->clear_under_internal_border)
+                FRAME_RIF (f)->clear_under_internal_border (f);
+#endif
 	      fset_redisplay (f);
 	      f->garbaged = false;
 	      f->resized_p = false;
@@ -11664,10 +11690,11 @@ echo_area_display (bool update_frame_p)
 	    {
 	      n = redisplay_mode_lines (FRAME_ROOT_WINDOW (f), false);
 
-#if defined (HAVE_WINDOW_SYSTEM) && !defined (HAVE_NS)
-	      x_clear_under_internal_border (f);
-#endif /* HAVE_WINDOW_SYSTEM && !HAVE_NS */
-
+#ifdef HAVE_WINDOW_SYSTEM
+              if (FRAME_WINDOW_P (f)
+                  && FRAME_RIF (f)->clear_under_internal_border)
+                FRAME_RIF (f)->clear_under_internal_border (f);
+#endif
 	    }
 
 	  if (window_height_changed_p
@@ -11999,7 +12026,7 @@ store_mode_line_noprop (const char *string, int field_width, int precision)
    frame_title_format.  */
 
 static void
-x_consider_frame_title (Lisp_Object frame)
+gui_consider_frame_title (Lisp_Object frame)
 {
   struct frame *f = XFRAME (frame);
 
@@ -12071,10 +12098,13 @@ x_consider_frame_title (Lisp_Object frame)
 	 already wasted too much time by walking through the list with
 	 display_mode_element, then we might need to optimize at a
 	 higher level than this.)  */
-      if (! STRINGP (f->name)
-	  || SBYTES (f->name) != len
-	  || memcmp (title, SDATA (f->name), len) != 0)
-	x_implicitly_set_name (f, make_string (title, len), Qnil);
+      if ((! STRINGP (f->name)
+           || SBYTES (f->name) != len
+           || memcmp (title, SDATA (f->name), len) != 0)
+          && FRAME_TERMINAL (f)->implicit_set_name_hook)
+	FRAME_TERMINAL (f)->implicit_set_name_hook (f,
+                                                    make_string (title, len),
+                                                    Qnil);
     }
 }
 
@@ -12146,7 +12176,7 @@ prepare_menu_bars (void)
 		  || FRAME_VISIBLE_P (f) == 1
 		  /* Exclude TTY frames that are obscured because they
 		     are not the top frame on their console.  This is
-		     because x_consider_frame_title actually switches
+		     because gui_consider_frame_title actually switches
 		     to the frame, which for TTY frames means it is
 		     marked as garbaged, and will be completely
 		     redrawn on the next redisplay cycle.  This causes
@@ -12154,7 +12184,7 @@ prepare_menu_bars (void)
 		     are more than one of them, even though nothing
 		     should be changed on display.  */
 		  || (FRAME_VISIBLE_P (f) == 2 && FRAME_WINDOW_P (f))))
-	    x_consider_frame_title (frame);
+	    gui_consider_frame_title (frame);
 	}
     }
 #endif /* HAVE_WINDOW_SYSTEM */
@@ -12848,7 +12878,8 @@ redisplay_tool_bar (struct frame *f)
 
       if (new_height != WINDOW_PIXEL_HEIGHT (w))
 	{
-	  x_change_tool_bar_height (f, new_height);
+          if (FRAME_TERMINAL (f)->change_tool_bar_height_hook)
+            FRAME_TERMINAL (f)->change_tool_bar_height_hook (f, new_height);
 	  frame_default_tool_bar_height = new_height;
 	  /* Always do that now.  */
 	  clear_glyph_matrix (w->desired_matrix);
@@ -12943,7 +12974,8 @@ redisplay_tool_bar (struct frame *f)
 
 	  if (change_height_p)
 	    {
-	      x_change_tool_bar_height (f, new_height);
+              if (FRAME_TERMINAL (f)->change_tool_bar_height_hook)
+                FRAME_TERMINAL (f)->change_tool_bar_height_hook (f, new_height);
 	      frame_default_tool_bar_height = new_height;
 	      clear_glyph_matrix (w->desired_matrix);
 	      f->n_tool_bar_rows = nrows;
@@ -13153,7 +13185,7 @@ note_tool_bar_highlight (struct frame *f, int x, int y)
   clear_mouse_face (hlinfo);
 
   /* Mouse is down, but on different tool-bar item?  */
-  mouse_down_p = (x_mouse_grabbed (dpyinfo)
+  mouse_down_p = (gui_mouse_grabbed (dpyinfo)
 		  && f == dpyinfo->last_mouse_frame);
 
   if (mouse_down_p && f->last_tool_bar_item != prop_idx)
@@ -13963,12 +13995,6 @@ redisplay_internal (void)
 #if defined (USE_X_TOOLKIT) || defined (USE_GTK) || defined (HAVE_NS)
   if (popup_activated ())
     {
-#ifdef NS_IMPL_COCOA
-      /* On macOS we may have disabled screen updates due to window
-         resizing.  We should re-enable them so the popup can be
-         displayed.  */
-      ns_enable_screen_updates ();
-#endif
       return;
     }
 #endif
@@ -14485,10 +14511,11 @@ redisplay_internal (void)
 		      && garbaged_frame_retries++ < MAX_GARBAGED_FRAME_RETRIES)
                     goto retry;
 
-#if defined (HAVE_WINDOW_SYSTEM) && !defined (HAVE_NS)
-		  x_clear_under_internal_border (f);
-#endif /* HAVE_WINDOW_SYSTEM && !HAVE_NS */
-
+#ifdef HAVE_WINDOW_SYSTEM
+                  if (FRAME_WINDOW_P (f)
+                      && FRAME_RIF (f)->clear_under_internal_border)
+                    FRAME_RIF (f)->clear_under_internal_border (f);
+#endif
 		  /* Prevent various kinds of signals during display
 		     update.  stdio is not robust about handling
 		     signals, which can cause an apparent I/O error.  */
@@ -14770,12 +14797,6 @@ unwind_redisplay (void)
 {
   redisplaying_p = false;
   unblock_buffer_flips ();
-#ifdef NS_IMPL_COCOA
-  /* On macOS we may have disabled screen updates due to window
-     resizing.  When redisplay completes we want to re-enable
-     them.  */
-  ns_enable_screen_updates ();
-#endif
 }
 
 
@@ -17682,7 +17703,7 @@ redisplay_window (Lisp_Object window, bool just_this_one_p)
 	    ignore_mouse_drag_p = true;
 #endif
         }
-      x_consider_frame_title (w->frame);
+      gui_consider_frame_title (w->frame);
 #endif
     }
 
@@ -17697,16 +17718,16 @@ redisplay_window (Lisp_Object window, bool just_this_one_p)
       if (draw_window_fringes (w, true))
 	{
 	  if (WINDOW_RIGHT_DIVIDER_WIDTH (w))
-	    x_draw_right_divider (w);
+	    gui_draw_right_divider (w);
 	  else
-	    x_draw_vertical_border (w);
+	    gui_draw_vertical_border (w);
 	}
       unblock_input ();
       update_end (f);
     }
 
   if (WINDOW_BOTTOM_DIVIDER_WIDTH (w))
-    x_draw_bottom_divider (w);
+    gui_draw_bottom_divider (w);
 #endif /* HAVE_WINDOW_SYSTEM */
 
   /* We go to this label, with fonts_changed set, if it is
@@ -18016,12 +18037,14 @@ try_window_reusing_current_matrix (struct window *w)
 
 	  if (run.height > 0 && run.current_y != run.desired_y)
 	    {
+#ifdef HAVE_WINDOW_SYSTEM
 	      update_begin (f);
-	      FRAME_RIF (f)->update_window_begin_hook (w);
+	      gui_update_window_begin (w);
 	      FRAME_RIF (f)->clear_window_mouse_face (w);
 	      FRAME_RIF (f)->scroll_run_hook (w, &run);
-	      FRAME_RIF (f)->update_window_end_hook (w, false, false);
+	      gui_update_window_end (w, false, false);
 	      update_end (f);
+#endif
 	    }
 
 	  /* Shift current matrix down by nrows_scrolled lines.  */
@@ -18180,12 +18203,14 @@ try_window_reusing_current_matrix (struct window *w)
 
       if (run.height)
 	{
+#ifdef HAVE_WINDOW_SYSTEM
 	  update_begin (f);
-	  FRAME_RIF (f)->update_window_begin_hook (w);
+	  gui_update_window_begin (w);
 	  FRAME_RIF (f)->clear_window_mouse_face (w);
 	  FRAME_RIF (f)->scroll_run_hook (w, &run);
-	  FRAME_RIF (f)->update_window_end_hook (w, false, false);
+	  gui_update_window_end (w, false, false);
 	  update_end (f);
+#endif
 	}
 
       /* Adjust Y positions of reused rows.  */
@@ -19133,10 +19158,12 @@ try_window_id (struct window *w)
 
       if (FRAME_WINDOW_P (f))
 	{
-	  FRAME_RIF (f)->update_window_begin_hook (w);
+#ifdef HAVE_WINDOW_SYSTEM
+	  gui_update_window_begin (w);
 	  FRAME_RIF (f)->clear_window_mouse_face (w);
 	  FRAME_RIF (f)->scroll_run_hook (w, &run);
-	  FRAME_RIF (f)->update_window_end_hook (w, false, false);
+	  gui_update_window_end (w, false, false);
+#endif
 	}
       else
 	{
@@ -19150,7 +19177,7 @@ try_window_id (struct window *w)
 		     + window_internal_height (w));
 
 #if defined (HAVE_GPM) || defined (MSDOS)
-	  x_clear_window_mouse_face (w);
+	  gui_clear_window_mouse_face (w);
 #endif
 	  /* Perform the operation on the screen.  */
 	  if (dvpos > 0)
@@ -20132,15 +20159,53 @@ append_space_for_newline (struct it *it, bool default_face_p)
 	  it->what = IT_CHARACTER;
 	  memset (&it->position, 0, sizeof it->position);
 	  it->object = Qnil;
-	  it->c = it->char_to_display = ' ';
 	  it->len = 1;
 
+	  int local_default_face_id =
+	    lookup_basic_face (it->w, it->f, DEFAULT_FACE_ID);
+	  struct face* default_face =
+	    FACE_FROM_ID_OR_NULL (it->f, local_default_face_id);
+
+	  /* Corner case for when display-fill-column-indicator-mode
+	     is active and the extra character should be added in the
+	     same place than the line.  */
+	  int indicator_column = (it->w->pseudo_window_p == 0
+				  ? fill_column_indicator_column (it)
+				  : -1);
+	  if (0 <= indicator_column)
+	    {
+	       struct font *font =
+	         default_face->font ?
+		   default_face->font : FRAME_FONT (it->f);
+	       const int char_width =
+	         font->average_width ?
+		   font->average_width : font->space_width;
+
+	       int column_x;
+	       if (!INT_MULTIPLY_WRAPV (indicator_column, char_width,
+					&column_x)
+		   && !INT_ADD_WRAPV (it->lnum_pixel_width, column_x,
+				      &column_x)
+		   && it->current_x == column_x)
+	         {
+	           it->c = it->char_to_display =
+		     XFIXNAT (Vdisplay_fill_column_indicator_character);
+	           it->face_id =
+		     merge_faces (it->w, Qfill_column_indicator,
+		                  0, saved_face_id);
+	           face = FACE_FROM_ID (it->f, it->face_id);
+	           goto produce_glyphs;
+	         }
+	    }
+
+	  it->c = it->char_to_display = ' ';
 	  /* If the default face was remapped, be sure to use the
 	     remapped face for the appended newline.  */
 	  if (default_face_p)
-	    it->face_id = lookup_basic_face (it->w, it->f, DEFAULT_FACE_ID);
+	    it->face_id = local_default_face_id;
 	  else if (it->face_before_selective_p)
 	    it->face_id = it->saved_face_id;
+
 	  face = FACE_FROM_ID (it->f, it->face_id);
 	  it->face_id = FACE_FOR_CHAR (it->f, face, 0, -1, Qnil);
 	  /* In R2L rows, we will prepend a stretch glyph that will
@@ -20154,6 +20219,7 @@ append_space_for_newline (struct it *it, bool default_face_p)
 	      && saved_x + FRAME_COLUMN_WIDTH (it->f) < it->last_visible_x)
 	    it->end_of_box_run_p = false;
 
+	produce_glyphs:
 	  PRODUCE_GLYPHS (it);
 
 #ifdef HAVE_WINDOW_SYSTEM
@@ -20174,7 +20240,7 @@ append_space_for_newline (struct it *it, bool default_face_p)
 	      it->object = saved_object; /* get_it_property needs this */
 	      normal_char_ascent_descent (font, -1, &it->ascent, &it->descent);
 	      /* Must do a subset of line height processing from
-		 x_produce_glyph for newline characters.  */
+		 gui_produce_glyph for newline characters.  */
 	      height = get_it_property (it, Qline_height);
 	      if (CONSP (height)
 		  && CONSP (XCDR (height))
@@ -20302,7 +20368,8 @@ extend_face_to_end_of_line (struct it *it)
 #ifdef HAVE_WINDOW_SYSTEM
       && !face->stipple
 #endif
-      && !it->glyph_row->reversed_p)
+      && !it->glyph_row->reversed_p
+      && !Vdisplay_fill_column_indicator)
     return;
 
   /* Set the glyph row flag indicating that the face of the last glyph
@@ -20354,6 +20421,82 @@ extend_face_to_end_of_line (struct it *it)
 		default_face->id;
 	      it->glyph_row->used[RIGHT_MARGIN_AREA] = 1;
 	    }
+
+	  /* Display fill column indicator if not in modeline or
+	     toolbar and display fill column indicator mode is
+	     active.  */
+	  int indicator_column = (it->w->pseudo_window_p == 0
+				  ? fill_column_indicator_column (it)
+				  : -1);
+	  if (0 <= indicator_column)
+            {
+	      struct font *font =
+	        default_face->font ? default_face->font : FRAME_FONT (f);
+	      const int char_width =
+	        font->average_width ?
+		  font->average_width : font->space_width;
+
+	      int column_x;
+	      if (!INT_MULTIPLY_WRAPV (indicator_column, char_width, &column_x)
+		  && !INT_ADD_WRAPV (it->lnum_pixel_width, column_x, &column_x)
+		  && it->current_x <= column_x
+		  && column_x <= it->last_visible_x)
+	        {
+	          const char saved_char = it->char_to_display;
+	          const struct text_pos saved_pos = it->position;
+	          const bool saved_avoid_cursor = it->avoid_cursor_p;
+	          const int saved_face_id = it->face_id;
+	          const bool saved_box_start = it->start_of_box_run_p;
+	          Lisp_Object save_object = it->object;
+
+	          /* The stretch width needs to considet the latter
+	             added glyph.  */
+	          const int stretch_width =
+	            column_x - it->current_x - char_width;
+
+	          memset (&it->position, 0, sizeof it->position);
+	          it->avoid_cursor_p = true;
+	          it->object = Qnil;
+
+	          /* Only generate a stretch glyph if there is distance
+	             between current_x and and the indicator position.  */
+	          if (stretch_width > 0)
+		    {
+		      int stretch_ascent = (((it->ascent + it->descent)
+		                             * FONT_BASE (font)) / FONT_HEIGHT (font));
+		      append_stretch_glyph (it, Qnil, stretch_width,
+		                            it->ascent + it->descent,
+		                            stretch_ascent);
+		    }
+
+	          /* Generate the glyph indicator only if
+	             append_space_for_newline didn't already.  */
+	          if (it->current_x < column_x)
+	            {
+		      it->char_to_display =
+	                XFIXNAT (Vdisplay_fill_column_indicator_character);
+	              it->face_id =
+	                merge_faces (it->w, Qfill_column_indicator,
+	                             0, saved_face_id);
+	              PRODUCE_GLYPHS (it);
+	            }
+
+	          /* Restore the face after the indicator was generated.  */
+	          it->face_id = saved_face_id;
+
+	          /* If there is space after the indicator generate an
+	             extra empty glyph to restore the face.  Issue was
+	             observed in X systems.  */
+	          it->char_to_display = ' ';
+	          PRODUCE_GLYPHS (it);
+
+	          it->char_to_display = saved_char;
+	          it->position = saved_pos;
+	          it->avoid_cursor_p = saved_avoid_cursor;
+	          it->start_of_box_run_p = saved_box_start;
+	          it->object = save_object;
+	        }
+            }
 	}
 #ifdef HAVE_WINDOW_SYSTEM
       if (it->glyph_row->reversed_p)
@@ -20362,7 +20505,7 @@ extend_face_to_end_of_line (struct it *it)
 	     rightmost glyph will be drawn flushed all the way to the
 	     right margin of the window.  The stretch glyph that will
 	     occupy the empty space, if any, to the left of the
-	     glyphs.  */
+	     glyph.  */
 	  struct font *font = face->font ? face->font : FRAME_FONT (f);
 	  struct glyph *row_start = it->glyph_row->glyphs[TEXT_AREA];
 	  struct glyph *row_end = row_start + it->glyph_row->used[TEXT_AREA];
@@ -20475,10 +20618,35 @@ extend_face_to_end_of_line (struct it *it)
 	it->face_id = default_face->id;
       else
 	it->face_id = face->id;
-      PRODUCE_GLYPHS (it);
 
-      while (it->current_x <= it->last_visible_x)
-	PRODUCE_GLYPHS (it);
+      /* Display fill-column indicator if needed.  */
+      int indicator_column = fill_column_indicator_column (it);
+      if (0 <= indicator_column
+	  && INT_ADD_WRAPV (it->lnum_pixel_width, indicator_column,
+			    &indicator_column))
+	indicator_column = -1;
+      do
+	{
+	  int saved_face_id;
+	  bool indicate = it->current_x == indicator_column;
+	  if (indicate)
+	    {
+	      saved_face_id = it->face_id;
+	      it->face_id =
+		merge_faces (it->w, Qfill_column_indicator, 0, saved_face_id);
+	      it->c = it->char_to_display =
+		XFIXNAT (Vdisplay_fill_column_indicator_character);
+	    }
+
+	  PRODUCE_GLYPHS (it);
+
+	  if (indicate)
+	    {
+	      it->face_id = saved_face_id;
+	      it->c = it->char_to_display = ' ';
+	    }
+	}
+      while (it->current_x <= it->last_visible_x);
 
       if (WINDOW_RIGHT_MARGIN_WIDTH (it->w) > 0
 	  && (it->glyph_row->used[RIGHT_MARGIN_AREA]
@@ -20568,7 +20736,8 @@ highlight_trailing_whitespace (struct it *it)
       if (!row->reversed_p)
 	{
 	  while (glyph >= start
-		 && glyph->type == CHAR_GLYPH
+	         && (glyph->type == CHAR_GLYPH
+	             || glyph->type == STRETCH_GLYPH)
 		 && NILP (glyph->object))
 	    --glyph;
 	}
@@ -23828,7 +23997,8 @@ display_mode_element (struct it *it, int depth, int field_width, int precision,
 			       ? string_byte_to_char (elt, bytepos)
 			       : bytepos);
 		    spec = decode_mode_spec (it->w, c, field, &string);
-		    multibyte = STRINGP (string) && STRING_MULTIBYTE (string);
+		    eassert (NILP (string) || STRINGP (string));
+		    multibyte = !NILP (string) && STRING_MULTIBYTE (string);
 
 		    switch (mode_line_target)
 		      {
@@ -24504,8 +24674,9 @@ percent99 (ptrdiff_t n, ptrdiff_t d)
 
 /* Return a string for the output of a mode line %-spec for window W,
    generated by character C.  FIELD_WIDTH > 0 means pad the string
-   returned with spaces to that value.  Return a Lisp string in
-   *STRING if the resulting string is taken from that Lisp string.
+   returned with spaces to that value.  Set *STRING to be a Lisp
+   string if the resulting string is taken from that Lisp string;
+   otherwise, set *STRING to Qnil.
 
    Note we operate on the current buffer for most purposes.  */
 
@@ -25714,7 +25885,7 @@ dump_glyph_string (struct glyph_string *s)
 #endif /* GLYPH_DEBUG */
 
 /* Initialize glyph string S.  CHAR2B is a suitably allocated vector
-   of XChar2b structures for S; it can't be allocated in
+   of 2-byte unsigned integers for S; it can't be allocated in
    init_glyph_string because it must be allocated via `alloca'.  W
    is the window on which S is drawn.  ROW and AREA are the glyph row
    and area within the row from which S is constructed.  START is the
@@ -25744,7 +25915,7 @@ init_glyph_string (struct glyph_string *s,
 #ifdef HAVE_NTGUI
 		   HDC hdc,
 #endif
-		   XChar2b *char2b, struct window *w, struct glyph_row *row,
+		   unsigned *char2b, struct window *w, struct glyph_row *row,
 		   enum glyph_row_area area, int start, enum draw_glyphs_face hl)
 {
   memset (s, 0, sizeof *s);
@@ -25753,7 +25924,6 @@ init_glyph_string (struct glyph_string *s,
 #ifdef HAVE_NTGUI
   s->hdc = hdc;
 #endif
-  s->display = FRAME_X_DISPLAY (s->f);
   s->char2b = char2b;
   s->hl = hl;
   s->row = row;
@@ -25824,7 +25994,7 @@ append_glyph_string (struct glyph_string **head, struct glyph_string **tail,
 
 static struct face *
 get_char_face_and_encoding (struct frame *f, int c, int face_id,
-			    XChar2b *char2b, bool display_p)
+			    unsigned *char2b, bool display_p)
 {
   struct face *face = FACE_FROM_ID (f, face_id);
   unsigned code = 0;
@@ -25836,7 +26006,8 @@ get_char_face_and_encoding (struct frame *f, int c, int face_id,
       if (code == FONT_INVALID_CODE)
 	code = 0;
     }
-  STORE_XCHAR2B (char2b, (code >> 8), (code & 0xFF));
+  /* Ensure that the code is only 2 bytes wide.  */
+  *char2b = code & 0xFFFF;
 
   /* Make sure X resources of the face are allocated.  */
 #ifdef HAVE_X_WINDOWS
@@ -25857,7 +26028,7 @@ get_char_face_and_encoding (struct frame *f, int c, int face_id,
 
 static struct face *
 get_glyph_face_and_encoding (struct frame *f, struct glyph *glyph,
-			     XChar2b *char2b)
+			     unsigned *char2b)
 {
   struct face *face;
   unsigned code = 0;
@@ -25879,7 +26050,8 @@ get_glyph_face_and_encoding (struct frame *f, struct glyph *glyph,
 	code = 0;
     }
 
-  STORE_XCHAR2B (char2b, (code >> 8), (code & 0xFF));
+  /* Ensure that the code is only 2 bytes wide.  */
+  *char2b = code & 0xFFFF;
   return face;
 }
 
@@ -25888,7 +26060,7 @@ get_glyph_face_and_encoding (struct frame *f, struct glyph *glyph,
    Return true iff FONT has a glyph for C.  */
 
 static bool
-get_char_glyph_code (int c, struct font *font, XChar2b *char2b)
+get_char_glyph_code (int c, struct font *font, unsigned *char2b)
 {
   unsigned code;
 
@@ -25899,7 +26071,9 @@ get_char_glyph_code (int c, struct font *font, XChar2b *char2b)
 
   if (code == FONT_INVALID_CODE)
     return false;
-  STORE_XCHAR2B (char2b, (code >> 8), (code & 0xFF));
+
+  /* Ensure that the code is only 2 bytes wide.  */
+  *char2b = code & 0xFFFF;
   return true;
 }
 
@@ -26012,7 +26186,8 @@ fill_gstring_glyph_string (struct glyph_string *s, int face_id,
       Lisp_Object lglyph = LGSTRING_GLYPH (lgstring, i);
       unsigned code = LGLYPH_CODE (lglyph);
 
-      STORE_XCHAR2B ((s->char2b + i), code >> 8, code & 0xFF);
+      /* Ensure that the code is only 2 bytes wide.  */
+      s->char2b[i] = code & 0xFFFF;
     }
   s->width = composition_gstring_width (lgstring, s->cmp_from, s->cmp_to, NULL);
   return glyph - s->row->glyphs[s->area];
@@ -26191,17 +26366,16 @@ fill_stretch_glyph_string (struct glyph_string *s, int start, int end)
 }
 
 static struct font_metrics *
-get_per_char_metric (struct font *font, XChar2b *char2b)
+get_per_char_metric (struct font *font, const unsigned *char2b)
 {
   static struct font_metrics metrics;
-  unsigned code;
 
   if (! font)
     return NULL;
-  code = (XCHAR2B_BYTE1 (char2b) << 8) | XCHAR2B_BYTE2 (char2b);
-  if (code == FONT_INVALID_CODE)
+  if (*char2b == FONT_INVALID_CODE)
     return NULL;
-  font->driver->text_extents (font, &code, 1, &metrics);
+
+  font->driver->text_extents (font, char2b, 1, &metrics);
   return &metrics;
 }
 
@@ -26219,7 +26393,7 @@ normal_char_ascent_descent (struct font *font, int c, int *ascent, int *descent)
 
   if (FONT_TOO_HIGH (font))
     {
-      XChar2b char2b;
+      unsigned char2b;
 
       /* Get metrics of C, defaulting to a reasonably sized ASCII
 	 character.  */
@@ -26260,13 +26434,13 @@ normal_char_height (struct font *font, int c)
    assumed to be zero.  */
 
 void
-x_get_glyph_overhangs (struct glyph *glyph, struct frame *f, int *left, int *right)
+gui_get_glyph_overhangs (struct glyph *glyph, struct frame *f, int *left, int *right)
 {
   *left = *right = 0;
 
   if (glyph->type == CHAR_GLYPH)
     {
-      XChar2b char2b;
+      unsigned char2b;
       struct face *face = get_glyph_face_and_encoding (f, glyph, &char2b);
       if (face->font)
 	{
@@ -26350,7 +26524,7 @@ left_overwriting (struct glyph_string *s)
   for (i = first - 1; i >= 0; --i)
     {
       int left, right;
-      x_get_glyph_overhangs (glyphs + i, s->f, &left, &right);
+      gui_get_glyph_overhangs (glyphs + i, s->f, &left, &right);
       if (x + right > 0)
 	k = i;
       x -= glyphs[i].pixel_width;
@@ -26405,7 +26579,7 @@ right_overwriting (struct glyph_string *s)
   for (i = first; i < end; ++i)
     {
       int left, right;
-      x_get_glyph_overhangs (glyphs + i, s->f, &left, &right);
+      gui_get_glyph_overhangs (glyphs + i, s->f, &left, &right);
       if (x - left < 0)
 	k = i;
       x += glyphs[i].pixel_width;
@@ -26580,7 +26754,7 @@ compute_overhangs_and_x (struct glyph_string *s, int x, bool backward_p)
      do									   \
        {								   \
 	 int face_id;							   \
-	 XChar2b *char2b;						   \
+	 unsigned *char2b;					   \
 									   \
 	 face_id = (row)->glyphs[area][START].face_id;			   \
 									   \
@@ -26609,7 +26783,7 @@ compute_overhangs_and_x (struct glyph_string *s, int x, bool backward_p)
     struct face *base_face = FACE_FROM_ID (f, face_id);		    \
     ptrdiff_t cmp_id = (row)->glyphs[area][START].u.cmp.id;		    \
     struct composition *cmp = composition_table[cmp_id];		    \
-    XChar2b *char2b;							    \
+    unsigned *char2b;						            \
     struct glyph_string *first_s = NULL;				    \
     int n;								    \
     									    \
@@ -26641,7 +26815,7 @@ compute_overhangs_and_x (struct glyph_string *s, int x, bool backward_p)
 #define BUILD_GSTRING_GLYPH_STRING(START, END, HEAD, TAIL, HL, X, LAST_X) \
   do {									  \
     int face_id;							  \
-    XChar2b *char2b;							  \
+    unsigned *char2b;						          \
     Lisp_Object gstring;						  \
     									  \
     face_id = (row)->glyphs[area][START].face_id;			  \
@@ -27067,7 +27241,7 @@ font_for_underline_metrics (struct glyph_string *s)
   }
 
 /* Store one glyph for IT->char_to_display in IT->glyph_row.
-   Called from x_produce_glyphs when IT->glyph_row is non-null.  */
+   Called from gui_produce_glyphs when IT->glyph_row is non-null.  */
 
 static void
 append_glyph (struct it *it)
@@ -27149,9 +27323,8 @@ append_glyph (struct it *it)
     IT_EXPAND_MATRIX_WIDTH (it, area);
 }
 
-/* Store one glyph for the composition IT->cmp_it.id in
-   IT->glyph_row.  Called from x_produce_glyphs when IT->glyph_row is
-   non-null.  */
+/* Store one glyph for the composition IT->cmp_it.id in IT->glyph_row.
+   Called from gui_produce_glyphs when IT->glyph_row is non-null.  */
 
 static void
 append_composite_glyph (struct it *it)
@@ -28227,7 +28400,7 @@ produce_glyphless_glyph (struct it *it, bool for_no_font, Lisp_Object acronym)
    for an overview of struct it.  */
 
 void
-x_produce_glyphs (struct it *it)
+gui_produce_glyphs (struct it *it)
 {
   int extra_line_spacing = it->extra_line_spacing;
 
@@ -28235,7 +28408,7 @@ x_produce_glyphs (struct it *it)
 
   if (it->what == IT_CHARACTER)
     {
-      XChar2b char2b;
+      unsigned char2b;
       struct face *face = FACE_FROM_ID (it->f, it->face_id);
       struct font *font = face->font;
       struct font_metrics *pcm = NULL;
@@ -28634,7 +28807,7 @@ x_produce_glyphs (struct it *it)
 	  int lbearing, rbearing;
 	  int i, width, ascent, descent;
 	  int c;
-	  XChar2b char2b;
+	  unsigned char2b;
 	  struct font_metrics *pcm;
 	  ptrdiff_t pos;
 
@@ -28995,7 +29168,7 @@ x_produce_glyphs (struct it *it)
    being updated, and UPDATED_AREA is the area of that row being updated.  */
 
 void
-x_write_glyphs (struct window *w, struct glyph_row *updated_row,
+gui_write_glyphs (struct window *w, struct glyph_row *updated_row,
 		struct glyph *start, enum glyph_row_area updated_area, int len)
 {
   int x, hpos, chpos = w->phys_cursor.hpos;
@@ -29039,7 +29212,7 @@ x_write_glyphs (struct window *w, struct glyph_row *updated_row,
    Insert LEN glyphs from START at the nominal cursor position.  */
 
 void
-x_insert_glyphs (struct window *w, struct glyph_row *updated_row,
+gui_insert_glyphs (struct window *w, struct glyph_row *updated_row,
 		 struct glyph *start, enum glyph_row_area updated_area, int len)
 {
   struct frame *f;
@@ -29096,7 +29269,7 @@ x_insert_glyphs (struct window *w, struct glyph_row *updated_row,
    updated window W.  TO_X == -1 means clear to the end of this area.  */
 
 void
-x_clear_end_of_line (struct window *w, struct glyph_row *updated_row,
+gui_clear_end_of_line (struct window *w, struct glyph_row *updated_row,
 		     enum glyph_row_area updated_area, int to_x)
 {
   struct frame *f;
@@ -29296,7 +29469,7 @@ get_window_cursor_type (struct window *w, struct glyph *glyph, int *width,
 
   /* Detect a nonselected window or nonselected frame.  */
   else if (w != XWINDOW (f->selected_window)
-	   || f != FRAME_DISPLAY_INFO (f)->x_highlight_frame)
+	   || f != FRAME_DISPLAY_INFO (f)->highlight_frame)
     {
       *active_cursor = false;
 
@@ -29483,7 +29656,7 @@ notice_overwritten_cursor (struct window *w, enum glyph_row_area area,
    with respect to the overlapping part OVERLAPS.  */
 
 void
-x_fix_overlapping_area (struct window *w, struct glyph_row *row,
+gui_fix_overlapping_area (struct window *w, struct glyph_row *row,
 			enum glyph_row_area area, int overlaps)
 {
   int i, x;
@@ -29562,12 +29735,12 @@ draw_phys_cursor_glyph (struct window *w, struct glyph_row *row,
 
 	  if (row > w->current_matrix->rows
 	      && MATRIX_ROW_OVERLAPS_SUCC_P (row - 1))
-	    x_fix_overlapping_area (w, row - 1, TEXT_AREA,
+	    gui_fix_overlapping_area (w, row - 1, TEXT_AREA,
 				    OVERLAPS_ERASED_CURSOR);
 
 	  if (MATRIX_ROW_BOTTOM_Y (row) < window_text_bottom_y (w)
 	      && MATRIX_ROW_OVERLAPS_PRED_P (row + 1))
-	    x_fix_overlapping_area (w, row + 1, TEXT_AREA,
+	    gui_fix_overlapping_area (w, row + 1, TEXT_AREA,
 				    OVERLAPS_ERASED_CURSOR);
 	}
     }
@@ -29857,7 +30030,7 @@ update_cursor_in_window_tree (struct window *w, bool on_p)
    Don't change the cursor's position.  */
 
 void
-x_update_cursor (struct frame *f, bool on_p)
+gui_update_cursor (struct frame *f, bool on_p)
 {
   update_cursor_in_window_tree (XWINDOW (f->root_window), on_p);
 }
@@ -29869,7 +30042,7 @@ x_update_cursor (struct frame *f, bool on_p)
    is about to be rewritten.  */
 
 void
-x_clear_cursor (struct window *w)
+gui_clear_cursor (struct window *w)
 {
   if (FRAME_VISIBLE_P (XFRAME (w->frame)) && w->phys_cursor_on_p)
     update_window_cursor (w, false);
@@ -30020,13 +30193,13 @@ show_mouse_face (Mouse_HLInfo *hlinfo, enum draw_glyphs_face draw)
 #ifndef HAVE_EXT_TOOL_BAR
       if (draw == DRAW_NORMAL_TEXT
 	  && !EQ (hlinfo->mouse_face_window, f->tool_bar_window))
-	FRAME_RIF (f)->define_frame_cursor (f, FRAME_X_OUTPUT (f)->text_cursor);
+	FRAME_RIF (f)->define_frame_cursor (f, FRAME_OUTPUT_DATA (f)->text_cursor);
       else
 #endif
       if (draw == DRAW_MOUSE_FACE)
-	FRAME_RIF (f)->define_frame_cursor (f, FRAME_X_OUTPUT (f)->hand_cursor);
+	FRAME_RIF (f)->define_frame_cursor (f, FRAME_OUTPUT_DATA (f)->hand_cursor);
       else
-	FRAME_RIF (f)->define_frame_cursor (f, FRAME_X_OUTPUT (f)->nontext_cursor);
+	FRAME_RIF (f)->define_frame_cursor (f, FRAME_OUTPUT_DATA (f)->nontext_cursor);
     }
 #endif	/* HAVE_WINDOW_SYSTEM */
 }
@@ -30955,7 +31128,7 @@ Returns the alist element for the first matching AREA in MAP.  */)
 
 /* Display frame CURSOR, optionally using shape defined by POINTER.  */
 static void
-define_frame_cursor1 (struct frame *f, Cursor cursor, Lisp_Object pointer)
+define_frame_cursor1 (struct frame *f, Emacs_Cursor cursor, Lisp_Object pointer)
 {
 #ifdef HAVE_WINDOW_SYSTEM
   if (!FRAME_WINDOW_P (f))
@@ -30968,25 +31141,25 @@ define_frame_cursor1 (struct frame *f, Cursor cursor, Lisp_Object pointer)
   if (!NILP (pointer))
     {
       if (EQ (pointer, Qarrow))
-	cursor = FRAME_X_OUTPUT (f)->nontext_cursor;
+	cursor = FRAME_OUTPUT_DATA (f)->nontext_cursor;
       else if (EQ (pointer, Qhand))
-	cursor = FRAME_X_OUTPUT (f)->hand_cursor;
+	cursor = FRAME_OUTPUT_DATA (f)->hand_cursor;
       else if (EQ (pointer, Qtext))
-	cursor = FRAME_X_OUTPUT (f)->text_cursor;
+	cursor = FRAME_OUTPUT_DATA (f)->text_cursor;
       else if (EQ (pointer, intern ("hdrag")))
-	cursor = FRAME_X_OUTPUT (f)->horizontal_drag_cursor;
+	cursor = FRAME_OUTPUT_DATA (f)->horizontal_drag_cursor;
       else if (EQ (pointer, intern ("nhdrag")))
-	cursor = FRAME_X_OUTPUT (f)->vertical_drag_cursor;
+	cursor = FRAME_OUTPUT_DATA (f)->vertical_drag_cursor;
 # ifdef HAVE_X_WINDOWS
       else if (EQ (pointer, intern ("vdrag")))
 	cursor = FRAME_DISPLAY_INFO (f)->vertical_scroll_bar_cursor;
 # endif
       else if (EQ (pointer, intern ("hourglass")))
-	cursor = FRAME_X_OUTPUT (f)->hourglass_cursor;
+	cursor = FRAME_OUTPUT_DATA (f)->hourglass_cursor;
       else if (EQ (pointer, Qmodeline))
-	cursor = FRAME_X_OUTPUT (f)->modeline_cursor;
+	cursor = FRAME_OUTPUT_DATA (f)->modeline_cursor;
       else
-	cursor = FRAME_X_OUTPUT (f)->nontext_cursor;
+	cursor = FRAME_OUTPUT_DATA (f)->nontext_cursor;
     }
 
   if (cursor != No_Cursor)
@@ -31007,7 +31180,7 @@ note_mode_line_or_margin_highlight (Lisp_Object window, int x, int y,
   struct window *w = XWINDOW (window);
   struct frame *f = XFRAME (w->frame);
   Mouse_HLInfo *hlinfo = MOUSE_HL_INFO (f);
-  Cursor cursor = No_Cursor;
+  Emacs_Cursor cursor = No_Cursor;
   Lisp_Object pointer = Qnil;
   int dx, dy, width, height;
   ptrdiff_t charpos;
@@ -31138,7 +31311,7 @@ note_mode_line_or_margin_highlight (Lisp_Object window, int x, int y,
 
 	  if (STRINGP (string))
 	    {
-	      cursor = FRAME_X_OUTPUT (f)->nontext_cursor;
+	      cursor = FRAME_OUTPUT_DATA (f)->nontext_cursor;
 
 	      if (NILP (pointer))
 		pointer = Fget_text_property (pos, Qpointer, string);
@@ -31153,13 +31326,13 @@ note_mode_line_or_margin_highlight (Lisp_Object window, int x, int y,
 		  if (!KEYMAPP (map))
 		    map = Fget_text_property (pos, Qkeymap, string);
 		  if (!KEYMAPP (map) && draggable && area == ON_MODE_LINE)
-		    cursor = FRAME_X_OUTPUT (f)->vertical_drag_cursor;
+		    cursor = FRAME_OUTPUT_DATA (f)->vertical_drag_cursor;
 		}
 	    }
 	  else if (draggable && area == ON_MODE_LINE)
-	    cursor = FRAME_X_OUTPUT (f)->vertical_drag_cursor;
+	    cursor = FRAME_OUTPUT_DATA (f)->vertical_drag_cursor;
 	  else
-	    cursor = FRAME_X_OUTPUT (f)->nontext_cursor;
+	    cursor = FRAME_OUTPUT_DATA (f)->nontext_cursor;
 	}
 #endif
     }
@@ -31320,7 +31493,7 @@ note_mouse_highlight (struct frame *f, int x, int y)
   enum window_part part = ON_NOTHING;
   Lisp_Object window;
   struct window *w;
-  Cursor cursor = No_Cursor;
+  Emacs_Cursor cursor = No_Cursor;
   Lisp_Object pointer = Qnil;  /* Takes precedence over cursor!  */
   struct buffer *b;
 
@@ -31368,41 +31541,41 @@ note_mouse_highlight (struct frame *f, int x, int y)
       switch (part)
 	{
 	case INTERNAL_BORDER_NONE:
-	  if (cursor != FRAME_X_OUTPUT (f)->nontext_cursor)
+	  if (cursor != FRAME_OUTPUT_DATA (f)->nontext_cursor)
 	    /* Reset cursor.  */
-	    cursor = FRAME_X_OUTPUT (f)->nontext_cursor;
+	    cursor = FRAME_OUTPUT_DATA (f)->nontext_cursor;
 	  break;
 	case INTERNAL_BORDER_LEFT_EDGE:
-	  cursor = FRAME_X_OUTPUT (f)->left_edge_cursor;
+	  cursor = FRAME_OUTPUT_DATA (f)->left_edge_cursor;
 	  break;
 	case INTERNAL_BORDER_TOP_LEFT_CORNER:
-	  cursor = FRAME_X_OUTPUT (f)->top_left_corner_cursor;
+	  cursor = FRAME_OUTPUT_DATA (f)->top_left_corner_cursor;
 	  break;
 	case INTERNAL_BORDER_TOP_EDGE:
-	  cursor = FRAME_X_OUTPUT (f)->top_edge_cursor;
+	  cursor = FRAME_OUTPUT_DATA (f)->top_edge_cursor;
 	  break;
 	case INTERNAL_BORDER_TOP_RIGHT_CORNER:
-	  cursor = FRAME_X_OUTPUT (f)->top_right_corner_cursor;
+	  cursor = FRAME_OUTPUT_DATA (f)->top_right_corner_cursor;
 	  break;
 	case INTERNAL_BORDER_RIGHT_EDGE:
-	  cursor = FRAME_X_OUTPUT (f)->right_edge_cursor;
+	  cursor = FRAME_OUTPUT_DATA (f)->right_edge_cursor;
 	  break;
 	case INTERNAL_BORDER_BOTTOM_RIGHT_CORNER:
-	  cursor = FRAME_X_OUTPUT (f)->bottom_right_corner_cursor;
+	  cursor = FRAME_OUTPUT_DATA (f)->bottom_right_corner_cursor;
 	  break;
 	case INTERNAL_BORDER_BOTTOM_EDGE:
-	  cursor = FRAME_X_OUTPUT (f)->bottom_edge_cursor;
+	  cursor = FRAME_OUTPUT_DATA (f)->bottom_edge_cursor;
 	  break;
 	case INTERNAL_BORDER_BOTTOM_LEFT_CORNER:
-	  cursor = FRAME_X_OUTPUT (f)->bottom_left_corner_cursor;
+	  cursor = FRAME_OUTPUT_DATA (f)->bottom_left_corner_cursor;
 	  break;
 	default:
 	  /* This should not happen.  */
-	  if (cursor != FRAME_X_OUTPUT (f)->nontext_cursor)
-	    cursor = FRAME_X_OUTPUT (f)->nontext_cursor;
+	  if (cursor != FRAME_OUTPUT_DATA (f)->nontext_cursor)
+	    cursor = FRAME_OUTPUT_DATA (f)->nontext_cursor;
 	}
 
-      if (cursor != FRAME_X_OUTPUT (f)->nontext_cursor)
+      if (cursor != FRAME_OUTPUT_DATA (f)->nontext_cursor)
 	{
 	  /* Do we really want a help echo here?  */
 	  help_echo_string = build_string ("drag-mouse-1: resize frame");
@@ -31438,7 +31611,7 @@ note_mouse_highlight (struct frame *f, int x, int y)
 #ifdef HAVE_WINDOW_SYSTEM
       if (part == ON_LEFT_MARGIN || part == ON_RIGHT_MARGIN)
 	{
-	  cursor = FRAME_X_OUTPUT (f)->nontext_cursor;
+	  cursor = FRAME_OUTPUT_DATA (f)->nontext_cursor;
 	  /* Show non-text cursor (Bug#16647).  */
 	  goto set_cursor;
 	}
@@ -31450,13 +31623,13 @@ note_mouse_highlight (struct frame *f, int x, int y)
 #ifdef HAVE_WINDOW_SYSTEM
   if (part == ON_VERTICAL_BORDER)
     {
-      cursor = FRAME_X_OUTPUT (f)->horizontal_drag_cursor;
+      cursor = FRAME_OUTPUT_DATA (f)->horizontal_drag_cursor;
       help_echo_string = build_string ("drag-mouse-1: resize");
       goto set_cursor;
     }
   else if (part == ON_RIGHT_DIVIDER)
     {
-      cursor = FRAME_X_OUTPUT (f)->horizontal_drag_cursor;
+      cursor = FRAME_OUTPUT_DATA (f)->horizontal_drag_cursor;
       help_echo_string = build_string ("drag-mouse-1: resize");
       goto set_cursor;
     }
@@ -31465,18 +31638,18 @@ note_mouse_highlight (struct frame *f, int x, int y)
 	|| minibuf_level
 	|| NILP (Vresize_mini_windows))
       {
-	cursor = FRAME_X_OUTPUT (f)->vertical_drag_cursor;
+	cursor = FRAME_OUTPUT_DATA (f)->vertical_drag_cursor;
 	help_echo_string = build_string ("drag-mouse-1: resize");
 	goto set_cursor;
       }
     else
-      cursor = FRAME_X_OUTPUT (f)->nontext_cursor;
+      cursor = FRAME_OUTPUT_DATA (f)->nontext_cursor;
   else if (part == ON_LEFT_FRINGE || part == ON_RIGHT_FRINGE
 	   || part == ON_VERTICAL_SCROLL_BAR
 	   || part == ON_HORIZONTAL_SCROLL_BAR)
-    cursor = FRAME_X_OUTPUT (f)->nontext_cursor;
+    cursor = FRAME_OUTPUT_DATA (f)->nontext_cursor;
   else
-    cursor = FRAME_X_OUTPUT (f)->text_cursor;
+    cursor = FRAME_OUTPUT_DATA (f)->text_cursor;
 #endif
 
   /* Are we in a window whose display is up to date?
@@ -31567,7 +31740,7 @@ note_mouse_highlight (struct frame *f, int x, int y)
 	    {
 #ifdef HAVE_WINDOW_SYSTEM
 	      if (area != TEXT_AREA)
-		cursor = FRAME_X_OUTPUT (f)->nontext_cursor;
+		cursor = FRAME_OUTPUT_DATA (f)->nontext_cursor;
 	      else
 		pointer = Vvoid_text_area_pointer;
 #endif
@@ -31628,7 +31801,9 @@ note_mouse_highlight (struct frame *f, int x, int y)
 	     is currently hidden to avoid Bug#30519.  */
 	  || (!hlinfo->mouse_face_hidden
 	      && OVERLAYP (hlinfo->mouse_face_overlay)
-	      && mouse_face_overlay_overlaps (hlinfo->mouse_face_overlay)))
+	      /* It's possible the overlay was deleted (Bug#35273).  */
+              && XMARKER (OVERLAY_START (hlinfo->mouse_face_overlay))->buffer
+              && mouse_face_overlay_overlaps (hlinfo->mouse_face_overlay)))
 	{
 	  /* Find the highest priority overlay with a mouse-face.  */
 	  Lisp_Object overlay = Qnil;
@@ -31897,7 +32072,7 @@ note_mouse_highlight (struct frame *f, int x, int y)
    functions to ensure the mouse-highlight is off.  */
 
 void
-x_clear_window_mouse_face (struct window *w)
+gui_clear_window_mouse_face (struct window *w)
 {
   Mouse_HLInfo *hlinfo = MOUSE_HL_INFO (XFRAME (w->frame));
   Lisp_Object window;
@@ -31937,7 +32112,7 @@ cancel_mouse_face (struct frame *f)
    which intersects rectangle R.  R is in window-relative coordinates.  */
 
 static void
-expose_area (struct window *w, struct glyph_row *row, XRectangle *r,
+expose_area (struct window *w, struct glyph_row *row, const Emacs_Rectangle *r,
 	     enum glyph_row_area area)
 {
   struct glyph *first = row->glyphs[area];
@@ -31995,7 +32170,7 @@ expose_area (struct window *w, struct glyph_row *row, XRectangle *r,
    true if mouse-face was overwritten.  */
 
 static bool
-expose_line (struct window *w, struct glyph_row *row, XRectangle *r)
+expose_line (struct window *w, struct glyph_row *row, const Emacs_Rectangle *r)
 {
   eassert (row->enabled_p);
 
@@ -32030,7 +32205,7 @@ static void
 expose_overlaps (struct window *w,
 		 struct glyph_row *first_overlapping_row,
 		 struct glyph_row *last_overlapping_row,
-		 XRectangle *r)
+		 const Emacs_Rectangle *r)
 {
   struct glyph_row *row;
 
@@ -32041,13 +32216,13 @@ expose_overlaps (struct window *w,
 
 	row->clip = r;
 	if (row->used[LEFT_MARGIN_AREA])
-	  x_fix_overlapping_area (w, row, LEFT_MARGIN_AREA, OVERLAPS_BOTH);
+	  gui_fix_overlapping_area (w, row, LEFT_MARGIN_AREA, OVERLAPS_BOTH);
 
 	if (row->used[TEXT_AREA])
-	  x_fix_overlapping_area (w, row, TEXT_AREA, OVERLAPS_BOTH);
+	  gui_fix_overlapping_area (w, row, TEXT_AREA, OVERLAPS_BOTH);
 
 	if (row->used[RIGHT_MARGIN_AREA])
-	  x_fix_overlapping_area (w, row, RIGHT_MARGIN_AREA, OVERLAPS_BOTH);
+	  gui_fix_overlapping_area (w, row, RIGHT_MARGIN_AREA, OVERLAPS_BOTH);
 	row->clip = NULL;
       }
 }
@@ -32056,9 +32231,9 @@ expose_overlaps (struct window *w,
 /* Return true if W's cursor intersects rectangle R.  */
 
 static bool
-phys_cursor_in_rect_p (struct window *w, XRectangle *r)
+phys_cursor_in_rect_p (struct window *w, const Emacs_Rectangle *r)
 {
-  XRectangle cr, result;
+  Emacs_Rectangle cr, result;
   struct glyph *cursor_glyph;
   struct glyph_row *row;
 
@@ -32076,7 +32251,7 @@ phys_cursor_in_rect_p (struct window *w, XRectangle *r)
       cr.y = row->y;
       cr.width = WINDOW_RIGHT_FRINGE_WIDTH (w);
       cr.height = row->height;
-      return x_intersect_rectangles (&cr, r, &result);
+      return gui_intersect_rectangles (&cr, r, &result);
     }
 
   cursor_glyph = get_phys_cursor_glyph (w);
@@ -32090,7 +32265,7 @@ phys_cursor_in_rect_p (struct window *w, XRectangle *r)
       cr.height = w->phys_cursor_height;
       /* ++KFS: W32 version used W32-specific IntersectRect here, but
 	 I assume the effect is the same -- and this is portable.  */
-      return x_intersect_rectangles (&cr, r, &result);
+      return gui_intersect_rectangles (&cr, r, &result);
     }
   /* If we don't understand the format, pretend we're not in the hot-spot.  */
   return false;
@@ -32102,7 +32277,7 @@ phys_cursor_in_rect_p (struct window *w, XRectangle *r)
    have vertical scroll bars.  */
 
 void
-x_draw_vertical_border (struct window *w)
+gui_draw_vertical_border (struct window *w)
 {
   struct frame *f = XFRAME (WINDOW_FRAME (w));
 
@@ -32153,7 +32328,7 @@ x_draw_vertical_border (struct window *w)
 /* Draw window dividers for window W.  */
 
 void
-x_draw_right_divider (struct window *w)
+gui_draw_right_divider (struct window *w)
 {
   struct frame *f = WINDOW_XFRAME (w);
 
@@ -32179,7 +32354,7 @@ x_draw_right_divider (struct window *w)
 }
 
 static void
-x_draw_bottom_divider (struct window *w)
+gui_draw_bottom_divider (struct window *w)
 {
   struct frame *f = XFRAME (WINDOW_FRAME (w));
 
@@ -32216,10 +32391,10 @@ x_draw_bottom_divider (struct window *w)
    mouse-face.  */
 
 static bool
-expose_window (struct window *w, XRectangle *fr)
+expose_window (struct window *w, const Emacs_Rectangle *fr)
 {
   struct frame *f = XFRAME (w->frame);
-  XRectangle wr, r;
+  Emacs_Rectangle wr, r;
   bool mouse_face_overwritten_p = false;
 
   /* If window is not yet fully initialized, do nothing.  This can
@@ -32244,7 +32419,7 @@ expose_window (struct window *w, XRectangle *fr)
   wr.width = WINDOW_PIXEL_WIDTH (w);
   wr.height = WINDOW_PIXEL_HEIGHT (w);
 
-  if (x_intersect_rectangles (fr, &wr, &r))
+  if (gui_intersect_rectangles (fr, &wr, &r))
     {
       int yb = window_text_bottom_y (w);
       struct glyph_row *row;
@@ -32261,7 +32436,7 @@ expose_window (struct window *w, XRectangle *fr)
       bool cursor_cleared_p = (!w->pseudo_window_p
 			       && phys_cursor_in_rect_p (w, &r));
       if (cursor_cleared_p)
-	x_clear_cursor (w);
+	gui_clear_cursor (w);
 
       /* If the row containing the cursor extends face to end of line,
 	 then expose_area might overwrite the cursor outside the
@@ -32354,12 +32529,12 @@ expose_window (struct window *w, XRectangle *fr)
 
 	  /* Draw border between windows.  */
 	  if (WINDOW_RIGHT_DIVIDER_WIDTH (w))
-	    x_draw_right_divider (w);
+	    gui_draw_right_divider (w);
 	  else
-	    x_draw_vertical_border (w);
+	    gui_draw_vertical_border (w);
 
 	  if (WINDOW_BOTTOM_DIVIDER_WIDTH (w))
-	    x_draw_bottom_divider (w);
+	    gui_draw_bottom_divider (w);
 
 	  /* Turn the cursor on again.  */
 	  if (cursor_cleared_p
@@ -32378,7 +32553,7 @@ expose_window (struct window *w, XRectangle *fr)
    true if the exposure overwrites mouse-face.  */
 
 static bool
-expose_window_tree (struct window *w, XRectangle *r)
+expose_window_tree (struct window *w, const Emacs_Rectangle *r)
 {
   struct frame *f = XFRAME (w->frame);
   bool mouse_face_overwritten_p = false;
@@ -32406,7 +32581,7 @@ expose_window_tree (struct window *w, XRectangle *r)
 void
 expose_frame (struct frame *f, int x, int y, int w, int h)
 {
-  XRectangle r;
+  Emacs_Rectangle r;
   bool mouse_face_overwritten_p = false;
 
   TRACE ((stderr, "expose_frame "));
@@ -32493,10 +32668,11 @@ expose_frame (struct frame *f, int x, int y, int w, int h)
    empty.  */
 
 bool
-x_intersect_rectangles (XRectangle *r1, XRectangle *r2, XRectangle *result)
+gui_intersect_rectangles (const Emacs_Rectangle *r1, const Emacs_Rectangle *r2,
+                          Emacs_Rectangle *result)
 {
-  XRectangle *left, *right;
-  XRectangle *upper, *lower;
+  const Emacs_Rectangle *left, *right;
+  const Emacs_Rectangle *upper, *lower;
   bool intersection_p = false;
 
   /* Rearrange so that R1 is the left-most rectangle.  */
@@ -32642,6 +32818,9 @@ be let-bound around code that needs to disable messages temporarily. */);
   /* Name of a text property which disables line-number display.  */
   DEFSYM (Qdisplay_line_numbers_disable, "display-line-numbers-disable");
 
+  /* Name of the face used to display fill column indicator character.  */
+  DEFSYM (Qfill_column_indicator, "fill-column-indicator");
+
   /* Name and number of the face used to highlight escape glyphs.  */
   DEFSYM (Qescape_glyph, "escape-glyph");
 
@@ -32904,14 +33083,18 @@ which no explicit name has been set (see `modify-frame-parameters').  */);
 This variable has the same structure as `mode-line-format' (which see),
 and is used only on frames for which no explicit name has been set
 \(see `modify-frame-parameters').  */);
+  /* Do not nest calls to pure_list.  This works around a bug in
+     Oracle Developer Studio 12.6.  */
+  Lisp_Object icon_title_name_format
+    = pure_list (empty_unibyte_string,
+		 intern_c_string ("invocation-name"),
+		 build_pure_c_string ("@"),
+		 intern_c_string ("system-name"));
   Vicon_title_format
     = Vframe_title_format
     = pure_list (intern_c_string ("multiple-frames"),
 		 build_pure_c_string ("%b"),
-		 pure_list (empty_unibyte_string,
-			    intern_c_string ("invocation-name"),
-			    build_pure_c_string ("@"),
-			    intern_c_string ("system-name")));
+		 icon_title_name_format);
 
   DEFVAR_LISP ("message-log-max", Vmessage_log_max,
     doc: /* Maximum number of lines to keep in the message log buffer.
@@ -33210,6 +33393,30 @@ either `relative' or `visual'.  */);
   DEFSYM (Qdisplay_line_numbers_widen, "display-line-numbers-widen");
   Fmake_variable_buffer_local (Qdisplay_line_numbers_widen);
 
+  DEFVAR_BOOL ("display-fill-column-indicator", Vdisplay_fill_column_indicator,
+    doc: /* Non-nil means display the fill column indicator.  */);
+  Vdisplay_fill_column_indicator = false;
+  DEFSYM (Qdisplay_fill_column_indicator, "display-fill-column-indicator");
+  Fmake_variable_buffer_local (Qdisplay_fill_column_indicator);
+
+  DEFVAR_LISP ("display-fill-column-indicator-column", Vdisplay_fill_column_indicator_column,
+    doc: /* Column for indicator when `display-fill-column-indicator'
+is non-nil.  The default value is t which means that the indicator
+will use the `fill-column' variable.  If it is set to an integer the
+indicator will be drawn in that column.  */);
+  Vdisplay_fill_column_indicator_column = Qt;
+  DEFSYM (Qdisplay_fill_column_indicator_column, "display-fill-column-indicator-column");
+  Fmake_variable_buffer_local (Qdisplay_fill_column_indicator_column);
+
+  DEFVAR_LISP ("display-fill-column-indicator-character", Vdisplay_fill_column_indicator_character,
+    doc: /* Character to draw the indicator when
+`display-fill-column-indicator' is non-nil.  The default is U+2502 but
+a good alternative is (ascii 124) if the font in fill-column-indicator
+face does not support Unicode characters.  */);
+  Vdisplay_fill_column_indicator_character = Qnil;
+  DEFSYM (Qdisplay_fill_column_indicator_character, "display-fill-column-indicator-character");
+  Fmake_variable_buffer_local (Qdisplay_fill_column_indicator_character);
+
   DEFVAR_BOOL ("inhibit-eval-during-redisplay", inhibit_eval_during_redisplay,
     doc: /* Non-nil means don't eval Lisp during redisplay.  */);
   inhibit_eval_during_redisplay = false;
diff --git a/src/xfaces.c b/src/xfaces.c
index c6723ebe2c..d211ec8c46 100644
--- a/src/xfaces.c
+++ b/src/xfaces.c
@@ -321,11 +321,6 @@ bool face_change;
 
 static bool tty_suppress_bold_inverse_default_colors_p;
 
-/* A list of the form `((x . y))' used to avoid consing in
-   Finternal_set_lisp_face_attribute.  */
-
-static Lisp_Object Vparam_value_alist;
-
 /* The total number of colors currently allocated.  */
 
 #ifdef GLYPH_DEBUG
@@ -343,7 +338,7 @@ struct named_merge_point;
 
 static struct face *realize_face (struct face_cache *, Lisp_Object *,
 				  int);
-static struct face *realize_x_face (struct face_cache *, Lisp_Object *);
+static struct face *realize_gui_face (struct face_cache *, Lisp_Object *);
 static struct face *realize_tty_face (struct face_cache *, Lisp_Object *);
 static bool realize_basic_faces (struct frame *);
 static bool realize_default_face (struct frame *);
@@ -353,7 +348,7 @@ static void free_face_cache (struct face_cache *);
 static bool merge_face_ref (struct window *w,
                             struct frame *, Lisp_Object, Lisp_Object *,
 			    bool, struct named_merge_point *);
-static int color_distance (XColor *x, XColor *y);
+static int color_distance (Emacs_Color *x, Emacs_Color *y);
 
 #ifdef HAVE_WINDOW_SYSTEM
 static void set_font_frame_param (Lisp_Object, Lisp_Object);
@@ -518,12 +513,12 @@ x_free_gc (struct frame *f, GC gc)
 #ifdef HAVE_NTGUI
 /* W32 emulation of GCs */
 
-static GC
-x_create_gc (struct frame *f, unsigned long mask, XGCValues *xgcv)
+static Emacs_GC *
+x_create_gc (struct frame *f, unsigned long mask, Emacs_GC *egc)
 {
-  GC gc;
+  Emacs_GC *gc;
   block_input ();
-  gc = XCreateGC (NULL, FRAME_W32_WINDOW (f), mask, xgcv);
+  gc = XCreateGC (NULL, FRAME_W32_WINDOW (f), mask, egc);
   unblock_input ();
   IF_DEBUG (++ngcs);
   return gc;
@@ -533,7 +528,7 @@ x_create_gc (struct frame *f, unsigned long mask, XGCValues *xgcv)
 /* Free GC which was used on frame F.  */
 
 static void
-x_free_gc (struct frame *f, GC gc)
+x_free_gc (struct frame *f, Emacs_GC *gc)
 {
   IF_DEBUG ((--ngcs, eassert (ngcs >= 0)));
   xfree (gc);
@@ -544,18 +539,18 @@ x_free_gc (struct frame *f, GC gc)
 #ifdef HAVE_NS
 /* NS emulation of GCs */
 
-static GC
+static Emacs_GC *
 x_create_gc (struct frame *f,
 	     unsigned long mask,
-	     XGCValues *xgcv)
+	     Emacs_GC *egc)
 {
-  GC gc = xmalloc (sizeof *gc);
-  *gc = *xgcv;
+  Emacs_GC *gc = xmalloc (sizeof *gc);
+  *gc = *egc;
   return gc;
 }
 
 static void
-x_free_gc (struct frame *f, GC gc)
+x_free_gc (struct frame *f, Emacs_GC *gc)
 {
   xfree (gc);
 }
@@ -777,13 +772,13 @@ load_pixmap (struct frame *f, Lisp_Object name)
       h = XFIXNUM (Fcar (Fcdr (name)));
       bits = Fcar (Fcdr (Fcdr (name)));
 
-      bitmap_id = x_create_bitmap_from_data (f, SSDATA (bits),
-					     w, h);
+      bitmap_id = image_create_bitmap_from_data (f, SSDATA (bits),
+                                                 w, h);
     }
   else
     {
       /* It must be a string -- a file name.  */
-      bitmap_id = x_create_bitmap_from_file (f, name);
+      bitmap_id = image_create_bitmap_from_file (f, name);
     }
   unblock_input ();
 
@@ -807,7 +802,7 @@ load_pixmap (struct frame *f, Lisp_Object name)
 
 
 /***********************************************************************
-				X Colors
+                            Color Handling
  ***********************************************************************/
 
 /* Parse RGB_LIST, and fill in the RGB fields of COLOR.
@@ -815,7 +810,7 @@ load_pixmap (struct frame *f, Lisp_Object name)
    Return true iff RGB_LIST is OK.  */
 
 static bool
-parse_rgb_list (Lisp_Object rgb_list, XColor *color)
+parse_rgb_list (Lisp_Object rgb_list, Emacs_Color *color)
 {
 #define PARSE_RGB_LIST_FIELD(field)					\
   if (CONSP (rgb_list) && FIXNUMP (XCAR (rgb_list)))			\
@@ -840,8 +835,8 @@ parse_rgb_list (Lisp_Object rgb_list, XColor *color)
    returned in it.  */
 
 static bool
-tty_lookup_color (struct frame *f, Lisp_Object color, XColor *tty_color,
-		  XColor *std_color)
+tty_lookup_color (struct frame *f, Lisp_Object color, Emacs_Color *tty_color,
+		  Emacs_Color *std_color)
 {
   Lisp_Object frame, color_desc;
 
@@ -898,11 +893,11 @@ tty_lookup_color (struct frame *f, Lisp_Object color, XColor *tty_color,
     return false;
 }
 
-/* A version of defined_color for non-X frames.  */
+/* An implementation of defined_color_hook for tty frames.  */
 
-static bool
+bool
 tty_defined_color (struct frame *f, const char *color_name,
-		   XColor *color_def, bool alloc)
+		   Emacs_Color *color_def, bool alloc, bool _makeIndex)
 {
   bool status = true;
 
@@ -929,36 +924,6 @@ tty_defined_color (struct frame *f, const char *color_name,
   return status;
 }
 
-
-/* Decide if color named COLOR_NAME is valid for the display
-   associated with the frame F; if so, return the rgb values in
-   COLOR_DEF.  If ALLOC, allocate a new colormap cell.
-
-   This does the right thing for any type of frame.  */
-
-static bool
-defined_color (struct frame *f, const char *color_name, XColor *color_def,
-	       bool alloc)
-{
-  if (!FRAME_WINDOW_P (f))
-    return tty_defined_color (f, color_name, color_def, alloc);
-#ifdef HAVE_X_WINDOWS
-  else if (FRAME_X_P (f))
-    return x_defined_color (f, color_name, color_def, alloc);
-#endif
-#ifdef HAVE_NTGUI
-  else if (FRAME_W32_P (f))
-    return w32_defined_color (f, color_name, color_def, alloc);
-#endif
-#ifdef HAVE_NS
-  else if (FRAME_NS_P (f))
-    return ns_defined_color (f, color_name, color_def, alloc, true);
-#endif
-  else
-    emacs_abort ();
-}
-
-
 /* Given the index IDX of a tty color on frame F, return its name, a
    Lisp string.  */
 
@@ -1000,10 +965,11 @@ tty_color_name (struct frame *f, int idx)
 static bool
 face_color_gray_p (struct frame *f, const char *color_name)
 {
-  XColor color;
+  Emacs_Color color;
   bool gray_p;
 
-  if (defined_color (f, color_name, &color, false))
+  if (FRAME_TERMINAL (f)->defined_color_hook
+      (f, color_name, &color, false, true))
     gray_p = (/* Any color sufficiently close to black counts as gray.  */
 	      (color.red < 5000 && color.green < 5000 && color.blue < 5000)
 	      ||
@@ -1028,7 +994,7 @@ face_color_supported_p (struct frame *f, const char *color_name,
 			bool background_p)
 {
   Lisp_Object frame;
-  XColor not_used;
+  Emacs_Color not_used;
 
   XSETFRAME (frame, f);
   return
@@ -1043,7 +1009,7 @@ face_color_supported_p (struct frame *f, const char *color_name,
 	   && face_color_gray_p (f, color_name)))
     :
 #endif
-    tty_defined_color (f, color_name, &not_used, false);
+    tty_defined_color (f, color_name, &not_used, false, false);
 }
 
 
@@ -1077,7 +1043,7 @@ COLOR must be a valid color name.  */)
 
 static unsigned long
 load_color2 (struct frame *f, struct face *face, Lisp_Object name,
-             enum lface_attribute_index target_index, XColor *color)
+             enum lface_attribute_index target_index, Emacs_Color *color)
 {
   eassert (STRINGP (name));
   eassert (target_index == LFACE_FOREGROUND_INDEX
@@ -1087,9 +1053,10 @@ load_color2 (struct frame *f, struct face *face, Lisp_Object name,
 	   || target_index == LFACE_STRIKE_THROUGH_INDEX
 	   || target_index == LFACE_BOX_INDEX);
 
-  /* if the color map is full, defined_color will return a best match
+  /* if the color map is full, defined_color_hook will return a best match
      to the values in an existing cell. */
-  if (!defined_color (f, SSDATA (name), color, true))
+  if (!FRAME_TERMINAL (f)->defined_color_hook
+      (f, SSDATA (name), color, true, true))
     {
       add_to_log ("Unable to load color \"%s\"", name);
 
@@ -1150,7 +1117,7 @@ unsigned long
 load_color (struct frame *f, struct face *face, Lisp_Object name,
 	    enum lface_attribute_index target_index)
 {
-  XColor color;
+  Emacs_Color color;
   return load_color2 (f, face, name, target_index, &color);
 }
 
@@ -1167,7 +1134,7 @@ load_face_colors (struct frame *f, struct face *face,
 		  Lisp_Object attrs[LFACE_VECTOR_SIZE])
 {
   Lisp_Object fg, bg, dfg;
-  XColor xfg, xbg;
+  Emacs_Color xfg, xbg;
 
   bg = attrs[LFACE_BACKGROUND_INDEX];
   fg = attrs[LFACE_FOREGROUND_INDEX];
@@ -1188,7 +1155,7 @@ load_face_colors (struct frame *f, struct face *face,
   if (!face_color_supported_p (f, SSDATA (bg), false)
       && !NILP (Fbitmap_spec_p (Vface_default_stipple)))
     {
-      x_destroy_bitmap (f, face->stipple);
+      image_destroy_bitmap (f, face->stipple);
       face->stipple = load_pixmap (f, Vface_default_stipple);
     }
 
@@ -2298,11 +2265,12 @@ filter_face_ref (Lisp_Object face_ref,
 }
 
 /* Merge face attributes from the lisp `face reference' FACE_REF on
-   frame F into the face attribute vector TO.  If ERR_MSGS,
-   problems with FACE_REF cause an error message to be shown.  Return
-   true if no errors occurred (regardless of the value of ERR_MSGS).
-   Use NAMED_MERGE_POINTS to detect loops in face inheritance or
-   list structure; it may be 0 for most callers.
+   frame F into the face attribute vector TO as appropriate for
+   window W; W is used only for filtering face specs.  If ERR_MSGS
+   is non-zero, problems with FACE_REF cause an error message to be
+   shown.  Return true if no errors occurred (regardless of the value
+   of ERR_MSGS).  Use NAMED_MERGE_POINTS to detect loops in face
+   inheritance or list structure; it may be 0 for most callers.
 
    FACE_REF may be a single face specification or a list of such
    specifications.  Each face specification can be:
@@ -2319,9 +2287,10 @@ filter_face_ref (Lisp_Object face_ref,
 
    4. Conses of the form
    (:filtered (:window PARAMETER VALUE) FACE-SPECIFICATION),
-   which applies FACE-SPECIFICATION only if the
-   given face attributes are being evaluated in the context of a
-   window with a parameter named PARAMETER being EQ VALUE.
+   which applies FACE-SPECIFICATION only if the given face attributes
+   are being evaluated in the context of a window with a parameter
+   named PARAMETER being EQ VALUE.  In this case, W specifies the window
+   for which the filtered face spec is to be evaluated.
 
    5. nil, which means to merge nothing.
 
@@ -3348,11 +3317,8 @@ FRAME 0 means change the face on all frames, and change the default
 	  else
 	    /* Update the current frame's parameters.  */
 	    {
-	      Lisp_Object cons;
-	      cons = XCAR (Vparam_value_alist);
-	      XSETCAR (cons, param);
-	      XSETCDR (cons, value);
-	      Fmodify_frame_parameters (frame, Vparam_value_alist);
+	      AUTO_FRAME_ARG (arg, param, value);
+	      Fmodify_frame_parameters (frame, arg);
 	    }
 	}
     }
@@ -3484,8 +3450,8 @@ ordinary `x-get-resource' doesn't take a frame argument.  */)
   CHECK_STRING (class);
   f = decode_live_frame (frame);
   block_input ();
-  value = display_x_get_resource (FRAME_DISPLAY_INFO (f),
-				  resource, class, Qnil, Qnil);
+  value = gui_display_get_resource (FRAME_DISPLAY_INFO (f),
+                                    resource, class, Qnil, Qnil);
   unblock_input ();
   return value;
 }
@@ -4153,7 +4119,7 @@ free_realized_face (struct frame *f, struct face *face)
 #ifdef HAVE_X_WINDOWS
 	  free_face_colors (f, face);
 #endif /* HAVE_X_WINDOWS */
-	  x_destroy_bitmap (f, face->stipple);
+	  image_destroy_bitmap (f, face->stipple);
 	}
 #endif /* HAVE_WINDOW_SYSTEM */
 
@@ -4174,25 +4140,25 @@ prepare_face_for_display (struct frame *f, struct face *face)
 
   if (face->gc == 0)
     {
-      XGCValues xgcv;
+      Emacs_GC egc;
       unsigned long mask = GCForeground | GCBackground | GCGraphicsExposures;
 
-      xgcv.foreground = face->foreground;
-      xgcv.background = face->background;
+      egc.foreground = face->foreground;
+      egc.background = face->background;
 #ifdef HAVE_X_WINDOWS
-      xgcv.graphics_exposures = False;
+      egc.graphics_exposures = False;
 #endif
 
       block_input ();
 #ifdef HAVE_X_WINDOWS
       if (face->stipple)
 	{
-	  xgcv.fill_style = FillOpaqueStippled;
-	  xgcv.stipple = x_bitmap_pixmap (f, face->stipple);
+	  egc.fill_style = FillOpaqueStippled;
+	  egc.stipple = image_bitmap_pixmap (f, face->stipple);
 	  mask |= GCFillStyle | GCStipple;
 	}
 #endif
-      face->gc = x_create_gc (f, mask, &xgcv);
+      face->gc = x_create_gc (f, mask, &egc);
       if (face->font)
 	font_prepare_for_face (f, face);
       unblock_input ();
@@ -4204,7 +4170,7 @@ prepare_face_for_display (struct frame *f, struct face *face)
 /* Returns the `distance' between the colors X and Y.  */
 
 static int
-color_distance (XColor *x, XColor *y)
+color_distance (Emacs_Color *x, Emacs_Color *y)
 {
   /* This formula is from a paper titled `Colour metric' by Thiadmer Riemersma.
      Quoting from that paper:
@@ -4239,15 +4205,23 @@ two lists of the form (RED GREEN BLUE) aforementioned. */)
    Lisp_Object metric)
 {
   struct frame *f = decode_live_frame (frame);
-  XColor cdef1, cdef2;
+  Emacs_Color cdef1, cdef2;
 
   if (!(CONSP (color1) && parse_rgb_list (color1, &cdef1))
       && !(STRINGP (color1)
-	   && defined_color (f, SSDATA (color1), &cdef1, false)))
+           && FRAME_TERMINAL (f)->defined_color_hook (f,
+                                                      SSDATA (color1),
+                                                      &cdef1,
+                                                      false,
+                                                      true)))
     signal_error ("Invalid color", color1);
   if (!(CONSP (color2) && parse_rgb_list (color2, &cdef2))
       && !(STRINGP (color2)
-	   && defined_color (f, SSDATA (color2), &cdef2, false)))
+           && FRAME_TERMINAL (f)->defined_color_hook (f,
+                                                      SSDATA (color2),
+                                                      &cdef2,
+                                                      false,
+                                                      true)))
     signal_error ("Invalid color", color2);
 
   if (NILP (metric))
@@ -4799,9 +4773,9 @@ DEFUN ("face-attributes-as-vector", Fface_attributes_as_vector,
     (2) `close in spirit' to what the attributes specify, if not exact.  */
 
 static bool
-x_supports_face_attributes_p (struct frame *f,
-			      Lisp_Object attrs[LFACE_VECTOR_SIZE],
-			      struct face *def_face)
+gui_supports_face_attributes_p (struct frame *f,
+                                Lisp_Object attrs[LFACE_VECTOR_SIZE],
+                                struct face *def_face)
 {
   Lisp_Object *def_attrs = def_face->lface;
 
@@ -4911,8 +4885,8 @@ tty_supports_face_attributes_p (struct frame *f,
 {
   int weight, slant;
   Lisp_Object val, fg, bg;
-  XColor fg_tty_color, fg_std_color;
-  XColor bg_tty_color, bg_std_color;
+  Emacs_Color fg_tty_color, fg_std_color;
+  Emacs_Color bg_tty_color, bg_std_color;
   unsigned test_caps = 0;
   Lisp_Object *def_attrs = def_face->lface;
 
@@ -5014,7 +4988,7 @@ tty_supports_face_attributes_p (struct frame *f,
       else
 	/* Make sure the color is really different than the default.  */
 	{
-	  XColor def_fg_color;
+	  Emacs_Color def_fg_color;
 	  if (tty_lookup_color (f, def_fg, &def_fg_color, 0)
 	      && (color_distance (&fg_tty_color, &def_fg_color)
 		  <= TTY_SAME_COLOR_THRESHOLD))
@@ -5038,7 +5012,7 @@ tty_supports_face_attributes_p (struct frame *f,
       else
 	/* Make sure the color is really different than the default.  */
 	{
-	  XColor def_bg_color;
+	  Emacs_Color def_bg_color;
 	  if (tty_lookup_color (f, def_bg, &def_bg_color, 0)
 	      && (color_distance (&bg_tty_color, &def_bg_color)
 		  <= TTY_SAME_COLOR_THRESHOLD))
@@ -5138,7 +5112,7 @@ face for italic.  */)
     supports = tty_supports_face_attributes_p (f, attrs, def_face);
 #ifdef HAVE_WINDOW_SYSTEM
   else
-    supports = x_supports_face_attributes_p (f, attrs, def_face);
+    supports = gui_supports_face_attributes_p (f, attrs, def_face);
 #endif
 
   return supports ? Qt : Qnil;
@@ -5458,7 +5432,7 @@ realize_default_face (struct frame *f)
 	 acceptable as a font for the default face (perhaps because
 	 auto-scaled fonts are rejected), so we must adjust the frame
 	 font.  */
-      x_set_font (f, LFACE_FONT (lface), Qnil);
+      gui_set_font (f, LFACE_FONT (lface), Qnil);
     }
 #endif
   return true;
@@ -5524,7 +5498,7 @@ realize_face (struct face_cache *cache, Lisp_Object attrs[LFACE_VECTOR_SIZE],
     }
 
   if (FRAME_WINDOW_P (cache->f))
-    face = realize_x_face (cache, attrs);
+    face = realize_gui_face (cache, attrs);
   else if (FRAME_TERMCAP_P (cache->f) || FRAME_MSDOS_P (cache->f))
     face = realize_tty_face (cache, attrs);
   else if (FRAME_INITIAL_P (cache->f))
@@ -5575,14 +5549,14 @@ realize_non_ascii_face (struct frame *f, Lisp_Object font_object,
 
 
 /* Realize the fully-specified face with attributes ATTRS in face
-   cache CACHE for ASCII characters.  Do it for X frame CACHE->f.  If
-   the new face doesn't share font with the default face, a fontname
-   is allocated from the heap and set in `font_name' of the new face,
-   but it is not yet loaded here.  Value is a pointer to the newly
-   created realized face.  */
+   cache CACHE for ASCII characters.  Do it for GUI frame CACHE->f.
+   If the new face doesn't share font with the default face, a
+   fontname is allocated from the heap and set in `font_name' of the
+   new face, but it is not yet loaded here.  Value is a pointer to the
+   newly created realized face.  */
 
 static struct face *
-realize_x_face (struct face_cache *cache, Lisp_Object attrs[LFACE_VECTOR_SIZE])
+realize_gui_face (struct face_cache *cache, Lisp_Object attrs[LFACE_VECTOR_SIZE])
 {
   struct face *face = NULL;
 #ifdef HAVE_WINDOW_SYSTEM
@@ -6633,8 +6607,6 @@ syms_of_xfaces (void)
   /* The name of the function used to compute colors on TTYs.  */
   DEFSYM (Qtty_color_alist, "tty-color-alist");
 
-  Vparam_value_alist = list1 (Fcons (Qnil, Qnil));
-  staticpro (&Vparam_value_alist);
   Vface_alternative_font_family_alist = Qnil;
   staticpro (&Vface_alternative_font_family_alist);
   Vface_alternative_font_registry_alist = Qnil;
diff --git a/src/xfns.c b/src/xfns.c
index 13f66f0718..4195980d33 100644
--- a/src/xfns.c
+++ b/src/xfns.c
@@ -653,7 +653,7 @@ gamma_correct (struct frame *f, XColor *color)
 
 bool
 x_defined_color (struct frame *f, const char *color_name,
-		 XColor *color, bool alloc_p)
+		 Emacs_Color *color, bool alloc_p, bool _makeIndex)
 {
   bool success_p = false;
   Colormap cmap = FRAME_X_COLORMAP (f);
@@ -698,7 +698,7 @@ x_decode_color (struct frame *f, Lisp_Object color_name, int mono_color)
 
   /* x_defined_color is responsible for coping with failures
      by looking for a near-miss.  */
-  if (x_defined_color (f, SSDATA (color_name), &cdef, true))
+  if (x_defined_color (f, SSDATA (color_name), &cdef, true, false))
     return cdef.pixel;
 
   signal_error ("Undefined color", color_name);
@@ -978,7 +978,7 @@ xg_set_icon (struct frame *f, Lisp_Object file)
   bool result = false;
   Lisp_Object found;
 
-  found = x_find_image_file (file);
+  found = image_find_image_file (file);
 
   if (! NILP (found))
     {
@@ -1021,7 +1021,7 @@ xg_set_icon_from_xpm_data (struct frame *f, const char **data)
 #endif /* USE_GTK */
 
 
-/* Functions called only from `x_set_frame_param'
+/* Functions called only from `gui_set_frame_parameters'
    to set individual parameters.
 
    If FRAME_X_WINDOW (f) is 0,
@@ -1388,8 +1388,8 @@ x_set_cursor_color (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 
       if (FRAME_VISIBLE_P (f))
 	{
-	  x_update_cursor (f, false);
-	  x_update_cursor (f, true);
+	  gui_update_cursor (f, false);
+	  gui_update_cursor (f, true);
 	}
     }
 
@@ -1466,7 +1466,7 @@ x_set_icon_type (struct frame *f, Lisp_Object arg, Lisp_Object oldval)
 				   ? f->icon_name
 				   : f->name)));
   else
-    result = x_bitmap_icon (f, arg);
+    result = FRAME_TERMINAL (f)->set_bitmap_icon_hook (f, arg);
 
   if (result)
     {
@@ -2115,7 +2115,8 @@ x_default_scroll_bar_color_parameter (struct frame *f,
   struct x_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
   Lisp_Object tem;
 
-  tem = x_get_arg (dpyinfo, alist, prop, xprop, xclass, RES_TYPE_STRING);
+  tem = gui_display_get_arg (dpyinfo, alist, prop, xprop, xclass,
+                             RES_TYPE_STRING);
   if (EQ (tem, Qunbound))
     {
 #ifdef USE_TOOLKIT_SCROLL_BARS
@@ -2125,7 +2126,7 @@ x_default_scroll_bar_color_parameter (struct frame *f,
       AUTO_STRING (foreground, "foreground");
       AUTO_STRING (background, "foreground");
       AUTO_STRING (verticalScrollBar, "verticalScrollBar");
-      tem = (display_x_get_resource
+      tem = (gui_display_get_resource
 	     (dpyinfo, foreground_p ? foreground : background,
 	      empty_unibyte_string,
 	      verticalScrollBar,
@@ -2148,7 +2149,7 @@ x_default_scroll_bar_color_parameter (struct frame *f,
     }
 
   AUTO_FRAME_ARG (arg, prop, tem);
-  x_set_frame_parameters (f, arg);
+  gui_set_frame_parameters (f, arg);
   return tem;
 }
 
@@ -2783,6 +2784,9 @@ set_up_x_back_buffer (struct frame *f)
   block_input ();
   if (FRAME_X_WINDOW (f) && !FRAME_X_DOUBLE_BUFFERED_P (f))
     {
+#ifdef USE_CAIRO
+      x_cr_destroy_frame_context (f);
+#endif
       FRAME_X_RAW_DRAWABLE (f) = FRAME_X_WINDOW (f);
       if (FRAME_DISPLAY_INFO (f)->supports_xdbe)
         {
@@ -2812,6 +2816,9 @@ tear_down_x_back_buffer (struct frame *f)
     {
       if (FRAME_X_DOUBLE_BUFFERED_P (f))
         {
+#ifdef USE_CAIRO
+	  x_cr_destroy_frame_context (f);
+#endif
           XdbeDeallocateBackBufferName (FRAME_X_DISPLAY (f),
                                         FRAME_X_DRAWABLE (f));
           FRAME_X_RAW_DRAWABLE (f) = FRAME_X_WINDOW (f);
@@ -3257,8 +3264,8 @@ x_icon_verify (struct frame *f, Lisp_Object parms)
 
   /* Set the position of the icon.  Note that twm groups all
      icons in an icon window.  */
-  icon_x = x_frame_get_and_record_arg (f, parms, Qicon_left, 0, 0, RES_TYPE_NUMBER);
-  icon_y = x_frame_get_and_record_arg (f, parms, Qicon_top, 0, 0, RES_TYPE_NUMBER);
+  icon_x = gui_frame_get_and_record_arg (f, parms, Qicon_left, 0, 0, RES_TYPE_NUMBER);
+  icon_y = gui_frame_get_and_record_arg (f, parms, Qicon_top, 0, 0, RES_TYPE_NUMBER);
   if (!EQ (icon_x, Qunbound) && !EQ (icon_y, Qunbound))
     {
       CHECK_FIXNUM (icon_x);
@@ -3278,9 +3285,9 @@ x_icon (struct frame *f, Lisp_Object parms)
   /* Set the position of the icon.  Note that twm groups all
      icons in an icon window.  */
   Lisp_Object icon_x
-    = x_frame_get_and_record_arg (f, parms, Qicon_left, 0, 0, RES_TYPE_NUMBER);
+    = gui_frame_get_and_record_arg (f, parms, Qicon_left, 0, 0, RES_TYPE_NUMBER);
   Lisp_Object icon_y
-    = x_frame_get_and_record_arg (f, parms, Qicon_top, 0, 0, RES_TYPE_NUMBER);
+    = gui_frame_get_and_record_arg (f, parms, Qicon_top, 0, 0, RES_TYPE_NUMBER);
   if (!EQ (icon_x, Qunbound) && !EQ (icon_y, Qunbound))
     {
       CHECK_TYPE_RANGED_INTEGER (int, icon_x);
@@ -3294,12 +3301,13 @@ x_icon (struct frame *f, Lisp_Object parms)
   if (! EQ (icon_x, Qunbound))
     x_wm_set_icon_position (f, XFIXNUM (icon_x), XFIXNUM (icon_y));
 
-#if false /* x_get_arg removes the visibility parameter as a side effect,
-	     but x_create_frame still needs it.  */
+#if false /* gui_display_get_arg removes the visibility parameter as a
+	     side effect, but x_create_frame still needs it.  */
   /* Start up iconic or window? */
   struct x_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
   x_wm_set_window_state
-    (f, (EQ (x_get_arg (dpyinfo, parms, Qvisibility, 0, 0, RES_TYPE_SYMBOL),
+    (f, (EQ (gui_display_get_arg (dpyinfo, parms, Qvisibility, 0, 0,
+                                  RES_TYPE_SYMBOL),
 	     Qicon)
 	 ? IconicState
 	 : NormalState));
@@ -3407,7 +3415,7 @@ x_free_gcs (struct frame *f)
 
 
 /* Handler for signals raised during x_create_frame and
-   x_create_tip_frame.  FRAME is the frame which is partially
+   Fx_create_tip_frame.  FRAME is the frame which is partially
    constructed.  */
 
 static Lisp_Object
@@ -3417,7 +3425,7 @@ unwind_create_frame (Lisp_Object frame)
 
   /* If frame is already dead, nothing to do.  This can happen if the
      display is disconnected after the frame has become official, but
-     before x_create_frame removes the unwind protect.  */
+     before Fx_create_frame removes the unwind protect.  */
   if (!FRAME_LIVE_P (f))
     return Qnil;
 
@@ -3463,8 +3471,8 @@ static void
 x_default_font_parameter (struct frame *f, Lisp_Object parms)
 {
   struct x_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
-  Lisp_Object font_param = x_get_arg (dpyinfo, parms, Qfont, NULL, NULL,
-                                      RES_TYPE_STRING);
+  Lisp_Object font_param = gui_display_get_arg (dpyinfo, parms, Qfont, NULL, NULL,
+                                                RES_TYPE_STRING);
   Lisp_Object font = Qnil;
   if (EQ (font_param, Qunbound))
     font_param = Qnil;
@@ -3481,13 +3489,14 @@ x_default_font_parameter (struct frame *f, Lisp_Object parms)
 
   if (NILP (font))
       font = !NILP (font_param) ? font_param
-      : x_get_arg (dpyinfo, parms, Qfont, "font", "Font", RES_TYPE_STRING);
+      : gui_display_get_arg (dpyinfo, parms, Qfont, "font", "Font",
+                             RES_TYPE_STRING);
 
   if (! FONTP (font) && ! STRINGP (font))
     {
       const char *names[]
 	= {
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 	    /* This will find the normal Xft font.  */
  	    "monospace-10",
 #endif
@@ -3518,11 +3527,11 @@ x_default_font_parameter (struct frame *f, Lisp_Object parms)
       /* Remember the explicit font parameter, so we can re-apply it after
 	 we've applied the `default' face settings.  */
       AUTO_FRAME_ARG (arg, Qfont_parameter, font_param);
-      x_set_frame_parameters (f, arg);
+      gui_set_frame_parameters (f, arg);
     }
 
   /* This call will make X resources override any system font setting.  */
-  x_default_parameter (f, parms, Qfont, font, "font", "Font", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qfont, font, "font", "Font", RES_TYPE_STRING);
 }
 
 
@@ -3592,9 +3601,11 @@ This function is an internal primitive--use `make-frame' instead.  */)
      until we know if this frame has a specified name.  */
   Vx_resource_name = Vinvocation_name;
 
-  display = x_get_arg (dpyinfo, parms, Qterminal, 0, 0, RES_TYPE_NUMBER);
+  display = gui_display_get_arg (dpyinfo, parms, Qterminal, 0, 0,
+                                 RES_TYPE_NUMBER);
   if (EQ (display, Qunbound))
-    display = x_get_arg (dpyinfo, parms, Qdisplay, 0, 0, RES_TYPE_STRING);
+    display = gui_display_get_arg (dpyinfo, parms, Qdisplay, 0, 0,
+                                   RES_TYPE_STRING);
   if (EQ (display, Qunbound))
     display = Qnil;
   dpyinfo = check_x_display_info (display);
@@ -3603,7 +3614,8 @@ This function is an internal primitive--use `make-frame' instead.  */)
   if (!dpyinfo->terminal->name)
     error ("Terminal is not live, can't create new frames on it");
 
-  name = x_get_arg (dpyinfo, parms, Qname, "name", "Name", RES_TYPE_STRING);
+  name = gui_display_get_arg (dpyinfo, parms, Qname, "name", "Name",
+                              RES_TYPE_STRING);
   if (!STRINGP (name)
       && ! EQ (name, Qunbound)
       && ! NILP (name))
@@ -3613,15 +3625,17 @@ This function is an internal primitive--use `make-frame' instead.  */)
     Vx_resource_name = name;
 
   /* See if parent window is specified.  */
-  parent = x_get_arg (dpyinfo, parms, Qparent_id, NULL, NULL, RES_TYPE_NUMBER);
+  parent = gui_display_get_arg (dpyinfo, parms, Qparent_id, NULL, NULL,
+                                RES_TYPE_NUMBER);
   if (EQ (parent, Qunbound))
     parent = Qnil;
   if (! NILP (parent))
     CHECK_FIXNUM (parent);
 
   frame = Qnil;
-  tem = x_get_arg (dpyinfo, parms, Qminibuffer, "minibuffer", "Minibuffer",
-		   RES_TYPE_SYMBOL);
+  tem = gui_display_get_arg (dpyinfo,
+                             parms, Qminibuffer, "minibuffer", "Minibuffer",
+                             RES_TYPE_SYMBOL);
   if (EQ (tem, Qnone) || NILP (tem))
     f = make_frame_without_minibuffer (Qnil, kb, display);
   else if (EQ (tem, Qonly))
@@ -3634,8 +3648,12 @@ This function is an internal primitive--use `make-frame' instead.  */)
   else
     f = make_frame (true);
 
-  parent_frame = x_get_arg (dpyinfo, parms, Qparent_frame, NULL, NULL,
-			    RES_TYPE_SYMBOL);
+  parent_frame = gui_display_get_arg (dpyinfo,
+                                      parms,
+                                      Qparent_frame,
+                                      NULL,
+                                      NULL,
+                                      RES_TYPE_SYMBOL);
   /* Accept parent-frame iff parent-id was not specified.  */
   if (!NILP (parent)
       || EQ (parent_frame, Qunbound)
@@ -3648,16 +3666,24 @@ This function is an internal primitive--use `make-frame' instead.  */)
   fset_parent_frame (f, parent_frame);
   store_frame_param (f, Qparent_frame, parent_frame);
 
-  if (!NILP (tem = (x_get_arg (dpyinfo, parms, Qundecorated, NULL, NULL,
-			       RES_TYPE_BOOLEAN)))
+  if (!NILP (tem = (gui_display_get_arg (dpyinfo,
+                                         parms,
+                                         Qundecorated,
+                                         NULL,
+                                         NULL,
+                                         RES_TYPE_BOOLEAN)))
       && !(EQ (tem, Qunbound)))
     undecorated = true;
 
   FRAME_UNDECORATED (f) = undecorated;
   store_frame_param (f, Qundecorated, undecorated ? Qt : Qnil);
 
-  if (!NILP (tem = (x_get_arg (dpyinfo, parms, Qoverride_redirect, NULL, NULL,
-			       RES_TYPE_BOOLEAN)))
+  if (!NILP (tem = (gui_display_get_arg (dpyinfo,
+                                         parms,
+                                         Qoverride_redirect,
+                                         NULL,
+                                         NULL,
+                                         RES_TYPE_BOOLEAN)))
       && !(EQ (tem, Qunbound)))
     override_redirect = true;
 
@@ -3681,9 +3707,12 @@ This function is an internal primitive--use `make-frame' instead.  */)
   f->output_data.x->white_relief.pixel = -1;
   f->output_data.x->black_relief.pixel = -1;
 
-  fset_icon_name (f,
-		  x_get_arg (dpyinfo, parms, Qicon_name, "iconName", "Title",
-			     RES_TYPE_STRING));
+  fset_icon_name (f, gui_display_get_arg (dpyinfo,
+                                          parms,
+                                          Qicon_name,
+                                          "iconName",
+                                          "Title",
+                                          RES_TYPE_STRING));
   if (! STRINGP (f->icon_name))
     fset_icon_name (f, Qnil);
 
@@ -3768,8 +3797,8 @@ This function is an internal primitive--use `make-frame' instead.  */)
   dpyinfo_refcount = dpyinfo->reference_count;
 #endif /* GLYPH_DEBUG */
 
-  x_default_parameter (f, parms, Qfont_backend, Qnil,
-		       "fontBackend", "FontBackend", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qfont_backend, Qnil,
+                         "fontBackend", "FontBackend", RES_TYPE_STRING);
 
   /* Extract the window parameters from the supplied values
      that are needed to determine window geometry.  */
@@ -3782,8 +3811,8 @@ This function is an internal primitive--use `make-frame' instead.  */)
 
   /* Frame contents get displaced if an embedded X window has a border.  */
   if (! FRAME_X_EMBEDDED_P (f))
-    x_default_parameter (f, parms, Qborder_width, make_fixnum (0),
-			 "borderWidth", "BorderWidth", RES_TYPE_NUMBER);
+    gui_default_parameter (f, parms, Qborder_width, make_fixnum (0),
+                           "borderWidth", "BorderWidth", RES_TYPE_NUMBER);
 
   /* This defaults to 1 in order to match xterm.  We recognize either
      internalBorderWidth or internalBorder (which is what xterm calls
@@ -3792,54 +3821,55 @@ This function is an internal primitive--use `make-frame' instead.  */)
     {
       Lisp_Object value;
 
-      value = x_get_arg (dpyinfo, parms, Qinternal_border_width,
-			 "internalBorder", "internalBorder", RES_TYPE_NUMBER);
+      value = gui_display_get_arg (dpyinfo, parms, Qinternal_border_width,
+                                   "internalBorder", "internalBorder",
+                                   RES_TYPE_NUMBER);
       if (! EQ (value, Qunbound))
 	parms = Fcons (Fcons (Qinternal_border_width, value),
 		       parms);
     }
-  x_default_parameter (f, parms, Qinternal_border_width,
+  gui_default_parameter (f, parms, Qinternal_border_width,
 #ifdef USE_GTK /* We used to impose 0 in xg_create_frame_widgets.  */
-		       make_fixnum (0),
+                         make_fixnum (0),
 #else
-		       make_fixnum (1),
+                         make_fixnum (1),
 #endif
-		       "internalBorderWidth", "internalBorderWidth",
-		       RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qright_divider_width, make_fixnum (0),
-		       NULL, NULL, RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qbottom_divider_width, make_fixnum (0),
-		       NULL, NULL, RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qvertical_scroll_bars,
+                         "internalBorderWidth", "internalBorderWidth",
+                         RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qright_divider_width, make_fixnum (0),
+                         NULL, NULL, RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qbottom_divider_width, make_fixnum (0),
+                         NULL, NULL, RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qvertical_scroll_bars,
 #if defined (USE_GTK) && defined (USE_TOOLKIT_SCROLL_BARS)
-		       Qright,
+                         Qright,
 #else
-		       Qleft,
+                         Qleft,
 #endif
-		       "verticalScrollBars", "ScrollBars",
-		       RES_TYPE_SYMBOL);
-  x_default_parameter (f, parms, Qhorizontal_scroll_bars, Qnil,
-		       "horizontalScrollBars", "ScrollBars",
-		       RES_TYPE_SYMBOL);
+                         "verticalScrollBars", "ScrollBars",
+                         RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qhorizontal_scroll_bars, Qnil,
+                         "horizontalScrollBars", "ScrollBars",
+                         RES_TYPE_SYMBOL);
   /* Also do the stuff which must be set before the window exists.  */
-  x_default_parameter (f, parms, Qforeground_color, build_string ("black"),
-		       "foreground", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qbackground_color, build_string ("white"),
-		       "background", "Background", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qmouse_color, build_string ("black"),
-		       "pointerColor", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qborder_color, build_string ("black"),
-		       "borderColor", "BorderColor", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qscreen_gamma, Qnil,
-		       "screenGamma", "ScreenGamma", RES_TYPE_FLOAT);
-  x_default_parameter (f, parms, Qline_spacing, Qnil,
-		       "lineSpacing", "LineSpacing", RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qleft_fringe, Qnil,
-		       "leftFringe", "LeftFringe", RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qright_fringe, Qnil,
-		       "rightFringe", "RightFringe", RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qno_special_glyphs, Qnil,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qforeground_color, build_string ("black"),
+                         "foreground", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qbackground_color, build_string ("white"),
+                         "background", "Background", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qmouse_color, build_string ("black"),
+                         "pointerColor", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qborder_color, build_string ("black"),
+                         "borderColor", "BorderColor", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qscreen_gamma, Qnil,
+                         "screenGamma", "ScreenGamma", RES_TYPE_FLOAT);
+  gui_default_parameter (f, parms, Qline_spacing, Qnil,
+                         "lineSpacing", "LineSpacing", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qleft_fringe, Qnil,
+                         "leftFringe", "LeftFringe", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qright_fringe, Qnil,
+                         "rightFringe", "RightFringe", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qno_special_glyphs, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
 
   x_default_scroll_bar_color_parameter (f, parms, Qscroll_bar_foreground,
 					"scrollBarForeground",
@@ -3848,7 +3878,7 @@ This function is an internal primitive--use `make-frame' instead.  */)
 					"scrollBarBackground",
 					"ScrollBarBackground", false);
 
-  /* Init faces before x_default_parameter is called for the
+  /* Init faces before gui_default_parameter is called for the
      scroll-bar-width parameter because otherwise we end up in
      init_iterator with a null face cache, which should not happen.  */
   init_frame_faces (f);
@@ -3865,10 +3895,12 @@ This function is an internal primitive--use `make-frame' instead.  */)
 
      Also process `min-width' and `min-height' parameters right here
      because `frame-windows-min-size' needs them.  */
-  tem = x_get_arg (dpyinfo, parms, Qmin_width, NULL, NULL, RES_TYPE_NUMBER);
+  tem = gui_display_get_arg (dpyinfo, parms, Qmin_width, NULL, NULL,
+                             RES_TYPE_NUMBER);
   if (FIXNUMP (tem))
     store_frame_param (f, Qmin_width, tem);
-  tem = x_get_arg (dpyinfo, parms, Qmin_height, NULL, NULL, RES_TYPE_NUMBER);
+  tem = gui_display_get_arg (dpyinfo, parms, Qmin_height, NULL, NULL,
+                             RES_TYPE_NUMBER);
   if (FIXNUMP (tem))
     store_frame_param (f, Qmin_height, tem);
   adjust_frame_size (f, FRAME_COLS (f) * FRAME_COLUMN_WIDTH (f),
@@ -3880,32 +3912,34 @@ This function is an internal primitive--use `make-frame' instead.  */)
      here; they are processed specially at startup, and reflected in
      the values of the mode variables.  */
 
-  x_default_parameter (f, parms, Qmenu_bar_lines,
-		       NILP (Vmenu_bar_mode)
-		       ? make_fixnum (0) : make_fixnum (1),
-		       NULL, NULL, RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qtool_bar_lines,
-		       NILP (Vtool_bar_mode)
-		       ? make_fixnum (0) : make_fixnum (1),
-		       NULL, NULL, RES_TYPE_NUMBER);
-
-  x_default_parameter (f, parms, Qbuffer_predicate, Qnil,
-		       "bufferPredicate", "BufferPredicate",
-		       RES_TYPE_SYMBOL);
-  x_default_parameter (f, parms, Qtitle, Qnil,
-		       "title", "Title", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qwait_for_wm, Qt,
-		       "waitForWM", "WaitForWM", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qtool_bar_position,
-                       FRAME_TOOL_BAR_POSITION (f), 0, 0, RES_TYPE_SYMBOL);
-  x_default_parameter (f, parms, Qinhibit_double_buffering, Qnil,
-                       "inhibitDoubleBuffering", "InhibitDoubleBuffering",
-                       RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qmenu_bar_lines,
+                         NILP (Vmenu_bar_mode)
+                         ? make_fixnum (0) : make_fixnum (1),
+                         NULL, NULL, RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qtool_bar_lines,
+                         NILP (Vtool_bar_mode)
+                         ? make_fixnum (0) : make_fixnum (1),
+                         NULL, NULL, RES_TYPE_NUMBER);
+
+  gui_default_parameter (f, parms, Qbuffer_predicate, Qnil,
+                         "bufferPredicate", "BufferPredicate",
+                         RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qtitle, Qnil,
+                         "title", "Title", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qwait_for_wm, Qt,
+                         "waitForWM", "WaitForWM", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qtool_bar_position,
+                         FRAME_TOOL_BAR_POSITION (f), 0, 0, RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qinhibit_double_buffering, Qnil,
+                         "inhibitDoubleBuffering", "InhibitDoubleBuffering",
+                         RES_TYPE_BOOLEAN);
 
   /* Compute the size of the X window.  */
-  window_prompting = x_figure_window_size (f, parms, true, &x_width, &x_height);
+  window_prompting = gui_figure_window_size (f, parms, true,
+                                             &x_width, &x_height);
 
-  tem = x_get_arg (dpyinfo, parms, Qunsplittable, 0, 0, RES_TYPE_BOOLEAN);
+  tem = gui_display_get_arg (dpyinfo, parms, Qunsplittable, 0, 0,
+                             RES_TYPE_BOOLEAN);
   f->no_split = minibuffer_only || EQ (tem, Qt);
 
   x_icon_verify (f, parms);
@@ -3927,23 +3961,23 @@ This function is an internal primitive--use `make-frame' instead.  */)
 
   /* We need to do this after creating the X window, so that the
      icon-creation functions can say whose icon they're describing.  */
-  x_default_parameter (f, parms, Qicon_type, Qt,
-		       "bitmapIcon", "BitmapIcon", RES_TYPE_BOOLEAN);
-
-  x_default_parameter (f, parms, Qauto_raise, Qnil,
-		       "autoRaise", "AutoRaiseLower", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qauto_lower, Qnil,
-		       "autoLower", "AutoRaiseLower", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qcursor_type, Qbox,
-		       "cursorType", "CursorType", RES_TYPE_SYMBOL);
-  x_default_parameter (f, parms, Qscroll_bar_width, Qnil,
-		       "scrollBarWidth", "ScrollBarWidth",
-		       RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qscroll_bar_height, Qnil,
-		       "scrollBarHeight", "ScrollBarHeight",
-		       RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qalpha, Qnil,
-		       "alpha", "Alpha", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qicon_type, Qt,
+                         "bitmapIcon", "BitmapIcon", RES_TYPE_BOOLEAN);
+
+  gui_default_parameter (f, parms, Qauto_raise, Qnil,
+                         "autoRaise", "AutoRaiseLower", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qauto_lower, Qnil,
+                         "autoLower", "AutoRaiseLower", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qcursor_type, Qbox,
+                         "cursorType", "CursorType", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qscroll_bar_width, Qnil,
+                         "scrollBarWidth", "ScrollBarWidth",
+                         RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qscroll_bar_height, Qnil,
+                         "scrollBarHeight", "ScrollBarHeight",
+                         RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qalpha, Qnil,
+                         "alpha", "Alpha", RES_TYPE_NUMBER);
 
   if (!NILP (parent_frame))
     {
@@ -3955,10 +3989,10 @@ This function is an internal primitive--use `make-frame' instead.  */)
       unblock_input ();
     }
 
-  x_default_parameter (f, parms, Qno_focus_on_map, Qnil,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qno_accept_focus, Qnil,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qno_focus_on_map, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qno_accept_focus, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
 
 #if defined (USE_X_TOOLKIT) || defined (USE_GTK)
   /* Create the menu bar.  */
@@ -3979,7 +4013,7 @@ This function is an internal primitive--use `make-frame' instead.  */)
 #endif /* USE_X_TOOLKIT || USE_GTK */
 
   /* Consider frame official, now.  */
-  f->can_x_set_window_size = true;
+  f->can_set_window_size = true;
 
   if (x_width > 0)
     SET_FRAME_WIDTH (f, x_width);
@@ -3999,8 +4033,8 @@ This function is an internal primitive--use `make-frame' instead.  */)
   /* Process fullscreen parameter here in the hope that normalizing a
      fullheight/fullwidth frame will produce the size set by the last
      adjust_frame_size call.  */
-  x_default_parameter (f, parms, Qfullscreen, Qnil,
-		       "fullscreen", "Fullscreen", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qfullscreen, Qnil,
+                         "fullscreen", "Fullscreen", RES_TYPE_SYMBOL);
 
   /* Make the window appear on the frame and enable display, unless
      the caller says not to.  However, with explicit parent, Emacs
@@ -4008,7 +4042,8 @@ This function is an internal primitive--use `make-frame' instead.  */)
   if (!f->output_data.x->explicit_parent)
     {
       Lisp_Object visibility
-	= x_get_arg (dpyinfo, parms, Qvisibility, 0, 0, RES_TYPE_SYMBOL);
+	= gui_display_get_arg (dpyinfo, parms, Qvisibility, 0, 0,
+                               RES_TYPE_SYMBOL);
 
       if (EQ (visibility, Qicon))
 	x_iconify_frame (f);
@@ -4043,11 +4078,11 @@ This function is an internal primitive--use `make-frame' instead.  */)
   unblock_input ();
 
   /* Works iff frame has been already mapped.  */
-  x_default_parameter (f, parms, Qskip_taskbar, Qnil,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qskip_taskbar, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
   /* The `z-group' parameter works only for visible frames.  */
-  x_default_parameter (f, parms, Qz_group, Qnil,
-		       NULL, NULL, RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qz_group, Qnil,
+                         NULL, NULL, RES_TYPE_SYMBOL);
 
   /* Initialize `default-minibuffer-frame' in case this is the first
      frame on this terminal.  */
@@ -4056,8 +4091,9 @@ This function is an internal primitive--use `make-frame' instead.  */)
           || !FRAME_LIVE_P (XFRAME (KVAR (kb, Vdefault_minibuffer_frame)))))
     kset_default_minibuffer_frame (kb, frame);
 
-  /* All remaining specified parameters, which have not been "used"
-     by x_get_arg and friends, now go in the misc. alist of the frame.  */
+  /* All remaining specified parameters, which have not been "used" by
+     gui_display_get_arg and friends, now go in the misc. alist of the
+     frame.  */
   for (tem = parms; CONSP (tem); tem = XCDR (tem))
     if (CONSP (XCAR (tem)) && !NILP (XCAR (XCAR (tem))))
       fset_param_alist (f, Fcons (XCAR (tem), f->param_alist));
@@ -4069,60 +4105,6 @@ This function is an internal primitive--use `make-frame' instead.  */)
  return unbind_to (count, frame);
 }
 
-
-/* FRAME is used only to get a handle on the X display.  We don't pass the
-   display info directly because we're called from frame.c, which doesn't
-   know about that structure.  */
-
-Lisp_Object
-x_get_focus_frame (struct frame *frame)
-{
-  struct x_display_info *dpyinfo = FRAME_DISPLAY_INFO (frame);
-  Lisp_Object xfocus;
-  if (! dpyinfo->x_focus_frame)
-    return Qnil;
-
-  XSETFRAME (xfocus, dpyinfo->x_focus_frame);
-  return xfocus;
-}
-
-
-/* In certain situations, when the window manager follows a
-   click-to-focus policy, there seems to be no way around calling
-   XSetInputFocus to give another frame the input focus .
-
-   In an ideal world, XSetInputFocus should generally be avoided so
-   that applications don't interfere with the window manager's focus
-   policy.  But I think it's okay to use when it's clearly done
-   following a user-command.  */
-
-void
-x_focus_frame (struct frame *f, bool noactivate)
-{
-  Display *dpy = FRAME_X_DISPLAY (f);
-
-  block_input ();
-  x_catch_errors (dpy);
-
-  if (FRAME_X_EMBEDDED_P (f))
-    {
-      /* For Xembedded frames, normally the embedder forwards key
-	 events.  See XEmbed Protocol Specification at
-	 http://freedesktop.org/wiki/Specifications/xembed-spec  */
-      xembed_request_focus (f);
-    }
-  else
-    {
-      XSetInputFocus (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f),
-		      RevertToParent, CurrentTime);
-      if (!noactivate)
-	x_ewmh_activate_frame (f);
-    }
-
-  x_uncatch_errors ();
-  unblock_input ();
-}
-
 
 DEFUN ("xw-color-defined-p", Fxw_color_defined_p, Sxw_color_defined_p, 1, 2, 0,
        doc: /* Internal function called by `color-defined-p'.
@@ -4134,7 +4116,7 @@ DEFUN ("xw-color-defined-p", Fxw_color_defined_p, Sxw_color_defined_p, 1, 2, 0,
 
   CHECK_STRING (color);
 
-  if (x_defined_color (f, SSDATA (color), &foo, false))
+  if (x_defined_color (f, SSDATA (color), &foo, false, false))
     return Qt;
   else
     return Qnil;
@@ -4150,7 +4132,7 @@ DEFUN ("xw-color-values", Fxw_color_values, Sxw_color_values, 1, 2, 0,
 
   CHECK_STRING (color);
 
-  if (x_defined_color (f, SSDATA (color), &foo, false))
+  if (x_defined_color (f, SSDATA (color), &foo, false, false))
     return list3i (foo.red, foo.green, foo.blue);
   else
     return Qnil;
@@ -4496,7 +4478,7 @@ On MS Windows, this just returns nil.  */)
    Return false if and only if the workarea information cannot be
    obtained via the _NET_WORKAREA root window property.  */
 
-#if ! GTK_CHECK_VERSION (3, 4, 0)
+#ifndef HAVE_GTK3
 static bool
 x_get_net_workarea (struct x_display_info *dpyinfo, XRectangle *rect)
 {
@@ -4583,7 +4565,7 @@ x_get_monitor_for_frame (struct frame *f,
 
       if (mi->geom.width == 0) continue;
 
-      if (x_intersect_rectangles (&mi->geom, &frect, &res))
+      if (gui_intersect_rectangles (&mi->geom, &frect, &res))
         {
           a = res.width * res.height;
           if (a > area)
@@ -4712,7 +4694,7 @@ x_get_monitor_attributes_xinerama (struct x_display_info *dpyinfo)
       if (i == 0 && x_get_net_workarea (dpyinfo, &workarea_r))
 	{
 	  mi->work = workarea_r;
-	  if (! x_intersect_rectangles (&mi->geom, &mi->work, &mi->work))
+	  if (! gui_intersect_rectangles (&mi->geom, &mi->work, &mi->work))
 	    mi->work = mi->geom;
 	}
       else
@@ -4816,7 +4798,7 @@ x_get_monitor_attributes_xrandr (struct x_display_info *dpyinfo)
           if (i == primary && x_get_net_workarea (dpyinfo, &workarea_r))
             {
               mi->work= workarea_r;
-              if (! x_intersect_rectangles (&mi->geom, &mi->work, &mi->work))
+              if (! gui_intersect_rectangles (&mi->geom, &mi->work, &mi->work))
                 mi->work = mi->geom;
             }
           else
@@ -4906,9 +4888,9 @@ Internal use only, use `display-monitor-attributes-list' instead.  */)
   Lisp_Object attributes_list = Qnil;
 
 #ifdef USE_GTK
-  double mm_width_per_pixel, mm_height_per_pixel;
   GdkDisplay *gdpy;
 #if ! GTK_CHECK_VERSION (3, 22, 0)
+  double mm_width_per_pixel, mm_height_per_pixel;
   GdkScreen *gscreen;
 #endif
   gint primary_monitor = 0, n_monitors, i;
@@ -4917,19 +4899,18 @@ Internal use only, use `display-monitor-attributes-list' instead.  */)
   struct MonitorInfo *monitors;
 
   block_input ();
-  mm_width_per_pixel = ((double) WidthMMOfScreen (dpyinfo->screen)
-			/ x_display_pixel_width (dpyinfo));
-  mm_height_per_pixel = ((double) HeightMMOfScreen (dpyinfo->screen)
-			 / x_display_pixel_height (dpyinfo));
   gdpy = gdk_x11_lookup_xdisplay (dpyinfo->display);
 #if GTK_CHECK_VERSION (3, 22, 0)
   n_monitors = gdk_display_get_n_monitors (gdpy);
 #else
   gscreen = gdk_display_get_default_screen (gdpy);
-#if GTK_CHECK_VERSION (2, 20, 0)
-  primary_monitor = gdk_screen_get_primary_monitor (gscreen);
-#endif
   n_monitors = gdk_screen_get_n_monitors (gscreen);
+  primary_monitor = gdk_screen_get_primary_monitor (gscreen);
+  /* Fallback if gdk_screen_get_monitor_{width,height}_mm fail */
+  mm_width_per_pixel = ((double) WidthMMOfScreen (dpyinfo->screen)
+			/ x_display_pixel_width (dpyinfo));
+  mm_height_per_pixel = ((double) HeightMMOfScreen (dpyinfo->screen)
+			 / x_display_pixel_height (dpyinfo));
 #endif
   monitor_frames = make_nil_vector (n_monitors);
   monitors = xzalloc (n_monitors * sizeof *monitors);
@@ -4958,7 +4939,7 @@ Internal use only, use `display-monitor-attributes-list' instead.  */)
 
   for (i = 0; i < n_monitors; ++i)
     {
-      gint width_mm = -1, height_mm = -1;
+      gint width_mm, height_mm;
       GdkRectangle rec, work;
       struct MonitorInfo *mi = &monitors[i];
       int scale = 1;
@@ -4975,18 +4956,17 @@ Internal use only, use `display-monitor-attributes-list' instead.  */)
 #if GTK_CHECK_VERSION (3, 22, 0)
       width_mm = gdk_monitor_get_width_mm (monitor);
       height_mm = gdk_monitor_get_height_mm (monitor);
-#elif GTK_CHECK_VERSION (2, 14, 0)
+#else
       width_mm = gdk_screen_get_monitor_width_mm (gscreen, i);
       height_mm = gdk_screen_get_monitor_height_mm (gscreen, i);
-#endif
       if (width_mm < 0)
 	width_mm = rec.width * mm_width_per_pixel + 0.5;
       if (height_mm < 0)
 	height_mm = rec.height * mm_height_per_pixel + 0.5;
-
+#endif
 #if GTK_CHECK_VERSION (3, 22, 0)
       gdk_monitor_get_workarea (monitor, &work);
-#elif GTK_CHECK_VERSION (3, 4, 0)
+#elif defined HAVE_GTK3
       gdk_screen_get_monitor_workarea (gscreen, i, &work);
 #else
       /* Emulate the behavior of GTK+ 3.4.  */
@@ -5010,7 +4990,7 @@ Internal use only, use `display-monitor-attributes-list' instead.  */)
       /* GTK returns scaled sizes for the workareas.  */
 #if GTK_CHECK_VERSION (3, 22, 0)
       scale = gdk_monitor_get_scale_factor (monitor);
-#elif GTK_CHECK_VERSION (3, 10, 0)
+#elif defined HAVE_GTK3
       scale = gdk_screen_get_monitor_scale_factor (gscreen, i);
 #endif
       rec.width *= scale;
@@ -5030,8 +5010,8 @@ Internal use only, use `display-monitor-attributes-list' instead.  */)
       mi->mm_height = height_mm;
 
 #if GTK_CHECK_VERSION (3, 22, 0)
-      mi->name = xstrdup (gdk_monitor_get_model (monitor));
-#elif GTK_CHECK_VERSION (2, 14, 0)
+      dupstring (&mi->name, (gdk_monitor_get_model (monitor)));
+#else
       mi->name = gdk_screen_get_monitor_plug_name (gscreen, i);
 #endif
     }
@@ -5041,11 +5021,7 @@ Internal use only, use `display-monitor-attributes-list' instead.  */)
                                                  primary_monitor,
                                                  monitor_frames,
                                                  source);
-#if GTK_CHECK_VERSION (2, 14, 0)
   free_monitors (monitors, n_monitors);
-#else
-  xfree (monitors);
-#endif
   unblock_input ();
 #else  /* not USE_GTK */
 
@@ -5380,7 +5356,7 @@ Frames are listed from topmost (first) to bottommost (last).  */)
 static void
 x_frame_restack (struct frame *f1, struct frame *f2, bool above_flag)
 {
-#if defined (USE_GTK) && GTK_CHECK_VERSION (2, 18, 0)
+#ifdef USE_GTK
   block_input ();
   xg_frame_restack (f1, f2, above_flag);
   unblock_input ();
@@ -5535,8 +5511,8 @@ select_visual (struct x_display_info *dpyinfo)
   /* See if a visual is specified.  */
   AUTO_STRING (visualClass, "visualClass");
   AUTO_STRING (VisualClass, "VisualClass");
-  Lisp_Object value = display_x_get_resource (dpyinfo, visualClass,
-					      VisualClass, Qnil, Qnil);
+  Lisp_Object value = gui_display_get_resource (dpyinfo, visualClass,
+                                                VisualClass, Qnil, Qnil);
 
   if (STRINGP (value))
     {
@@ -6122,7 +6098,7 @@ unwind_create_tip_frame (Lisp_Object frame)
    PARMS is a list of frame parameters.  TEXT is the string to
    display in the tip frame.  Value is the frame.
 
-   Note that functions called here, esp. x_default_parameter can
+   Note that functions called here, esp. gui_default_parameter can
    signal errors, for instance when a specified color name is
    undefined.  We have to make sure that we're in a consistent state
    when this happens.  */
@@ -6144,7 +6120,8 @@ x_create_tip_frame (struct x_display_info *dpyinfo, Lisp_Object parms)
   parms = Fcopy_alist (parms);
 
   /* Get the name of the frame to use for resource lookup.  */
-  name = x_get_arg (dpyinfo, parms, Qname, "name", "Name", RES_TYPE_STRING);
+  name = gui_display_get_arg (dpyinfo, parms, Qname, "name", "Name",
+                              RES_TYPE_STRING);
   if (!STRINGP (name)
       && !EQ (name, Qunbound)
       && !NILP (name))
@@ -6245,15 +6222,15 @@ x_create_tip_frame (struct x_display_info *dpyinfo, Lisp_Object parms)
   dpyinfo_refcount = dpyinfo->reference_count;
 #endif /* GLYPH_DEBUG */
 
-  x_default_parameter (f, parms, Qfont_backend, Qnil,
-		       "fontBackend", "FontBackend", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qfont_backend, Qnil,
+                         "fontBackend", "FontBackend", RES_TYPE_STRING);
 
   /* Extract the window parameters from the supplied values that are
      needed to determine window geometry.  */
   x_default_font_parameter (f, parms);
 
-  x_default_parameter (f, parms, Qborder_width, make_fixnum (0),
-		       "borderWidth", "BorderWidth", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qborder_width, make_fixnum (0),
+                         "borderWidth", "BorderWidth", RES_TYPE_NUMBER);
 
   /* This defaults to 2 in order to match xterm.  We recognize either
      internalBorderWidth or internalBorder (which is what xterm calls
@@ -6262,43 +6239,44 @@ x_create_tip_frame (struct x_display_info *dpyinfo, Lisp_Object parms)
     {
       Lisp_Object value;
 
-      value = x_get_arg (dpyinfo, parms, Qinternal_border_width,
-			 "internalBorder", "internalBorder", RES_TYPE_NUMBER);
+      value = gui_display_get_arg (dpyinfo, parms, Qinternal_border_width,
+                                   "internalBorder", "internalBorder",
+                                   RES_TYPE_NUMBER);
       if (! EQ (value, Qunbound))
 	parms = Fcons (Fcons (Qinternal_border_width, value),
 		       parms);
     }
 
-  x_default_parameter (f, parms, Qinternal_border_width, make_fixnum (1),
-		       "internalBorderWidth", "internalBorderWidth",
-		       RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qright_divider_width, make_fixnum (0),
-		       NULL, NULL, RES_TYPE_NUMBER);
-  x_default_parameter (f, parms, Qbottom_divider_width, make_fixnum (0),
-		       NULL, NULL, RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qinternal_border_width, make_fixnum (1),
+                         "internalBorderWidth", "internalBorderWidth",
+                         RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qright_divider_width, make_fixnum (0),
+                         NULL, NULL, RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qbottom_divider_width, make_fixnum (0),
+                         NULL, NULL, RES_TYPE_NUMBER);
 
   /* Also do the stuff which must be set before the window exists.  */
-  x_default_parameter (f, parms, Qforeground_color, build_string ("black"),
-		       "foreground", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qbackground_color, build_string ("white"),
-		       "background", "Background", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qmouse_color, build_string ("black"),
-		       "pointerColor", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qcursor_color, build_string ("black"),
-		       "cursorColor", "Foreground", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qborder_color, build_string ("black"),
-		       "borderColor", "BorderColor", RES_TYPE_STRING);
-  x_default_parameter (f, parms, Qno_special_glyphs, Qnil,
-		       NULL, NULL, RES_TYPE_BOOLEAN);
-
-  /* Init faces before x_default_parameter is called for the
+  gui_default_parameter (f, parms, Qforeground_color, build_string ("black"),
+                         "foreground", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qbackground_color, build_string ("white"),
+                         "background", "Background", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qmouse_color, build_string ("black"),
+                         "pointerColor", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qcursor_color, build_string ("black"),
+                         "cursorColor", "Foreground", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qborder_color, build_string ("black"),
+                         "borderColor", "BorderColor", RES_TYPE_STRING);
+  gui_default_parameter (f, parms, Qno_special_glyphs, Qnil,
+                         NULL, NULL, RES_TYPE_BOOLEAN);
+
+  /* Init faces before gui_default_parameter is called for the
      scroll-bar-width parameter because otherwise we end up in
      init_iterator with a null face cache, which should not happen.  */
   init_frame_faces (f);
 
   f->output_data.x->parent_desc = FRAME_DISPLAY_INFO (f)->root_window;
 
-  x_figure_window_size (f, parms, false, &x_width, &x_height);
+  gui_figure_window_size (f, parms, false, &x_width, &x_height);
 
   {
     XSetWindowAttributes attrs;
@@ -6341,14 +6319,14 @@ x_create_tip_frame (struct x_display_info *dpyinfo, Lisp_Object parms)
 
   x_make_gc (f);
 
-  x_default_parameter (f, parms, Qauto_raise, Qnil,
-		       "autoRaise", "AutoRaiseLower", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qauto_lower, Qnil,
-		       "autoLower", "AutoRaiseLower", RES_TYPE_BOOLEAN);
-  x_default_parameter (f, parms, Qcursor_type, Qbox,
-		       "cursorType", "CursorType", RES_TYPE_SYMBOL);
-  x_default_parameter (f, parms, Qalpha, Qnil,
-		       "alpha", "Alpha", RES_TYPE_NUMBER);
+  gui_default_parameter (f, parms, Qauto_raise, Qnil,
+                         "autoRaise", "AutoRaiseLower", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qauto_lower, Qnil,
+                         "autoLower", "AutoRaiseLower", RES_TYPE_BOOLEAN);
+  gui_default_parameter (f, parms, Qcursor_type, Qbox,
+                         "cursorType", "CursorType", RES_TYPE_SYMBOL);
+  gui_default_parameter (f, parms, Qalpha, Qnil,
+                         "alpha", "Alpha", RES_TYPE_NUMBER);
 
   /* Dimensions, especially FRAME_LINES (f), must be done via change_frame_size.
      Change will not be effected unless different from the current
@@ -6419,7 +6397,7 @@ x_create_tip_frame (struct x_display_info *dpyinfo, Lisp_Object parms)
      below.  And the frame needs to be on Vframe_list or making it
      visible won't work.  */
   Vframe_list = Fcons (frame, Vframe_list);
-  f->can_x_set_window_size = true;
+  f->can_set_window_size = true;
 
   /* Setting attributes of faces of the tooltip frame from resources
      and similar will set face_change, which leads to the clearing of
@@ -7605,41 +7583,41 @@ visible.  */)
 
 frame_parm_handler x_frame_parm_handlers[] =
 {
-  x_set_autoraise,
-  x_set_autolower,
+  gui_set_autoraise,
+  gui_set_autolower,
   x_set_background_color,
   x_set_border_color,
-  x_set_border_width,
+  gui_set_border_width,
   x_set_cursor_color,
   x_set_cursor_type,
-  x_set_font,
+  gui_set_font,
   x_set_foreground_color,
   x_set_icon_name,
   x_set_icon_type,
   x_set_internal_border_width,
-  x_set_right_divider_width,
-  x_set_bottom_divider_width,
+  gui_set_right_divider_width,
+  gui_set_bottom_divider_width,
   x_set_menu_bar_lines,
   x_set_mouse_color,
   x_explicitly_set_name,
-  x_set_scroll_bar_width,
-  x_set_scroll_bar_height,
+  gui_set_scroll_bar_width,
+  gui_set_scroll_bar_height,
   x_set_title,
-  x_set_unsplittable,
-  x_set_vertical_scroll_bars,
-  x_set_horizontal_scroll_bars,
-  x_set_visibility,
+  gui_set_unsplittable,
+  gui_set_vertical_scroll_bars,
+  gui_set_horizontal_scroll_bars,
+  gui_set_visibility,
   x_set_tool_bar_lines,
   x_set_scroll_bar_foreground,
   x_set_scroll_bar_background,
-  x_set_screen_gamma,
-  x_set_line_spacing,
-  x_set_left_fringe,
-  x_set_right_fringe,
+  gui_set_screen_gamma,
+  gui_set_line_spacing,
+  gui_set_left_fringe,
+  gui_set_right_fringe,
   x_set_wait_for_wm,
-  x_set_fullscreen,
-  x_set_font_backend,
-  x_set_alpha,
+  gui_set_fullscreen,
+  gui_set_font_backend,
+  gui_set_alpha,
   x_set_sticky,
   x_set_tool_bar_position,
   x_set_inhibit_double_buffering,
@@ -7650,7 +7628,7 @@ frame_parm_handler x_frame_parm_handlers[] =
   x_set_no_accept_focus,
   x_set_z_group,
   x_set_override_redirect,
-  x_set_no_special_glyphs,
+  gui_set_no_special_glyphs,
 };
 
 void
diff --git a/src/xfont.c b/src/xfont.c
index 5ecbd6de33..81808e7a62 100644
--- a/src/xfont.c
+++ b/src/xfont.c
@@ -46,18 +46,20 @@ struct xfont_info
 
 /* Prototypes of support functions.  */
 
-static XCharStruct *xfont_get_pcm (XFontStruct *, XChar2b *);
+static XCharStruct *xfont_get_pcm (XFontStruct *, unsigned char2b);
 
 /* Get metrics of character CHAR2B in XFONT.  Value is null if CHAR2B
    is not contained in the font.  */
 
 static XCharStruct *
-xfont_get_pcm (XFontStruct *xfont, XChar2b *char2b)
+xfont_get_pcm (XFontStruct *xfont, unsigned char2b)
 {
   /* The result metric information.  */
   XCharStruct *pcm = NULL;
+  const unsigned char byte1 = char2b >> 8;
+  const unsigned char byte2 = char2b & 0xFF;
 
-  eassert (xfont && char2b);
+  eassert (xfont);
 
   if (xfont->per_char != NULL)
     {
@@ -66,13 +68,13 @@ xfont_get_pcm (XFontStruct *xfont, XChar2b *char2b)
 	  /* min_char_or_byte2 specifies the linear character index
 	     corresponding to the first element of the per_char array,
 	     max_char_or_byte2 is the index of the last character.  A
-	     character with non-zero CHAR2B->byte1 is not in the font.
+	     character with non-zero byte1 is not in the font.
 	     A character with byte2 less than min_char_or_byte2 or
 	     greater max_char_or_byte2 is not in the font.  */
-	  if (char2b->byte1 == 0
-	      && char2b->byte2 >= xfont->min_char_or_byte2
-	      && char2b->byte2 <= xfont->max_char_or_byte2)
-	    pcm = xfont->per_char + char2b->byte2 - xfont->min_char_or_byte2;
+	  if (byte1 == 0
+	      && byte2 >= xfont->min_char_or_byte2
+	      && byte2 <= xfont->max_char_or_byte2)
+	    pcm = xfont->per_char + byte2 - xfont->min_char_or_byte2;
 	}
       else
 	{
@@ -89,14 +91,14 @@ xfont_get_pcm (XFontStruct *xfont, XChar2b *char2b)
 	     D = max_char_or_byte2 - min_char_or_byte2 + 1
 	     / = integer division
 	     \ = integer modulus  */
-	  if (char2b->byte1 >= xfont->min_byte1
-	      && char2b->byte1 <= xfont->max_byte1
-	      && char2b->byte2 >= xfont->min_char_or_byte2
-	      && char2b->byte2 <= xfont->max_char_or_byte2)
+	  if (byte1 >= xfont->min_byte1
+	      && byte1 <= xfont->max_byte1
+	      && byte2 >= xfont->min_char_or_byte2
+	      && byte2 <= xfont->max_char_or_byte2)
 	    pcm = (xfont->per_char
 		   + ((xfont->max_char_or_byte2 - xfont->min_char_or_byte2 + 1)
-		      * (char2b->byte1 - xfont->min_byte1))
-		   + (char2b->byte2 - xfont->min_char_or_byte2));
+		      * (byte1 - xfont->min_byte1))
+		   + (byte2 - xfont->min_char_or_byte2));
 	}
     }
   else
@@ -104,8 +106,8 @@ xfont_get_pcm (XFontStruct *xfont, XChar2b *char2b)
       /* If the per_char pointer is null, all glyphs between the first
 	 and last character indexes inclusive have the same
 	 information, as given by both min_bounds and max_bounds.  */
-      if (char2b->byte2 >= xfont->min_char_or_byte2
-	  && char2b->byte2 <= xfont->max_char_or_byte2)
+      if (byte2 >= xfont->min_char_or_byte2
+	  && byte2 <= xfont->max_char_or_byte2)
 	pcm = &xfont->max_bounds;
     }
 
@@ -193,7 +195,6 @@ xfont_chars_supported (Lisp_Object chars, XFontStruct *xfont,
 	{
 	  int c = XFIXNUM (XCAR (chars));
 	  unsigned code = ENCODE_CHAR (charset, c);
-	  XChar2b char2b;
 
 	  if (code == CHARSET_INVALID_CODE (charset))
 	    break;
@@ -201,9 +202,7 @@ xfont_chars_supported (Lisp_Object chars, XFontStruct *xfont,
 	    continue;
 	  if (code >= 0x10000)
 	    break;
-	  char2b.byte1 = code >> 8;
-	  char2b.byte2 = code & 0xFF;
-	  if (! xfont_get_pcm (xfont, &char2b))
+	  if (! xfont_get_pcm (xfont, code))
 	    break;
 	}
       return (NILP (chars));
@@ -216,7 +215,6 @@ xfont_chars_supported (Lisp_Object chars, XFontStruct *xfont,
 	{
 	  int c = XFIXNUM (AREF (chars, i));
 	  unsigned code = ENCODE_CHAR (charset, c);
-	  XChar2b char2b;
 
 	  if (code == CHARSET_INVALID_CODE (charset))
 	    continue;
@@ -224,9 +222,7 @@ xfont_chars_supported (Lisp_Object chars, XFontStruct *xfont,
 	    break;
 	  if (code >= 0x10000)
 	    continue;
-	  char2b.byte1 = code >> 8;
-	  char2b.byte2 = code & 0xFF;
-	  if (xfont_get_pcm (xfont, &char2b))
+	  if (xfont_get_pcm (xfont, code))
 	    break;
 	}
       return (i >= 0);
@@ -801,11 +797,9 @@ xfont_open (struct frame *f, Lisp_Object entity, int pixel_size)
   else
     {
       XCharStruct *pcm;
-      XChar2b char2b;
       Lisp_Object val;
 
-      char2b.byte1 = 0x00, char2b.byte2 = 0x20;
-      pcm = xfont_get_pcm (xfont, &char2b);
+      pcm = xfont_get_pcm (xfont, 0x20);
       if (pcm)
 	font->space_width = pcm->width;
       else
@@ -823,8 +817,8 @@ xfont_open (struct frame *f, Lisp_Object entity, int pixel_size)
 	    {
 	      int width = font->space_width, n = pcm != NULL;
 
-	      for (char2b.byte2 = 33; char2b.byte2 <= 126; char2b.byte2++)
-		if ((pcm = xfont_get_pcm (xfont, &char2b)) != NULL)
+	      for (unsigned char2b = 33; char2b <= 126; ++char2b)
+		if ((pcm = xfont_get_pcm (xfont, char2b)) != NULL)
 		  width += pcm->width, n++;
 	      if (n > 0)
 		font->average_width = width / n;
@@ -934,7 +928,6 @@ xfont_encode_char (struct font *font, int c)
   XFontStruct *xfont = ((struct xfont_info *) font)->xfont;
   struct charset *charset;
   unsigned code;
-  XChar2b char2b;
 
   charset = CHARSET_FROM_ID (font->encoding_charset);
   code = ENCODE_CHAR (charset, c);
@@ -946,13 +939,11 @@ xfont_encode_char (struct font *font, int c)
       return (ENCODE_CHAR (charset, c) != CHARSET_INVALID_CODE (charset)
 	      ? code : FONT_INVALID_CODE);
     }
-  char2b.byte1 = code >> 8;
-  char2b.byte2 = code & 0xFF;
-  return (xfont_get_pcm (xfont, &char2b) ? code : FONT_INVALID_CODE);
+  return (xfont_get_pcm (xfont, code) ? code : FONT_INVALID_CODE);
 }
 
 static void
-xfont_text_extents (struct font *font, unsigned int *code,
+xfont_text_extents (struct font *font, const unsigned int *code,
 		    int nglyphs, struct font_metrics *metrics)
 {
   XFontStruct *xfont = ((struct xfont_info *) font)->xfont;
@@ -961,13 +952,11 @@ xfont_text_extents (struct font *font, unsigned int *code,
 
   for (i = 0, first = true; i < nglyphs; i++)
     {
-      XChar2b char2b;
       static XCharStruct *pcm;
 
       if (code[i] >= 0x10000)
 	continue;
-      char2b.byte1 = code[i] >> 8, char2b.byte2 = code[i] & 0xFF;
-      pcm = xfont_get_pcm (xfont, &char2b);
+      pcm = xfont_get_pcm (xfont, code[i]);
       if (! pcm)
 	continue;
       if (first)
@@ -1000,6 +989,7 @@ xfont_draw (struct glyph_string *s, int from, int to, int x, int y,
             bool with_background)
 {
   XFontStruct *xfont = ((struct xfont_info *) s->font)->xfont;
+  Display *display = FRAME_X_DISPLAY (s->f);
   int len = to - from;
   GC gc = s->gc;
   int i;
@@ -1007,7 +997,7 @@ xfont_draw (struct glyph_string *s, int from, int to, int x, int y,
   if (s->gc != s->face->gc)
     {
       block_input ();
-      XSetFont (s->display, gc, xfont->fid);
+      XSetFont (display, gc, xfont->fid);
       unblock_input ();
     }
 
@@ -1016,26 +1006,26 @@ xfont_draw (struct glyph_string *s, int from, int to, int x, int y,
       USE_SAFE_ALLOCA;
       char *str = SAFE_ALLOCA (len);
       for (i = 0; i < len ; i++)
-	str[i] = XCHAR2B_BYTE2 (s->char2b + from + i);
+	str[i] = s->char2b[from + i] & 0xFF;
       block_input ();
       if (with_background)
 	{
 	  if (s->padding_p)
 	    for (i = 0; i < len; i++)
-              XDrawImageString (FRAME_X_DISPLAY (s->f), FRAME_X_DRAWABLE (s->f),
+              XDrawImageString (display, FRAME_X_DRAWABLE (s->f),
 				gc, x + i, y, str + i, 1);
 	  else
-            XDrawImageString (FRAME_X_DISPLAY (s->f), FRAME_X_DRAWABLE (s->f),
+            XDrawImageString (display, FRAME_X_DRAWABLE (s->f),
 			      gc, x, y, str, len);
 	}
       else
 	{
 	  if (s->padding_p)
 	    for (i = 0; i < len; i++)
-              XDrawString (FRAME_X_DISPLAY (s->f), FRAME_X_DRAWABLE (s->f),
+              XDrawString (display, FRAME_X_DRAWABLE (s->f),
 			   gc, x + i, y, str + i, 1);
 	  else
-            XDrawString (FRAME_X_DISPLAY (s->f), FRAME_X_DRAWABLE (s->f),
+            XDrawString (display, FRAME_X_DRAWABLE (s->f),
 			 gc, x, y, str, len);
 	}
       unblock_input ();
@@ -1048,21 +1038,51 @@ xfont_draw (struct glyph_string *s, int from, int to, int x, int y,
     {
       if (s->padding_p)
 	for (i = 0; i < len; i++)
-          XDrawImageString16 (FRAME_X_DISPLAY (s->f), FRAME_X_DRAWABLE (s->f),
-			      gc, x + i, y, s->char2b + from + i, 1);
+          {
+            const unsigned code = s->char2b[from + i];
+            const XChar2b char2b = { .byte1 = code >> 8,
+                                     .byte2 = code & 0xFF };
+            XDrawImageString16 (display, FRAME_X_DRAWABLE (s->f),
+                                gc, x + i, y, &char2b, 1);
+          }
       else
-        XDrawImageString16 (FRAME_X_DISPLAY (s->f), FRAME_X_DRAWABLE (s->f),
-			    gc, x, y, s->char2b + from, len);
+        {
+          USE_SAFE_ALLOCA;
+          const unsigned *code = s->char2b + from;
+          XChar2b *char2b;
+          SAFE_NALLOCA (char2b, 1, len);
+          for (int i = 0; i < len; ++i)
+            char2b[i] = (XChar2b) { .byte1 = code[i] >> 8,
+                                    .byte2 = code[i] & 0xFF };
+          XDrawImageString16 (display, FRAME_X_DRAWABLE (s->f),
+                              gc, x, y, char2b, len);
+          SAFE_FREE ();
+        }
     }
   else
     {
       if (s->padding_p)
 	for (i = 0; i < len; i++)
-          XDrawString16 (FRAME_X_DISPLAY (s->f), FRAME_X_DRAWABLE (s->f),
-			 gc, x + i, y, s->char2b + from + i, 1);
+          {
+            const unsigned code = s->char2b[from + i];
+            const XChar2b char2b = { .byte1 = code >> 8,
+                                     .byte2 = code & 0xFF };
+            XDrawString16 (display, FRAME_X_DRAWABLE (s->f),
+                           gc, x + i, y, &char2b, 1);
+          }
       else
-        XDrawString16 (FRAME_X_DISPLAY (s->f), FRAME_X_DRAWABLE (s->f),
-		       gc, x, y, s->char2b + from, len);
+        {
+          USE_SAFE_ALLOCA;
+          const unsigned *code = s->char2b + from;
+          XChar2b *char2b;
+          SAFE_NALLOCA (char2b, 1, len);
+          for (int i = 0; i < len; ++i)
+            char2b[i] = (XChar2b) { .byte1 = code[i] >> 8,
+                                    .byte2 = code[i] & 0xFF };
+          XDrawString16 (display, FRAME_X_DRAWABLE (s->f),
+                         gc, x, y, char2b, len);
+          SAFE_FREE ();
+        }
     }
   unblock_input ();
 
diff --git a/src/xftfont.c b/src/xftfont.c
index 8a4516f7f9..4f0a0d81d8 100644
--- a/src/xftfont.c
+++ b/src/xftfont.c
@@ -127,120 +127,18 @@ xftfont_match (struct frame *f, Lisp_Object spec)
 
 static FcChar8 ascii_printable[95];
 
-static void
-xftfont_fix_match (FcPattern *pat, FcPattern *match)
-{
-  /*  These values are not used for matching (except antialias), but for
-      rendering, so make sure they are carried over to the match.
-      We also put antialias here because most fonts are antialiased, so
-      the match will have antialias true.  */
-
-  FcBool b = FcTrue;
-  int i;
-  double dpi;
-
-  FcPatternGetBool (pat, FC_ANTIALIAS, 0, &b);
-  if (! b)
-    {
-      FcPatternDel (match, FC_ANTIALIAS);
-      FcPatternAddBool (match, FC_ANTIALIAS, FcFalse);
-    }
-  FcPatternGetBool (pat, FC_HINTING, 0, &b);
-  if (! b)
-    {
-      FcPatternDel (match, FC_HINTING);
-      FcPatternAddBool (match, FC_HINTING, FcFalse);
-    }
-#ifndef FC_HINT_STYLE
-# define FC_HINT_STYLE "hintstyle"
-#endif
-  if (FcResultMatch == FcPatternGetInteger (pat, FC_HINT_STYLE, 0, &i))
-    {
-      FcPatternDel (match, FC_HINT_STYLE);
-      FcPatternAddInteger (match, FC_HINT_STYLE, i);
-    }
-#ifndef FC_LCD_FILTER
-  /* Older fontconfig versions don't have FC_LCD_FILTER. */
-#define FC_LCD_FILTER "lcdfilter"
-#endif
-  if (FcResultMatch == FcPatternGetInteger (pat, FC_LCD_FILTER, 0, &i))
-    {
-      FcPatternDel (match, FC_LCD_FILTER);
-      FcPatternAddInteger (match, FC_LCD_FILTER, i);
-    }
-  if (FcResultMatch == FcPatternGetInteger (pat, FC_RGBA, 0, &i))
-    {
-      FcPatternDel (match, FC_RGBA);
-      FcPatternAddInteger (match, FC_RGBA, i);
-    }
-  if (FcResultMatch == FcPatternGetDouble (pat, FC_DPI, 0, &dpi))
-    {
-      FcPatternDel (match, FC_DPI);
-      FcPatternAddDouble (match, FC_DPI, dpi);
-    }
-}
-
-static void
-xftfont_add_rendering_parameters (FcPattern *pat, Lisp_Object entity)
-{
-  Lisp_Object tail;
-  int ival;
-
-  for (tail = AREF (entity, FONT_EXTRA_INDEX); CONSP (tail); tail = XCDR (tail))
-    {
-      Lisp_Object key = XCAR (XCAR (tail));
-      Lisp_Object val = XCDR (XCAR (tail));
-
-      if (EQ (key, QCantialias))
-          FcPatternAddBool (pat, FC_ANTIALIAS, NILP (val) ? FcFalse : FcTrue);
-      else if (EQ (key, QChinting))
-	FcPatternAddBool (pat, FC_HINTING, NILP (val) ? FcFalse : FcTrue);
-      else if (EQ (key, QCautohint))
-	FcPatternAddBool (pat, FC_AUTOHINT, NILP (val) ? FcFalse : FcTrue);
-      else if (EQ (key, QChintstyle))
-	{
-	  if (FIXNUMP (val))
-	    FcPatternAddInteger (pat, FC_HINT_STYLE, XFIXNUM (val));
-          else if (SYMBOLP (val)
-                   && FcNameConstant (SDATA (SYMBOL_NAME (val)), &ival))
-	    FcPatternAddInteger (pat, FC_HINT_STYLE, ival);
-	}
-      else if (EQ (key, QCrgba))
-	{
-	  if (FIXNUMP (val))
-	    FcPatternAddInteger (pat, FC_RGBA, XFIXNUM (val));
-          else if (SYMBOLP (val)
-                   && FcNameConstant (SDATA (SYMBOL_NAME (val)), &ival))
-	    FcPatternAddInteger (pat, FC_RGBA, ival);
-	}
-      else if (EQ (key, QClcdfilter))
-	{
-	  if (FIXNUMP (val))
-	    FcPatternAddInteger (pat, FC_LCD_FILTER, ival = XFIXNUM (val));
-          else if (SYMBOLP (val)
-                   && FcNameConstant (SDATA (SYMBOL_NAME (val)), &ival))
-	    FcPatternAddInteger (pat, FC_LCD_FILTER, ival);
-	}
-#ifdef FC_EMBOLDEN
-      else if (EQ (key, QCembolden))
-	FcPatternAddBool (pat, FC_EMBOLDEN, NILP (val) ? FcFalse : FcTrue);
-#endif
-    }
-}
-
 static Lisp_Object
 xftfont_open (struct frame *f, Lisp_Object entity, int pixel_size)
 {
   FcResult result;
   Display *display = FRAME_X_DISPLAY (f);
-  Lisp_Object val, filename, idx, font_object;
+  Lisp_Object val, filename, font_object;
   FcPattern *pat = NULL, *match;
   struct font_info *xftfont_info = NULL;
   struct font *font;
   double size = 0;
   XftFont *xftfont = NULL;
   int spacing;
-  int i;
   XGlyphInfo extents;
   FT_Face ft_face;
   FcMatrix *matrix;
@@ -250,52 +148,17 @@ xftfont_open (struct frame *f, Lisp_Object entity, int pixel_size)
     return Qnil;
   val = XCDR (val);
   filename = XCAR (val);
-  idx = XCDR (val);
   size = XFIXNUM (AREF (entity, FONT_SIZE_INDEX));
   if (size == 0)
     size = pixel_size;
-  pat = FcPatternCreate ();
-  FcPatternAddInteger (pat, FC_WEIGHT, FONT_WEIGHT_NUMERIC (entity));
-  i = FONT_SLANT_NUMERIC (entity) - 100;
-  if (i < 0) i = 0;
-  FcPatternAddInteger (pat, FC_SLANT, i);
-  FcPatternAddInteger (pat, FC_WIDTH, FONT_WIDTH_NUMERIC (entity));
-  FcPatternAddDouble (pat, FC_PIXEL_SIZE, pixel_size);
-  val = AREF (entity, FONT_FAMILY_INDEX);
-  if (! NILP (val))
-    FcPatternAddString (pat, FC_FAMILY, (FcChar8 *) SDATA (SYMBOL_NAME (val)));
-  val = AREF (entity, FONT_FOUNDRY_INDEX);
-  if (! NILP (val))
-    FcPatternAddString (pat, FC_FOUNDRY, (FcChar8 *) SDATA (SYMBOL_NAME (val)));
-  val = AREF (entity, FONT_SPACING_INDEX);
-  if (! NILP (val))
-    FcPatternAddInteger (pat, FC_SPACING, XFIXNUM (val));
-  val = AREF (entity, FONT_DPI_INDEX);
-  if (! NILP (val))
-    {
-      double dbl = XFIXNUM (val);
-
-      FcPatternAddDouble (pat, FC_DPI, dbl);
-    }
-  val = AREF (entity, FONT_AVGWIDTH_INDEX);
-  if (FIXNUMP (val) && XFIXNUM (val) == 0)
-    FcPatternAddBool (pat, FC_SCALABLE, FcTrue);
-  /* This is necessary to identify the exact font (e.g. 10x20.pcf.gz
-     over 10x20-ISO8859-1.pcf.gz).  */
-  FcPatternAddCharSet (pat, FC_CHARSET, ftfont_get_fc_charset (entity));
-
-  xftfont_add_rendering_parameters (pat, entity);
-
-  FcPatternAddString (pat, FC_FILE, (FcChar8 *) SDATA (filename));
-  FcPatternAddInteger (pat, FC_INDEX, XFIXNUM (idx));
-
 
   block_input ();
 
+  pat = ftfont_entity_pattern (entity, pixel_size);
   /* Substitute in values from X resources and XftDefaultSet.  */
   XftDefaultSubstitute (display, FRAME_X_SCREEN_NUMBER (f), pat);
   match = XftFontMatch (display, FRAME_X_SCREEN_NUMBER (f), pat, &result);
-  xftfont_fix_match (pat, match);
+  ftfont_fix_match (pat, match);
 
   FcPatternDestroy (pat);
   xftfont = XftFontOpenPattern (display, match);
@@ -536,7 +399,7 @@ xftfont_encode_char (struct font *font, int c)
 }
 
 static void
-xftfont_text_extents (struct font *font, unsigned int *code,
+xftfont_text_extents (struct font *font, const unsigned int *code,
 		      int nglyphs, struct font_metrics *metrics)
 {
   struct font_info *xftfont_info = (struct font_info *) font;
@@ -621,8 +484,7 @@ xftfont_draw (struct glyph_string *s, int from, int to, int x, int y,
     }
   code = alloca (sizeof (FT_UInt) * len);
   for (i = 0; i < len; i++)
-    code[i] = ((XCHAR2B_BYTE1 (s->char2b + from + i) << 8)
-	       | XCHAR2B_BYTE2 (s->char2b + from + i));
+    code[i] = s->char2b[from + i];
 
   if (s->padding_p)
     for (i = 0; i < len; i++)
@@ -696,7 +558,7 @@ xftfont_cached_font_ok (struct frame *f, Lisp_Object font_object,
   bool ok = false;
   int i1, i2, r1, r2;
 
-  xftfont_add_rendering_parameters (pat, entity);
+  ftfont_add_rendering_parameters (pat, entity);
   XftDefaultSubstitute (display, FRAME_X_SCREEN_NUMBER (f), pat);
 
   r1 = FcPatternGetBool (pat, FC_ANTIALIAS, 0, &b1);
@@ -769,12 +631,6 @@ void
 syms_of_xftfont (void)
 {
   DEFSYM (Qxft, "xft");
-  DEFSYM (QChinting, ":hinting");
-  DEFSYM (QCautohint, ":autohint");
-  DEFSYM (QChintstyle, ":hintstyle");
-  DEFSYM (QCrgba, ":rgba");
-  DEFSYM (QCembolden, ":embolden");
-  DEFSYM (QClcdfilter, ":lcdfilter");
 
   DEFVAR_BOOL ("xft-font-ascent-descent-override",
 	       xft_font_ascent_descent_override,
diff --git a/src/xrdb.c b/src/xrdb.c
index 35de446cb7..9c625e9821 100644
--- a/src/xrdb.c
+++ b/src/xrdb.c
@@ -60,12 +60,12 @@ x_get_customization_string (XrmDatabase db, const char *name,
 {
   char *full_name = alloca (strlen (name) + sizeof "customization" + 3);
   char *full_class = alloca (strlen (class) + sizeof "Customization" + 3);
-  char *result;
+  const char *result;
 
   sprintf (full_name,  "%s.%s", name,  "customization");
   sprintf (full_class, "%s.%s", class, "Customization");
 
-  result = x_get_string_resource (db, full_name, full_class);
+  result = x_get_string_resource (&db, full_name, full_class);
   return result ? xstrdup (result) : NULL;
 }
 
@@ -383,7 +383,7 @@ x_load_resources (Display *display, const char *xrm_string,
   XrmDatabase db;
   char line[256];
 
-#if defined USE_MOTIF || !defined HAVE_XFT || !defined USE_LUCID
+#if defined USE_MOTIF || !(defined USE_CAIRO || defined HAVE_XFT) || !defined USE_LUCID
   const char *helv = "-*-helvetica-medium-r-*--*-120-*-*-*-*-iso8859-1";
 #endif
 
@@ -456,7 +456,7 @@ x_load_resources (Display *display, const char *xrm_string,
 
   sprintf (line, "Emacs.dialog*.background: grey75");
   XrmPutLineResource (&rdb, line);
-#if !defined (HAVE_XFT) || !defined (USE_LUCID)
+#if !(defined USE_CAIRO || defined HAVE_XFT) || !defined (USE_LUCID)
   sprintf (line, "Emacs.dialog*.font: %s", helv);
   XrmPutLineResource (&rdb, line);
   sprintf (line, "*XlwMenu*font: %s", helv);
@@ -547,19 +547,20 @@ x_get_resource (XrmDatabase rdb, const char *name, const char *class,
 /* Retrieve the string resource specified by NAME with CLASS from
    database RDB. */
 
-char *
-x_get_string_resource (XrmDatabase rdb, const char *name, const char *class)
+const char *
+x_get_string_resource (void *v_rdb, const char *name, const char *class)
 {
+  XrmDatabase *rdb = v_rdb;
   XrmValue value;
 
   if (inhibit_x_resources)
     /* --quick was passed, so this is a no-op.  */
     return NULL;
 
-  if (x_get_resource (rdb, name, class, x_rm_string, &value))
-    return (char *) value.addr;
+  if (x_get_resource (*rdb, name, class, x_rm_string, &value))
+    return (const char *) value.addr;
 
-  return 0;
+  return NULL;
 }
 
 /* Stand-alone test facilities.  */
@@ -648,7 +649,7 @@ main (int argc, char **argv)
 	  printf ("Class: ");
 	  gets (query_class);
 
-	  value = x_get_string_resource (xdb, query_name, query_class);
+	  value = x_get_string_resource (&xdb, query_name, query_class);
 
 	  if (value != NULL)
 	    printf ("\t%s(%s):  %s\n\n", query_name, query_class, value);
diff --git a/src/xsettings.c b/src/xsettings.c
index 947d5cfb7b..3e9012e3ab 100644
--- a/src/xsettings.c
+++ b/src/xsettings.c
@@ -45,9 +45,13 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <gconf/gconf-client.h>
 #endif
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
+#ifdef USE_CAIRO
+#include <fontconfig/fontconfig.h>
+#else  /* HAVE_XFT */
 #include <X11/Xft/Xft.h>
 #endif
+#endif
 
 static char *current_mono_font;
 static char *current_font;
@@ -83,7 +87,7 @@ dpyinfo_valid (struct x_display_info *dpyinfo)
 
 /* Store a monospace font change event if the monospaced font changed.  */
 
-#if defined HAVE_XFT && (defined HAVE_GSETTINGS || defined HAVE_GCONF)
+#if (defined USE_CAIRO || defined HAVE_XFT) && (defined HAVE_GSETTINGS || defined HAVE_GCONF)
 static void
 store_monospaced_changed (const char *newfont)
 {
@@ -102,7 +106,7 @@ store_monospaced_changed (const char *newfont)
 
 /* Store a font name change event if the font name changed.  */
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 static void
 store_font_name_changed (const char *newfont)
 {
@@ -117,7 +121,7 @@ store_font_name_changed (const char *newfont)
                                   XCAR (first_dpyinfo->name_list_element));
     }
 }
-#endif /* HAVE_XFT */
+#endif /* USE_CAIRO || HAVE_XFT */
 
 /* Map TOOL_BAR_STYLE from a string to its corresponding Lisp value.
    Return Qnil if TOOL_BAR_STYLE is not known.  */
@@ -157,7 +161,7 @@ store_tool_bar_style_changed (const char *newstyle,
                                 XCAR (dpyinfo->name_list_element));
 }
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 #define XSETTINGS_FONT_NAME       "Gtk/FontName"
 #endif
 #define XSETTINGS_TOOL_BAR_STYLE  "Gtk/ToolbarStyle"
@@ -174,7 +178,7 @@ enum {
 };
 struct xsettings
 {
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   FcBool aa, hinting;
   int rgba, lcdfilter, hintstyle;
   double dpi;
@@ -191,7 +195,7 @@ struct xsettings
 #define GSETTINGS_SCHEMA         "org.gnome.desktop.interface"
 #define GSETTINGS_TOOL_BAR_STYLE "toolbar-style"
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 #define GSETTINGS_MONO_FONT  "monospace-font-name"
 #define GSETTINGS_FONT_NAME  "font-name"
 #endif
@@ -224,7 +228,7 @@ something_changed_gsettingsCB (GSettings *settings,
           g_variant_unref (val);
         }
     }
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   else if (strcmp (key, GSETTINGS_MONO_FONT) == 0)
     {
       val = g_settings_get_value (settings, GSETTINGS_MONO_FONT);
@@ -253,14 +257,14 @@ something_changed_gsettingsCB (GSettings *settings,
           g_variant_unref (val);
         }
     }
-#endif /* HAVE_XFT */
+#endif /* USE_CAIRO || HAVE_XFT */
 }
 
 #endif /* HAVE_GSETTINGS */
 
 #ifdef HAVE_GCONF
 #define GCONF_TOOL_BAR_STYLE "/desktop/gnome/interface/toolbar_style"
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 #define GCONF_MONO_FONT  "/desktop/gnome/interface/monospace_font_name"
 #define GCONF_FONT_NAME  "/desktop/gnome/interface/font_name"
 #endif
@@ -286,7 +290,7 @@ something_changed_gconfCB (GConfClient *client,
       const char *value = gconf_value_get_string (v);
       store_tool_bar_style_changed (value, first_dpyinfo);
     }
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   else if (strcmp (key, GCONF_MONO_FONT) == 0)
     {
       const char *value = gconf_value_get_string (v);
@@ -297,12 +301,12 @@ something_changed_gconfCB (GConfClient *client,
       const char *value = gconf_value_get_string (v);
       store_font_name_changed (value);
     }
-#endif /* HAVE_XFT */
+#endif /* USE_CAIRO || HAVE_XFT */
 }
 
 #endif /* HAVE_GCONF */
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
 
 /* Older fontconfig versions don't have FC_LCD_*.  */
 #ifndef FC_LCD_NONE
@@ -315,7 +319,7 @@ something_changed_gconfCB (GConfClient *client,
 #define FC_LCD_FILTER "lcdfilter"
 #endif
 
-#endif /* HAVE_XFT */
+#endif /* USE_CAIRO || HAVE_XFT */
 
 /* Find the window that contains the XSETTINGS property values.  */
 
@@ -440,7 +444,7 @@ parse_settings (unsigned char *prop,
       if (bytes_parsed > bytes) return settings_seen;
 
       want_this = strcmp (XSETTINGS_TOOL_BAR_STYLE, name) == 0;
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
       if ((nlen > 6 && memcmp (name, "Xft/", 4) == 0)
 	  || strcmp (XSETTINGS_FONT_NAME, name) == 0)
 	want_this = true;
@@ -490,7 +494,7 @@ parse_settings (unsigned char *prop,
               dupstring (&settings->tb_style, sval);
               settings->seen |= SEEN_TB_STYLE;
             }
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
           else if (strcmp (name, XSETTINGS_FONT_NAME) == 0)
             {
               dupstring (&settings->font, sval);
@@ -553,7 +557,7 @@ parse_settings (unsigned char *prop,
               else
                 settings->seen &= ~SEEN_LCDFILTER;
             }
-#endif /* HAVE_XFT */
+#endif /* USE_CAIRO || HAVE_XFT */
 	  else
 	    want_this = false;
 	  settings_seen += want_this;
@@ -604,16 +608,18 @@ static void
 apply_xft_settings (struct x_display_info *dpyinfo,
                     struct xsettings *settings)
 {
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   FcPattern *pat;
   struct xsettings oldsettings;
   bool changed = false;
 
   memset (&oldsettings, 0, sizeof (oldsettings));
   pat = FcPatternCreate ();
+#ifdef HAVE_XFT
   XftDefaultSubstitute (dpyinfo->display,
                         XScreenNumberOfScreen (dpyinfo->screen),
                         pat);
+#endif
   FcPatternGetBool (pat, FC_ANTIALIAS, 0, &oldsettings.aa);
   FcPatternGetBool (pat, FC_HINTING, 0, &oldsettings.hinting);
 #ifdef FC_HINT_STYLE
@@ -713,7 +719,9 @@ apply_xft_settings (struct x_display_info *dpyinfo,
       };
       char buf[sizeof format + d_formats * d_growth + lf_formats * lf_growth];
 
+#ifdef HAVE_XFT
       XftDefaultSet (dpyinfo->display, pat);
+#endif
       store_config_changed_event (Qfont_render,
 				  XCAR (dpyinfo->name_list_element));
       Vxft_settings
@@ -725,7 +733,7 @@ apply_xft_settings (struct x_display_info *dpyinfo,
     }
   else
     FcPatternDestroy (pat);
-#endif /* HAVE_XFT */
+#endif /* USE_CAIRO || HAVE_XFT */
 }
 
 /* Read XSettings from the display for DPYINFO.
@@ -748,7 +756,7 @@ read_and_apply_settings (struct x_display_info *dpyinfo, bool send_event_p)
         current_tool_bar_style = map_tool_bar_style (settings.tb_style);
       xfree (settings.tb_style);
     }
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   if (settings.seen & SEEN_FONT)
     {
       if (send_event_p)
@@ -850,7 +858,7 @@ init_gsettings (void)
       g_variant_unref (val);
     }
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   val = g_settings_get_value (gsettings_client, GSETTINGS_MONO_FONT);
   if (val)
     {
@@ -868,7 +876,7 @@ init_gsettings (void)
         dupstring (&current_font, g_variant_get_string (val, NULL));
       g_variant_unref (val);
     }
-#endif /* HAVE_XFT */
+#endif /* USE_CAIRO || HAVE_XFT */
 
 #endif /* HAVE_GSETTINGS */
 }
@@ -903,7 +911,7 @@ init_gconf (void)
       g_free (s);
     }
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   s = gconf_client_get_string (gconf_client, GCONF_MONO_FONT, NULL);
   if (s)
     {
@@ -932,7 +940,7 @@ init_gconf (void)
                            GCONF_FONT_NAME,
                            something_changed_gconfCB,
                            NULL, NULL, NULL);
-#endif /* HAVE_XFT */
+#endif /* USE_CAIRO || HAVE_XFT */
 #endif /* HAVE_GCONF */
 }
 
@@ -1055,7 +1063,7 @@ If this variable is nil, Emacs ignores system font changes.  */);
                doc: /* Font settings applied to Xft.  */);
   Vxft_settings = empty_unibyte_string;
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   Fprovide (intern_c_string ("font-render-setting"), Qnil);
 #if defined (HAVE_GCONF) || defined (HAVE_GSETTINGS)
   Fprovide (intern_c_string ("system-font-setting"), Qnil);
diff --git a/src/xterm.c b/src/xterm.c
index def6915d62..c064647da0 100644
--- a/src/xterm.c
+++ b/src/xterm.c
@@ -201,7 +201,6 @@ enum xembed_message
     XEMBED_ACTIVATE_ACCELERATOR   = 14
   };
 
-static void x_free_cr_resources (struct frame *);
 static bool x_alloc_nearest_color_1 (Display *, Colormap, XColor *);
 static void x_raise_frame (struct frame *);
 static void x_lower_frame (struct frame *);
@@ -234,7 +233,7 @@ static void x_wm_set_window_state (struct frame *, int);
 static void x_wm_set_icon_pixmap (struct frame *, ptrdiff_t);
 static void x_initialize (void);
 
-static bool get_current_wm_state (struct frame *, Window, int *, bool *);
+static bool x_get_current_wm_state (struct frame *, Window, int *, bool *);
 
 /* Flush display of frame F.  */
 
@@ -298,7 +297,10 @@ record_event (char *locus, int type)
 #ifdef USE_CAIRO
 
 #define FRAME_CR_CONTEXT(f)	((f)->output_data.x->cr_context)
-#define FRAME_CR_SURFACE(f)	((f)->output_data.x->cr_surface)
+#define FRAME_CR_SURFACE_DESIRED_WIDTH(f) \
+  ((f)->output_data.x->cr_surface_desired_width)
+#define FRAME_CR_SURFACE_DESIRED_HEIGHT(f) \
+  ((f)->output_data.x->cr_surface_desired_height)
 
 static struct x_gc_ext_data *
 x_gc_get_ext_data (struct frame *f, GC gc, int create_if_not_found_p)
@@ -333,19 +335,28 @@ x_extension_initialize (struct x_display_info *dpyinfo)
   dpyinfo->ext_codes = ext_codes;
 }
 
-static void
-x_cr_destroy_surface (struct frame *f)
+void
+x_cr_destroy_frame_context (struct frame *f)
 {
-  if (FRAME_CR_SURFACE (f))
+  if (FRAME_CR_CONTEXT (f))
     {
-      cairo_t *cr = FRAME_CR_CONTEXT (f);
-      cairo_surface_destroy (FRAME_CR_SURFACE (f));
-      FRAME_CR_SURFACE (f) = 0;
-      if (cr) cairo_destroy (cr);
+      cairo_destroy (FRAME_CR_CONTEXT (f));
       FRAME_CR_CONTEXT (f) = NULL;
     }
 }
 
+static void
+x_cr_update_surface_desired_size (struct frame *f, int width, int height)
+{
+  if (FRAME_CR_SURFACE_DESIRED_WIDTH (f) != width
+      || FRAME_CR_SURFACE_DESIRED_HEIGHT (f) != height)
+    {
+      x_cr_destroy_frame_context (f);
+      FRAME_CR_SURFACE_DESIRED_WIDTH (f) = width;
+      FRAME_CR_SURFACE_DESIRED_HEIGHT (f) = height;
+    }
+}
+
 cairo_t *
 x_begin_cr_clip (struct frame *f, GC gc)
 {
@@ -353,21 +364,19 @@ x_begin_cr_clip (struct frame *f, GC gc)
 
   if (!cr)
     {
-
-      if (! FRAME_CR_SURFACE (f))
-        {
-	  int scale = 1;
-#ifdef USE_GTK
-	  scale = xg_get_scale (f);
-#endif
-
-	  FRAME_CR_SURFACE (f) =
-	    cairo_image_surface_create (CAIRO_FORMAT_ARGB32,
-					scale * FRAME_PIXEL_WIDTH (f),
-					scale * FRAME_PIXEL_HEIGHT (f));
-	}
-      cr = cairo_create (FRAME_CR_SURFACE (f));
-      FRAME_CR_CONTEXT (f) = cr;
+      int width = FRAME_CR_SURFACE_DESIRED_WIDTH (f);
+      int height = FRAME_CR_SURFACE_DESIRED_HEIGHT (f);
+      cairo_surface_t *surface;
+      if (FRAME_X_DOUBLE_BUFFERED_P (f))
+	surface = cairo_xlib_surface_create (FRAME_X_DISPLAY (f),
+					     FRAME_X_RAW_DRAWABLE (f),
+					     FRAME_X_VISUAL (f),
+					     width, height);
+      else
+	surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,
+					      width, height);
+      cr = FRAME_CR_CONTEXT (f) = cairo_create (surface);
+      cairo_surface_destroy (surface);
     }
   cairo_save (cr);
 
@@ -395,6 +404,8 @@ void
 x_end_cr_clip (struct frame *f)
 {
   cairo_restore (FRAME_CR_CONTEXT (f));
+  if (FRAME_X_DOUBLE_BUFFERED_P (f))
+    x_mark_frame_dirty (f);
 }
 
 void
@@ -405,7 +416,7 @@ x_set_cr_source_with_gc_foreground (struct frame *f, GC gc)
 
   XGetGCValues (FRAME_X_DISPLAY (f), gc, GCForeground, &xgcv);
   color.pixel = xgcv.foreground;
-  x_query_color (f, &color);
+  x_query_colors (f, &color, 1);
   cairo_set_source_rgb (FRAME_CR_CONTEXT (f), color.red / 65535.0,
 			color.green / 65535.0, color.blue / 65535.0);
 }
@@ -418,7 +429,7 @@ x_set_cr_source_with_gc_background (struct frame *f, GC gc)
 
   XGetGCValues (FRAME_X_DISPLAY (f), gc, GCBackground, &xgcv);
   color.pixel = xgcv.background;
-  x_query_color (f, &color);
+  x_query_colors (f, &color, 1);
   cairo_set_source_rgb (FRAME_CR_CONTEXT (f), color.red / 65535.0,
 			color.green / 65535.0, color.blue / 65535.0);
 }
@@ -532,11 +543,11 @@ x_cr_draw_frame (cairo_t *cr, struct frame *f)
   width = FRAME_PIXEL_WIDTH (f);
   height = FRAME_PIXEL_HEIGHT (f);
 
-  x_free_cr_resources (f);
+  cairo_t *saved_cr = FRAME_CR_CONTEXT (f);
   FRAME_CR_CONTEXT (f) = cr;
   x_clear_area (f, 0, 0, width, height);
   expose_frame (f, 0, 0, width, height);
-  FRAME_CR_CONTEXT (f) = NULL;
+  FRAME_CR_CONTEXT (f) = saved_cr;
 }
 
 static cairo_status_t
@@ -615,11 +626,11 @@ x_cr_export_frames (Lisp_Object frames, cairo_surface_type_t surface_type)
 
   while (1)
     {
-      x_free_cr_resources (f);
+      cairo_t *saved_cr = FRAME_CR_CONTEXT (f);
       FRAME_CR_CONTEXT (f) = cr;
       x_clear_area (f, 0, 0, width, height);
       expose_frame (f, 0, 0, width, height);
-      FRAME_CR_CONTEXT (f) = NULL;
+      FRAME_CR_CONTEXT (f) = saved_cr;
 
       if (NILP (frames))
 	break;
@@ -653,35 +664,6 @@ x_cr_export_frames (Lisp_Object frames, cairo_surface_type_t surface_type)
 
 #endif	/* USE_CAIRO */
 
-static void
-x_free_cr_resources (struct frame *f)
-{
-#ifdef USE_CAIRO
-  if (f == NULL)
-    {
-      Lisp_Object rest, frame;
-      FOR_EACH_FRAME (rest, frame)
-	if (FRAME_X_P (XFRAME (frame)))
-	  x_free_cr_resources (XFRAME (frame));
-    }
-  else
-    {
-      cairo_t *cr = FRAME_CR_CONTEXT (f);
-
-      if (cr)
-	{
-	  cairo_surface_t *surface = cairo_get_target (cr);
-
-	  if (cairo_surface_get_type (surface) == CAIRO_SURFACE_TYPE_XLIB)
-	    {
-	      cairo_destroy (cr);
-	      FRAME_CR_CONTEXT (f) = NULL;
-	    }
-	}
-    }
-#endif
-}
-
 static void
 x_set_clip_rectangles (struct frame *f, GC gc, XRectangle *rectangles, int n)
 {
@@ -716,12 +698,39 @@ static void
 x_fill_rectangle (struct frame *f, GC gc, int x, int y, int width, int height)
 {
 #ifdef USE_CAIRO
+  Display *dpy = FRAME_X_DISPLAY (f);
   cairo_t *cr;
+  XGCValues xgcv;
 
   cr = x_begin_cr_clip (f, gc);
-  x_set_cr_source_with_gc_foreground (f, gc);
-  cairo_rectangle (cr, x, y, width, height);
-  cairo_fill (cr);
+  XGetGCValues (dpy, gc, GCFillStyle | GCStipple, &xgcv);
+  if (xgcv.fill_style == FillSolid
+      /* Invalid resource ID (one or more of the three most
+	 significant bits set to 1) is obtained if the GCStipple
+	 component has never been explicitly set.  It should be
+	 regarded as Pixmap of unspecified size filled with ones.  */
+      || (xgcv.stipple & ((Pixmap) 7 << (sizeof (Pixmap) * CHAR_BIT - 3))))
+    {
+      x_set_cr_source_with_gc_foreground (f, gc);
+      cairo_rectangle (cr, x, y, width, height);
+      cairo_fill (cr);
+    }
+  else
+    {
+      eassert (xgcv.fill_style == FillOpaqueStippled);
+      eassert (xgcv.stipple != None);
+      x_set_cr_source_with_gc_background (f, gc);
+      cairo_rectangle (cr, x, y, width, height);
+      cairo_fill_preserve (cr);
+
+      cairo_pattern_t *pattern = x_bitmap_stipple (f, xgcv.stipple);
+      if (pattern)
+	{
+	  x_set_cr_source_with_gc_foreground (f, gc);
+	  cairo_clip (cr);
+	  cairo_mask (cr, pattern);
+	}
+    }
   x_end_cr_clip (f);
 #else
   XFillRectangle (FRAME_X_DISPLAY (f), FRAME_X_DRAWABLE (f),
@@ -906,7 +915,7 @@ x_find_topmost_parent (struct frame *f)
 
 #define OPAQUE  0xffffffff
 
-void
+static void
 x_set_frame_alpha (struct frame *f)
 {
   struct x_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
@@ -917,7 +926,7 @@ x_set_frame_alpha (struct frame *f)
   unsigned long opac;
   Window parent;
 
-  if (dpyinfo->x_highlight_frame == f)
+  if (dpyinfo->highlight_frame == f)
     alpha = f->alpha[0];
   else
     alpha = f->alpha[1];
@@ -989,77 +998,16 @@ x_set_frame_alpha (struct frame *f)
 
 /* Start an update of frame F.  This function is installed as a hook
    for update_begin, i.e. it is called when update_begin is called.
-   This function is called prior to calls to x_update_window_begin for
+   This function is called prior to calls to gui_update_window_begin for
    each window being updated.  Currently, there is nothing to do here
    because all interesting stuff is done on a window basis.  */
 
 static void
 x_update_begin (struct frame *f)
 {
-#ifdef USE_CAIRO
-  if (FRAME_TOOLTIP_P (f) && !FRAME_VISIBLE_P (f))
-    return;
-
-  if (! FRAME_CR_SURFACE (f))
-    {
-      int width, height;
-#ifdef USE_GTK
-      if (FRAME_GTK_WIDGET (f))
-        {
-          GdkWindow *w = gtk_widget_get_window (FRAME_GTK_WIDGET (f));
-	  int scale = xg_get_scale (f);
-	  width = scale * gdk_window_get_width (w);
-	  height = scale * gdk_window_get_height (w);
-        }
-      else
-#endif
-        {
-          width = FRAME_PIXEL_WIDTH (f);
-          height = FRAME_PIXEL_HEIGHT (f);
-          if (! FRAME_EXTERNAL_TOOL_BAR (f))
-            height += FRAME_TOOL_BAR_HEIGHT (f);
-          if (! FRAME_EXTERNAL_MENU_BAR (f))
-            height += FRAME_MENU_BAR_HEIGHT (f);
-        }
-
-      if (width > 0 && height > 0)
-        {
-          block_input();
-          FRAME_CR_SURFACE (f) = cairo_image_surface_create
-            (CAIRO_FORMAT_ARGB32, width, height);
-          unblock_input();
-        }
-    }
-#endif /* USE_CAIRO */
-}
-
-/* Start update of window W.  */
-
-static void
-x_update_window_begin (struct window *w)
-{
-  struct frame *f = XFRAME (WINDOW_FRAME (w));
-  Mouse_HLInfo *hlinfo = MOUSE_HL_INFO (f);
-
-  w->output_cursor = w->cursor;
-
-  block_input ();
-
-  if (f == hlinfo->mouse_face_mouse_frame)
-    {
-      /* Don't do highlighting for mouse motion during the update.  */
-      hlinfo->mouse_face_defer = true;
-
-      /* If F needs to be redrawn, simply forget about any prior mouse
-	 highlighting.  */
-      if (FRAME_GARBAGED_P (f))
-	hlinfo->mouse_face_window = Qnil;
-    }
-
-  unblock_input ();
+  /* Nothing to do.  */
 }
 
-
 /* Draw a vertical window border from (x,y0) to (x,y1)  */
 
 static void
@@ -1139,55 +1087,6 @@ x_draw_window_divider (struct window *w, int x0, int x1, int y0, int y1)
     }
 }
 
-/* End update of window W.
-
-   Draw vertical borders between horizontally adjacent windows, and
-   display W's cursor if CURSOR_ON_P is non-zero.
-
-   MOUSE_FACE_OVERWRITTEN_P non-zero means that some row containing
-   glyphs in mouse-face were overwritten.  In that case we have to
-   make sure that the mouse-highlight is properly redrawn.
-
-   W may be a menu bar pseudo-window in case we don't have X toolkit
-   support.  Such windows don't have a cursor, so don't display it
-   here.  */
-
-static void
-x_update_window_end (struct window *w, bool cursor_on_p,
-		     bool mouse_face_overwritten_p)
-{
-  if (!w->pseudo_window_p)
-    {
-      block_input ();
-
-      if (cursor_on_p)
-	display_and_set_cursor (w, true,
-				w->output_cursor.hpos, w->output_cursor.vpos,
-				w->output_cursor.x, w->output_cursor.y);
-
-      if (draw_window_fringes (w, true))
-	{
-	  if (WINDOW_RIGHT_DIVIDER_WIDTH (w))
-	    x_draw_right_divider (w);
-	  else
-	    x_draw_vertical_border (w);
-	}
-
-      unblock_input ();
-    }
-
-  /* If a row with mouse-face was overwritten, arrange for
-     XTframe_up_to_date to redisplay the mouse highlight.  */
-  if (mouse_face_overwritten_p)
-    {
-      Mouse_HLInfo *hlinfo = MOUSE_HL_INFO (XFRAME (w->frame));
-
-      hlinfo->mouse_face_beg_row = hlinfo->mouse_face_beg_col = -1;
-      hlinfo->mouse_face_end_row = hlinfo->mouse_face_end_col = -1;
-      hlinfo->mouse_face_window = Qnil;
-    }
-}
-
 /* Show the frame back buffer.  If frame is double-buffered,
    atomically publish to the user's screen graphics updates made since
    the last call to show_back_buffer.  */
@@ -1198,6 +1097,11 @@ show_back_buffer (struct frame *f)
   if (FRAME_X_DOUBLE_BUFFERED_P (f))
     {
 #ifdef HAVE_XDBE
+#ifdef USE_CAIRO
+      cairo_t *cr = FRAME_CR_CONTEXT (f);
+      if (cr)
+	cairo_surface_flush (cairo_get_target (cr));
+#endif
       XdbeSwapInfo swap_info;
       memset (&swap_info, 0, sizeof (swap_info));
       swap_info.swap_window = FRAME_X_WINDOW (f);
@@ -1234,30 +1138,33 @@ x_update_end (struct frame *f)
   MOUSE_HL_INFO (f)->mouse_face_defer = false;
 
 #ifdef USE_CAIRO
-  if (FRAME_CR_SURFACE (f))
+  if (!FRAME_X_DOUBLE_BUFFERED_P (f))
     {
-      cairo_t *cr;
-      cairo_surface_t *surface;
-      int width, height;
-
       block_input ();
-      width = FRAME_PIXEL_WIDTH (f);
-      height = FRAME_PIXEL_HEIGHT (f);
-      if (! FRAME_EXTERNAL_TOOL_BAR (f))
-	height += FRAME_TOOL_BAR_HEIGHT (f);
-      if (! FRAME_EXTERNAL_MENU_BAR (f))
-	height += FRAME_MENU_BAR_HEIGHT (f);
-      surface = cairo_xlib_surface_create (FRAME_X_DISPLAY (f),
-					   FRAME_X_DRAWABLE (f),
-					   FRAME_DISPLAY_INFO (f)->visual,
-					   width,
-					   height);
-      cr = cairo_create (surface);
-      cairo_surface_destroy (surface);
-
-      cairo_set_source_surface (cr, FRAME_CR_SURFACE (f), 0, 0);
-      cairo_paint (cr);
-      cairo_destroy (cr);
+      cairo_surface_t *source_surface = cairo_get_target (FRAME_CR_CONTEXT (f));
+      if (source_surface)
+	{
+	  cairo_t *cr;
+	  cairo_surface_t *surface;
+	  int width, height;
+
+	  width = FRAME_PIXEL_WIDTH (f);
+	  height = FRAME_PIXEL_HEIGHT (f);
+	  if (! FRAME_EXTERNAL_TOOL_BAR (f))
+	    height += FRAME_TOOL_BAR_HEIGHT (f);
+	  if (! FRAME_EXTERNAL_MENU_BAR (f))
+	    height += FRAME_MENU_BAR_HEIGHT (f);
+	  surface = cairo_xlib_surface_create (FRAME_X_DISPLAY (f),
+					       FRAME_X_DRAWABLE (f),
+					       FRAME_X_VISUAL (f),
+					       width, height);
+	  cr = cairo_create (surface);
+	  cairo_surface_destroy (surface);
+
+	  cairo_set_source_surface (cr, source_surface, 0, 0);
+	  cairo_paint (cr);
+	  cairo_destroy (cr);
+	}
       unblock_input ();
     }
 #endif
@@ -1505,37 +1412,8 @@ x_draw_fringe_bitmap (struct window *w, struct glyph_row *row, struct draw_fring
 			    Glyph display
  ***********************************************************************/
 
-
-
-static void x_set_glyph_string_clipping (struct glyph_string *);
-static void x_set_glyph_string_gc (struct glyph_string *);
-static void x_draw_glyph_string_foreground (struct glyph_string *);
-static void x_draw_composite_glyph_string_foreground (struct glyph_string *);
-static void x_draw_glyph_string_box (struct glyph_string *);
-static void x_draw_glyph_string  (struct glyph_string *);
-static _Noreturn void x_delete_glyphs (struct frame *, int);
-static void x_compute_glyph_string_overhangs (struct glyph_string *);
-static void x_set_cursor_gc (struct glyph_string *);
-static void x_set_mode_line_face_gc (struct glyph_string *);
-static void x_set_mouse_face_gc (struct glyph_string *);
 static bool x_alloc_lighter_color (struct frame *, Display *, Colormap,
 				   unsigned long *, double, int);
-static void x_setup_relief_color (struct frame *, struct relief *,
-                                  double, int, unsigned long);
-static void x_setup_relief_colors (struct glyph_string *);
-static void x_draw_image_glyph_string (struct glyph_string *);
-static void x_draw_image_relief (struct glyph_string *);
-static void x_draw_image_foreground (struct glyph_string *);
-#ifndef USE_CAIRO
-static void x_draw_image_foreground_1 (struct glyph_string *, Pixmap);
-#endif
-static void x_clear_glyph_string_rect (struct glyph_string *, int,
-                                       int, int, int);
-static void x_draw_relief_rect (struct frame *, int, int, int, int,
-                                int, bool, bool, bool, bool, bool,
-                                XRectangle *);
-static void x_draw_box_rect (struct glyph_string *, int, int, int, int,
-                             int, bool, bool, XRectangle *);
 static void x_scroll_bar_clear (struct frame *);
 
 #ifdef GLYPH_DEBUG
@@ -1559,6 +1437,7 @@ x_set_cursor_gc (struct glyph_string *s)
       /* Cursor on non-default face: must merge.  */
       XGCValues xgcv;
       unsigned long mask;
+      Display *display = FRAME_X_DISPLAY (s->f);
 
       xgcv.background = s->f->output_data.x->cursor_pixel;
       xgcv.foreground = s->face->background;
@@ -1584,11 +1463,11 @@ x_set_cursor_gc (struct glyph_string *s)
       mask = GCForeground | GCBackground | GCGraphicsExposures;
 
       if (FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc)
-	XChangeGC (s->display, FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc,
+	XChangeGC (display, FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc,
 		   mask, &xgcv);
       else
 	FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc
-          = XCreateGC (s->display, FRAME_X_DRAWABLE (s->f), mask, &xgcv);
+          = XCreateGC (display, FRAME_X_DRAWABLE (s->f), mask, &xgcv);
 
       s->gc = FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc;
     }
@@ -1624,6 +1503,7 @@ x_set_mouse_face_gc (struct glyph_string *s)
 	 except for FONT.  */
       XGCValues xgcv;
       unsigned long mask;
+      Display *display = FRAME_X_DISPLAY (s->f);
 
       xgcv.background = s->face->background;
       xgcv.foreground = s->face->foreground;
@@ -1631,11 +1511,11 @@ x_set_mouse_face_gc (struct glyph_string *s)
       mask = GCForeground | GCBackground | GCGraphicsExposures;
 
       if (FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc)
-	XChangeGC (s->display, FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc,
+	XChangeGC (display, FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc,
 		   mask, &xgcv);
       else
 	FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc
-          = XCreateGC (s->display, FRAME_X_DRAWABLE (s->f), mask, &xgcv);
+          = XCreateGC (display, FRAME_X_DRAWABLE (s->f), mask, &xgcv);
 
       s->gc = FRAME_DISPLAY_INFO (s->f)->scratch_cursor_gc;
 
@@ -1746,13 +1626,8 @@ x_compute_glyph_string_overhangs (struct glyph_string *s)
 
       if (s->first_glyph->type == CHAR_GLYPH)
 	{
-	  unsigned *code = alloca (sizeof (unsigned) * s->nchars);
 	  struct font *font = s->font;
-	  int i;
-
-	  for (i = 0; i < s->nchars; i++)
-	    code[i] = (s->char2b[i].byte1 << 8) | s->char2b[i].byte2;
-	  font->driver->text_extents (font, code, s->nchars, &metrics);
+	  font->driver->text_extents (font, s->char2b, s->nchars, &metrics);
 	}
       else
 	{
@@ -1777,11 +1652,12 @@ x_compute_glyph_string_overhangs (struct glyph_string *s)
 static void
 x_clear_glyph_string_rect (struct glyph_string *s, int x, int y, int w, int h)
 {
+  Display *display = FRAME_X_DISPLAY (s->f);
   XGCValues xgcv;
-  XGetGCValues (s->display, s->gc, GCForeground | GCBackground, &xgcv);
-  XSetForeground (s->display, s->gc, xgcv.background);
+  XGetGCValues (display, s->gc, GCForeground | GCBackground, &xgcv);
+  XSetForeground (display, s->gc, xgcv.background);
   x_fill_rectangle (s->f, s->gc, x, y, w, h);
-  XSetForeground (s->display, s->gc, xgcv.foreground);
+  XSetForeground (display, s->gc, xgcv.foreground);
 }
 
 
@@ -1802,13 +1678,15 @@ x_draw_glyph_string_background (struct glyph_string *s, bool force_p)
 
       if (s->stippled_p)
 	{
+          Display *display = FRAME_X_DISPLAY (s->f);
+
 	  /* Fill background with a stipple pattern.  */
-	  XSetFillStyle (s->display, s->gc, FillOpaqueStippled);
+	  XSetFillStyle (display, s->gc, FillOpaqueStippled);
 	  x_fill_rectangle (s->f, s->gc, s->x,
 			  s->y + box_line_width,
 			  s->background_width,
 			  s->height - 2 * box_line_width);
-	  XSetFillStyle (s->display, s->gc, FillSolid);
+	  XSetFillStyle (display, s->gc, FillSolid);
 	  s->background_filled_p = true;
 	}
       else if (FONT_HEIGHT (s->font) < s->height - 2 * box_line_width
@@ -1975,7 +1853,7 @@ static void
 x_draw_glyphless_glyph_string_foreground (struct glyph_string *s)
 {
   struct glyph *glyph = s->first_glyph;
-  XChar2b char2b[8];
+  unsigned char2b[8];
   int x, i, j;
 
   /* If first glyph of S has a left box line, start drawing the text
@@ -2026,14 +1904,10 @@ x_draw_glyphless_glyph_string_foreground (struct glyph_string *s)
       if (str)
 	{
 	  int upper_len = (len + 1) / 2;
-	  unsigned code;
 
 	  /* It is assured that all LEN characters in STR is ASCII.  */
 	  for (j = 0; j < len; j++)
-	    {
-	      code = s->font->driver->encode_char (s->font, str[j]);
-	      STORE_XCHAR2B (char2b + j, code >> 8, code & 0xFF);
-	    }
+            char2b[j] = s->font->driver->encode_char (s->font, str[j]) & 0xFFFF;
 	  s->font->driver->draw (s, 0, upper_len,
 				 x + glyph->slice.glyphless.upper_xoff,
 				 s->ybase + glyph->slice.glyphless.upper_yoff,
@@ -2354,17 +2228,15 @@ x_query_colors (struct frame *f, XColor *colors, int ncolors)
   XQueryColors (FRAME_X_DISPLAY (f), FRAME_X_COLORMAP (f), colors, ncolors);
 }
 
+/* Store F's background color into *BGCOLOR.  */
 
-/* On frame F, translate pixel color to RGB values for the color in
-   COLOR.  Use cached information, if available.  */
-
-void
-x_query_color (struct frame *f, XColor *color)
+static void
+x_query_frame_background_color (struct frame *f, XColor *bgcolor)
 {
-  x_query_colors (f, color, 1);
+  bgcolor->pixel = FRAME_BACKGROUND_PIXEL (f);
+  x_query_colors (f, bgcolor, 1);
 }
 
-
 /* On frame F, translate the color name to RGB values.  Use cached
    information, if possible.
 
@@ -2528,7 +2400,7 @@ x_copy_color (struct frame *f, unsigned long pixel)
   color.pixel = pixel;
   block_input ();
   /* The color could still be found in the color_cells array.  */
-  x_query_color (f, &color);
+  x_query_colors (f, &color, 1);
   XAllocColor (FRAME_X_DISPLAY (f), FRAME_X_COLORMAP (f), &color);
   unblock_input ();
 #ifdef DEBUG_X_COLORS
@@ -2569,7 +2441,7 @@ x_alloc_lighter_color (struct frame *f, Display *display, Colormap cmap,
 
   /* Get RGB color values.  */
   color.pixel = *pixel;
-  x_query_color (f, &color);
+  x_query_colors (f, &color, 1);
 
   /* Change RGB values by specified FACTOR.  Avoid overflow!  */
   eassert (factor >= 0);
@@ -2698,7 +2570,7 @@ x_setup_relief_colors (struct glyph_string *s)
       XGCValues xgcv;
 
       /* Get the background color of the face.  */
-      XGetGCValues (s->display, s->gc, GCBackground, &xgcv);
+      XGetGCValues (FRAME_X_DISPLAY (s->f), s->gc, GCBackground, &xgcv);
       color = xgcv.background;
     }
 
@@ -2908,10 +2780,11 @@ x_draw_box_rect (struct glyph_string *s,
 		 int left_x, int top_y, int right_x, int bottom_y, int width,
 		 bool left_p, bool right_p, XRectangle *clip_rect)
 {
+  Display *display = FRAME_X_DISPLAY (s->f);
   XGCValues xgcv;
 
-  XGetGCValues (s->display, s->gc, GCForeground, &xgcv);
-  XSetForeground (s->display, s->gc, s->face->box_color);
+  XGetGCValues (display, s->gc, GCForeground, &xgcv);
+  XSetForeground (display, s->gc, s->face->box_color);
   x_set_clip_rectangles (s->f, s->gc, clip_rect, 1);
 
   /* Top.  */
@@ -2932,7 +2805,7 @@ x_draw_box_rect (struct glyph_string *s,
     x_fill_rectangle (s->f, s->gc,
 		    right_x - width + 1, top_y, width, bottom_y - top_y + 1);
 
-  XSetForeground (s->display, s->gc, xgcv.foreground);
+  XSetForeground (display, s->gc, xgcv.foreground);
   x_reset_clip_rectangles (s->f, s->gc);
 }
 
@@ -2989,11 +2862,13 @@ x_draw_glyph_string_box (struct glyph_string *s)
 }
 
 
+#ifndef USE_CAIRO
 static void
 x_composite_image (struct glyph_string *s, Pixmap dest,
                    int srcX, int srcY, int dstX, int dstY,
                    int width, int height)
 {
+  Display *display = FRAME_X_DISPLAY (s->f);
 #ifdef HAVE_XRENDER
   if (s->img->picture)
     {
@@ -3003,31 +2878,29 @@ x_composite_image (struct glyph_string *s, Pixmap dest,
 
       /* FIXME: Should we do this each time or would it make sense to
          store destination in the frame struct?  */
-      default_format = XRenderFindVisualFormat (s->display,
-                                                DefaultVisual (s->display, 0));
-      destination = XRenderCreatePicture (s->display, dest,
+      default_format = XRenderFindVisualFormat (display,
+                                                DefaultVisual (display, 0));
+      destination = XRenderCreatePicture (display, dest,
                                           default_format, 0, &attr);
 
-      /* FIXME: It may make sense to use PictOpSrc instead of
-         PictOpOver, as I don't know if we care about alpha values too
-         much here.  */
-      XRenderComposite (s->display, PictOpOver,
+      XRenderComposite (display, PictOpSrc,
                         s->img->picture, s->img->mask_picture, destination,
                         srcX, srcY,
                         srcX, srcY,
                         dstX, dstY,
                         width, height);
 
-      XRenderFreePicture (s->display, destination);
+      XRenderFreePicture (display, destination);
       return;
     }
 #endif
 
-  XCopyArea (s->display, s->img->pixmap,
+  XCopyArea (display, s->img->pixmap,
 	     dest, s->gc,
 	     srcX, srcY,
 	     width, height, dstX, dstY);
 }
+#endif	/* !USE_CAIRO */
 
 
 /* Draw foreground of image glyph string S.  */
@@ -3097,14 +2970,14 @@ x_draw_image_foreground (struct glyph_string *s)
 	  xgcv.clip_x_origin = x;
 	  xgcv.clip_y_origin = y;
 	  xgcv.function = GXcopy;
-	  XChangeGC (s->display, s->gc, mask, &xgcv);
+	  XChangeGC (FRAME_X_DISPLAY (s->f), s->gc, mask, &xgcv);
 
 	  get_glyph_string_clip_rect (s, &clip_rect);
 	  image_rect.x = x;
 	  image_rect.y = y;
 	  image_rect.width = s->slice.width;
 	  image_rect.height = s->slice.height;
-	  if (x_intersect_rectangles (&clip_rect, &image_rect, &r))
+	  if (gui_intersect_rectangles (&clip_rect, &image_rect, &r))
             x_composite_image (s, FRAME_X_DRAWABLE (s->f),
 			       s->slice.x + r.x - x, s->slice.y + r.y - y,
                                r.x, r.y, r.width, r.height);
@@ -3118,7 +2991,7 @@ x_draw_image_foreground (struct glyph_string *s)
 	  image_rect.y = y;
 	  image_rect.width = s->slice.width;
 	  image_rect.height = s->slice.height;
-	  if (x_intersect_rectangles (&clip_rect, &image_rect, &r))
+	  if (gui_intersect_rectangles (&clip_rect, &image_rect, &r))
             x_composite_image (s, FRAME_X_DRAWABLE (s->f), s->slice.x + r.x - x, s->slice.y + r.y - y,
                                r.x, r.y, r.width, r.height);
 
@@ -3246,6 +3119,8 @@ x_draw_image_foreground_1 (struct glyph_string *s, Pixmap pixmap)
 
   if (s->img->pixmap)
     {
+      Display *display = FRAME_X_DISPLAY (s->f);
+
       if (s->img->mask)
 	{
 	  /* We can't set both a clip mask and use XSetClipRectangles
@@ -3261,16 +3136,16 @@ x_draw_image_foreground_1 (struct glyph_string *s, Pixmap pixmap)
 	  xgcv.clip_x_origin = x - s->slice.x;
 	  xgcv.clip_y_origin = y - s->slice.y;
 	  xgcv.function = GXcopy;
-	  XChangeGC (s->display, s->gc, mask, &xgcv);
+	  XChangeGC (display, s->gc, mask, &xgcv);
 
-	  XCopyArea (s->display, s->img->pixmap, pixmap, s->gc,
+	  XCopyArea (display, s->img->pixmap, pixmap, s->gc,
 		     s->slice.x, s->slice.y,
 		     s->slice.width, s->slice.height, x, y);
-	  XSetClipMask (s->display, s->gc, None);
+	  XSetClipMask (display, s->gc, None);
 	}
       else
 	{
-	  XCopyArea (s->display, s->img->pixmap, pixmap, s->gc,
+	  XCopyArea (display, s->img->pixmap, pixmap, s->gc,
 		     s->slice.x, s->slice.y,
 		     s->slice.width, s->slice.height, x, y);
 
@@ -3305,10 +3180,12 @@ x_draw_glyph_string_bg_rect (struct glyph_string *s, int x, int y, int w, int h)
 {
   if (s->stippled_p)
     {
+      Display *display = FRAME_X_DISPLAY (s->f);
+
       /* Fill background with a stipple pattern.  */
-      XSetFillStyle (s->display, s->gc, FillOpaqueStippled);
+      XSetFillStyle (display, s->gc, FillOpaqueStippled);
       x_fill_rectangle (s->f, s->gc, x, y, w, h);
-      XSetFillStyle (s->display, s->gc, FillSolid);
+      XSetFillStyle (display, s->gc, FillSolid);
     }
   else
     x_clear_glyph_string_rect (s, x, y, w, h);
@@ -3335,7 +3212,10 @@ x_draw_image_glyph_string (struct glyph_string *s)
   int box_line_hwidth = eabs (s->face->box_line_width);
   int box_line_vwidth = max (s->face->box_line_width, 0);
   int height;
+#ifndef USE_CAIRO
+  Display *display = FRAME_X_DISPLAY (s->f);
   Pixmap pixmap = None;
+#endif
 
   height = s->height;
   if (s->slice.y == 0)
@@ -3364,34 +3244,34 @@ x_draw_image_glyph_string (struct glyph_string *s)
 	  int depth = DefaultDepthOfScreen (screen);
 
 	  /* Create a pixmap as large as the glyph string.  */
-          pixmap = XCreatePixmap (s->display, FRAME_X_DRAWABLE (s->f),
+          pixmap = XCreatePixmap (display, FRAME_X_DRAWABLE (s->f),
 				  s->background_width,
 				  s->height, depth);
 
 	  /* Don't clip in the following because we're working on the
 	     pixmap.  */
-	  XSetClipMask (s->display, s->gc, None);
+	  XSetClipMask (display, s->gc, None);
 
 	  /* Fill the pixmap with the background color/stipple.  */
 	  if (s->stippled_p)
 	    {
 	      /* Fill background with a stipple pattern.  */
-	      XSetFillStyle (s->display, s->gc, FillOpaqueStippled);
-	      XSetTSOrigin (s->display, s->gc, - s->x, - s->y);
-	      XFillRectangle (s->display, pixmap, s->gc,
+	      XSetFillStyle (display, s->gc, FillOpaqueStippled);
+	      XSetTSOrigin (display, s->gc, - s->x, - s->y);
+	      XFillRectangle (display, pixmap, s->gc,
 			      0, 0, s->background_width, s->height);
-	      XSetFillStyle (s->display, s->gc, FillSolid);
-	      XSetTSOrigin (s->display, s->gc, 0, 0);
+	      XSetFillStyle (display, s->gc, FillSolid);
+	      XSetTSOrigin (display, s->gc, 0, 0);
 	    }
 	  else
 	    {
 	      XGCValues xgcv;
-	      XGetGCValues (s->display, s->gc, GCForeground | GCBackground,
+	      XGetGCValues (display, s->gc, GCForeground | GCBackground,
 			    &xgcv);
-	      XSetForeground (s->display, s->gc, xgcv.background);
-	      XFillRectangle (s->display, pixmap, s->gc,
+	      XSetForeground (display, s->gc, xgcv.background);
+	      XFillRectangle (display, pixmap, s->gc,
 			      0, 0, s->background_width, s->height);
-	      XSetForeground (s->display, s->gc, xgcv.foreground);
+	      XSetForeground (display, s->gc, xgcv.foreground);
 	    }
 	}
       else
@@ -3423,9 +3303,9 @@ x_draw_image_glyph_string (struct glyph_string *s)
     {
       x_draw_image_foreground_1 (s, pixmap);
       x_set_glyph_string_clipping (s);
-      XCopyArea (s->display, pixmap, FRAME_X_DRAWABLE (s->f), s->gc,
+      XCopyArea (display, pixmap, FRAME_X_DRAWABLE (s->f), s->gc,
 		 0, 0, s->background_width, s->height, s->x, s->y);
-      XFreePixmap (s->display, pixmap);
+      XFreePixmap (display, pixmap);
     }
   else
 #endif	/* ! USE_CAIRO */
@@ -3486,6 +3366,7 @@ x_draw_stretch_glyph_string (struct glyph_string *s)
 	{
 	  int y = s->y;
 	  int w = background_width - width, h = s->height;
+          Display *display = FRAME_X_DISPLAY (s->f);
 	  XRectangle r;
 	  GC gc;
 
@@ -3508,17 +3389,17 @@ x_draw_stretch_glyph_string (struct glyph_string *s)
 	  if (s->face->stipple)
 	    {
 	      /* Fill background with a stipple pattern.  */
-	      XSetFillStyle (s->display, gc, FillOpaqueStippled);
+	      XSetFillStyle (display, gc, FillOpaqueStippled);
 	      x_fill_rectangle (s->f, gc, x, y, w, h);
-	      XSetFillStyle (s->display, gc, FillSolid);
+	      XSetFillStyle (display, gc, FillSolid);
 	    }
 	  else
 	    {
 	      XGCValues xgcv;
-	      XGetGCValues (s->display, gc, GCForeground | GCBackground, &xgcv);
-	      XSetForeground (s->display, gc, xgcv.background);
+	      XGetGCValues (display, gc, GCForeground | GCBackground, &xgcv);
+	      XSetForeground (display, gc, xgcv.background);
 	      x_fill_rectangle (s->f, gc, x, y, w, h);
-	      XSetForeground (s->display, gc, xgcv.foreground);
+	      XSetForeground (display, gc, xgcv.foreground);
 	    }
 
 	  x_reset_clip_rectangles (s->f, gc);
@@ -3573,10 +3454,12 @@ x_get_scale_factor(Display *disp, int *scale_x, int *scale_y)
 static void
 x_draw_underwave (struct glyph_string *s)
 {
+  Display *display = FRAME_X_DISPLAY (s->f);
+
   /* Adjust for scale/HiDPI.  */
   int scale_x, scale_y;
 
-  x_get_scale_factor (s->display, &scale_x, &scale_y);
+  x_get_scale_factor (display, &scale_x, &scale_y);
 
   int wave_height = 3 * scale_y, wave_length = 2 * scale_x;
 
@@ -3603,10 +3486,10 @@ x_draw_underwave (struct glyph_string *s)
   wave_clip.height = wave_height;
   get_glyph_string_clip_rect (s, &string_clip);
 
-  if (!x_intersect_rectangles (&wave_clip, &string_clip, &final_clip))
+  if (!gui_intersect_rectangles (&wave_clip, &string_clip, &final_clip))
     return;
 
-  XSetClipRectangles (s->display, s->gc, 0, 0, &final_clip, 1, Unsorted);
+  XSetClipRectangles (display, s->gc, 0, 0, &final_clip, 1, Unsorted);
 
   /* Draw the waves */
 
@@ -3625,16 +3508,16 @@ x_draw_underwave (struct glyph_string *s)
 
   while (x1 <= xmax)
     {
-      XSetLineAttributes (s->display, s->gc, thickness, LineSolid, CapButt,
+      XSetLineAttributes (display, s->gc, thickness, LineSolid, CapButt,
                           JoinRound);
-      XDrawLine (s->display, FRAME_X_DRAWABLE (s->f), s->gc, x1, y1, x2, y2);
+      XDrawLine (display, FRAME_X_DRAWABLE (s->f), s->gc, x1, y1, x2, y2);
       x1  = x2, y1 = y2;
       x2 += dx, y2 = y0 + odd*dy;
       odd = !odd;
     }
 
   /* Restore previous clipping rectangle(s) */
-  XSetClipRectangles (s->display, s->gc, 0, 0, s->clip, s->num_clips, Unsorted);
+  XSetClipRectangles (display, s->gc, 0, 0, s->clip, s->num_clips, Unsorted);
 #endif	/* not USE_CAIRO */
 }
 
@@ -3751,11 +3634,12 @@ x_draw_glyph_string (struct glyph_string *s)
                 x_draw_underwave (s);
               else
                 {
+                  Display *display = FRAME_X_DISPLAY (s->f);
                   XGCValues xgcv;
-                  XGetGCValues (s->display, s->gc, GCForeground, &xgcv);
-                  XSetForeground (s->display, s->gc, s->face->underline_color);
+                  XGetGCValues (display, s->gc, GCForeground, &xgcv);
+                  XSetForeground (display, s->gc, s->face->underline_color);
                   x_draw_underwave (s);
-                  XSetForeground (s->display, s->gc, xgcv.foreground);
+                  XSetForeground (display, s->gc, xgcv.foreground);
                 }
             }
           else if (s->face->underline_type == FACE_UNDER_LINE)
@@ -3835,12 +3719,13 @@ x_draw_glyph_string (struct glyph_string *s)
                                 s->x, y, s->width, thickness);
               else
                 {
+                  Display *display = FRAME_X_DISPLAY (s->f);
                   XGCValues xgcv;
-                  XGetGCValues (s->display, s->gc, GCForeground, &xgcv);
-                  XSetForeground (s->display, s->gc, s->face->underline_color);
+                  XGetGCValues (display, s->gc, GCForeground, &xgcv);
+                  XSetForeground (display, s->gc, s->face->underline_color);
                   x_fill_rectangle (s->f, s->gc,
                                   s->x, y, s->width, thickness);
-                  XSetForeground (s->display, s->gc, xgcv.foreground);
+                  XSetForeground (display, s->gc, xgcv.foreground);
                 }
             }
         }
@@ -3854,12 +3739,13 @@ x_draw_glyph_string (struct glyph_string *s)
 			    s->width, h);
 	  else
 	    {
+              Display *display = FRAME_X_DISPLAY (s->f);
 	      XGCValues xgcv;
-	      XGetGCValues (s->display, s->gc, GCForeground, &xgcv);
-	      XSetForeground (s->display, s->gc, s->face->overline_color);
+	      XGetGCValues (display, s->gc, GCForeground, &xgcv);
+	      XSetForeground (display, s->gc, s->face->overline_color);
 	      x_fill_rectangle (s->f, s->gc, s->x, s->y + dy,
 			      s->width, h);
-	      XSetForeground (s->display, s->gc, xgcv.foreground);
+	      XSetForeground (display, s->gc, xgcv.foreground);
 	    }
 	}
 
@@ -3883,12 +3769,13 @@ x_draw_glyph_string (struct glyph_string *s)
 			    s->width, h);
 	  else
 	    {
+              Display *display = FRAME_X_DISPLAY (s->f);
 	      XGCValues xgcv;
-	      XGetGCValues (s->display, s->gc, GCForeground, &xgcv);
-	      XSetForeground (s->display, s->gc, s->face->strike_through_color);
+	      XGetGCValues (display, s->gc, GCForeground, &xgcv);
+	      XSetForeground (display, s->gc, s->face->strike_through_color);
 	      x_fill_rectangle (s->f, s->gc, s->x, glyph_y + dy,
 			      s->width, h);
-	      XSetForeground (s->display, s->gc, xgcv.foreground);
+	      XSetForeground (display, s->gc, xgcv.foreground);
 	    }
 	}
 
@@ -3971,7 +3858,7 @@ x_shift_glyphs_for_insert (struct frame *f, int x, int y, int width, int height,
    for X frames.  */
 
 static void
-x_delete_glyphs (struct frame *f, register int n)
+x_delete_glyphs (struct frame *f, int n)
 {
   emacs_abort ();
 }
@@ -4333,11 +4220,26 @@ x_scroll_run (struct window *w, struct run *run)
 
   block_input ();
 
-  /* Cursor off.  Will be switched on again in x_update_window_end.  */
-  x_clear_cursor (w);
+  /* Cursor off.  Will be switched on again in gui_update_window_end.  */
+  gui_clear_cursor (w);
 
 #ifdef USE_CAIRO
-  if (FRAME_CR_CONTEXT (f))
+  if (FRAME_X_DOUBLE_BUFFERED_P (f))
+    {
+      cairo_t *cr = FRAME_CR_CONTEXT (f);
+      if (cr)
+	cairo_surface_flush (cairo_get_target (cr));
+      XCopyArea (FRAME_X_DISPLAY (f),
+		 FRAME_X_DRAWABLE (f), FRAME_X_DRAWABLE (f),
+		 f->output_data.x->normal_gc,
+		 x, from_y,
+		 width, height,
+		 x, to_y);
+      if (cr)
+	cairo_surface_mark_dirty_rectangle (cairo_get_target (cr),
+					    x, to_y, width, height);
+    }
+  else if (FRAME_CR_CONTEXT (f))
     {
       cairo_surface_t *s = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,
 						       width, height);
@@ -4379,7 +4281,7 @@ x_scroll_run (struct window *w, struct run *run)
 
 
 static void
-frame_highlight (struct frame *f)
+x_frame_highlight (struct frame *f)
 {
   /* We used to only do this if Vx_no_window_manager was non-nil, but
      the ICCCM (section 4.1.6) says that the window's border pixmap
@@ -4395,12 +4297,12 @@ frame_highlight (struct frame *f)
 		    f->output_data.x->border_pixel);
   x_uncatch_errors ();
   unblock_input ();
-  x_update_cursor (f, true);
+  gui_update_cursor (f, true);
   x_set_frame_alpha (f);
 }
 
 static void
-frame_unhighlight (struct frame *f)
+x_frame_unhighlight (struct frame *f)
 {
   /* We used to only do this if Vx_no_window_manager was non-nil, but
      the ICCCM (section 4.1.6) says that the window's border pixmap
@@ -4413,7 +4315,7 @@ frame_unhighlight (struct frame *f)
 			  f->output_data.x->border_tile);
   x_uncatch_errors ();
   unblock_input ();
-  x_update_cursor (f, true);
+  gui_update_cursor (f, true);
   x_set_frame_alpha (f);
 }
 
@@ -4745,29 +4647,29 @@ XTframe_rehighlight (struct frame *frame)
 static void
 x_frame_rehighlight (struct x_display_info *dpyinfo)
 {
-  struct frame *old_highlight = dpyinfo->x_highlight_frame;
+  struct frame *old_highlight = dpyinfo->highlight_frame;
 
   if (dpyinfo->x_focus_frame)
     {
-      dpyinfo->x_highlight_frame
+      dpyinfo->highlight_frame
 	= ((FRAMEP (FRAME_FOCUS_FRAME (dpyinfo->x_focus_frame)))
 	   ? XFRAME (FRAME_FOCUS_FRAME (dpyinfo->x_focus_frame))
 	   : dpyinfo->x_focus_frame);
-      if (! FRAME_LIVE_P (dpyinfo->x_highlight_frame))
+      if (! FRAME_LIVE_P (dpyinfo->highlight_frame))
 	{
 	  fset_focus_frame (dpyinfo->x_focus_frame, Qnil);
-	  dpyinfo->x_highlight_frame = dpyinfo->x_focus_frame;
+	  dpyinfo->highlight_frame = dpyinfo->x_focus_frame;
 	}
     }
   else
-    dpyinfo->x_highlight_frame = 0;
+    dpyinfo->highlight_frame = 0;
 
-  if (dpyinfo->x_highlight_frame != old_highlight)
+  if (dpyinfo->highlight_frame != old_highlight)
     {
       if (old_highlight)
-	frame_unhighlight (old_highlight);
-      if (dpyinfo->x_highlight_frame)
-	frame_highlight (dpyinfo->x_highlight_frame);
+	x_frame_unhighlight (old_highlight);
+      if (dpyinfo->highlight_frame)
+	x_frame_highlight (dpyinfo->highlight_frame);
     }
 }
 
@@ -4950,7 +4852,7 @@ x_emacs_to_x_modifiers (struct x_display_info *dpyinfo, intmax_t state)
 /* Convert a keysym to its name.  */
 
 char *
-x_get_keysym_name (int keysym)
+get_keysym_name (int keysym)
 {
   char *value;
 
@@ -4987,9 +4889,9 @@ x_get_keysym_name (int keysym)
    the mouse.  */
 
 static Lisp_Object
-construct_mouse_click (struct input_event *result,
-		       const XButtonEvent *event,
-		       struct frame *f)
+x_construct_mouse_click (struct input_event *result,
+                         const XButtonEvent *event,
+                         struct frame *f)
 {
   /* Make the event type NO_EVENT; we'll change that when we decide
      otherwise.  */
@@ -5018,7 +4920,7 @@ construct_mouse_click (struct input_event *result,
    another motion event, so we can check again the next time it moves.  */
 
 static bool
-note_mouse_movement (struct frame *frame, const XMotionEvent *event)
+x_note_mouse_movement (struct frame *frame, const XMotionEvent *event)
 {
   XRectangle *r;
   struct x_display_info *dpyinfo;
@@ -5156,7 +5058,7 @@ XTmouse_position (struct frame **fp, int insist, Lisp_Object *bar_window,
 
 	x_catch_errors (FRAME_X_DISPLAY (*fp));
 
-	if (x_mouse_grabbed (dpyinfo))
+	if (gui_mouse_grabbed (dpyinfo))
 	  {
 	    /* If mouse was grabbed on a frame, give coords for that frame
 	       even if the mouse is now outside it.  */
@@ -7695,7 +7597,7 @@ x_net_wm_state (struct frame *f, Window window)
   Lisp_Object lval = Qnil;
   bool sticky = false;
 
-  get_current_wm_state (f, window, &value, &sticky);
+  x_get_current_wm_state (f, window, &value, &sticky);
 
   switch (value)
     {
@@ -7917,12 +7819,14 @@ handle_one_xevent (struct x_display_info *dpyinfo,
                reply with "Next" if we received "Page", but we
                currently never do because we are interested in
                images, only, which should have 1 page.  */
-            Pixmap pixmap = (Pixmap) event->xclient.data.l[1];
 	    f = x_window_to_frame (dpyinfo, event->xclient.window);
 	    if (!f)
 	      goto OTHER;
+#ifndef USE_CAIRO
+            Pixmap pixmap = (Pixmap) event->xclient.data.l[1];
             x_kill_gs_process (pixmap, f);
             expose_frame (f, 0, 0, 0, 0);
+#endif	/* !USE_CAIRO */
 	    goto done;
           }
 
@@ -8184,7 +8088,7 @@ handle_one_xevent (struct x_display_info *dpyinfo,
       if (event->xunmap.window == tip_window)
         {
           tip_window = None;
-          x_redo_mouse_highlight (dpyinfo);
+          gui_redo_mouse_highlight (dpyinfo);
         }
 
       f = x_top_window_to_frame (dpyinfo, event->xunmap.window);
@@ -8314,7 +8218,7 @@ handle_one_xevent (struct x_display_info *dpyinfo,
              fit in 81 bytes.  So, we must prepare sufficient
              bytes for copy_buffer.  513 bytes (256 chars for
              two-byte character set) seems to be a fairly good
-             approximation.  -- 2000.8.10 handa@etl.go.jp  */
+             approximation.  -- 2000.8.10 handa@gnu.org  */
           unsigned char copy_buffer[513];
           unsigned char *copy_bufptr = copy_buffer;
           int copy_bufsiz = sizeof (copy_buffer);
@@ -8619,12 +8523,12 @@ handle_one_xevent (struct x_display_info *dpyinfo,
       /* EnterNotify counts as mouse movement,
 	 so update things that depend on mouse position.  */
       if (f && !f->output_data.x->hourglass_p)
-	note_mouse_movement (f, &event->xmotion);
+	x_note_mouse_movement (f, &event->xmotion);
 #ifdef USE_GTK
       /* We may get an EnterNotify on the buttons in the toolbar.  In that
          case we moved out of any highlighted area and need to note this.  */
       if (!f && dpyinfo->last_mouse_glyph_frame)
-        note_mouse_movement (dpyinfo->last_mouse_glyph_frame, &event->xmotion);
+        x_note_mouse_movement (dpyinfo->last_mouse_glyph_frame, &event->xmotion);
 #endif
       goto OTHER;
 
@@ -8657,7 +8561,7 @@ handle_one_xevent (struct x_display_info *dpyinfo,
 #ifdef USE_GTK
       /* See comment in EnterNotify above */
       else if (dpyinfo->last_mouse_glyph_frame)
-        note_mouse_movement (dpyinfo->last_mouse_glyph_frame, &event->xmotion);
+        x_note_mouse_movement (dpyinfo->last_mouse_glyph_frame, &event->xmotion);
 #endif
       goto OTHER;
 
@@ -8671,7 +8575,7 @@ handle_one_xevent (struct x_display_info *dpyinfo,
         previous_help_echo_string = help_echo_string;
         help_echo_string = Qnil;
 
-	f = (x_mouse_grabbed (dpyinfo) ? dpyinfo->last_mouse_frame
+	f = (gui_mouse_grabbed (dpyinfo) ? dpyinfo->last_mouse_frame
 	     : x_window_to_frame (dpyinfo, event->xmotion.window));
 
         if (hlinfo->mouse_face_hidden)
@@ -8726,7 +8630,7 @@ handle_one_xevent (struct x_display_info *dpyinfo,
 		last_mouse_window = window;
 	      }
 
-            if (!note_mouse_movement (f, &event->xmotion))
+            if (!x_note_mouse_movement (f, &event->xmotion))
 	      help_echo_string = previous_help_echo_string;
           }
         else
@@ -8795,7 +8699,9 @@ handle_one_xevent (struct x_display_info *dpyinfo,
         font_drop_xrender_surfaces (f);
       unblock_input ();
 #ifdef USE_CAIRO
-      if (f) x_cr_destroy_surface (f);
+      if (f)
+	x_cr_update_surface_desired_size (f, configureEvent.xconfigure.width,
+					  configureEvent.xconfigure.height);
 #endif
 #ifdef USE_GTK
       if (!f
@@ -8809,7 +8715,8 @@ handle_one_xevent (struct x_display_info *dpyinfo,
           xg_frame_resized (f, configureEvent.xconfigure.width,
                             configureEvent.xconfigure.height);
 #ifdef USE_CAIRO
-          x_cr_destroy_surface (f);
+	  x_cr_update_surface_desired_size (f, configureEvent.xconfigure.width,
+					    configureEvent.xconfigure.height);
 #endif
           f = 0;
         }
@@ -8918,7 +8825,7 @@ handle_one_xevent (struct x_display_info *dpyinfo,
 	dpyinfo->last_mouse_glyph_frame = NULL;
 	x_display_set_last_user_time (dpyinfo, event->xbutton.time);
 
-	if (x_mouse_grabbed (dpyinfo))
+	if (gui_mouse_grabbed (dpyinfo))
 	  f = dpyinfo->last_mouse_frame;
 	else
 	  {
@@ -8934,7 +8841,7 @@ handle_one_xevent (struct x_display_info *dpyinfo,
 		   into a parent frame with the child frame selected and
 		   `no-accept-focus' is not set, select the clicked
 		   frame.  */
-		struct frame *hf = dpyinfo->x_highlight_frame;
+		struct frame *hf = dpyinfo->highlight_frame;
 
 		if (FRAME_PARENT_FRAME (f) || (hf && frame_ancestor_p (f, hf)))
 		  {
@@ -8984,13 +8891,13 @@ handle_one_xevent (struct x_display_info *dpyinfo,
                           && event->xbutton.time > ignore_next_mouse_click_timeout)
                         {
                           ignore_next_mouse_click_timeout = 0;
-                          construct_mouse_click (&inev.ie, &event->xbutton, f);
+                          x_construct_mouse_click (&inev.ie, &event->xbutton, f);
                         }
                       if (event->type == ButtonRelease)
                         ignore_next_mouse_click_timeout = 0;
                     }
                   else
-                    construct_mouse_click (&inev.ie, &event->xbutton, f);
+                    x_construct_mouse_click (&inev.ie, &event->xbutton, f);
                 }
             if (FRAME_X_EMBEDDED_P (f))
               xembed_send_message (f, event->xbutton.time,
@@ -9467,7 +9374,7 @@ x_draw_bar_cursor (struct window *w, struct glyph_row *row, int width, enum text
 /* RIF: Define cursor CURSOR on frame F.  */
 
 static void
-x_define_frame_cursor (struct frame *f, Cursor cursor)
+x_define_frame_cursor (struct frame *f, Emacs_Cursor cursor)
 {
   if (!f->pointer_invisible
       && f->output_data.x->current_cursor != cursor)
@@ -9551,7 +9458,7 @@ x_draw_window_cursor (struct window *w, struct glyph_row *glyph_row, int x,
 
 /* Make the x-window of frame F use the gnu icon bitmap.  */
 
-bool
+static bool
 x_bitmap_icon (struct frame *f, Lisp_Object file)
 {
   ptrdiff_t bitmap_id;
@@ -9561,7 +9468,7 @@ x_bitmap_icon (struct frame *f, Lisp_Object file)
 
   /* Free up our existing icon bitmap and mask if any.  */
   if (f->output_data.x->icon_bitmap > 0)
-    x_destroy_bitmap (f, f->output_data.x->icon_bitmap);
+    image_destroy_bitmap (f, f->output_data.x->icon_bitmap);
   f->output_data.x->icon_bitmap = 0;
 
   if (STRINGP (file))
@@ -9572,7 +9479,7 @@ x_bitmap_icon (struct frame *f, Lisp_Object file)
       if (xg_set_icon (f, file))
 	return false;
 #endif /* USE_GTK */
-      bitmap_id = x_create_bitmap_from_file (f, file);
+      bitmap_id = image_create_bitmap_from_file (f, file);
       x_create_bitmap_mask (f, bitmap_id);
     }
   else
@@ -9602,8 +9509,10 @@ x_bitmap_icon (struct frame *f, Lisp_Object file)
 	  /* If all else fails, use the (black and white) xbm image. */
 	  if (rc == -1)
 	    {
-	      rc = x_create_bitmap_from_data (f, (char *) gnu_xbm_bits,
-					      gnu_xbm_width, gnu_xbm_height);
+              rc = image_create_bitmap_from_data (f,
+                                                  (char *) gnu_xbm_bits,
+                                                  gnu_xbm_width,
+                                                  gnu_xbm_height);
 	      if (rc == -1)
 		return true;
 
@@ -9616,7 +9525,7 @@ x_bitmap_icon (struct frame *f, Lisp_Object file)
 	 this increments the ref-count one extra time.
 	 As a result, the GNU bitmap and mask are never freed.
 	 That way, we don't have to worry about allocating it again.  */
-      x_reference_bitmap (f, FRAME_DISPLAY_INFO (f)->icon_bitmap_id);
+      image_reference_bitmap (f, FRAME_DISPLAY_INFO (f)->icon_bitmap_id);
 
       bitmap_id = FRAME_DISPLAY_INFO (f)->icon_bitmap_id;
     }
@@ -9647,7 +9556,7 @@ x_text_icon (struct frame *f, const char *icon_name)
   }
 
   if (f->output_data.x->icon_bitmap > 0)
-    x_destroy_bitmap (f, f->output_data.x->icon_bitmap);
+    image_destroy_bitmap (f, f->output_data.x->icon_bitmap);
   f->output_data.x->icon_bitmap = 0;
   x_wm_set_icon_pixmap (f, 0);
 
@@ -9838,7 +9747,7 @@ static char *error_msg;
 /* Handle the loss of connection to display DPY.  ERROR_MESSAGE is
    the text of an error message that lead to the connection loss.  */
 
-static _Noreturn void
+static AVOID
 x_connection_closed (Display *dpy, const char *error_message, bool ioerror)
 {
   struct x_display_info *dpyinfo = x_display_info_for_display (dpy);
@@ -10001,7 +9910,7 @@ x_error_quitter (Display *display, XErrorEvent *event)
    It kills all frames on the display that we lost touch with.
    If that was the only one, it prints an error message and kills Emacs.  */
 
-static _Noreturn int
+static _Noreturn ATTRIBUTE_COLD int
 x_io_error_quitter (Display *display)
 {
   char buf[256];
@@ -10018,7 +9927,7 @@ x_io_error_quitter (Display *display)
    frame.  If it is negative, generate a new fontset from
    FONT-OBJECT.  */
 
-Lisp_Object
+static Lisp_Object
 x_new_font (struct frame *f, Lisp_Object font_object, int fontset)
 {
   struct font *font = XFONT_OBJECT (font_object);
@@ -10150,7 +10059,7 @@ xim_open_dpy (struct x_display_info *dpyinfo, char *resource_name)
     {
       if (dpyinfo->xim)
 	XCloseIM (dpyinfo->xim);
-      xim = XOpenIM (dpyinfo->display, dpyinfo->xrdb, resource_name,
+      xim = XOpenIM (dpyinfo->display, dpyinfo->rdb, resource_name,
 		     emacs_class);
       dpyinfo->xim = xim;
 
@@ -10249,7 +10158,7 @@ xim_initialize (struct x_display_info *dpyinfo, char *resource_name)
       xim_inst->dpyinfo = dpyinfo;
       xim_inst->resource_name = xstrdup (resource_name);
       ret = XRegisterIMInstantiateCallback
-	(dpyinfo->display, dpyinfo->xrdb, xim_inst->resource_name,
+	(dpyinfo->display, dpyinfo->rdb, xim_inst->resource_name,
 	 emacs_class, xim_instantiate_callback,
 	 /* This is XPointer in XFree86 but (XPointer *)
 	    on Tru64, at least, hence the configure test.  */
@@ -10277,7 +10186,7 @@ xim_close_dpy (struct x_display_info *dpyinfo)
       if (dpyinfo->display)
 	{
 	  Bool ret = XUnregisterIMInstantiateCallback
-	    (dpyinfo->display, dpyinfo->xrdb, xim_inst->resource_name,
+	    (dpyinfo->display, dpyinfo->rdb, xim_inst->resource_name,
 	     emacs_class, xim_instantiate_callback,
 	     (XRegisterIMInstantiateCallback_arg6) xim_inst);
 	  eassert (ret == True);
@@ -10390,10 +10299,10 @@ x_calc_absolute_position (struct frame *f)
 /* CHANGE_GRAVITY is 1 when calling from Fset_frame_position,
    to really change the position, and 0 when calling from
    x_make_frame_visible (in that case, XOFF and YOFF are the current
-   position values).  It is -1 when calling from x_set_frame_parameters,
+   position values).  It is -1 when calling from gui_set_frame_parameters,
    which means, do adjust for borders but don't change the gravity.  */
 
-void
+static void
 x_set_offset (struct frame *f, register int xoff, register int yoff, int change_gravity)
 {
   int modified_top, modified_left;
@@ -10696,10 +10605,10 @@ x_set_z_group (struct frame *f, Lisp_Object new_value, Lisp_Object old_value)
    Return true iff we are not hidden.  */
 
 static bool
-get_current_wm_state (struct frame *f,
-                      Window window,
-                      int *size_state,
-                      bool *sticky)
+x_get_current_wm_state (struct frame *f,
+                        Window window,
+                        int *size_state,
+                        bool *sticky)
 {
   unsigned long actual_size;
   int i;
@@ -10806,7 +10715,7 @@ do_ewmh_fullscreen (struct frame *f)
   int cur;
   bool dummy;
 
-  get_current_wm_state (f, FRAME_OUTER_WINDOW (f), &cur, &dummy);
+  x_get_current_wm_state (f, FRAME_OUTER_WINDOW (f), &cur, &dummy);
 
   /* Some window managers don't say they support _NET_WM_STATE, but they do say
      they support _NET_WM_STATE_FULLSCREEN.  Try that also.  */
@@ -10947,7 +10856,7 @@ x_handle_net_wm_state (struct frame *f, const XPropertyEvent *event)
   int value = FULLSCREEN_NONE;
   Lisp_Object lval;
   bool sticky = false;
-  bool not_hidden = get_current_wm_state (f, event->window, &value, &sticky);
+  bool not_hidden = x_get_current_wm_state (f, event->window, &value, &sticky);
 
   lval = Qnil;
   switch (value)
@@ -11274,7 +11183,7 @@ x_set_window_size_1 (struct frame *f, bool change_gravity,
 	/* Try to restore fullscreen state.  */
 	{
 	  store_frame_param (f, Qfullscreen, fullscreen);
-	  x_set_fullscreen (f, fullscreen, fullscreen);
+	  gui_set_fullscreen (f, fullscreen, fullscreen);
 	}
     }
   else
@@ -11368,7 +11277,7 @@ frame_set_mouse_pixel_position (struct frame *f, int pix_x, int pix_y)
 
 /* Raise frame F.  */
 
-void
+static void
 x_raise_frame (struct frame *f)
 {
   block_input ();
@@ -11392,9 +11301,18 @@ x_lower_frame (struct frame *f)
     }
 }
 
+static void
+XTframe_raise_lower (struct frame *f, bool raise_flag)
+{
+  if (raise_flag)
+    x_raise_frame (f);
+  else
+    x_lower_frame (f);
+}
+
 /* Request focus with XEmbed */
 
-void
+static void
 xembed_request_focus (struct frame *f)
 {
   /* See XEmbed Protocol Specification at
@@ -11406,7 +11324,7 @@ xembed_request_focus (struct frame *f)
 
 /* Activate frame with Extended Window Manager Hints */
 
-void
+static void
 x_ewmh_activate_frame (struct frame *f)
 {
   /* See Window Manager Specification/Extended Window Manager Hints at
@@ -11425,14 +11343,56 @@ x_ewmh_activate_frame (struct frame *f)
     }
 }
 
+static Lisp_Object
+x_get_focus_frame (struct frame *f)
+{
+  Lisp_Object lisp_focus;
+
+  struct frame *focus =  FRAME_DISPLAY_INFO (f)->x_focus_frame;
+
+  if (!focus)
+    return Qnil;
+
+  XSETFRAME (lisp_focus, focus);
+  return lisp_focus;
+}
+
+/* In certain situations, when the window manager follows a
+   click-to-focus policy, there seems to be no way around calling
+   XSetInputFocus to give another frame the input focus .
+
+   In an ideal world, XSetInputFocus should generally be avoided so
+   that applications don't interfere with the window manager's focus
+   policy.  But I think it's okay to use when it's clearly done
+   following a user-command.  */
+
 static void
-XTframe_raise_lower (struct frame *f, bool raise_flag)
+x_focus_frame (struct frame *f, bool noactivate)
 {
-  if (raise_flag)
-    x_raise_frame (f);
+  Display *dpy = FRAME_X_DISPLAY (f);
+
+  block_input ();
+  x_catch_errors (dpy);
+
+  if (FRAME_X_EMBEDDED_P (f))
+    {
+      /* For Xembedded frames, normally the embedder forwards key
+	 events.  See XEmbed Protocol Specification at
+	 http://freedesktop.org/wiki/Specifications/xembed-spec  */
+      xembed_request_focus (f);
+    }
   else
-    x_lower_frame (f);
+    {
+      XSetInputFocus (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f),
+		      RevertToParent, CurrentTime);
+      if (!noactivate)
+	x_ewmh_activate_frame (f);
+    }
+
+  x_uncatch_errors ();
+  unblock_input ();
 }
+
 
 /* XEmbed implementation.  */
 
@@ -11513,7 +11473,7 @@ x_make_frame_visible (struct frame *f)
 
   block_input ();
 
-  x_set_bitmap_icon (f);
+  gui_set_bitmap_icon (f);
 
   if (! FRAME_VISIBLE_P (f))
     {
@@ -11648,8 +11608,8 @@ x_make_frame_invisible (struct frame *f)
   window = FRAME_OUTER_WINDOW (f);
 
   /* Don't keep the highlight on an invisible frame.  */
-  if (FRAME_DISPLAY_INFO (f)->x_highlight_frame == f)
-    FRAME_DISPLAY_INFO (f)->x_highlight_frame = 0;
+  if (FRAME_DISPLAY_INFO (f)->highlight_frame == f)
+    FRAME_DISPLAY_INFO (f)->highlight_frame = 0;
 
   block_input ();
 
@@ -11690,6 +11650,15 @@ x_make_frame_invisible (struct frame *f)
   unblock_input ();
 }
 
+static void
+x_make_frame_visible_invisible (struct frame *f, bool visible)
+{
+  if (visible)
+    x_make_frame_visible (f);
+  else
+    x_make_frame_invisible (f);
+}
+
 /* Change window state from mapped to iconified.  */
 
 void
@@ -11700,15 +11669,15 @@ x_iconify_frame (struct frame *f)
 #endif
 
   /* Don't keep the highlight on an invisible frame.  */
-  if (FRAME_DISPLAY_INFO (f)->x_highlight_frame == f)
-    FRAME_DISPLAY_INFO (f)->x_highlight_frame = 0;
+  if (FRAME_DISPLAY_INFO (f)->highlight_frame == f)
+    FRAME_DISPLAY_INFO (f)->highlight_frame = 0;
 
   if (FRAME_ICONIFIED_P (f))
     return;
 
   block_input ();
 
-  x_set_bitmap_icon (f);
+  gui_set_bitmap_icon (f);
 
 #if defined (USE_GTK)
   if (FRAME_GTK_OUTER_WIDGET (f))
@@ -11857,7 +11826,9 @@ x_free_frame_resources (struct frame *f)
 	free_frame_xic (f);
 #endif
 
-      x_free_cr_resources (f);
+#ifdef USE_CAIRO
+      x_cr_destroy_frame_context (f);
+#endif
 #ifdef USE_X_TOOLKIT
       if (f->output_data.x->widget)
 	{
@@ -11964,8 +11935,8 @@ x_free_frame_resources (struct frame *f)
     dpyinfo->x_focus_frame = 0;
   if (f == dpyinfo->x_focus_event_frame)
     dpyinfo->x_focus_event_frame = 0;
-  if (f == dpyinfo->x_highlight_frame)
-    dpyinfo->x_highlight_frame = 0;
+  if (f == dpyinfo->highlight_frame)
+    dpyinfo->highlight_frame = 0;
   if (f == hlinfo->mouse_face_mouse_frame)
     reset_mouse_highlight (hlinfo);
 
@@ -12133,7 +12104,7 @@ x_wm_set_icon_pixmap (struct frame *f, ptrdiff_t pixmap_id)
 
   if (pixmap_id > 0)
     {
-      icon_pixmap = x_bitmap_pixmap (f, pixmap_id);
+      icon_pixmap = image_bitmap_pixmap (f, pixmap_id);
       f->output_data.x->wm_hints.icon_pixmap = icon_pixmap;
       icon_mask = x_bitmap_mask (f, pixmap_id);
       f->output_data.x->wm_hints.icon_mask = icon_mask;
@@ -12203,6 +12174,25 @@ x_check_font (struct frame *f, struct font *font)
 #endif /* GLYPH_DEBUG */
 
 
+/***********************************************************************
+                             Image Hooks
+ ***********************************************************************/
+
+static void
+x_free_pixmap (struct frame *f, Emacs_Pixmap pixmap)
+{
+#ifdef USE_CAIRO
+  if (pixmap)
+    {
+      xfree (pixmap->data);
+      xfree (pixmap);
+    }
+#else
+  XFreePixmap (FRAME_X_DISPLAY (f), pixmap);
+#endif
+}
+
+
 /***********************************************************************
 			    Initialization
  ***********************************************************************/
@@ -12514,7 +12504,7 @@ x_term_init (Lisp_Object display_name, char *xrm_option, char *resource_name)
 
         dpy = DEFAULT_GDK_DISPLAY ();
 
-#if ! GTK_CHECK_VERSION (2, 90, 0)
+#ifndef HAVE_GTK3
         /* Load our own gtkrc if it exists.  */
         {
           const char *file = "~/.emacs.d/gtkrc";
@@ -12707,7 +12697,7 @@ x_term_init (Lisp_Object display_name, char *xrm_option, char *resource_name)
 #endif
   /* Put the rdb where we can find it in a way that works on
      all versions.  */
-  dpyinfo->xrdb = xrdb;
+  dpyinfo->rdb = xrdb;
 
   dpyinfo->screen = ScreenOfDisplay (dpyinfo->display,
 				     DefaultScreen (dpyinfo->display));
@@ -12738,8 +12728,8 @@ x_term_init (Lisp_Object display_name, char *xrm_option, char *resource_name)
 	  AUTO_STRING (privateColormap, "privateColormap");
 	  AUTO_STRING (PrivateColormap, "PrivateColormap");
 	  Lisp_Object value
-	    = display_x_get_resource (dpyinfo, privateColormap,
-				      PrivateColormap, Qnil, Qnil);
+	    = gui_display_get_resource (dpyinfo, privateColormap,
+                                        PrivateColormap, Qnil, Qnil);
 	  if (STRINGP (value)
 	      && (!strcmp (SSDATA (value), "true")
 		  || !strcmp (SSDATA (value), "on")))
@@ -12758,7 +12748,7 @@ x_term_init (Lisp_Object display_name, char *xrm_option, char *resource_name)
     dpyinfo->supports_xdbe = true;
 #endif
 
-#ifdef HAVE_XFT
+#if defined USE_CAIRO || defined HAVE_XFT
   {
     /* If we are using Xft, the following precautions should be made:
 
@@ -12956,8 +12946,8 @@ x_term_init (Lisp_Object display_name, char *xrm_option, char *resource_name)
   {
     AUTO_STRING (synchronous, "synchronous");
     AUTO_STRING (Synchronous, "Synchronous");
-    Lisp_Object value = display_x_get_resource (dpyinfo, synchronous,
-						Synchronous, Qnil, Qnil);
+    Lisp_Object value = gui_display_get_resource (dpyinfo, synchronous,
+                                                  Synchronous, Qnil, Qnil);
     if (STRINGP (value)
 	&& (!strcmp (SSDATA (value), "true")
 	    || !strcmp (SSDATA (value), "on")))
@@ -12967,8 +12957,8 @@ x_term_init (Lisp_Object display_name, char *xrm_option, char *resource_name)
   {
     AUTO_STRING (useXIM, "useXIM");
     AUTO_STRING (UseXIM, "UseXIM");
-    Lisp_Object value = display_x_get_resource (dpyinfo, useXIM, UseXIM,
-						Qnil, Qnil);
+    Lisp_Object value = gui_display_get_resource (dpyinfo, useXIM, UseXIM,
+                                                  Qnil, Qnil);
 #ifdef USE_XIM
     if (STRINGP (value)
 	&& (!strcmp (SSDATA (value), "false")
@@ -13099,21 +13089,23 @@ x_activate_timeout_atimer (void)
 
 /* Set up use of X before we make the first connection.  */
 
+extern frame_parm_handler x_frame_parm_handlers[];
+
 static struct redisplay_interface x_redisplay_interface =
   {
     x_frame_parm_handlers,
-    x_produce_glyphs,
-    x_write_glyphs,
-    x_insert_glyphs,
-    x_clear_end_of_line,
+    gui_produce_glyphs,
+    gui_write_glyphs,
+    gui_insert_glyphs,
+    gui_clear_end_of_line,
     x_scroll_run,
     x_after_update_window_line,
-    x_update_window_begin,
-    x_update_window_end,
+    NULL, /* update_window_begin */
+    NULL, /* update_window_end   */
     x_flip_and_flush,
-    x_clear_window_mouse_face,
-    x_get_glyph_overhangs,
-    x_fix_overlapping_area,
+    gui_clear_window_mouse_face,
+    gui_get_glyph_overhangs,
+    gui_fix_overlapping_area,
     x_draw_fringe_bitmap,
 #ifdef USE_CAIRO
     x_cr_define_fringe_bitmap,
@@ -13126,6 +13118,7 @@ static struct redisplay_interface x_redisplay_interface =
     x_draw_glyph_string,
     x_define_frame_cursor,
     x_clear_frame_area,
+    x_clear_under_internal_border,
     x_draw_window_cursor,
     x_draw_vertical_window_border,
     x_draw_window_divider,
@@ -13157,13 +13150,13 @@ x_delete_terminal (struct terminal *terminal)
   /* Normally, the display is available...  */
   if (dpyinfo->display)
     {
-      x_destroy_all_bitmaps (dpyinfo);
+      image_destroy_all_bitmaps (dpyinfo);
       XSetCloseDownMode (dpyinfo->display, DestroyAll);
 
       /* Whether or not XCloseDisplay destroys the associated resource
 	 database depends on the version of libX11.  To avoid both
 	 crash and memory leak, we dissociate the database from the
-	 display and then destroy dpyinfo->xrdb ourselves.
+	 display and then destroy dpyinfo->rdb ourselves.
 
 	 Unfortunately, the above strategy does not work in some
 	 situations due to a bug in newer versions of libX11: because
@@ -13183,7 +13176,7 @@ x_delete_terminal (struct terminal *terminal)
       /* We used to call XrmDestroyDatabase from x_delete_display, but
 	 some older versions of libX11 crash if we call it after
 	 closing all the displays.  */
-      XrmDestroyDatabase (dpyinfo->xrdb);
+      XrmDestroyDatabase (dpyinfo->rdb);
 #endif
 
 #ifdef USE_GTK
@@ -13241,19 +13234,42 @@ x_create_terminal (struct x_display_info *dpyinfo)
   terminal->read_socket_hook = XTread_socket;
   terminal->frame_up_to_date_hook = XTframe_up_to_date;
   terminal->buffer_flipping_unblocked_hook = XTbuffer_flipping_unblocked_hook;
+  terminal->defined_color_hook = x_defined_color;
+  terminal->query_frame_background_color = x_query_frame_background_color;
+  terminal->query_colors = x_query_colors;
   terminal->mouse_position_hook = XTmouse_position;
+  terminal->get_focus_frame = x_get_focus_frame;
+  terminal->focus_frame_hook = x_focus_frame;
   terminal->frame_rehighlight_hook = XTframe_rehighlight;
   terminal->frame_raise_lower_hook = XTframe_raise_lower;
+  terminal->frame_visible_invisible_hook = x_make_frame_visible_invisible;
   terminal->fullscreen_hook = XTfullscreen_hook;
+  terminal->iconify_frame_hook = x_iconify_frame;
+  terminal->set_window_size_hook = x_set_window_size;
+  terminal->set_frame_offset_hook = x_set_offset;
+  terminal->set_frame_alpha_hook = x_set_frame_alpha;
+  terminal->set_new_font_hook = x_new_font;
+  terminal->set_bitmap_icon_hook = x_bitmap_icon;
+  terminal->implicit_set_name_hook = x_implicitly_set_name;
   terminal->menu_show_hook = x_menu_show;
+#ifdef HAVE_EXT_MENU_BAR
+  terminal->activate_menubar_hook = x_activate_menubar;
+#endif
 #if defined (USE_X_TOOLKIT) || defined (USE_GTK)
   terminal->popup_dialog_hook = xw_popup_dialog;
+#endif
+#ifndef HAVE_EXT_TOOL_BAR
+  terminal->change_tool_bar_height_hook = x_change_tool_bar_height;
 #endif
   terminal->set_vertical_scroll_bar_hook = XTset_vertical_scroll_bar;
   terminal->set_horizontal_scroll_bar_hook = XTset_horizontal_scroll_bar;
+  terminal->set_scroll_bar_default_width_hook = x_set_scroll_bar_default_width;
+  terminal->set_scroll_bar_default_height_hook = x_set_scroll_bar_default_height;
   terminal->condemn_scroll_bars_hook = XTcondemn_scroll_bars;
   terminal->redeem_scroll_bar_hook = XTredeem_scroll_bar;
   terminal->judge_scroll_bars_hook = XTjudge_scroll_bars;
+  terminal->get_string_resource_hook = x_get_string_resource;
+  terminal->free_pixmap = x_free_pixmap;
   terminal->delete_frame_hook = x_destroy_window;
   terminal->delete_terminal_hook = x_delete_terminal;
   /* Other hooks are NULL by default.  */
diff --git a/src/xterm.h b/src/xterm.h
index c5ad38650c..2bd2c0105f 100644
--- a/src/xterm.h
+++ b/src/xterm.h
@@ -50,17 +50,8 @@ typedef Widget xt_or_gtk_widget;
 #include <gdk/gdkx.h>
 #endif /* USE_GTK */
 
-/* True iff GTK's version is at least I.J.K.  */
-#ifndef GTK_CHECK_VERSION
-# ifdef USE_GTK
-#  define GTK_CHECK_VERSION(i, j, k) \
-     ((i) \
-      < GTK_MAJOR_VERSION + ((j) \
-			     < GTK_MINOR_VERSION + ((k) \
-						    <= GTK_MICRO_VERSION)))
-# else
-#  define GTK_CHECK_VERSION(i, j, k) false
-# endif
+#ifndef USE_GTK
+#define GTK_CHECK_VERSION(i, j, k) false
 #endif
 
 #ifdef USE_GTK
@@ -76,11 +67,6 @@ typedef GtkWidget *xt_or_gtk_widget;
 #endif
 #endif /* USE_GTK */
 
-/* The GtkTooltip API came in 2.12, but gtk-enable-tooltips in 2.14. */
-#if GTK_CHECK_VERSION (2, 14, 0)
-#define USE_GTK_TOOLTIP
-#endif
-
 #ifdef USE_CAIRO
 #include <cairo-xlib.h>
 #ifdef CAIRO_HAS_PDF_SURFACE
@@ -144,7 +130,7 @@ struct xim_inst_t
 struct x_bitmap_record
 {
 #ifdef USE_CAIRO
-  void *img;
+  cairo_pattern_t *stipple;
 #endif
   Pixmap pixmap;
   bool have_mask;
@@ -165,6 +151,8 @@ struct x_gc_ext_data
   /* Clipping rectangles.  */
   XRectangle clip_rects[MAX_CLIP_RECTS];
 };
+
+extern cairo_pattern_t *x_bitmap_stipple (struct frame *, Pixmap);
 #endif
 
 
@@ -249,7 +237,7 @@ struct x_display_info
 #endif
 
   /* X Resource data base */
-  XrmDatabase xrdb;
+  XrmDatabase rdb;
 
   /* Minimum width over all characters in all fonts in font_table.  */
   int smallest_char_width;
@@ -364,7 +352,7 @@ struct x_display_info
      event).  It points to the X focus frame's selected window's
      frame.  It differs from x_focus_frame when we're using a global
      minibuffer.  */
-  struct frame *x_highlight_frame;
+  struct frame *highlight_frame;
 
   /* The frame waiting to be auto-raised in XTread_socket.  */
   struct frame *x_pending_autoraise_frame;
@@ -594,12 +582,9 @@ struct x_output
   GdkGeometry size_hints;
   long hint_flags;
 
-#ifdef USE_GTK_TOOLTIP
   GtkTooltip *ttip_widget;
   GtkWidget *ttip_lbl;
   GtkWindow *ttip_window;
-#endif /* USE_GTK_TOOLTIP */
-
 #endif /* USE_GTK */
 
   /* If >=0, a bitmap index.  The indicated bitmap is used for the
@@ -742,13 +727,12 @@ struct x_output
 #ifdef USE_CAIRO
   /* Cairo drawing context.  */
   cairo_t *cr_context;
-  /* Cairo surface for double buffering */
-  cairo_surface_t *cr_surface;
+  /* Width and height reported by the last ConfigureNotify event.
+     They are used when creating the cairo surface next time.  */
+  int cr_surface_desired_width, cr_surface_desired_height;
 #endif
 };
 
-#define No_Cursor (None)
-
 enum
 {
   /* Values for focus_state, used as bit mask.
@@ -764,9 +748,11 @@ enum
 
 /* Return the X output data for frame F.  */
 #define FRAME_X_OUTPUT(f) ((f)->output_data.x)
+#define FRAME_OUTPUT_DATA(f) FRAME_X_OUTPUT (f)
 
 /* Return the X window used for displaying data in frame F.  */
 #define FRAME_X_WINDOW(f) ((f)->output_data.x->window_desc)
+#define FRAME_NATIVE_WINDOW(f) FRAME_X_WINDOW (f)
 
 /* Return the drawable used for rendering to frame F.  */
 #define FRAME_X_RAW_DRAWABLE(f) ((f)->output_data.x->draw_desc)
@@ -793,18 +779,6 @@ extern void x_mark_frame_dirty (struct frame *f);
                                FRAME_X_WINDOW (f))
 #else
 #ifdef USE_GTK
-/* Functions not present in older Gtk+ */
-
-#ifndef HAVE_GTK_WIDGET_GET_WINDOW
-#define gtk_widget_get_window(w) ((w)->window)
-#endif
-#ifndef HAVE_GTK_WIDGET_GET_MAPPED
-#define gtk_widget_get_mapped(w) (GTK_WIDGET_MAPPED (w))
-#endif
-#ifndef HAVE_GTK_ADJUSTMENT_GET_PAGE_SIZE
-#define gtk_adjustment_get_page_size(w) ((w)->page_size)
-#define gtk_adjustment_get_upper(w) ((w)->upper)
-#endif
 
 #ifdef HAVE_GTK3
 #define DEFAULT_GDK_DISPLAY() \
@@ -1087,6 +1061,7 @@ extern void x_real_pos_and_offsets (struct frame *f,
 
 XrmDatabase x_load_resources (Display *, const char *, const char *,
 			      const char *);
+extern const char *x_get_string_resource (void *, const char *, const char *);
 
 /* Defined in xterm.c */
 
@@ -1103,8 +1078,13 @@ extern bool x_had_errors_p (Display *);
 extern void x_uncatch_errors (void);
 extern void x_uncatch_errors_after_check (void);
 extern void x_clear_errors (Display *);
-extern void xembed_request_focus (struct frame *);
-extern void x_ewmh_activate_frame (struct frame *);
+extern void x_set_window_size (struct frame *f, bool, int, int, bool);
+extern void x_make_frame_visible (struct frame *f);
+extern void x_make_frame_invisible (struct frame *f);
+extern void x_iconify_frame (struct frame *f);
+extern void x_free_frame_resources (struct frame *);
+extern void x_wm_set_size_hint (struct frame *, long, bool);
+
 extern void x_delete_terminal (struct terminal *terminal);
 extern unsigned long x_copy_color (struct frame *, unsigned long);
 #ifdef USE_X_TOOLKIT
@@ -1117,7 +1097,7 @@ extern bool x_alloc_lighter_color_for_widget (Widget, Display *, Colormap,
 					      double, int);
 #endif
 extern bool x_alloc_nearest_color (struct frame *, Colormap, XColor *);
-extern void x_query_color (struct frame *f, XColor *);
+extern void x_query_colors (struct frame *f, XColor *, int);
 extern void x_clear_area (struct frame *f, int, int, int, int);
 #if !defined USE_X_TOOLKIT && !defined USE_GTK
 extern void x_mouse_leave (struct x_display_info *);
@@ -1128,6 +1108,7 @@ extern int x_dispatch_event (XEvent *, Display *);
 #endif
 extern int x_x_to_emacs_modifiers (struct x_display_info *, int);
 #ifdef USE_CAIRO
+extern void x_cr_destroy_frame_context (struct frame *);
 extern cairo_t *x_begin_cr_clip (struct frame *, GC);
 extern void x_end_cr_clip (struct frame *);
 extern void x_set_cr_source_with_gc_foreground (struct frame *, GC);
@@ -1194,6 +1175,13 @@ extern void x_clear_under_internal_border (struct frame *f);
 extern void tear_down_x_back_buffer (struct frame *f);
 extern void initial_set_up_x_back_buffer (struct frame *f);
 
+/* Defined in xfns.c.  */
+extern void x_real_positions (struct frame *, int *, int *);
+extern void x_change_tool_bar_height (struct frame *, int);
+extern void x_implicitly_set_name (struct frame *, Lisp_Object, Lisp_Object);
+extern void x_set_scroll_bar_default_width (struct frame *);
+extern void x_set_scroll_bar_default_height (struct frame *);
+
 /* Defined in xselect.c.  */
 
 extern void x_handle_property_notify (const XPropertyEvent *);
@@ -1236,7 +1224,8 @@ extern void destroy_frame_xic (struct frame *);
 extern void xic_set_preeditarea (struct window *, int, int);
 extern void xic_set_statusarea (struct frame *);
 extern void xic_set_xfontset (struct frame *, const char *);
-extern bool x_defined_color (struct frame *, const char *, XColor *, bool);
+extern bool x_defined_color (struct frame *, const char *, Emacs_Color *,
+                             bool, bool);
 #ifdef HAVE_X_I18N
 extern void free_frame_xic (struct frame *);
 # if defined HAVE_X_WINDOWS && defined USE_X_TOOLKIT
@@ -1275,15 +1264,6 @@ extern void x_session_close (void);
 
 #define FRAME_X_EMBEDDED_P(f) (FRAME_X_OUTPUT(f)->explicit_parent != 0)
 
-#define STORE_XCHAR2B(chp, b1, b2) \
-  ((chp)->byte1 = (b1), (chp)->byte2 = (b2))
-
-#define XCHAR2B_BYTE1(chp) \
-  ((chp)->byte1)
-
-#define XCHAR2B_BYTE2(chp) \
-  ((chp)->byte2)
-
 #define STORE_NATIVE_RECT(nr,rx,ry,rwidth,rheight)	\
   ((nr).x = (rx),					\
    (nr).y = (ry),					\
diff --git a/test/Makefile.in b/test/Makefile.in
index ce6ce04b8b..c18099587c 100644
--- a/test/Makefile.in
+++ b/test/Makefile.in
@@ -254,8 +254,8 @@ else
 FPIC_CFLAGS = -fPIC
 endif
 
-HYBRID_MALLOC = @HYBRID_MALLOC@
-LIBEGNU_ARCHIVE = ../lib/lib$(if $(HYBRID_MALLOC),e)gnu.a
+GMP_LIB = @GMP_LIB@
+GMP_OBJ = $(if @GMP_OBJ@, ../src/@GMP_OBJ@)
 
 # Note: emacs-module.h is generated from emacs-module.h.in, hence we
 # look in ../src, not $(srcdir)/../src.
@@ -264,11 +264,16 @@ MODULE_CFLAGS = -I../src -I$(srcdir)/../lib \
   $(WARN_CFLAGS) $(WERROR_CFLAGS) $(CFLAGS)
 
 test_module = $(test_module_dir)/mod-test${SO}
-src/emacs-module-tests.log: $(test_module)
-$(test_module): $(test_module:${SO}=.c) ../src/emacs-module.h $(LIBEGNU_ARCHIVE)
+src/emacs-module-tests.log src/emacs-module-tests.elc: $(test_module)
+
+# In the compilation command, we can't use any object or archive file
+# as source because those are not compiled with -fPIC.  Therefore we
+# use only source files.
+$(test_module): $(test_module:${SO}=.c) ../src/emacs-module.h
 	$(AM_V_at)${MKDIR_P} $(dir $@)
 	$(AM_V_CCLD)$(CC) -shared $(CPPFLAGS) $(MODULE_CFLAGS) $(LDFLAGS) \
-	  -o $@ $< $(LIBEGNU_ARCHIVE)
+	  -o $@ $< $(GMP_LIB) $(GMP_OBJ:.o=.c) \
+	  $(srcdir)/../lib/timespec.c $(srcdir)/../lib/gettime.c
 endif
 
 ## Check that there is no 'automated' subdirectory, which would
diff --git a/test/data/emacs-module/mod-test.c b/test/data/emacs-module/mod-test.c
index a39e41afee..2891b73c1a 100644
--- a/test/data/emacs-module/mod-test.c
+++ b/test/data/emacs-module/mod-test.c
@@ -19,7 +19,9 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include "config.h"
 
+#undef NDEBUG
 #include <assert.h>
+
 #include <errno.h>
 #include <limits.h>
 #include <stdio.h>
@@ -27,6 +29,14 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <string.h>
 #include <time.h>
 
+#ifdef HAVE_GMP
+#include <gmp.h>
+#else
+#include "mini-gmp.h"
+#define EMACS_MODULE_HAVE_MPZ_T
+#endif
+
+#define EMACS_MODULE_GMP
 #include <emacs-module.h>
 
 #include "timespec.h"
@@ -307,16 +317,6 @@ Fmod_test_invalid_finalizer (emacs_env *env, ptrdiff_t nargs, emacs_value *args,
   return env->intern (env, "nil");
 }
 
-static void
-signal_wrong_type_argument (emacs_env *env, const char *predicate,
-                            emacs_value arg)
-{
-  emacs_value symbol = env->intern (env, "wrong-type-argument");
-  emacs_value elements[2] = {env->intern (env, predicate), arg};
-  emacs_value data = env->funcall (env, env->intern (env, "list"), 2, elements);
-  env->non_local_exit_signal (env, symbol, data);
-}
-
 static void
 signal_errno (emacs_env *env, const char *function)
 {
@@ -337,16 +337,10 @@ Fmod_test_sleep_until (emacs_env *env, ptrdiff_t nargs, emacs_value *args,
                        void *data)
 {
   assert (nargs == 2);
-  const double until_seconds = env->extract_float (env, args[0]);
+  const struct timespec until = env->extract_time (env, args[0]);
   if (env->non_local_exit_check (env))
     return NULL;
-  if (until_seconds <= 0)
-    {
-      signal_wrong_type_argument (env, "cl-plusp", args[0]);
-      return NULL;
-    }
   const bool process_input = env->is_not_nil (env, args[1]);
-  const struct timespec until = dtotimespec (until_seconds);
   const struct timespec amount = make_timespec(0,  10000000);
   while (true)
     {
@@ -366,6 +360,53 @@ Fmod_test_sleep_until (emacs_env *env, ptrdiff_t nargs, emacs_value *args,
   return env->intern (env, "finished");
 }
 
+static emacs_value
+Fmod_test_add_nanosecond (emacs_env *env, ptrdiff_t nargs, emacs_value *args,
+                          void *data)
+{
+  assert (nargs == 1);
+  struct timespec time = env->extract_time (env, args[0]);
+  assert (time.tv_nsec >= 0);
+  assert (time.tv_nsec < 2000000000);  /* possible leap second */
+  time.tv_nsec++;
+  return env->make_time (env, time);
+}
+
+static emacs_value
+Fmod_test_nanoseconds (emacs_env *env, ptrdiff_t nargs, emacs_value *args, void *data) {
+  assert (nargs == 1);
+  struct timespec time = env->extract_time (env, args[0]);
+  struct emacs_mpz nanoseconds;
+  assert (LONG_MIN <= time.tv_sec && time.tv_sec <= LONG_MAX);
+  mpz_init_set_si (nanoseconds.value, time.tv_sec);
+#ifdef __MINGW32__
+  _Static_assert (1000000000 <= ULONG_MAX, "unsupported architecture");
+#else
+  static_assert (1000000000 <= ULONG_MAX, "unsupported architecture");
+#endif
+  mpz_mul_ui (nanoseconds.value, nanoseconds.value, 1000000000);
+  assert (0 <= time.tv_nsec && time.tv_nsec <= ULONG_MAX);
+  mpz_add_ui (nanoseconds.value, nanoseconds.value, time.tv_nsec);
+  emacs_value result = env->make_big_integer (env, &nanoseconds);
+  mpz_clear (nanoseconds.value);
+  return result;
+}
+
+static emacs_value
+Fmod_test_double (emacs_env *env, ptrdiff_t nargs, emacs_value *args,
+                  void *data)
+{
+  assert (nargs == 1);
+  emacs_value arg = args[0];
+  struct emacs_mpz value;
+  mpz_init (value.value);
+  env->extract_big_integer (env, arg, &value);
+  mpz_mul_ui (value.value, value.value, 2);
+  emacs_value result = env->make_big_integer (env, &value);
+  mpz_clear (value.value);
+  return result;
+}
+
 /* Lisp utilities for easier readability (simple wrappers).  */
 
 /* Provide FEATURE to Emacs.  */
@@ -394,6 +435,11 @@ bind_function (emacs_env *env, const char *name, emacs_value Sfun)
 int
 emacs_module_init (struct emacs_runtime *ert)
 {
+  /* Check that EMACS_MAJOR_VERSION is defined and an integral
+     constant.  */
+  char dummy[EMACS_MAJOR_VERSION];
+  assert (27 <= sizeof dummy);
+
   if (ert->size < sizeof *ert)
     {
       fprintf (stderr, "Runtime size of runtime structure (%"pT" bytes) "
@@ -434,6 +480,9 @@ emacs_module_init (struct emacs_runtime *ert)
   DEFUN ("mod-test-invalid-finalizer", Fmod_test_invalid_finalizer, 0, 0,
          NULL, NULL);
   DEFUN ("mod-test-sleep-until", Fmod_test_sleep_until, 2, 2, NULL, NULL);
+  DEFUN ("mod-test-add-nanosecond", Fmod_test_add_nanosecond, 1, 1, NULL, NULL);
+  DEFUN ("mod-test-nanoseconds", Fmod_test_nanoseconds, 1, 1, NULL, NULL);
+  DEFUN ("mod-test-double", Fmod_test_double, 1, 1, NULL, NULL);
 
 #undef DEFUN
 
diff --git a/test/lisp/autoinsert-tests.el b/test/lisp/autoinsert-tests.el
new file mode 100644
index 0000000000..a7b0547633
--- /dev/null
+++ b/test/lisp/autoinsert-tests.el
@@ -0,0 +1,104 @@
+;;; autoinsert-tests.el --- Tests for autoinsert.el  -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Simen Heggestøyl <simenheg@gmail.com>
+;; Keywords:
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;
+
+;;; Code:
+
+(require 'autoinsert)
+(require 'ert)
+
+(ert-deftest autoinsert-tests-auto-insert-skeleton ()
+  (let ((auto-insert-alist '((text-mode nil "f" _ "oo")))
+        (auto-insert-query nil))
+    (with-temp-buffer
+      (text-mode)
+      (auto-insert)
+      (should (equal (buffer-string) "foo"))
+      (should (equal (point) (+ (point-min) 1))))))
+
+(ert-deftest autoinsert-tests-auto-insert-file ()
+  (let ((temp-file (make-temp-file "autoinsert-tests" nil nil "foo")))
+    (unwind-protect
+        (let ((auto-insert-alist `((text-mode . ,temp-file)))
+              (auto-insert-query nil))
+          (with-temp-buffer
+            (text-mode)
+            (auto-insert)
+            (should (equal (buffer-string) "foo"))))
+      (when (file-exists-p temp-file)
+        (delete-file temp-file)))))
+
+(ert-deftest autoinsert-tests-auto-insert-function ()
+  (let ((auto-insert-alist '((text-mode . (lambda () (insert "foo")))))
+        (auto-insert-query nil))
+    (with-temp-buffer
+      (text-mode)
+      (auto-insert)
+      (should (equal (buffer-string) "foo")))))
+
+(ert-deftest autoinsert-tests-auto-insert-vector ()
+  (let ((auto-insert-alist '((text-mode . [(nil "f" _ "bar")
+                                           (lambda () (insert "oo"))])))
+        (auto-insert-query nil))
+    (with-temp-buffer
+      (text-mode)
+      (auto-insert)
+      (should (equal (buffer-string) "foobar")))))
+
+(ert-deftest autoinsert-tests-auto-insert-regexp-match ()
+  (let ((auto-insert-alist '(("foobar" nil "1st")
+                             ("fo+bar" nil "2nd")
+                             ("fo*bar" nil "3rd")))
+        (auto-insert-query nil))
+    (with-temp-buffer
+      (setq-local buffer-file-name "fooobar")
+      (auto-insert)
+      (should (equal (buffer-string) "2nd")))))
+
+(ert-deftest autoinsert-tests-define-auto-insert-before ()
+  (let ((auto-insert-alist
+         (list (cons 'text-mode '(lambda () (insert "foo")))))
+        (auto-insert-query nil))
+    (define-auto-insert 'text-mode
+      '(lambda () (insert "bar")))
+    (with-temp-buffer
+      (text-mode)
+      (auto-insert)
+      (should (equal (buffer-string) "barfoo")))))
+
+(ert-deftest autoinsert-tests-define-auto-insert-after ()
+  (let ((auto-insert-alist
+         (list (cons 'text-mode '(lambda () (insert "foo")))))
+        (auto-insert-query nil))
+    (define-auto-insert 'text-mode
+      '(lambda () (insert "bar"))
+      t)
+    (with-temp-buffer
+      (text-mode)
+      (auto-insert)
+      (should (equal (buffer-string) "foobar")))))
+
+(provide 'autoinsert-tests)
+;;; autoinsert-tests.el ends here
diff --git a/test/lisp/autorevert-tests.el b/test/lisp/autorevert-tests.el
index 6e8219d238..00c7ee2575 100644
--- a/test/lisp/autorevert-tests.el
+++ b/test/lisp/autorevert-tests.el
@@ -1,4 +1,4 @@
-;;; auto-revert-tests.el --- Tests of auto-revert
+;;; auto-revert-tests.el --- Tests of auto-revert   -*- lexical-binding: t -*-
 
 ;; Copyright (C) 2015-2019 Free Software Foundation, Inc.
 
@@ -19,6 +19,33 @@
 
 ;;; Commentary:
 
+;; Some of the tests require access to a remote host files.  Since
+;; this could be problematic, a mock-up connection method "mock" is
+;; used.  Emulating a remote connection, it simply calls "sh -i".
+;; Tramp's file name handlers still run, so this test is sufficient
+;; except for connection establishing.
+
+;; If you want to test a real Tramp connection, set
+;; $REMOTE_TEMPORARY_FILE_DIRECTORY to a suitable value in order to
+;; overwrite the default value.  If you want to skip tests accessing a
+;; remote host, set this environment variable to "/dev/null" or
+;; whatever is appropriate on your system.
+
+;; For the remote file-notify library, Tramp checks for the existence
+;; of a respective command.  The first command found is used.  In
+;; order to use a dedicated one, the environment variable
+;; $REMOTE_FILE_NOTIFY_LIBRARY shall be set, possible values are
+;; "inotifywait", "gio-monitor" and "gvfs-monitor-dir".
+
+;; Local file-notify libraries are auto-detected during Emacs
+;; configuration.  This can be changed with a respective configuration
+;; argument, like
+;;
+;;   --with-file-notification=inotify
+;;   --with-file-notification=kqueue
+;;   --with-file-notification=gfile
+;;   --with-file-notification=w32
+
 ;; A whole test run can be performed calling the command `auto-revert-test-all'.
 
 ;;; Code:
@@ -26,8 +53,14 @@
 (require 'ert)
 (require 'ert-x)
 (require 'autorevert)
-(setq auto-revert-notify-exclude-dir-regexp "nothing-to-be-excluded"
-      auto-revert-stop-on-user-input nil)
+(require 'tramp)
+
+(setq auto-revert-debug nil
+      auto-revert-notify-exclude-dir-regexp "nothing-to-be-excluded"
+      auto-revert-stop-on-user-input nil
+      file-notify-debug nil
+      tramp-verbose 0
+      tramp-message-show-message nil)
 
 (defconst auto-revert--timeout 10
   "Time to wait for a message.")
@@ -35,19 +68,91 @@
 (defvar auto-revert--messages nil
   "Used to collect messages issued during a section of a test.")
 
+;; There is no default value on w32 systems, which could work out of the box.
+(defconst auto-revert-test-remote-temporary-file-directory
+  (cond
+   ((getenv "REMOTE_TEMPORARY_FILE_DIRECTORY"))
+   ((eq system-type 'windows-nt) null-device)
+   (t (add-to-list
+       'tramp-methods
+       '("mock"
+	 (tramp-login-program        "sh")
+	 (tramp-login-args           (("-i")))
+	 (tramp-remote-shell         "/bin/sh")
+	 (tramp-remote-shell-args    ("-c"))
+	 (tramp-connection-timeout   10)))
+      (add-to-list
+       'tramp-default-host-alist
+       `("\\`mock\\'" nil ,(system-name)))
+      ;; Emacs' Makefile sets $HOME to a nonexistent value.  Needed in
+      ;; batch mode only, therefore.  `temporary-file-directory' might
+      ;; be quoted, so we unquote it just in case.
+      (unless (and (null noninteractive) (file-directory-p "~/"))
+        (setenv "HOME" (file-name-unquote temporary-file-directory)))
+      (format "/mock::%s" temporary-file-directory)))
+  "Temporary directory for Tramp tests.")
+
+;; Filter suppressed remote file-notify libraries.
+(when (stringp (getenv "REMOTE_FILE_NOTIFY_LIBRARY"))
+  (dolist (lib '("inotifywait" "gio-monitor" "gvfs-monitor-dir"))
+    (unless (string-equal (getenv "REMOTE_FILE_NOTIFY_LIBRARY") lib)
+      (add-to-list 'tramp-connection-properties `(nil ,lib nil)))))
+
+(defvar auto-revert--test-enabled-remote-checked nil
+  "Cached result of `auto-revert--test-enabled-remote'.
+If the function did run, the value is a cons cell, the `cdr'
+being the result.")
+
+(defun auto-revert--test-enabled-remote ()
+  "Whether remote file access is enabled."
+  (unless (consp auto-revert--test-enabled-remote-checked)
+    (setq
+     auto-revert--test-enabled-remote-checked
+     (cons
+      t (ignore-errors
+	  (and
+	   (not (getenv "EMACS_HYDRA_CI"))
+	   (file-remote-p auto-revert-test-remote-temporary-file-directory)
+	   (file-directory-p auto-revert-test-remote-temporary-file-directory)
+	   (file-writable-p
+            auto-revert-test-remote-temporary-file-directory))))))
+  ;; Return result.
+  (cdr auto-revert--test-enabled-remote-checked))
+
 (defun auto-revert--wait-for-revert (buffer)
   "Wait until a message reports reversion of BUFFER.
 This expects `auto-revert--messages' to be bound by
 `ert-with-message-capture' before calling."
-  (with-timeout (auto-revert--timeout nil)
-    (while
-        (null (string-match
-               (format-message "Reverting buffer `%s'." (buffer-name buffer))
-               auto-revert--messages))
+  ;; Remote files do not cooperate well with timers.  So we count ourselves.
+  (let ((ct (current-time)))
+    (while (and (< (float-time (time-subtract (current-time) ct))
+                   auto-revert--timeout)
+                (null (string-match
+                       (format-message
+                        "Reverting buffer `%s'\\." (buffer-name buffer))
+                       auto-revert--messages)))
       (if (with-current-buffer buffer auto-revert-use-notify)
           (read-event nil nil 0.1)
         (sleep-for 0.1)))))
 
+(defmacro auto-revert--deftest-remote (test docstring)
+  "Define ert `TEST-remote' for remote files."
+  (declare (indent 1))
+  `(ert-deftest ,(intern (concat (symbol-name test) "-remote")) ()
+     ,docstring
+     :tags '(:expensive-test)
+     (let ((temporary-file-directory
+	    auto-revert-test-remote-temporary-file-directory)
+           (auto-revert-remote-files t)
+	   (ert-test (ert-get-test ',test))
+           vc-handled-backends)
+       (skip-unless (auto-revert--test-enabled-remote))
+       (tramp-cleanup-connection
+	(tramp-dissect-file-name temporary-file-directory) nil 'keep-password)
+       (condition-case err
+           (funcall (ert-test-body ert-test))
+         (error (message "%s" err) (signal (car err) (cdr err)))))))
+
 (ert-deftest auto-revert-test00-auto-revert-mode ()
   "Check autorevert for a file."
   ;; `auto-revert-buffers' runs every 5".  And we must wait, until the
@@ -93,13 +198,16 @@ This expects `auto-revert--messages' to be bound by
         (kill-buffer buf))
       (ignore-errors (delete-file tmpfile)))))
 
+(auto-revert--deftest-remote auto-revert-test00-auto-revert-mode
+  "Check autorevert for a remote file.")
+
 ;; This is inspired by Bug#21841.
 (ert-deftest auto-revert-test01-auto-revert-several-files ()
   "Check autorevert for several files at once."
   :tags '(:expensive-test)
-  (skip-unless (executable-find "cp"))
+  (skip-unless (executable-find "cp" (file-remote-p temporary-file-directory)))
 
-  (let* ((cp (executable-find "cp"))
+  (let* ((cp (executable-find "cp" (file-remote-p temporary-file-directory)))
          (tmpdir1 (make-temp-file "auto-revert-test" 'dir))
          (tmpdir2 (make-temp-file "auto-revert-test" 'dir))
          (tmpfile1
@@ -139,7 +247,9 @@ This expects `auto-revert--messages' to be bound by
           ;; Strange, that `copy-directory' does not work as expected.
           ;; The following shell command is not portable on all
           ;; platforms, unfortunately.
-          (shell-command (format "%s -f %s/* %s" cp tmpdir2 tmpdir1))
+          (shell-command
+           (format "%s -f %s/* %s"
+                   cp (file-local-name tmpdir2) (file-local-name tmpdir1)))
 
           ;; Check, that the buffers have been reverted.
           (dolist (buf (list buf1 buf2))
@@ -155,6 +265,9 @@ This expects `auto-revert--messages' to be bound by
       (ignore-errors (delete-directory tmpdir1 'recursive))
       (ignore-errors (delete-directory tmpdir2 'recursive)))))
 
+(auto-revert--deftest-remote auto-revert-test01-auto-revert-several-files
+  "Check autorevert for several remote files at once.")
+
 ;; This is inspired by Bug#23276.
 (ert-deftest auto-revert-test02-auto-revert-deleted-file ()
   "Check autorevert for a deleted file."
@@ -185,8 +298,8 @@ This expects `auto-revert--messages' to be bound by
             (add-hook
              'before-revert-hook
              (lambda ()
-               ;; Temporarily.
-               (message "%s deleted" buffer-file-name)
+               (when auto-revert-debug
+                 (message "%s deleted" buffer-file-name))
                (delete-file buffer-file-name))
              nil t)
 
@@ -198,8 +311,9 @@ This expects `auto-revert--messages' to be bound by
             ;; notification should be disabled, falling back to
             ;; polling.
             (should (string-match "any text" (buffer-string)))
-            ;; With w32notify, the 'stopped' events are not sent.
+            ;; With w32notify, and on emba, the `stopped' events are not sent.
             (or (eq file-notify--library 'w32notify)
+                (getenv "EMACS_EMBA_CI")
                 (should-not auto-revert-notify-watch-descriptor))
 
             ;; Once the file has been recreated, the buffer shall be
@@ -231,6 +345,9 @@ This expects `auto-revert--messages' to be bound by
         (kill-buffer buf))
       (ignore-errors (delete-file tmpfile)))))
 
+(auto-revert--deftest-remote auto-revert-test02-auto-revert-deleted-file
+  "Check autorevert for a deleted remote file.")
+
 (ert-deftest auto-revert-test03-auto-revert-tail-mode ()
   "Check autorevert tail mode."
   ;; `auto-revert-buffers' runs every 5".  And we must wait, until the
@@ -266,6 +383,9 @@ This expects `auto-revert--messages' to be bound by
       (ignore-errors (kill-buffer buf))
       (ignore-errors (delete-file tmpfile)))))
 
+(auto-revert--deftest-remote auto-revert-test03-auto-revert-tail-mode
+  "Check remote autorevert tail mode.")
+
 (ert-deftest auto-revert-test04-auto-revert-mode-dired ()
   "Check autorevert for dired."
   ;; `auto-revert-buffers' runs every 5".  And we must wait, until the
@@ -314,6 +434,114 @@ This expects `auto-revert--messages' to be bound by
         (kill-buffer buf))
       (ignore-errors (delete-file tmpfile)))))
 
+(auto-revert--deftest-remote auto-revert-test04-auto-revert-mode-dired
+  "Check remote autorevert for dired.")
+
+(defun auto-revert-test--write-file (string file)
+  "Write STRING to FILE."
+  (write-region string nil file nil 'no-message))
+
+(defun auto-revert-test--buffer-string (buffer)
+  "Contents of BUFFER as a string."
+  (with-current-buffer buffer
+    (buffer-string)))
+
+(defun auto-revert-test--wait-for (pred max-wait)
+  "Wait until PRED is true, or MAX-WAIT seconds elapsed."
+  (let ((ct (current-time)))
+    (while (and (< (float-time (time-subtract (current-time) ct)) max-wait)
+                (not (funcall pred)))
+      (read-event nil nil 0.1))))
+
+(defun auto-revert-test--wait-for-buffer-text (buffer string max-wait)
+  "Wait until BUFFER has the contents STRING, or MAX-WAIT seconds elapsed."
+  (auto-revert-test--wait-for
+   (lambda () (string-equal (auto-revert-test--buffer-string buffer) string))
+   max-wait))
+
+(ert-deftest auto-revert-test05-global-notify ()
+  "Test `global-auto-revert-mode' without polling."
+  :tags '(:expensive-test)
+  (skip-unless (or file-notify--library
+                   (file-remote-p temporary-file-directory)))
+  (let* ((auto-revert-use-notify t)
+         (auto-revert-avoid-polling t)
+         (was-in-global-auto-revert-mode global-auto-revert-mode)
+         (file-1 (make-temp-file "global-auto-revert-test-1"))
+         (file-2 (make-temp-file "global-auto-revert-test-2"))
+         (file-3 (make-temp-file "global-auto-revert-test-3"))
+         (file-2b (concat file-2 "-b"))
+         buf-1 buf-2 buf-3)
+    (unwind-protect
+        (progn
+          (setq buf-1 (find-file-noselect file-1))
+          (setq buf-2 (find-file-noselect file-2))
+          (auto-revert-test--write-file "1-a" file-1)
+          (should (equal (auto-revert-test--buffer-string buf-1) ""))
+
+          (global-auto-revert-mode 1)   ; Turn it on.
+
+          (should (buffer-local-value
+                   'auto-revert-notify-watch-descriptor buf-1))
+          (should (buffer-local-value
+                   'auto-revert-notify-watch-descriptor buf-2))
+
+          ;; buf-1 should have been reverted immediately when the mode
+          ;; was enabled.
+          (should (equal (auto-revert-test--buffer-string buf-1) "1-a"))
+
+          ;; Alter a file.
+          (auto-revert-test--write-file "2-a" file-2)
+          ;; Allow for some time to handle notification events.
+          (auto-revert-test--wait-for-buffer-text buf-2 "2-a" 1)
+          (should (equal (auto-revert-test--buffer-string buf-2) "2-a"))
+
+          ;; Visit a file, and modify it on disk.
+          (setq buf-3 (find-file-noselect file-3))
+          ;; Newly opened buffers won't be use notification until the
+          ;; first poll cycle; wait for it.
+          (auto-revert-test--wait-for
+           (lambda () (buffer-local-value
+                       'auto-revert-notify-watch-descriptor buf-3))
+           (+ auto-revert-interval 1))
+          (should (buffer-local-value
+                   'auto-revert-notify-watch-descriptor buf-3))
+          (auto-revert-test--write-file "3-a" file-3)
+          (auto-revert-test--wait-for-buffer-text buf-3 "3-a" 1)
+          (should (equal (auto-revert-test--buffer-string buf-3) "3-a"))
+
+          ;; Delete a visited file, and re-create it with new contents.
+          (delete-file file-1)
+          (sleep-for 0.5)
+          (should (equal (auto-revert-test--buffer-string buf-1) "1-a"))
+          (auto-revert-test--write-file "1-b" file-1)
+          (auto-revert-test--wait-for-buffer-text buf-1 "1-b"
+           (+ auto-revert-interval 1))
+          (should (buffer-local-value
+                   'auto-revert-notify-watch-descriptor buf-1))
+
+          ;; Write a buffer to a new file, then modify the new file on disk.
+          (with-current-buffer buf-2
+            (write-file file-2b))
+          (should (equal (auto-revert-test--buffer-string buf-2) "2-a"))
+          (auto-revert-test--write-file "2-b" file-2b)
+          (auto-revert-test--wait-for-buffer-text buf-2 "2-b"
+           (+ auto-revert-interval 1))
+          (should (buffer-local-value
+                   'auto-revert-notify-watch-descriptor buf-2)))
+
+      ;; Clean up.
+      (unless was-in-global-auto-revert-mode
+        (global-auto-revert-mode 0))    ; Turn it off.
+      (dolist (buf (list buf-1 buf-2 buf-3))
+        (ignore-errors (kill-buffer buf)))
+      (dolist (file (list file-1 file-2 file-2b file-3))
+        (ignore-errors (delete-file file)))
+      )))
+
+(auto-revert--deftest-remote auto-revert-test04-auto-revert-mode-dired
+  "Test `global-auto-revert-mode' without polling for remote buffers.")
+
 (defun auto-revert-test-all (&optional interactive)
   "Run all tests for \\[auto-revert]."
   (interactive "p")
diff --git a/test/lisp/char-fold-tests.el b/test/lisp/char-fold-tests.el
index 8a647bd076..8a7414084b 100644
--- a/test/lisp/char-fold-tests.el
+++ b/test/lisp/char-fold-tests.el
@@ -26,6 +26,24 @@
   (mapconcat (lambda (_) (string (+ 9 (random 117))))
              (make-list n nil) ""))
 
+(defun char-fold--ascii-upcase (string)
+  "Like `upcase' but acts on ASCII characters only."
+  (replace-regexp-in-string "[a-z]+" 'upcase string))
+
+(defun char-fold--ascii-downcase (string)
+  "Like `downcase' but acts on ASCII characters only."
+  (replace-regexp-in-string "[a-z]+" 'downcase string))
+
+(defun char-fold--test-match-exactly (string &rest strings-to-match)
+  (let ((re (concat "\\`" (char-fold-to-regexp string) "\\'")))
+    (dolist (it strings-to-match)
+      (should (string-match re it)))
+    ;; Case folding
+    (let ((case-fold-search t))
+      (dolist (it strings-to-match)
+        (should (string-match (char-fold--ascii-upcase re) (downcase it)))
+        (should (string-match (char-fold--ascii-downcase re) (upcase it)))))))
+
 (defun char-fold--test-search-with-contents (contents string)
   (with-temp-buffer
     (insert contents)
@@ -54,25 +72,7 @@
        (concat w1 "\s\n\s\t\f\t\n\r\t" w2)
        (concat w1 (make-string 10 ?\s) w2)))))
 
-(defun char-fold--ascii-upcase (string)
-  "Like `upcase' but acts on ASCII characters only."
-  (replace-regexp-in-string "[a-z]+" 'upcase string))
-
-(defun char-fold--ascii-downcase (string)
-  "Like `downcase' but acts on ASCII characters only."
-  (replace-regexp-in-string "[a-z]+" 'downcase string))
-
-(defun char-fold--test-match-exactly (string &rest strings-to-match)
-  (let ((re (concat "\\`" (char-fold-to-regexp string) "\\'")))
-    (dolist (it strings-to-match)
-      (should (string-match re it)))
-    ;; Case folding
-    (let ((case-fold-search t))
-      (dolist (it strings-to-match)
-        (should (string-match (char-fold--ascii-upcase re) (downcase it)))
-        (should (string-match (char-fold--ascii-downcase re) (upcase it)))))))
-
-(ert-deftest char-fold--test-some-defaults ()
+(ert-deftest char-fold--test-multi-defaults ()
   (dolist (it '(("ffl" . "ﬄ") ("ffi" . "ﬃ")
                 ("fi" . "ﬁ") ("ff" . "ﬀ")
                 ("ä" . "ä")))
@@ -109,9 +109,7 @@
 (ert-deftest char-fold--speed-test ()
   (dolist (string (append '("tty-set-up-initial-frame-face"
                             "tty-set-up-initial-frame-face-frame-faceframe-faceframe-faceframe-face")
-                          (mapcar #'char-fold--random-word '(10 50 100
-                                                                     50 100))))
-    (message "Testing %s" string)
+                          (mapcar #'char-fold--random-word '(10 50 100 50 100))))
     ;; Make sure we didn't just fallback on the trivial search.
     (should-not (string= (regexp-quote string)
                          (char-fold-to-regexp string)))
@@ -126,5 +124,13 @@
         ;; Ensure it took less than a second.
         (should (< (- (time-to-seconds) time) 1))))))
 
+(ert-deftest char-fold--test-bug-35802 ()
+  (let* ((char-code-property-alist      ; initial value
+          (cons '(decomposition . "uni-decomposition.el")
+                char-code-property-alist))
+         (search-spaces-regexp "\\(\\s-\\|\n\\)+")
+         (char-fold-table (char-fold-make-table)))
+    (char-fold--test-match-exactly "ä" "ä")))
+
 (provide 'char-fold-tests)
 ;;; char-fold-tests.el ends here
diff --git a/test/lisp/comint-tests.el b/test/lisp/comint-tests.el
index 49e59c526f..0d2d648bba 100644
--- a/test/lisp/comint-tests.el
+++ b/test/lisp/comint-tests.el
@@ -39,6 +39,7 @@
     "[sudo] user 的密码：" ; localized
     "Password (again):"
     "Enter password:"
+    "Enter Auth Password:" ; OpenVPN (Bug#35724)
     "Mot de Passe :" ; localized (Bug#29729)
     "Passwort:") ; localized
   "List of strings that should match `comint-password-prompt-regexp'.")
diff --git a/test/lisp/delim-col-tests.el b/test/lisp/delim-col-tests.el
new file mode 100644
index 0000000000..f2a0377b07
--- /dev/null
+++ b/test/lisp/delim-col-tests.el
@@ -0,0 +1,181 @@
+;;; delim-col-tests.el --- Tests for delim-col.el  -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Stefan Kangas <stefankangas@gmail.com>
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;; Code:
+
+(require 'ert)
+(require 'delim-col)
+
+(ert-deftest delim-col-tests-delimit-columns ()
+  (with-temp-buffer
+    (insert "a	b	c\n")
+    (delimit-columns-region (point-min) (point-max))
+    (should (equal (buffer-string) "a, b, c\n")))
+  (with-temp-buffer
+    (insert "a	b	c	d\n"
+            "aaaa	bb	ccc	ddddd\n"
+            "aaa	bbb	cccc	dddd\n"
+            "aa	bb	ccccccc	ddd\n")
+    (delimit-columns-region (point-min) (point-max))
+    (should (equal (buffer-string)
+                   (concat "a,    b,   c,       d    \n"
+                           "aaaa, bb,  ccc,     ddddd\n"
+                           "aaa,  bbb, cccc,    dddd \n"
+                           "aa,   bb,  ccccccc, ddd  \n")))))
+
+(ert-deftest delim-col-tests-delimit-rectangle ()
+  (with-temp-buffer
+    (insert "a	b	c	d\n"
+            "aaaa	bb	ccc	ddddd\n"
+            "aaa	bbb	cccc	dddd\n"
+            "aa	bb	ccccccc	ddd\n")
+    (delimit-columns-rectangle 3 58) ; from first b to last c
+    (should (equal (buffer-string)
+                   (concat "a	b,   c      	d\n"
+                           "aaaa	bb,  ccc    	ddddd\n"
+                           "aaa	bbb, cccc   	dddd\n"
+                           "aa	bb,  ccccccc	ddd\n")))))
+
+(ert-deftest delim-col-tests-delimit-columns-str-separator ()
+  (let ((delimit-columns-str-separator ":"))
+    (with-temp-buffer
+      (insert "a	b\n")
+      (delimit-columns-region (point-min) (point-max))
+      (should (equal (buffer-string) "a:b\n")))
+    (with-temp-buffer
+      (insert "a	b	c	d\n"
+              "aa	bb	cc	dd\n")
+      (delimit-columns-rectangle 3 16) ; from first b to last c
+      (should (equal (buffer-string)
+                     (concat "a	b: c	d\n"
+                             "aa	bb:cc	dd\n"))))))
+
+(ert-deftest delim-col-tests-delimit-columns-str-before-after ()
+  (let ((delimit-columns-str-before "[ ")
+        (delimit-columns-str-after " ]"))
+    (with-temp-buffer
+      (insert "a	b	c\n")
+      (delimit-columns-region (point-min) (point-max))
+      (should (equal (buffer-string) "[ a, b, c ]\n")))
+    (with-temp-buffer
+      (insert "a	b	c	d\n"
+              "aaaa	bb	ccc	ddddd\n"
+              "aaa	bbb	cccc	dddd\n"
+              "aa	bb	ccccccc	ddd\n")
+      (delimit-columns-region (point-min) (point-max))
+      (should (equal (buffer-string)
+                     (concat "[ a,    b,   c,       d     ]\n"
+                             "[ aaaa, bb,  ccc,     ddddd ]\n"
+                             "[ aaa,  bbb, cccc,    dddd  ]\n"
+                             "[ aa,   bb,  ccccccc, ddd   ]\n"))))
+    (with-temp-buffer
+      (insert "a	b	c	d\n"
+              "aaaa	bb	ccc	ddddd\n"
+              "aaa	bbb	cccc	dddd\n"
+              "aa	bb	ccccccc	ddd\n")
+     (delimit-columns-rectangle 3 58)   ; from first b to last c
+     (should (equal (buffer-string)
+                    (concat "a	[ b,   c       ]	d\n"
+                            "aaaa	[ bb,  ccc     ]	ddddd\n"
+                            "aaa	[ bbb, cccc    ]	dddd\n"
+                            "aa	[ bb,  ccccccc ]	ddd\n"))))))
+
+(ert-deftest delim-col-tests-delimit-colummns-before-after ()
+  (let ((delimit-columns-before "<")
+        (delimit-columns-after ">"))
+    (with-temp-buffer
+      (insert "a	b\n")
+      (delimit-columns-region (point-min) (point-max))
+      (should (equal (buffer-string) "<a>, <b>\n")))
+    (with-temp-buffer
+      (insert "a	b	c	d\n"
+              "aa	bb	cc	dd\n")
+      (delimit-columns-rectangle 3 17)
+      (should (equal (buffer-string)
+                     (concat "a	<b>,  <c> 	d\n"
+                             "aa	<bb>, <cc>	dd\n"))))))
+
+(ert-deftest delim-col-tests-delimit-columns-separator ()
+  (let ((delimit-columns-separator ","))
+    (with-temp-buffer
+      (insert "a,b,c\n")
+      (delimit-columns-region (point-min) (point-max))
+      (should (equal (buffer-string) "a, b, c\n")))))
+
+(ert-deftest delim-col-tests-delimit-columns-format/nil ()
+  (let ((delimit-columns-format nil))
+    (with-temp-buffer
+      (insert "a	b\n"
+              "aa	bb\n")
+      (delimit-columns-region (point-min) (point-max))
+      (should (equal (buffer-string)
+                     (concat "a, b\n"
+                             "aa, bb\n"))))
+    (with-temp-buffer
+      (insert "a	b	c	d\n"
+              "aa	bb	cc	dd\n")
+      (delimit-columns-rectangle 3 17) ; from first b to last c
+      (should (equal (buffer-string)
+                     (concat "a	b, c	d\n"
+                             "aa	bb, cc	dd\n"))))))
+
+(ert-deftest delim-col-tests-delimit-columns-format/separator ()
+  (let ((delimit-columns-format 'separator)
+        (delimit-columns-before "<")
+        (delimit-columns-after ">"))
+    (with-temp-buffer
+      (insert "a	b\n"
+              "aa	bb\n")
+      (delimit-columns-region (point-min) (point-max))
+      (should (equal (buffer-string)
+                     (concat "<a> , <b> \n"
+                             "<aa>, <bb>\n"))))
+    (with-temp-buffer
+      (insert "a	b	c	d\n"
+              "aa	bb	cc	dd\n")
+      (delimit-columns-rectangle 3 17) ; from first b to last c
+      (should (equal (buffer-string)
+                     (concat "a	<b> , <c> 	d\n"
+                             "aa	<bb>, <cc>	dd\n"))))))
+
+(ert-deftest delim-col-tests-delimit-columns-format/padding ()
+  (let ((delimit-columns-format 'padding)
+        (delimit-columns-before "<")
+        (delimit-columns-after ">"))
+    (with-temp-buffer
+      (insert "a	b\n"
+              "aa	bb\n")
+      (delimit-columns-region (point-min) (point-max))
+      (should (equal (buffer-string)
+                     (concat "<a >, <b >\n"
+                             "<aa>, <bb>\n"))))
+    (with-temp-buffer
+      (insert "a	b	c	d\n"
+              "aa	bb	cc	dd\n")
+      (delimit-columns-rectangle 3 17)  ; from first b to last c
+      (should (equal (buffer-string)
+                     (concat "a	<b >, <c >	d\n"
+                             "aa	<bb>, <cc>	dd\n"))))))
+
+(provide 'delim-col-tests)
+;;; delim-col-tests.el ends here
diff --git a/test/lisp/descr-text-tests.el b/test/lisp/descr-text-tests.el
index 09daddee25..d4544c99cf 100644
--- a/test/lisp/descr-text-tests.el
+++ b/test/lisp/descr-text-tests.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2014, 2016-2019 Free Software Foundation, Inc.
 
-;; Author:     Michal Nazarewicz <mina86@mina86.com>
+;; Author: Michal Nazarewicz <mina86@mina86.com>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/test/lisp/emacs-lisp/bytecomp-tests.el b/test/lisp/emacs-lisp/bytecomp-tests.el
index f66a06bc1b..f45c9209c1 100644
--- a/test/lisp/emacs-lisp/bytecomp-tests.el
+++ b/test/lisp/emacs-lisp/bytecomp-tests.el
@@ -27,6 +27,7 @@
 
 (require 'ert)
 (require 'cl-lib)
+(require 'subr-x)
 (require 'bytecomp)
 
 ;;; Code:
@@ -296,7 +297,21 @@
        ((eq variable 'default)
 	(message "equal"))
        (t
-	(message "not equal")))))
+	(message "not equal"))))
+    ;; Bug#35770
+    (let ((x 'a)) (cond ((eq x 'a) 'correct)
+                        ((eq x 'b) 'incorrect)
+                        ((eq x 'a) 'incorrect)
+                        ((eq x 'c) 'incorrect)))
+    (let ((x #x10000000000000000))
+      (cond ((eql x #x10000000000000000) 'correct)
+            ((eql x #x10000000000000001) 'incorrect)
+            ((eql x #x10000000000000000) 'incorrect)
+            ((eql x #x10000000000000002) 'incorrect)))
+    (let ((x "a")) (cond ((equal x "a") 'correct)
+                         ((equal x "b") 'incorrect)
+                         ((equal x "a") 'incorrect)
+                         ((equal x "c") 'incorrect))))
   "List of expression for test.
 Each element will be executed by interpreter and with
 bytecompiled code, and their results compared.")
@@ -441,6 +456,20 @@ Subtests signal errors if something goes wrong."
     ;; Should not warn that mt--test2 is not known to be defined.
     (should-not (re-search-forward "my--test2" nil t))))
 
+(ert-deftest bytecomp-warn-wrong-args ()
+  (with-current-buffer (get-buffer-create "*Compile-Log*")
+    (let ((inhibit-read-only t)) (erase-buffer))
+    (byte-compile '(remq 1 2 3))
+    (ert-info ((buffer-string) :prefix "buffer: ")
+      (should (re-search-forward "remq.*3.*2")))))
+
+(ert-deftest bytecomp-warn-wrong-args-subr ()
+  (with-current-buffer (get-buffer-create "*Compile-Log*")
+    (let ((inhibit-read-only t)) (erase-buffer))
+    (byte-compile '(safe-length 1 2 3))
+    (ert-info ((buffer-string) :prefix "buffer: ")
+      (should (re-search-forward "safe-length.*3.*1")))))
+
 (ert-deftest test-eager-load-macro-expansion ()
   (test-byte-comp-compile-and-load nil
     '(progn (defmacro abc (arg) 1) (defun def () (abc 2))))
@@ -540,7 +569,9 @@ literals (Bug#20852)."
         (should (equal (cdr err)
                        (list (concat "unescaped character literals "
                                      "`?\"', `?(', `?)', `?;', `?[', `?]' "
-                                     "detected!"))))))))
+                                     "detected, "
+                                     "`?\\\"', `?\\(', `?\\)', `?\\;', `?\\[', "
+                                     "`?\\]' expected!"))))))))
 
 (ert-deftest bytecomp-tests--old-style-backquotes ()
   "Check that byte compiling warns about old-style backquotes."
@@ -611,6 +642,44 @@ literals (Bug#20852)."
       (if (buffer-live-p byte-compile-log-buffer)
           (kill-buffer byte-compile-log-buffer)))))
 
+(ert-deftest bytecomp-test--switch-duplicates ()
+  "Check that duplicates in switches are eliminated correctly (bug#35770)."
+  (dolist (params
+           '(((lambda (x)
+                (cond ((eq x 'a) 111)
+                      ((eq x 'b) 222)
+                      ((eq x 'a) 333)
+                      ((eq x 'c) 444)))
+              (a b c)
+              string<)
+             ((lambda (x)
+                (cond ((eql x #x10000000000000000) 111)
+                      ((eql x #x10000000000000001) 222)
+                      ((eql x #x10000000000000000) 333)
+                      ((eql x #x10000000000000002) 444)))
+              (#x10000000000000000 #x10000000000000001 #x10000000000000002)
+              <)
+             ((lambda (x)
+                (cond ((equal x "a") 111)
+                      ((equal x "b") 222)
+                      ((equal x "a") 333)
+                      ((equal x "c") 444)))
+              ("a" "b" "c")
+              string<)))
+    (let* ((lisp (nth 0 params))
+           (keys (nth 1 params))
+           (lessp (nth 2 params))
+           (bc (byte-compile lisp))
+           (lap (byte-decompile-bytecode (aref bc 1) (aref bc 2)))
+           ;; Assume the first constant is the switch table.
+           (table (cadr (assq 'byte-constant lap))))
+      (should (hash-table-p table))
+      (should (equal (sort (hash-table-keys table) lessp) keys))
+      (should (member '(byte-constant 111) lap))
+      (should (member '(byte-constant 222) lap))
+      (should-not (member '(byte-constant 333) lap))
+      (should (member '(byte-constant 444) lap)))))
+
 ;; Local Variables:
 ;; no-byte-compile: t
 ;; End:
diff --git a/test/lisp/emacs-lisp/cl-macs-tests.el b/test/lisp/emacs-lisp/cl-macs-tests.el
index 989553bd7b..09ce660a2f 100644
--- a/test/lisp/emacs-lisp/cl-macs-tests.el
+++ b/test/lisp/emacs-lisp/cl-macs-tests.el
@@ -513,4 +513,21 @@ collection clause."
    (macroexpand '(cl-defstruct (hash-table (:predicate hash-table-p))))
    :type 'wrong-type-argument))
 
+(ert-deftest cl-macs-test--symbol-macrolet ()
+  ;; A `setq' shouldn't be converted to a `setf' just because it occurs within
+  ;; a symbol-macrolet!
+  (should-error
+   ;; Use `eval' so the error is signaled when running the test rather than
+   ;; when macroexpanding it.
+   (eval '(let ((l (list 1))) (cl-symbol-macrolet ((x 1)) (setq (car l) 0)))))
+  ;; Make sure `gv-synthetic-place' isn't macro-expanded before `setf' gets to
+  ;; see its `gv-expander'.
+  (should (equal (let ((l '(0)))
+                   (let ((cl (car l)))
+                     (cl-symbol-macrolet
+                         ((p (gv-synthetic-place cl (lambda (v) `(setcar l ,v)))))
+                       (cl-incf p)))
+                   l)
+                 '(1))))
+
 ;;; cl-macs-tests.el ends here
diff --git a/test/lisp/emacs-lisp/cl-seq-tests.el b/test/lisp/emacs-lisp/cl-seq-tests.el
index 86288e99ca..6515eee9f2 100644
--- a/test/lisp/emacs-lisp/cl-seq-tests.el
+++ b/test/lisp/emacs-lisp/cl-seq-tests.el
@@ -302,6 +302,14 @@ Body are forms defining the test."
     (should (equal '(2 8) (last (cl-replace list list2) 2)))
     (should (equal '(1 1) (last (cl-fill list 1) 2)))))
 
+(ert-deftest cl-seq-bignum-eql ()
+  (let ((x (+ most-positive-fixnum 1))
+        (y (+ most-positive-fixnum 1)))
+    (let ((l (list y)))
+      (should (eq (cl-member x l) l)))
+    (let ((a (list (cons y 1) (cons 2 y))))
+      (should (eq (cl-assoc x a) (car a)))
+      (should (eq (cl-rassoc x a) (cadr a))))))
 
 (provide 'cl-seq-tests)
 ;;; cl-seq-tests.el ends here
diff --git a/test/lisp/emacs-lisp/eieio-tests/eieio-test-persist.el b/test/lisp/emacs-lisp/eieio-tests/eieio-test-persist.el
index 2820d16254..b105249c7c 100644
--- a/test/lisp/emacs-lisp/eieio-tests/eieio-test-persist.el
+++ b/test/lisp/emacs-lisp/eieio-tests/eieio-test-persist.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2011-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
@@ -274,7 +274,7 @@ persistent class.")
     :type vector
     :initarg :random-vector)))
 
-(ert-deftest eieio-test-persist-hash-and-vector ()
+(defun eieio-test-persist-hash-and-vector ()
   (let* ((jane (make-instance 'person :name "Jane"))
          (bob  (make-instance 'person :name "Bob"))
          (hans (make-instance 'person :name "Hans"))
@@ -294,10 +294,18 @@ persistent class.")
     (aset (car (slot-value class 'janitors)) 1 hans)
     (aset (nth 1 (slot-value class 'janitors)) 1 dierdre)
     (unwind-protect
-        ;; FIXME: This should not error.
-        (should-error (persist-test-save-and-compare class))
+        (persist-test-save-and-compare class)
       (delete-file (oref class file)))))
 
+(ert-deftest eieio-persist-hash-and-vector-backward-compatibility ()
+  (let ((eieio-backward-compatibility t)) ; The default.
+    (eieio-test-persist-hash-and-vector)))
+
+(ert-deftest eieio-persist-hash-and-vector-no-backward-compatibility ()
+  :expected-result :failed ;; Bug#29220.
+  (let ((eieio-backward-compatibility nil))
+    (eieio-test-persist-hash-and-vector)))
+
 ;; Extra quotation of lists inside other objects (Gnus registry), also
 ;; bug#29220.
 
@@ -312,7 +320,7 @@ persistent class.")
     :initarg :htab
     :type hash-table)))
 
-(ert-deftest eieio-test-persist-interior-lists ()
+(defun eieio-test-persist-interior-lists ()
   (let* ((thing (make-instance
                  'eieio-container
                  :vec [nil]
@@ -332,8 +340,16 @@ persistent class.")
     (setf (nth 2 (cadar alst)) john
           (nth 2 (cadadr alst)) alexie)
     (unwind-protect
-        ;; FIXME: Should not error.
-        (should-error (persist-test-save-and-compare thing))
+        (persist-test-save-and-compare thing)
       (delete-file (slot-value thing 'file)))))
 
+(ert-deftest eieio-test-persist-interior-lists-backward-compatibility ()
+  (let ((eieio-backward-compatibility t)) ; The default.
+    (eieio-test-persist-interior-lists)))
+
+(ert-deftest eieio-test-persist-interior-lists-no-backward-compatibility ()
+  :expected-result :failed ;; Bug#29220.
+  (let ((eieio-backward-compatibility nil))
+    (eieio-test-persist-interior-lists)))
+
 ;;; eieio-test-persist.el ends here
diff --git a/test/lisp/emacs-lisp/eieio-tests/eieio-tests.el b/test/lisp/emacs-lisp/eieio-tests/eieio-tests.el
index ea6df0f36f..e6a35c4cd7 100644
--- a/test/lisp/emacs-lisp/eieio-tests/eieio-tests.el
+++ b/test/lisp/emacs-lisp/eieio-tests/eieio-tests.el
@@ -696,6 +696,17 @@ Do not override for `prot-2'."
   (setq eitest-II3 (clone eitest-II2 "eitest-II3 Test."))
   (oset eitest-II3 slot3 'penguin)
 
+  ;; Test that slots are non-initialized slots are unbounded
+  (oref eitest-II2 slot1)
+  (should (slot-boundp eitest-II2 'slot1))
+  (should-not (slot-boundp eitest-II2 'slot2))
+  (should-not (slot-boundp eitest-II2 'slot3))
+  (should-not (slot-boundp eitest-II3 'slot2))
+  (should-not (slot-boundp eitest-II3 'slot1))
+  (should-not (slot-boundp eitest-II3 'slot2))
+  (should (eieio-instance-inheritor-slot-boundp eitest-II3 'slot2))
+  (should (slot-boundp eitest-II3 'slot3))
+
   ;; Test level 1 inheritance
   (should (eq (oref eitest-II3 slot1) 'moose))
   ;; Test level 2 inheritance
@@ -862,8 +873,7 @@ Subclasses to override slot attributes.")
     (should (oref obj1 a-slot))))
 
 (defclass NAMED (eieio-named)
-  ((some-slot :initform nil)
-   )
+  ((some-slot :initform nil))
   "A class inheriting from eieio-named.")
 
 (ert-deftest eieio-test-35-named-object ()
@@ -902,6 +912,48 @@ Subclasses to override slot attributes.")
   (should
    (fboundp 'eieio--defalias)))
 
+(ert-deftest eieio-test-38-clone-named-object ()
+  (let* ((A (NAMED :object-name "aa"))
+         (B (clone A :object-name "bb"))
+         (C (clone A "cc"))
+         (D (clone A))
+         (E (clone D)))
+    (should (string= "aa" (oref A object-name)))
+    (should (string= "bb" (oref B object-name)))
+    (should (string= "cc" (oref C object-name)))
+    (should (string= "aa-1" (oref D object-name)))
+    (should (string= "aa-2" (oref E object-name)))))
+
+(defclass TII (eieio-instance-inheritor)
+  ((a :initform 1 :initarg :a)
+   (b :initarg :b)
+   (c :initarg :c))
+  "Instance Inheritor test class.")
+
+(ert-deftest eieio-test-39-clone-instance-inheritor-with-args ()
+  (let* ((A (TII))
+         (B (clone A :b "bb"))
+         (C (clone B :a "aa")))
+
+    (should (string= "aa" (oref C :a)))
+    (should (string= "bb" (oref C :b)))
+
+    (should (slot-boundp A :a))
+    (should-not (slot-boundp A :b))
+    (should-not (slot-boundp A :c))
+
+    (should-not (slot-boundp B :a))
+    (should (slot-boundp B :b))
+    (should-not (slot-boundp A :c))
+
+    (should (slot-boundp C :a))
+    (should-not (slot-boundp C :b))
+    (should-not (slot-boundp C :c))
+
+    (should (eieio-instance-inheritor-slot-boundp C :a))
+    (should (eieio-instance-inheritor-slot-boundp C :b))
+    (should-not (eieio-instance-inheritor-slot-boundp C :c))))
+
 
 (provide 'eieio-tests)
 
diff --git a/test/lisp/emacs-lisp/lisp-mode-tests.el b/test/lisp/emacs-lisp/lisp-mode-tests.el
index a6370742ab..63632449ca 100644
--- a/test/lisp/emacs-lisp/lisp-mode-tests.el
+++ b/test/lisp/emacs-lisp/lisp-mode-tests.el
@@ -136,6 +136,34 @@ noindent\" 3
     (indent-sexp)
     (should (equal (buffer-string) "(())"))))
 
+(ert-deftest indent-sexp-stop-before-eol-comment ()
+  "`indent-sexp' shouldn't look for more sexps after an eol comment."
+  ;; See https://debbugs.gnu.org/35286.
+  (with-temp-buffer
+    (emacs-lisp-mode)
+    (let ((str "() ;;\n  x"))
+      (insert str)
+      (goto-char (point-min))
+      (indent-sexp)
+      ;; The "x" is in the next sexp, so it shouldn't get indented.
+      (should (equal (buffer-string) str)))))
+
+(ert-deftest indent-sexp-stop-before-eol-non-lisp ()
+  "`indent-sexp' shouldn't be too agressive in non-Lisp modes."
+  ;; See https://debbugs.gnu.org/35286#13.
+  (with-temp-buffer
+    (prolog-mode)
+    (let ((str "\
+x(H) -->
+    {y(H)}.
+a(A) -->
+    b(A)."))
+      (insert str)
+      (search-backward "{")
+      (indent-sexp)
+      ;; There's no line-spanning sexp, so nothing should be indented.
+      (should (equal (buffer-string) str)))))
+
 (ert-deftest lisp-indent-region ()
   "Test basics of `lisp-indent-region'."
   (with-temp-buffer
diff --git a/test/lisp/emacs-lisp/rmc-tests.el b/test/lisp/emacs-lisp/rmc-tests.el
index b20bfd4e0c..71c7835e20 100644
--- a/test/lisp/emacs-lisp/rmc-tests.el
+++ b/test/lisp/emacs-lisp/rmc-tests.el
@@ -31,7 +31,7 @@
 
 (ert-deftest test-read-multiple-choice ()
   (dolist (char '(?y ?n))
-    (cl-letf* (((symbol-function #'read-char) (lambda () char))
+    (cl-letf* (((symbol-function #'read-event) (lambda () char))
                (str (if (eq char ?y) "yes" "no")))
       (should (equal (list char str)
                      (read-multiple-choice "Do it? " '((?y "yes") (?n "no"))))))))
diff --git a/test/lisp/emacs-lisp/rx-tests.el b/test/lisp/emacs-lisp/rx-tests.el
index 4a5919edf0..6f392d616d 100644
--- a/test/lisp/emacs-lisp/rx-tests.el
+++ b/test/lisp/emacs-lisp/rx-tests.el
@@ -107,7 +107,13 @@
                    "ab"))
     (should (equal (and (string-match (rx (or "a" "ab" "abc")) s)
                         (match-string 0 s))
-                   "a"))))
+                   "a")))
+  ;; Test zero-argument `or'.
+  (should (equal (rx (or)) regexp-unmatchable)))
+
+(ert-deftest rx-seq ()
+  ;; Test zero-argument `seq'.
+  (should (equal (rx (seq)) "")))
 
 (provide 'rx-tests)
 ;; rx-tests.el ends here.
diff --git a/test/lisp/filenotify-tests.el b/test/lisp/filenotify-tests.el
index 842d66d778..9dfa794e30 100644
--- a/test/lisp/filenotify-tests.el
+++ b/test/lisp/filenotify-tests.el
@@ -195,7 +195,8 @@ Return nil when any other file notification watch is still active."
         file-notify--test-events nil
         file-notify--test-monitors nil))
 
-(setq password-cache-expiry nil
+(setq file-notify-debug nil
+      password-cache-expiry nil
       tramp-verbose 0
       tramp-message-show-message nil)
 
@@ -261,13 +262,13 @@ This returns only for the local case and gfilenotify; otherwise it is nil.
                              (gfile-monitor-name file-notify--test-desc)))
           (cdr (assq file-notify--test-desc file-notify--test-monitors))))))
 
-(defmacro file-notify--deftest-remote (test docstring &optional expected skip)
-  "Define ert `TEST-remote' for remote files."
+(defmacro file-notify--deftest-remote (test docstring &optional unstable)
+  "Define ert `TEST-remote' for remote files.
+If UNSTABLE is non-nil, the test is tagged as `:unstable'."
   (declare (indent 1))
   `(ert-deftest ,(intern (concat (symbol-name test) "-remote")) ()
      ,docstring
-     :expected-result (or ,expected :passed)
-     :tags ,(if skip ''(:expensive-test :unstable) ''(:expensive-test))
+     :tags (if ,unstable '(:expensive-test :unstable) '(:expensive-test))
      (let* ((temporary-file-directory
 	     file-notify-test-remote-temporary-file-directory)
 	    (ert-test (ert-get-test ',test))
@@ -515,8 +516,9 @@ and the event to `file-notify--test-events'."
     (unless (string-match
 	     (regexp-quote ".#")
 	     (file-notify--event-file-name file-notify--test-event))
-      ;;(message "file-notify--test-event-handler result: %s event: %S"
-               ;;(null (ert-test-failed-p result)) file-notify--test-event)
+      (when file-notify-debug
+        (message "file-notify--test-event-handler result: %s event: %S"
+                 (null (ert-test-failed-p result)) file-notify--test-event))
       (setq file-notify--test-events
 	    (append file-notify--test-events `(,file-notify--test-event))
 	    file-notify--test-results
@@ -680,17 +682,18 @@ delivered."
 	       (file-notify--test-library) "gvfs-monitor-dir.exe")
 	      '((deleted stopped)
 		(created deleted stopped)))
-	     ;; There are two `deleted' events, for the file and for
-	     ;; the directory.  Except for cygwin and kqueue.  And
-	     ;; cygwin does not raise a `changed' event.
-	     ((eq system-type 'cygwin)
-	      '(created deleted stopped))
-	     ((string-equal (file-notify--test-library) "kqueue")
-	      '(created changed deleted stopped))
              ;; On emba, `deleted' and `stopped' events of the
              ;; directory are not detected.
              ((getenv "EMACS_EMBA_CI")
               '(created changed deleted))
+	     ;; There are two `deleted' events, for the file and for
+	     ;; the directory.  Except for cygwin, kqueue and remote
+	     ;; files.  And cygwin does not raise a `changed' event.
+	     ((eq system-type 'cygwin)
+	      '(created deleted stopped))
+	     ((or (string-equal (file-notify--test-library) "kqueue")
+		  (file-remote-p temporary-file-directory))
+	      '(created changed deleted stopped))
 	     (t '(created changed deleted deleted stopped)))
 	  (write-region
 	   "any text" nil file-notify--test-tmpfile nil 'no-message)
@@ -740,6 +743,9 @@ delivered."
              ;; directory are not detected.
              ((getenv "EMACS_EMBA_CI")
               '(created changed created changed deleted deleted))
+             ;; Remote files return two `deleted' events.
+	     ((file-remote-p temporary-file-directory)
+	      '(created changed created changed deleted deleted stopped))
 	     (t '(created changed created changed
 		  deleted deleted deleted stopped)))
 	  (write-region
@@ -784,18 +790,19 @@ delivered."
 	       (file-notify--test-library) "gvfs-monitor-dir.exe")
 	      '((deleted stopped)
 		(created deleted stopped)))
-	     ;; There are two `deleted' events, for the file and for
-	     ;; the directory.  Except for cygwin and kqueue.  And
-	     ;; cygwin raises `created' and `deleted' events instead
-	     ;; of a `renamed' event.
-	     ((eq system-type 'cygwin)
-	      '(created created deleted deleted stopped))
-	     ((string-equal (file-notify--test-library) "kqueue")
-	      '(created changed renamed deleted stopped))
              ;; On emba, `deleted' and `stopped' events of the
              ;; directory are not detected.
              ((getenv "EMACS_EMBA_CI")
               '(created changed renamed deleted))
+	     ;; There are two `deleted' events, for the file and for
+	     ;; the directory.  Except for cygwin, kqueue and remote
+	     ;; files.  And cygwin raises `created' and `deleted'
+	     ;; events instead of a `renamed' event.
+	     ((eq system-type 'cygwin)
+	      '(created created deleted deleted stopped))
+	     ((or (string-equal (file-notify--test-library) "kqueue")
+		  (file-remote-p temporary-file-directory))
+	      '(created changed renamed deleted stopped))
 	     (t '(created changed renamed deleted deleted stopped)))
 	  (write-region
 	   "any text" nil file-notify--test-tmpfile nil 'no-message)
@@ -1039,11 +1046,12 @@ delivered."
 	        '((deleted stopped)
 	          (created deleted stopped)))
 	       ;; There are two `deleted' events, for the file and for
-	       ;; the directory.  Except for cygwin and kqueue.  And
-	       ;; cygwin does not raise a `changed' event.
+	       ;; the directory.  Except for cygwin, kqueue and remote
+	       ;; files.  And cygwin does not raise a `changed' event.
 	       ((eq system-type 'cygwin)
 	        '(created deleted stopped))
-	       ((string-equal (file-notify--test-library) "kqueue")
+	       ((or (string-equal (file-notify--test-library) "kqueue")
+		    (file-remote-p temporary-file-directory))
 	        '(created changed deleted stopped))
 	       (t '(created changed deleted deleted stopped)))
 	    (write-region
@@ -1203,8 +1211,8 @@ delivered."
 
 ;; Unpredictable failures, eg https://hydra.nixos.org/build/86016286
 (file-notify--deftest-remote file-notify-test07-many-events
-   "Check that events are not dropped for remote directories."
-   :passed (getenv "EMACS_HYDRA_CI"))
+  "Check that events are not dropped for remote directories."
+  (getenv "EMACS_HYDRA_CI"))
 
 (ert-deftest file-notify-test08-backup ()
   "Check that backup keeps file notification."
@@ -1259,7 +1267,8 @@ delivered."
         (file-notify--test-with-events
             (cond
              ;; On cygwin we only get the `changed' event.
-             ((eq system-type 'cygwin) '(changed))
+             ((eq system-type 'cygwin)
+              '(changed))
              (t '(renamed created changed)))
           ;; The file is renamed when creating a backup.  It shall
           ;; still be watched.
@@ -1400,11 +1409,15 @@ the file watch."
                  (cond
 		  ;; w32notify does not raise `deleted' and `stopped'
 		  ;; events for the watched directory.
-                  ((string-equal (file-notify--test-library) "w32notify") '())
+                  ((string-equal (file-notify--test-library) "w32notify")
+                   '())
                   ;; On emba, `deleted' and `stopped' events of the
                   ;; directory are not detected.
                   ((getenv "EMACS_EMBA_CI")
                    '())
+                  ;; Remote files send just one `stopped' event.
+                  ((file-remote-p temporary-file-directory)
+                   '(stopped))
                   (t '(deleted stopped))))))
           (delete-directory file-notify--test-tmpfile 'recursive))
         (unless (getenv "EMACS_EMBA_CI")
@@ -1421,8 +1434,8 @@ the file watch."
     ;; Cleanup.
     (file-notify--test-cleanup)))
 
-;(file-notify--deftest-remote file-notify-test09-watched-file-in-watched-dir
-;  "Check `file-notify-test09-watched-file-in-watched-dir' for remote files.")
+(file-notify--deftest-remote file-notify-test09-watched-file-in-watched-dir
+  "Check `file-notify-test09-watched-file-in-watched-dir' for remote files." t)
 
 (ert-deftest file-notify-test10-sufficient-resources ()
   "Check that file notification does not use too many resources."
diff --git a/test/lisp/files-tests.el b/test/lisp/files-tests.el
index 57d8363ef9..fe2e958f1c 100644
--- a/test/lisp/files-tests.el
+++ b/test/lisp/files-tests.el
@@ -137,7 +137,7 @@ form.")
       (hack-local-variables)
       (eval (nth 2 test-settings)))))
 
-(ert-deftest files-test-local-variables ()
+(ert-deftest files-tests-local-variables ()
   "Test the file-local variables implementation."
   (cl-letf (((symbol-function 'hack-local-variables-confirm)
              (lambda (&rest _)
@@ -154,7 +154,7 @@ form.")
   (expand-file-name "data/files-bug18141.el.gz" (getenv "EMACS_TEST_DIRECTORY"))
   "Test file for bug#18141.")
 
-(ert-deftest files-test-bug-18141 ()
+(ert-deftest files-tests-bug-18141 ()
   "Test for https://debbugs.gnu.org/18141 ."
   (skip-unless (executable-find "gzip"))
   ;; If called interactively, environment variable
@@ -170,7 +170,7 @@ form.")
 	    (should (eq buffer-file-coding-system 'iso-2022-7bit-unix))))
       (delete-file tempfile))))
 
-(ert-deftest files-test-make-temp-file-empty-prefix ()
+(ert-deftest files-tests-make-temp-file-empty-prefix ()
   "Test make-temp-file with an empty prefix."
   (let ((tempfile (make-temp-file ""))
         (tempdir (make-temp-file "" t))
@@ -188,7 +188,7 @@ form.")
 ;; Stop the above "Local Var..." confusing Emacs.
 
 
-(ert-deftest files-test-bug-21454 ()
+(ert-deftest files-tests-bug-21454 ()
   "Test for https://debbugs.gnu.org/21454 ."
   :expected-result :failed
   (let ((input-result
@@ -216,7 +216,7 @@ form.")
       (setenv "FOO" foo-env)
       (setenv "BAR" bar-env))))
 
-(ert-deftest files-test--save-buffers-kill-emacs--confirm-kill-processes ()
+(ert-deftest files-tests-save-buffers-kill-emacs--confirm-kill-processes ()
   "Test that `save-buffers-kill-emacs' honors
 `confirm-kill-processes'."
   (cl-letf* ((yes-or-no-p-prompts nil)
@@ -239,7 +239,7 @@ form.")
     (should-not yes-or-no-p-prompts)
     (should (equal kill-emacs-args '(nil)))))
 
-(ert-deftest files-test-read-file-in-~ ()
+(ert-deftest files-tests-read-file-in-~ ()
   "Test file prompting in directory named '~'.
 If we are in a directory named '~', the default value should not
 be $HOME."
@@ -278,7 +278,7 @@ be $HOME."
                    (file-name-unquote
                     (file-name-unquote temporary-file-directory))))))
 
-(ert-deftest files-tests--file-name-non-special--subprocess ()
+(ert-deftest files-tests-file-name-non-special--subprocess ()
   "Check that Bug#25949 is fixed."
   (skip-unless (executable-find "true"))
   (let ((default-directory (file-name-quote temporary-file-directory)))
@@ -306,7 +306,7 @@ be $HOME."
          (progn ,@body)
        (delete-file ,name))))
 
-(ert-deftest files-tests--file-name-non-special--buffers ()
+(ert-deftest files-tests-file-name-non-special--buffers ()
   "Check that Bug#25951 is fixed.
 We call `verify-visited-file-modtime' on a buffer visiting a file
 with a quoted name.  We use two different variants: first with
@@ -1119,7 +1119,7 @@ works as expected if the default directory is quoted."
                                     :command (list program "--version")
                                     :file-handler t)))))
 
-(ert-deftest files-tests--insert-directory-wildcard-in-dir-p ()
+(ert-deftest files-tests-insert-directory-wildcard-in-dir-p ()
   (let ((alist (list (cons "/home/user/*/.txt" (cons "/home/user/" "*/.txt"))
                      (cons "/home/user/.txt" nil)
                      (cons "/home/*/.txt" (cons "/home/" "*/.txt"))
@@ -1136,7 +1136,7 @@ works as expected if the default directory is quoted."
         (cdr path-res)
         (insert-directory-wildcard-in-dir-p (car path-res)))))))
 
-(ert-deftest files-tests--make-directory ()
+(ert-deftest files-tests-make-directory ()
   (let* ((dir (make-temp-file "files-mkdir-test" t))
 	 (dirname (file-name-as-directory dir))
 	 (file (concat dirname "file"))
@@ -1158,7 +1158,7 @@ works as expected if the default directory is quoted."
     (should-not (make-directory a/b t))
     (delete-directory dir 'recursive)))
 
-(ert-deftest files-test-no-file-write-contents ()
+(ert-deftest files-tests-no-file-write-contents ()
   "Test that `write-contents-functions' permits saving a file.
 Usually `basic-save-buffer' will prompt for a file name if the
 current buffer has none.  It should first call the functions in
@@ -1187,7 +1187,7 @@ name (Bug#28412)."
         (should (null (save-buffer)))
         (should (eq (buffer-size) 1))))))
 
-(ert-deftest files-tests--copy-directory ()
+(ert-deftest files-tests-copy-directory ()
   (let* ((dir (make-temp-file "files-mkdir-test" t))
 	 (dirname (file-name-as-directory dir))
 	 (source (concat dirname "source"))
@@ -1204,7 +1204,7 @@ name (Bug#28412)."
     (should (file-directory-p (concat (file-name-as-directory dest2) "a")))
     (delete-directory dir 'recursive)))
 
-(ert-deftest files-test-abbreviated-home-dir ()
+(ert-deftest files-tests-abbreviated-home-dir ()
   "Test that changing HOME does not confuse `abbreviate-file-name'.
 See <https://debbugs.gnu.org/19657#20>."
   (let* ((homedir temporary-file-directory)
@@ -1218,5 +1218,46 @@ See <https://debbugs.gnu.org/19657#20>."
                                     process-environment)))
     (should (equal old (file-truename (abbreviate-file-name testfile))))))
 
+(ert-deftest files-tests-executable-find ()
+  "Test that `executable-find' works also with a relative or remote PATH.
+See <https://debbugs.gnu.org/35241>."
+  (let ((tmpfile (make-temp-file "files-test" nil (car exec-suffixes))))
+    (unwind-protect
+        (progn
+          (set-file-modes tmpfile #o777)
+          (let ((exec-path `(,temporary-file-directory)))
+            (should
+             (equal tmpfile
+                    (executable-find (file-name-nondirectory tmpfile)))))
+          ;; An empty element of `exec-path' means `default-directory'.
+          (let ((default-directory temporary-file-directory)
+                (exec-path nil))
+            (should
+             (equal tmpfile
+                    (executable-find (file-name-nondirectory tmpfile)))))
+          ;; The remote file name shall be quoted, and handled like a
+          ;; non-existing directory.
+          (let ((default-directory "/ssh::")
+                (exec-path (append exec-path `("." ,temporary-file-directory))))
+            (should
+             (equal tmpfile
+                    (executable-find (file-name-nondirectory tmpfile))))))
+      (delete-file tmpfile))))
+
+(ert-deftest files-tests-dont-rewrite-precious-files ()
+  "Test that `file-precious-flag' forces files to be saved by
+renaming only, rather than modified in-place."
+  (let* ((temp-file-name (make-temp-file "files-tests"))
+         (advice (lambda (_start _end filename &rest _r)
+                   (should-not (string= filename temp-file-name)))))
+    (unwind-protect
+        (with-current-buffer (find-file-noselect temp-file-name)
+          (advice-add #'write-region :before advice)
+          (setq-local file-precious-flag t)
+          (insert "foobar")
+          (should (null (save-buffer))))
+      (ignore-errors (advice-remove #'write-region advice))
+      (ignore-errors (delete-file temp-file-name)))))
+
 (provide 'files-tests)
 ;;; files-tests.el ends here
diff --git a/test/lisp/font-lock-tests.el b/test/lisp/font-lock-tests.el
new file mode 100644
index 0000000000..5d127039ff
--- /dev/null
+++ b/test/lisp/font-lock-tests.el
@@ -0,0 +1,41 @@
+;;; font-lock-tests.el --- Test suite for font-lock. -*- lexical-binding: t -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Code:
+(require 'ert)
+
+(ert-deftest font-lock-test-append-anonymous-face ()
+  "Ensure `font-lock-append-text-property' does not splice anonymous faces."
+  (with-temp-buffer
+    (insert "foo")
+    (add-text-properties 1 3 '(face italic))
+    (font-lock-append-text-property 1 3 'face '(:strike-through t))
+    (should (equal (get-text-property 1 'face (current-buffer))
+                   '(italic (:strike-through t))))))
+
+(ert-deftest font-lock-test-prepend-anonymous-face ()
+  "Ensure `font-lock-prepend-text-property' does not splice anonymous faces."
+  (with-temp-buffer
+    (insert "foo")
+    (add-text-properties 1 3 '(face italic))
+    (font-lock-prepend-text-property 1 3 'face '(:strike-through t))
+    (should (equal (get-text-property 1 'face (current-buffer))
+                   '((:strike-through t) italic)))))
+
+;; font-lock-tests.el ends here
diff --git a/test/lisp/ido-tests.el b/test/lisp/ido-tests.el
index cb8f1d6306..c9736eb3ec 100644
--- a/test/lisp/ido-tests.el
+++ b/test/lisp/ido-tests.el
@@ -25,6 +25,8 @@
 
 ;;; Code:
 
+(require 'ido)
+
 (ert-deftest ido-tests--other-window-frame ()
   "Verifies that Bug#26360 is fixed."
   (should-not ido-mode)
@@ -44,4 +46,9 @@
         (should (commandp #'ido-display-buffer-other-frame)))
     (ido-mode 0)))
 
+(ert-deftest ido-directory-too-big-p ()
+  (should-not (ido-directory-too-big-p "/some/dir/"))
+  (let ((ido-big-directories (cons (rx "me/di") ido-big-directories)))
+    (should (ido-directory-too-big-p "/some/dir/"))))
+
 ;;; ido-tests.el ends here
diff --git a/test/lisp/image-file-tests.el b/test/lisp/image-file-tests.el
new file mode 100644
index 0000000000..b3676d1f02
--- /dev/null
+++ b/test/lisp/image-file-tests.el
@@ -0,0 +1,44 @@
+;;; image-file-tests.el --- Test suite for image-files  -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;; Code:
+
+(require 'ert)
+(require 'image-file)
+
+(defconst image-file-tests-data-directory
+  (expand-file-name "data/image" (getenv "EMACS_TEST_DIRECTORY"))
+  "Directory containing image test data.")
+
+(ert-deftest insert-image-file ()
+  (skip-unless (image-type-available-p 'png))
+  (with-temp-buffer
+    (set-buffer-multibyte t)
+    (insert-image-file (expand-file-name "blank-100x200.png"
+                                         image-file-tests-data-directory))
+    (should (image--get-image)))
+  (with-temp-buffer
+    (set-buffer-multibyte nil)
+    (insert-image-file (expand-file-name "blank-100x200.png"
+                                         image-file-tests-data-directory))
+    (should (image--get-image))))
+
+;;; image-file-tests.el ends here
diff --git a/test/lisp/image-tests.el b/test/lisp/image-tests.el
new file mode 100644
index 0000000000..621646e575
--- /dev/null
+++ b/test/lisp/image-tests.el
@@ -0,0 +1,56 @@
+;;; image-tests.el --- tests for image.el -*- lexical-binding: t -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Code:
+
+(require 'ert)
+(require 'image)
+
+(defconst image-tests--emacs-images-directory
+  (expand-file-name "../etc/images" (getenv "EMACS_TEST_DIRECTORY"))
+  "Directory containing Emacs images.")
+
+(ert-deftest image--set-property ()
+  "Test `image--set-property' behavior."
+  (let ((image (list 'image)))
+    ;; Add properties.
+    (setf (image-property image :scale) 1)
+    (should (equal image '(image :scale 1)))
+    (setf (image-property image :width) 8)
+    (should (equal image '(image :scale 1 :width 8)))
+    (setf (image-property image :height) 16)
+    (should (equal image '(image :scale 1 :width 8 :height 16)))
+    ;; Delete properties.
+    (setf (image-property image :type) nil)
+    (should (equal image '(image :scale 1 :width 8 :height 16)))
+    (setf (image-property image :scale) nil)
+    (should (equal image '(image :width 8 :height 16)))
+    (setf (image-property image :height) nil)
+    (should (equal image '(image :width 8)))
+    (setf (image-property image :width) nil)
+    (should (equal image '(image)))))
+
+(ert-deftest image-type-from-file-header-test ()
+  "Test image-type-from-file-header."
+  (should (eq 'svg
+	      (image-type-from-file-header
+	       (expand-file-name "splash.svg"
+				 image-tests--emacs-images-directory)))))
+
+;;; image-tests.el ends here
diff --git a/test/lisp/international/mule-tests.el b/test/lisp/international/mule-tests.el
index 4c937caa14..678cbc2973 100644
--- a/test/lisp/international/mule-tests.el
+++ b/test/lisp/international/mule-tests.el
@@ -36,6 +36,10 @@
                      (find-auto-coding "" (buffer-size)))
                    '(utf-8 . :coding)))))
 
+(ert-deftest mule-cmds-tests--encode-ebcdic ()
+  (should (equal (encode-coding-char ?a 'ebcdic-int) "\201"))
+  (should (not (multibyte-string-p (encode-coding-char ?a 'utf-8)))))
+
 ;; Stop "Local Variables" above causing confusion when visiting this file.
 
 
diff --git a/test/lisp/jsonrpc-tests.el b/test/lisp/jsonrpc-tests.el
index 52f709f14c..f3e48739ce 100644
--- a/test/lisp/jsonrpc-tests.el
+++ b/test/lisp/jsonrpc-tests.el
@@ -3,7 +3,6 @@
 ;; Copyright (C) 2018-2019 Free Software Foundation, Inc.
 
 ;; Author: João Távora <joaotavora@gmail.com>
-;; Maintainer: João Távora <joaotavora@gmail.com>
 ;; Keywords: tests
 
 ;; This program is free software; you can redistribute it and/or modify
diff --git a/test/lisp/mail/footnote-tests.el b/test/lisp/mail/footnote-tests.el
new file mode 100644
index 0000000000..464443f403
--- /dev/null
+++ b/test/lisp/mail/footnote-tests.el
@@ -0,0 +1,47 @@
+;;; footnote-tests.el --- Tests for footnote-mode    -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019  Free Software Foundation, Inc.
+
+;; Author: Stefan Monnier <monnier@iro.umontreal.ca>
+;; Keywords:
+
+;; This program is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; This program is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;
+
+;;; Code:
+
+(ert-deftest footnote-tests-same-place ()
+  (with-temp-buffer
+    (footnote-mode 1)
+    (insert "hello world")
+    (beginning-of-line) (forward-word)
+    (footnote-add-footnote)
+    (insert "footnote")
+    (footnote-back-to-message)
+    (should (equal (buffer-substring (point-min) (point))
+                   "hello[1]"))
+    (beginning-of-line) (forward-word)
+    (footnote-add-footnote)
+    (insert "other footnote")
+    (footnote-back-to-message)
+    (should (equal (buffer-substring (point-min) (point))
+                   "hello[1]"))
+    (should (equal (buffer-substring (point-min) (line-end-position))
+                   "hello[1][2] world"))))
+
+(provide 'footnote-tests)
+;;; footnote-tests.el ends here
diff --git a/test/lisp/makesum-tests.el b/test/lisp/makesum-tests.el
new file mode 100644
index 0000000000..09661593c6
--- /dev/null
+++ b/test/lisp/makesum-tests.el
@@ -0,0 +1,58 @@
+;;; makesum-tests.el --- Tests for makesum.el  -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Simen Heggestøyl <simenheg@gmail.com>
+;; Keywords:
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;
+
+;;; Code:
+
+(require 'ert)
+(require 'makesum)
+
+(ert-deftest makesum-tests-double-column-even-lines ()
+  (with-temp-buffer
+    (insert "a\nb\nc\nd\ne\nf")
+    (double-column (point-min) (point-max))
+    (should (string-match-p "a[ \t]+d\nb[ \t]+e\nc[ \t]+f" (buffer-string)))))
+
+(ert-deftest makesum-tests-double-column-odd-lines ()
+  (with-temp-buffer
+    (insert "a\nb\nc\nd\ne")
+    (double-column (point-min) (point-max))
+    (should (string-match-p "a[ \t]+d\nb[ \t]+e\nc" (buffer-string)))))
+
+(ert-deftest makesum-tests-double-column-noop ()
+  (with-temp-buffer
+    (insert "foo")
+    (let ((prev-buffer-string (buffer-string)))
+      (double-column (point-min) (point-max))
+      (should (equal prev-buffer-string (buffer-string))))))
+
+(ert-deftest makesum-tests-double-column-partial ()
+  (with-temp-buffer
+    (insert "a\nb\nc\nd\ne\nf")
+    (double-column 3 10)
+    (should (string-match-p "a\nb[ \t]+d\nc[ \t]+e\nf" (buffer-string)))))
+
+(provide 'makesum-tests)
+;;; makesum-tests.el ends here
diff --git a/test/lisp/net/tramp-archive-tests.el b/test/lisp/net/tramp-archive-tests.el
index 454279e435..02fe8edf27 100644
--- a/test/lisp/net/tramp-archive-tests.el
+++ b/test/lisp/net/tramp-archive-tests.el
@@ -157,89 +157,93 @@ variables, so we check the Emacs version directly."
   "Check archive file name components."
   (skip-unless tramp-archive-enabled)
 
-  (with-parsed-tramp-archive-file-name tramp-archive-test-archive nil
-    (should (string-equal method tramp-archive-method))
-    (should-not user)
-    (should-not domain)
-    (should
-     (string-equal
-      host
-      (file-remote-p
-       (tramp-archive-gvfs-file-name tramp-archive-test-archive) 'host)))
-    (should
-     (string-equal
-      host
-      (url-hexify-string (concat "file://" tramp-archive-test-file-archive))))
-    (should-not port)
-    (should (string-equal localname "/"))
-    (should (string-equal archive tramp-archive-test-file-archive)))
-
-  ;; Localname.
-  (with-parsed-tramp-archive-file-name
-      (concat tramp-archive-test-archive "foo") nil
-    (should (string-equal method tramp-archive-method))
-    (should-not user)
-    (should-not domain)
-    (should
-     (string-equal
-      host
-      (file-remote-p
-       (tramp-archive-gvfs-file-name tramp-archive-test-archive) 'host)))
-   (should
-     (string-equal
-      host
-      (url-hexify-string (concat "file://" tramp-archive-test-file-archive))))
-    (should-not port)
-    (should (string-equal localname "/foo"))
-    (should (string-equal archive tramp-archive-test-file-archive)))
-
-  ;; File archive in file archive.
-  (let* ((tramp-archive-test-file-archive
-	  (concat tramp-archive-test-archive "baz.tar"))
-	 (tramp-archive-test-archive
-	  (file-name-as-directory tramp-archive-test-file-archive))
-	 (tramp-methods (cons `(,tramp-archive-method) tramp-methods))
-	 (tramp-gvfs-methods tramp-archive-all-gvfs-methods))
-    (unwind-protect
-	(with-parsed-tramp-archive-file-name
-	    (expand-file-name "bar" tramp-archive-test-archive) nil
-	  (should (string-equal method tramp-archive-method))
-	  (should-not user)
-	  (should-not domain)
-	  (should
-	   (string-equal
-	    host
-	    (file-remote-p
-	     (tramp-archive-gvfs-file-name tramp-archive-test-archive) 'host)))
-	  ;; We reimplement the logic of tramp-archive.el here.  Don't
-	  ;; know, whether it is worth the test.
-	  (should
-	   (string-equal
-	    host
-	    (url-hexify-string
-	     (concat
-	      (tramp-gvfs-url-file-name
-	       (tramp-make-tramp-file-name
-		tramp-archive-method
-		;; User and Domain.
-		nil nil
-		;; Host.
-		(url-hexify-string
-		 (concat
-		  "file://"
-		  ;; `directory-file-name' does not leave file archive
-		  ;; boundaries.  So we must cut the trailing slash
-		  ;; ourselves.
-		  (substring
-		   (file-name-directory tramp-archive-test-file-archive) 0 -1)))
-		nil "/"))
-	      (file-name-nondirectory tramp-archive-test-file-archive)))))
-	  (should-not port)
-	  (should (string-equal localname "/bar"))
-	  (should (string-equal archive tramp-archive-test-file-archive)))
+  ;; Suppress method name check.
+  (let ((non-essential t))
+    (with-parsed-tramp-archive-file-name tramp-archive-test-archive nil
+      (should (string-equal method tramp-archive-method))
+      (should-not user)
+      (should-not domain)
+      (should
+       (string-equal
+	host
+	(file-remote-p
+	 (tramp-archive-gvfs-file-name tramp-archive-test-archive) 'host)))
+      (should
+       (string-equal
+	host
+	(url-hexify-string (concat "file://" tramp-archive-test-file-archive))))
+      (should-not port)
+      (should (string-equal localname "/"))
+      (should (string-equal archive tramp-archive-test-file-archive)))
+
+    ;; Localname.
+    (with-parsed-tramp-archive-file-name
+	(concat tramp-archive-test-archive "foo") nil
+      (should (string-equal method tramp-archive-method))
+      (should-not user)
+      (should-not domain)
+      (should
+       (string-equal
+	host
+	(file-remote-p
+	 (tramp-archive-gvfs-file-name tramp-archive-test-archive) 'host)))
+      (should
+       (string-equal
+	host
+	(url-hexify-string (concat "file://" tramp-archive-test-file-archive))))
+      (should-not port)
+      (should (string-equal localname "/foo"))
+      (should (string-equal archive tramp-archive-test-file-archive)))
+
+    ;; File archive in file archive.
+    (let* ((tramp-archive-test-file-archive
+	    (concat tramp-archive-test-archive "baz.tar"))
+	   (tramp-archive-test-archive
+	    (file-name-as-directory tramp-archive-test-file-archive))
+	   (tramp-methods (cons `(,tramp-archive-method) tramp-methods))
+	   (tramp-gvfs-methods tramp-archive-all-gvfs-methods))
+      (unwind-protect
+	  (with-parsed-tramp-archive-file-name
+	      (expand-file-name "bar" tramp-archive-test-archive) nil
+	    (should (string-equal method tramp-archive-method))
+	    (should-not user)
+	    (should-not domain)
+	    (should
+	     (string-equal
+	      host
+	      (file-remote-p
+	       (tramp-archive-gvfs-file-name tramp-archive-test-archive)
+	       'host)))
+	    ;; We reimplement the logic of tramp-archive.el here.
+	    ;; Don't know, whether it is worth the test.
+	    (should
+	     (string-equal
+	      host
+	      (url-hexify-string
+	       (concat
+		(tramp-gvfs-url-file-name
+		 (tramp-make-tramp-file-name
+		  tramp-archive-method
+		  ;; User and Domain.
+		  nil nil
+		  ;; Host.
+		  (url-hexify-string
+		   (concat
+		    "file://"
+		    ;; `directory-file-name' does not leave file
+		    ;; archive boundaries.  So we must cut the
+		    ;; trailing slash ourselves.
+		    (substring
+		     (file-name-directory tramp-archive-test-file-archive)
+		     0 -1)))
+		  nil "/"))
+		(file-name-nondirectory tramp-archive-test-file-archive)))))
+	    (should-not port)
+	    (should (string-equal localname "/bar"))
+	    (should (string-equal archive tramp-archive-test-file-archive)))
 
-      ;; Cleanup.
-      (tramp-archive-cleanup-hash))))
+	;; Cleanup.
+	(tramp-archive-cleanup-hash)))))
 
 (ert-deftest tramp-archive-test05-expand-file-name ()
   "Check `expand-file-name'."
diff --git a/test/lisp/net/tramp-tests.el b/test/lisp/net/tramp-tests.el
index cc3200be94..38f9af230a 100644
--- a/test/lisp/net/tramp-tests.el
+++ b/test/lisp/net/tramp-tests.el
@@ -41,6 +41,7 @@
 
 ;;; Code:
 
+(require 'cl-lib)
 (require 'dired)
 (require 'ert)
 (require 'ert-x)
@@ -175,10 +176,9 @@ properly.  BODY shall not contain a timeout."
 	 (let ((tramp--test-instrument-test-case-p t)) ,@body)
        ;; Unwind forms.
        (when (and (null tramp--test-instrument-test-case-p) (> tramp-verbose 3))
-	 (with-parsed-tramp-file-name tramp-test-temporary-file-directory nil
-	   (with-current-buffer (tramp-get-connection-buffer v)
-	     (message "%s" (buffer-string)))
-	   (with-current-buffer (tramp-get-debug-buffer v)
+	 (dolist (buf (tramp-list-tramp-buffers))
+	   (message ";; %s" buf)
+	   (with-current-buffer buf
 	     (message "%s" (buffer-string))))))))
 
 (defsubst tramp--test-message (fmt-string &rest arguments)
@@ -411,15 +411,26 @@ properly.  BODY shall not contain a timeout."
 
 (ert-deftest tramp-test02-file-name-dissect ()
   "Check remote file name components."
+  ;; `user-error' has appeared in Emacs 24.3.
+  (skip-unless (fboundp 'user-error))
+
   (let ((tramp-default-method "default-method")
 	(tramp-default-user "default-user")
 	(tramp-default-host "default-host")
 	tramp-default-method-alist
 	tramp-default-user-alist
 	tramp-default-host-alist
+	;; Suppress method name check.
+	(non-essential t)
 	;; Suppress check for multihops.
 	(tramp-cache-data (make-hash-table :test #'equal))
 	(tramp-connection-properties '((nil "login-program" t))))
+    ;; An unknown method shall raise an error.
+    (let (non-essential)
+      (should-error
+       (expand-file-name "/method:user@host:")
+       :type 'user-error))
+
     ;; Expand `tramp-default-user' and `tramp-default-host'.
     (should (string-equal
 	     (file-remote-p "/method::")
@@ -526,7 +537,8 @@ properly.  BODY shall not contain a timeout."
     (should (string-equal
 	     (file-remote-p "/-:user@host#1234:" 'method) "default-method"))
     (should (string-equal (file-remote-p "/-:user@host#1234:" 'user) "user"))
-    (should (string-equal (file-remote-p "/-:user@host#1234:" 'host) "host#1234"))
+    (should (string-equal
+	     (file-remote-p "/-:user@host#1234:" 'host) "host#1234"))
     (should (string-equal (file-remote-p "/-:user@host#1234:" 'localname) ""))
     (should (string-equal (file-remote-p "/-:user@host#1234:" 'hop) nil))
 
@@ -562,7 +574,8 @@ properly.  BODY shall not contain a timeout."
     (should (string-equal
 	     (file-remote-p "/-:1.2.3.4:")
 	     (format "/%s:%s@%s:" "default-method" "default-user" "1.2.3.4")))
-    (should (string-equal (file-remote-p "/-:1.2.3.4:" 'method) "default-method"))
+    (should (string-equal
+	     (file-remote-p "/-:1.2.3.4:" 'method) "default-method"))
     (should (string-equal (file-remote-p "/-:1.2.3.4:" 'user) "default-user"))
     (should (string-equal (file-remote-p "/-:1.2.3.4:" 'host) "1.2.3.4"))
     (should (string-equal (file-remote-p "/-:1.2.3.4:" 'localname) ""))
@@ -851,11 +864,16 @@ properly.  BODY shall not contain a timeout."
 (ert-deftest tramp-test02-file-name-dissect-simplified ()
   "Check simplified file name components."
   :tags '(:expensive-test)
+  ;; `user-error' has appeared in Emacs 24.3.
+  (skip-unless (fboundp 'user-error))
+
   (let ((tramp-default-method "default-method")
 	(tramp-default-user "default-user")
 	(tramp-default-host "default-host")
 	tramp-default-user-alist
 	tramp-default-host-alist
+	;; Suppress method name check.
+	(non-essential t)
 	;; Suppress check for multihops.
 	(tramp-cache-data (make-hash-table :test #'equal))
 	(tramp-connection-properties '((nil "login-program" t)))
@@ -863,6 +881,12 @@ properly.  BODY shall not contain a timeout."
     (unwind-protect
 	(progn
 	  (tramp-change-syntax 'simplified)
+	  ;; An unknown default method shall raise an error.
+	  (let (non-essential)
+	    (should-error
+	     (expand-file-name "/user@host:")
+	     :type 'user-error))
+
 	  ;; Expand `tramp-default-method' and `tramp-default-user'.
 	  (should (string-equal
 		   (file-remote-p "/host:")
@@ -1174,12 +1198,17 @@ properly.  BODY shall not contain a timeout."
 (ert-deftest tramp-test02-file-name-dissect-separate ()
   "Check separate file name components."
   :tags '(:expensive-test)
+  ;; `user-error' has appeared in Emacs 24.3.
+  (skip-unless (fboundp 'user-error))
+
   (let ((tramp-default-method "default-method")
 	(tramp-default-user "default-user")
 	(tramp-default-host "default-host")
 	tramp-default-method-alist
 	tramp-default-user-alist
 	tramp-default-host-alist
+	;; Suppress method name check.
+	(non-essential t)
 	;; Suppress check for multihops.
 	(tramp-cache-data (make-hash-table :test #'equal))
 	(tramp-connection-properties '((nil "login-program" t)))
@@ -1187,6 +1216,12 @@ properly.  BODY shall not contain a timeout."
     (unwind-protect
 	(progn
 	  (tramp-change-syntax 'separate)
+	  ;; An unknown method shall raise an error.
+	  (let (non-essential)
+	    (should-error
+	     (expand-file-name "/[method/user@host]")
+	     :type 'user-error))
+
 	  ;; Expand `tramp-default-user' and `tramp-default-host'.
 	  (should (string-equal
 		   (file-remote-p "/[method/]")
@@ -1825,24 +1860,30 @@ properly.  BODY shall not contain a timeout."
 (ert-deftest tramp-test03-file-name-defaults ()
   "Check default values for some methods."
   ;; Default values in tramp-adb.el.
-  (should (string-equal (file-remote-p "/adb::" 'host) ""))
+  (when (assoc "adb" tramp-methods)
+    (should (string-equal (file-remote-p "/adb::" 'host) "")))
   ;; Default values in tramp-ftp.el.
-  (should (string-equal (file-remote-p "/-:ftp.host:" 'method) "ftp"))
-  (dolist (u '("ftp" "anonymous"))
-    (should (string-equal (file-remote-p (format "/-:%s@:" u) 'method) "ftp")))
+  (when (assoc "ftp" tramp-methods)
+    (should (string-equal (file-remote-p "/-:ftp.host:" 'method) "ftp"))
+    (dolist (u '("ftp" "anonymous"))
+      (should
+       (string-equal (file-remote-p (format "/-:%s@:" u) 'method) "ftp"))))
   ;; Default values in tramp-sh.el and tramp-sudoedit.el.
-  (dolist (h `("127.0.0.1" "[::1]" "localhost" "localhost6" ,(system-name)))
-    (should
-     (string-equal (file-remote-p (format "/-:root@%s:" h) 'method) "su")))
-  (dolist (m '("su" "sudo" "ksu" "doas" "sudoedit"))
-    (should (string-equal (file-remote-p (format "/%s::" m) 'user) "root"))
-    (should
-     (string-equal (file-remote-p (format "/%s::" m) 'host) (system-name))))
-  (dolist (m '("rcp" "remcp" "rsh" "telnet" "krlogin" "fcp" "nc"))
-    (should
-     (string-equal (file-remote-p (format "/%s::" m) 'user) (user-login-name))))
+  (when (assoc "su" tramp-methods)
+    (dolist (h `("127.0.0.1" "[::1]" "localhost" "localhost6" ,(system-name)))
+      (should
+       (string-equal (file-remote-p (format "/-:root@%s:" h) 'method) "su")))
+    (dolist (m '("su" "sudo" "ksu" "doas" "sudoedit"))
+      (should (string-equal (file-remote-p (format "/%s::" m) 'user) "root"))
+      (should
+       (string-equal (file-remote-p (format "/%s::" m) 'host) (system-name))))
+    (dolist (m '("rcp" "remcp" "rsh" "telnet" "krlogin" "fcp" "nc"))
+      (should
+       (string-equal
+	(file-remote-p (format "/%s::" m) 'user) (user-login-name)))))
   ;; Default values in tramp-smb.el.
-  (should (string-equal (file-remote-p "/smb::" 'user) nil)))
+  (when (assoc "smb" tramp-methods)
+    (should (string-equal (file-remote-p "/smb::" 'user) nil))))
 
 ;; The following test is inspired by Bug#30946.
 (ert-deftest tramp-test03-file-name-host-rules ()
@@ -1897,121 +1938,129 @@ properly.  BODY shall not contain a timeout."
 
 (ert-deftest tramp-test04-substitute-in-file-name ()
   "Check `substitute-in-file-name'."
-  (should (string-equal (substitute-in-file-name "/method:host:///foo") "/foo"))
-  (should
-   (string-equal
-    (substitute-in-file-name "/method:host://foo") "/method:host:/foo"))
-  (should
-   (string-equal (substitute-in-file-name "/method:host:/path///foo") "/foo"))
-  (should
-   (string-equal
-    (substitute-in-file-name "/method:host:/path//foo") "/method:host:/foo"))
-  ;; Quoting local part.
-  (should
-   (string-equal
-    (substitute-in-file-name "/method:host:/:///foo") "/method:host:/:///foo"))
-  (should
-   (string-equal
-    (substitute-in-file-name "/method:host:/://foo") "/method:host:/://foo"))
-  (should
-   (string-equal
-    (substitute-in-file-name "/method:host:/:/path///foo")
-    "/method:host:/:/path///foo"))
-  (should
-   (string-equal
-    (substitute-in-file-name "/method:host:/:/path//foo")
-    "/method:host:/:/path//foo"))
-
-  (should
-   (string-equal (substitute-in-file-name "/method:host://~foo") "/~foo"))
-  (should
-   (string-equal
-    (substitute-in-file-name "/method:host:/~foo") "/method:host:/~foo"))
-  (should
-   (string-equal (substitute-in-file-name "/method:host:/path//~foo") "/~foo"))
-  ;; (substitute-in-file-name "/path/~foo") expands only for a local
-  ;; user "foo" to "/~foo"".  Otherwise, it doesn't expand.
-  (should
-   (string-equal
-    (substitute-in-file-name
-     "/method:host:/path/~foo") "/method:host:/path/~foo"))
-  ;; Quoting local part.
-  (should
-   (string-equal
-    (substitute-in-file-name "/method:host:/://~foo") "/method:host:/://~foo"))
-  (should
-   (string-equal
-    (substitute-in-file-name "/method:host:/:/~foo") "/method:host:/:/~foo"))
-  (should
-   (string-equal
-    (substitute-in-file-name
-     "/method:host:/:/path//~foo") "/method:host:/:/path//~foo"))
-  (should
-   (string-equal
-    (substitute-in-file-name
-     "/method:host:/:/path/~foo") "/method:host:/:/path/~foo"))
+  ;; Suppress method name check.
+  (let ((tramp-methods (cons '("method") tramp-methods)))
+    (should
+     (string-equal (substitute-in-file-name "/method:host:///foo") "/foo"))
+    (should
+     (string-equal
+      (substitute-in-file-name "/method:host://foo") "/method:host:/foo"))
+    (should
+     (string-equal (substitute-in-file-name "/method:host:/path///foo") "/foo"))
+    (should
+     (string-equal
+      (substitute-in-file-name "/method:host:/path//foo") "/method:host:/foo"))
+    ;; Quoting local part.
+    (should
+     (string-equal
+      (substitute-in-file-name "/method:host:/:///foo")
+      "/method:host:/:///foo"))
+    (should
+     (string-equal
+      (substitute-in-file-name "/method:host:/://foo") "/method:host:/://foo"))
+    (should
+     (string-equal
+      (substitute-in-file-name "/method:host:/:/path///foo")
+      "/method:host:/:/path///foo"))
+    (should
+     (string-equal
+      (substitute-in-file-name "/method:host:/:/path//foo")
+      "/method:host:/:/path//foo"))
 
-  (let (process-environment)
+    (should
+     (string-equal (substitute-in-file-name "/method:host://~foo") "/~foo"))
     (should
      (string-equal
-      (substitute-in-file-name "/method:host:/path/$FOO")
-      "/method:host:/path/$FOO"))
-    (setenv "FOO" "bla")
+      (substitute-in-file-name "/method:host:/~foo") "/method:host:/~foo"))
     (should
      (string-equal
-      (substitute-in-file-name "/method:host:/path/$FOO")
-      "/method:host:/path/bla"))
+      (substitute-in-file-name "/method:host:/path//~foo") "/~foo"))
+    ;; (substitute-in-file-name "/path/~foo") expands only for a local
+    ;; user "foo" to "/~foo"".  Otherwise, it doesn't expand.
     (should
      (string-equal
-      (substitute-in-file-name "/method:host:/path/$$FOO")
-      "/method:host:/path/$FOO"))
+      (substitute-in-file-name
+       "/method:host:/path/~foo") "/method:host:/path/~foo"))
     ;; Quoting local part.
     (should
      (string-equal
-      (substitute-in-file-name "/method:host:/:/path/$FOO")
-      "/method:host:/:/path/$FOO"))
-    (setenv "FOO" "bla")
+      (substitute-in-file-name "/method:host:/://~foo")
+      "/method:host:/://~foo"))
+    (should
+     (string-equal
+      (substitute-in-file-name "/method:host:/:/~foo") "/method:host:/:/~foo"))
     (should
      (string-equal
-      (substitute-in-file-name "/method:host:/:/path/$FOO")
-      "/method:host:/:/path/$FOO"))
+      (substitute-in-file-name
+       "/method:host:/:/path//~foo") "/method:host:/:/path//~foo"))
     (should
      (string-equal
-      (substitute-in-file-name "/method:host:/:/path/$$FOO")
-      "/method:host:/:/path/$$FOO"))))
+      (substitute-in-file-name
+       "/method:host:/:/path/~foo") "/method:host:/:/path/~foo"))
+
+    (let (process-environment)
+      (should
+       (string-equal
+	(substitute-in-file-name "/method:host:/path/$FOO")
+	"/method:host:/path/$FOO"))
+      (setenv "FOO" "bla")
+      (should
+       (string-equal
+	(substitute-in-file-name "/method:host:/path/$FOO")
+	"/method:host:/path/bla"))
+      (should
+       (string-equal
+	(substitute-in-file-name "/method:host:/path/$$FOO")
+	"/method:host:/path/$FOO"))
+      ;; Quoting local part.
+      (should
+       (string-equal
+	(substitute-in-file-name "/method:host:/:/path/$FOO")
+	"/method:host:/:/path/$FOO"))
+      (setenv "FOO" "bla")
+      (should
+       (string-equal
+	(substitute-in-file-name "/method:host:/:/path/$FOO")
+	"/method:host:/:/path/$FOO"))
+      (should
+       (string-equal
+	(substitute-in-file-name "/method:host:/:/path/$$FOO")
+	"/method:host:/:/path/$$FOO")))))
 
 (ert-deftest tramp-test05-expand-file-name ()
   "Check `expand-file-name'."
-  (should
-   (string-equal
-    (expand-file-name "/method:host:/path/./file") "/method:host:/path/file"))
-  (should
-   (string-equal
-    (expand-file-name "/method:host:/path/../file") "/method:host:/file"))
-  (should
-   (string-equal
-    (expand-file-name "/method:host:/path/.") "/method:host:/path"))
-  (should
-   (string-equal
-    (expand-file-name "/method:host:/path/..") "/method:host:/"))
-  (should
-   (string-equal
-    (expand-file-name "." "/method:host:/path/") "/method:host:/path"))
-  (should
-   (string-equal
-    (expand-file-name "" "/method:host:/path/") "/method:host:/path"))
-  ;; Quoting local part.
-  (should
-   (string-equal
-    (expand-file-name "/method:host:/:/path/./file")
-    "/method:host:/:/path/file"))
-  (should
-   (string-equal
-    (expand-file-name "/method:host:/:/path/../file") "/method:host:/:/file"))
-  (should
-   (string-equal
-    (expand-file-name "/method:host:/:/~/path/./file")
-    "/method:host:/:/~/path/file")))
+  ;; Suppress method name check.
+  (let ((tramp-methods (cons '("method") tramp-methods)))
+    (should
+     (string-equal
+      (expand-file-name "/method:host:/path/./file") "/method:host:/path/file"))
+    (should
+     (string-equal
+      (expand-file-name "/method:host:/path/../file") "/method:host:/file"))
+    (should
+     (string-equal
+      (expand-file-name "/method:host:/path/.") "/method:host:/path"))
+    (should
+     (string-equal
+      (expand-file-name "/method:host:/path/..") "/method:host:/"))
+    (should
+     (string-equal
+      (expand-file-name "." "/method:host:/path/") "/method:host:/path"))
+    (should
+     (string-equal
+      (expand-file-name "" "/method:host:/path/") "/method:host:/path"))
+    ;; Quoting local part.
+    (should
+     (string-equal
+      (expand-file-name "/method:host:/:/path/./file")
+      "/method:host:/:/path/file"))
+    (should
+     (string-equal
+      (expand-file-name "/method:host:/:/path/../file") "/method:host:/:/file"))
+    (should
+     (string-equal
+      (expand-file-name "/method:host:/:/~/path/./file")
+      "/method:host:/:/~/path/file"))))
 
 ;; The following test is inspired by Bug#26911 and Bug#34834.  They
 ;; are rather bugs in `expand-file-name', and it fails for all Emacs
@@ -2041,48 +2090,51 @@ properly.  BODY shall not contain a timeout."
   "Check `directory-file-name'.
 This checks also `file-name-as-directory', `file-name-directory',
 `file-name-nondirectory' and `unhandled-file-name-directory'."
-  (should
-   (string-equal
-    (directory-file-name "/method:host:/path/to/file")
-    "/method:host:/path/to/file"))
-  (should
-   (string-equal
-    (directory-file-name "/method:host:/path/to/file/")
-    "/method:host:/path/to/file"))
-  (should
-   (string-equal
-    (directory-file-name "/method:host:/path/to/file//")
-    "/method:host:/path/to/file"))
-  (should
-   (string-equal
-    (file-name-as-directory "/method:host:/path/to/file")
-    "/method:host:/path/to/file/"))
-  (should
-   (string-equal
-    (file-name-as-directory "/method:host:/path/to/file/")
-    "/method:host:/path/to/file/"))
-  (should
-   (string-equal
-    (file-name-directory "/method:host:/path/to/file")
-    "/method:host:/path/to/"))
-  (should
-   (string-equal
-    (file-name-directory "/method:host:/path/to/file/")
-    "/method:host:/path/to/file/"))
-  (should
-   (string-equal (file-name-directory "/method:host:file") "/method:host:"))
-  (should
-   (string-equal
-    (file-name-directory "/method:host:path/") "/method:host:path/"))
-  (should
-   (string-equal
-    (file-name-directory "/method:host:path/to") "/method:host:path/"))
-  (should
-   (string-equal (file-name-nondirectory "/method:host:/path/to/file") "file"))
-  (should
-   (string-equal (file-name-nondirectory "/method:host:/path/to/file/") ""))
-  (should-not
-   (unhandled-file-name-directory "/method:host:/path/to/file"))
+  ;; Suppress method name check.
+  (let ((tramp-methods (cons '("method") tramp-methods)))
+    (should
+     (string-equal
+      (directory-file-name "/method:host:/path/to/file")
+      "/method:host:/path/to/file"))
+    (should
+     (string-equal
+      (directory-file-name "/method:host:/path/to/file/")
+      "/method:host:/path/to/file"))
+    (should
+     (string-equal
+      (directory-file-name "/method:host:/path/to/file//")
+      "/method:host:/path/to/file"))
+    (should
+     (string-equal
+      (file-name-as-directory "/method:host:/path/to/file")
+      "/method:host:/path/to/file/"))
+    (should
+     (string-equal
+      (file-name-as-directory "/method:host:/path/to/file/")
+      "/method:host:/path/to/file/"))
+    (should
+     (string-equal
+      (file-name-directory "/method:host:/path/to/file")
+      "/method:host:/path/to/"))
+    (should
+     (string-equal
+      (file-name-directory "/method:host:/path/to/file/")
+      "/method:host:/path/to/file/"))
+    (should
+     (string-equal (file-name-directory "/method:host:file") "/method:host:"))
+    (should
+     (string-equal
+      (file-name-directory "/method:host:path/") "/method:host:path/"))
+    (should
+     (string-equal
+      (file-name-directory "/method:host:path/to") "/method:host:path/"))
+    (should
+     (string-equal
+      (file-name-nondirectory "/method:host:/path/to/file") "file"))
+    (should
+     (string-equal (file-name-nondirectory "/method:host:/path/to/file/") ""))
+    (should-not
+     (unhandled-file-name-directory "/method:host:/path/to/file")))
 
   ;; Bug#10085.
   (when (tramp--test-enabled) ;; Packages like tramp-gvfs.el might be disabled.
@@ -2270,6 +2322,37 @@ This checks also `file-name-as-directory', `file-name-directory',
 	;; Cleanup.
 	(ignore-errors (delete-file tmp-name))))))
 
+;; The following test is inspired by Bug#35497.
+(ert-deftest tramp-test10-write-region-file-precious-flag ()
+  "Check that `file-precious-flag' is respected with Tramp in use."
+  (skip-unless (tramp--test-enabled))
+  (skip-unless (tramp--test-sh-p))
+  ;; The bug is fixed in Emacs 27.1.
+  (skip-unless (tramp--test-emacs27-p))
+
+  (let* ((tmp-name (tramp--test-make-temp-name))
+         written-files
+         (advice (lambda (_start _end filename &rest _r)
+                   (push filename written-files))))
+
+    (unwind-protect
+        (with-current-buffer (find-file-noselect tmp-name)
+          ;; Write initial contents.  Adapt `visited-file-modtime'
+          ;; in order to suppress confirmation.
+          (insert "foo")
+          (write-region nil nil tmp-name)
+          (set-visited-file-modtime)
+          ;; Run the test.
+          (advice-add 'write-region :before advice)
+          (setq-local file-precious-flag t)
+          (insert "bar")
+          (should (null (save-buffer)))
+          (should-not (cl-member tmp-name written-files :test #'string=)))
+
+      ;; Cleanup.
+      (ignore-errors (advice-remove 'write-region advice))
+      (ignore-errors (delete-file tmp-name)))))
+
 (ert-deftest tramp-test11-copy-file ()
   "Check `copy-file'."
   (skip-unless (tramp--test-enabled))
@@ -2762,7 +2845,9 @@ This tests also `file-directory-p' and `file-accessible-directory-p'."
 	    ;; returns `file-missing'.
 	    (delete-directory tmp-name1 'recursive)
 	    (with-temp-buffer
-	      (should-error (insert-directory tmp-name1 nil))))
+	      (should-error
+	       (insert-directory tmp-name1 nil)
+	       :type tramp-file-missing)))
 
 	;; Cleanup.
 	(ignore-errors (delete-directory tmp-name1 'recursive))))))
@@ -3011,6 +3096,9 @@ They might differ only in access time."
   (setcar (nthcdr 4 attr2) tramp-time-dont-know)
   (equal attr1 attr2))
 
+;; This isn't 100% correct, but better than no explainer at all.
+(put #'tramp--test-file-attributes-equal-p 'ert-explainer #'ert--explain-equal)
+
 (ert-deftest tramp-test19-directory-files-and-attributes ()
   "Check `directory-files-and-attributes'."
   (skip-unless (tramp--test-enabled))
@@ -3843,6 +3931,10 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
 (defun tramp--test-timeout-handler (&rest _ignore)
   "Timeout handler, reporting a failed test."
   (interactive)
+  (let ((proc (get-buffer-process (current-buffer))))
+    (when (processp proc)
+      (tramp--test-message
+       "cmd: %s\n%s" (process-command proc) (buffer-string))))
   (ert-fail (format "`%s' timed out" (ert-test-name (ert-running-test)))))
 
 (ert-deftest tramp-test29-start-file-process ()
@@ -3923,23 +4015,24 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
   :tags '(:expensive-test)
   (skip-unless (tramp--test-enabled))
   (skip-unless (or (tramp--test-adb-p) (tramp--test-sh-p)))
-  ;; `make-process' supports file name handlers since Emacs 27.
+  ;; `make-process' has been inserted in Emacs 25.1.  It supports file
+  ;; name handlers since Emacs 27.
   (skip-unless (tramp--test-emacs27-p))
 
-  (tramp--test-instrument-test-case 0
   (dolist (quoted (if (tramp--test-expensive-test) '(nil t) '(nil)))
     (let ((default-directory tramp-test-temporary-file-directory)
 	  (tmp-name (tramp--test-make-temp-name nil quoted))
 	  kill-buffer-query-functions proc)
-      (should-not (make-process))
+      (should-not (with-no-warnings (make-process)))
 
       ;; Simple process.
       (unwind-protect
 	  (with-temp-buffer
 	    (setq proc
-		  (make-process
-		   :name "test1" :buffer (current-buffer) :command '("cat")
-		   :file-handler t))
+		  (with-no-warnings
+		    (make-process
+		     :name "test1" :buffer (current-buffer) :command '("cat")
+		     :file-handler t)))
 	    (should (processp proc))
 	    (should (equal (process-status proc) 'run))
 	    (process-send-string proc "foo")
@@ -3961,10 +4054,11 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
 	    (write-region "foo" nil tmp-name)
 	    (should (file-exists-p tmp-name))
 	    (setq proc
-		  (make-process
-		   :name "test2" :buffer (current-buffer)
-		   :command `("cat" ,(file-name-nondirectory tmp-name))
-		   :file-handler t))
+		  (with-no-warnings
+		    (make-process
+		     :name "test2" :buffer (current-buffer)
+		     :command `("cat" ,(file-name-nondirectory tmp-name))
+		     :file-handler t)))
 	    (should (processp proc))
 	    ;; Read output.
 	    (with-timeout (10 (tramp--test-timeout-handler))
@@ -3981,12 +4075,13 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
       (unwind-protect
 	  (with-temp-buffer
 	    (setq proc
-		  (make-process
-		   :name "test3" :buffer (current-buffer) :command '("cat")
-		   :filter
-		   (lambda (p s)
-		     (with-current-buffer (process-buffer p) (insert s)))
-		   :file-handler t))
+		  (with-no-warnings
+		    (make-process
+		     :name "test3" :buffer (current-buffer) :command '("cat")
+		     :filter
+		     (lambda (p s)
+		       (with-current-buffer (process-buffer p) (insert s)))
+		     :file-handler t)))
 	    (should (processp proc))
 	    (should (equal (process-status proc) 'run))
 	    (process-send-string proc "foo")
@@ -4006,12 +4101,13 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
       (unwind-protect
 	  (with-temp-buffer
 	    (setq proc
-		  (make-process
-		   :name "test4" :buffer (current-buffer) :command '("cat")
-		   :sentinel
-		   (lambda (p s)
-		     (with-current-buffer (process-buffer p) (insert s)))
-		   :file-handler t))
+		  (with-no-warnings
+		    (make-process
+		     :name "test4" :buffer (current-buffer) :command '("cat")
+		     :sentinel
+		     (lambda (p s)
+		       (with-current-buffer (process-buffer p) (insert s)))
+		     :file-handler t)))
 	    (should (processp proc))
 	    (should (equal (process-status proc) 'run))
 	    (process-send-string proc "foo")
@@ -4034,11 +4130,12 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
 	  (unwind-protect
 	      (with-temp-buffer
 		(setq proc
-		      (make-process
-		       :name "test5" :buffer (current-buffer)
-		       :command '("cat" "/")
-		       :stderr stderr
-		       :file-handler t))
+		      (with-no-warnings
+			(make-process
+			 :name "test5" :buffer (current-buffer)
+			 :command '("cat" "/")
+			 :stderr stderr
+			 :file-handler t)))
 		(should (processp proc))
 		;; Read stderr.
 		(with-current-buffer stderr
@@ -4050,7 +4147,7 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
 
 	    ;; Cleanup.
 	    (ignore-errors (delete-process proc))
-	    (ignore-errors (kill-buffer stderr)))))))))
+	    (ignore-errors (kill-buffer stderr))))))))
 
 (ert-deftest tramp-test31-interrupt-process ()
   "Check `interrupt-process'."
@@ -4060,7 +4157,10 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
   ;; Since Emacs 26.1.
   (skip-unless (boundp 'interrupt-process-functions))
 
-  (let ((default-directory tramp-test-temporary-file-directory)
+  ;; We must use `file-truename' for the temporary directory, in
+  ;; order to establish the connection prior running an asynchronous
+  ;; process.
+  (let ((default-directory (file-truename tramp-test-temporary-file-directory))
 	kill-buffer-query-functions proc)
     (unwind-protect
 	(with-temp-buffer
@@ -4079,6 +4179,16 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
       ;; Cleanup.
       (ignore-errors (delete-process proc)))))
 
+(defun tramp--test-shell-command-to-string-asynchronously (command)
+  "Like `shell-command-to-string', but for asynchronous processes."
+  (with-temp-buffer
+    (async-shell-command command (current-buffer))
+    (with-timeout
+        ((if (getenv "EMACS_EMBA_CI") 30 10) (tramp--test-timeout-handler))
+      (while (accept-process-output
+	      (get-buffer-process (current-buffer)) nil nil t)))
+    (buffer-substring-no-properties (point-min) (point-max))))
+
 (ert-deftest tramp-test32-shell-command ()
   "Check `shell-command'."
   :tags '(:expensive-test)
@@ -4094,6 +4204,8 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
 	  ;; Suppress nasty messages.
 	  (inhibit-message t)
 	  kill-buffer-query-functions)
+
+      ;; Test ordinary `shell-command'.
       (unwind-protect
 	  (with-temp-buffer
 	    (write-region "foo" nil tmp-name)
@@ -4114,6 +4226,7 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
 	;; Cleanup.
 	(ignore-errors (delete-file tmp-name)))
 
+      ;; Test ordinary `async-shell-command'.
       (unwind-protect
 	  (with-temp-buffer
 	    (write-region "foo" nil tmp-name)
@@ -4142,6 +4255,7 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
 	;; Cleanup.
 	(ignore-errors (delete-file tmp-name)))
 
+      ;; Test sending string to `async-shell-command'.
       (unwind-protect
 	  (with-temp-buffer
 	    (write-region "foo" nil tmp-name)
@@ -4169,17 +4283,24 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
 	      (buffer-string))))
 
 	;; Cleanup.
-	(ignore-errors (delete-file tmp-name))))))
+	(ignore-errors (delete-file tmp-name)))
 
-(defun tramp--test-shell-command-to-string-asynchronously (command)
-  "Like `shell-command-to-string', but for asynchronous processes."
-  (with-temp-buffer
-    (async-shell-command command (current-buffer))
-    (with-timeout
-        ((if (getenv "EMACS_EMBA_CI") 30 10) (tramp--test-timeout-handler))
-      (while (accept-process-output
-	      (get-buffer-process (current-buffer)) nil nil t)))
-    (buffer-substring-no-properties (point-min) (point-max))))
+      ;; Test `async-shell-command-width'.  Since Emacs 27.1.
+      (when (and (boundp 'async-shell-command-width)
+		 (zerop (call-process "tput" nil nil nil "cols"))
+                 (zerop (process-file "tput" nil nil nil "cols")))
+	(let (async-shell-command-width)
+	  (should
+	   (string-equal
+	    (format "%s\n" (car (process-lines "tput" "cols")))
+	    (tramp--test-shell-command-to-string-asynchronously
+	     "tput cols")))
+	  (setq async-shell-command-width 1024)
+	  (should
+	   (string-equal
+	    "1024\n"
+	    (tramp--test-shell-command-to-string-asynchronously
+	     "tput cols"))))))))
 
 ;; This test is inspired by Bug#23952.
 (ert-deftest tramp-test33-environment-variables ()
@@ -4257,7 +4378,7 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
 	      (should-not
 	       (string-match
 		(regexp-quote envvar)
-		(funcall this-shell-command-to-string "set")))))))))
+		(funcall this-shell-command-to-string "env")))))))))
 
 ;; This test is inspired by Bug#27009.
 (ert-deftest tramp-test33-environment-variables-and-port-numbers ()
@@ -4534,7 +4655,11 @@ This tests also `make-symbolic-link', `file-truename' and `add-name-to-file'."
   (skip-unless (tramp--test-sh-p))
 
   (dolist (quoted (if (tramp--test-expensive-test) '(nil t) '(nil)))
-    (let* ((default-directory tramp-test-temporary-file-directory)
+    ;; We must use `file-truename' for the temporary directory, in
+    ;; order to establish the connection prior running an asynchronous
+    ;; process.
+    (let* ((default-directory
+	     (file-truename tramp-test-temporary-file-directory))
 	   (tmp-name1 (tramp--test-make-temp-name nil quoted))
 	   (tmp-name2 (expand-file-name "foo" tmp-name1))
 	   (tramp-remote-process-environment tramp-remote-process-environment)
@@ -5557,7 +5682,9 @@ process sentinels.  They shall not disturb each other."
   (let ((default-directory (expand-file-name temporary-file-directory))
 	(code
 	 (format
-	  "(message \"Tramp loaded: %%s\" (and (file-remote-p %S) t))"
+	  ;; Suppress method name check.
+	  "(let ((non-essential t)) \
+             (message \"Tramp loaded: %%s\" (and (file-remote-p %S) t)))"
 	  tramp-test-temporary-file-directory)))
     (should
      (string-match
@@ -5695,7 +5822,7 @@ Since it unloads Tramp, it shall be the last test to run."
 	  (ert-fail (format "`%s' still bound" x)))))
   ;; The defstruct `tramp-file-name' and all its internal functions
   ;; shall be purged.
-  (should-not (cl--find-class 'tramp-file-name))
+  (should-not (with-no-warnings (cl--find-class 'tramp-file-name)))
   (mapatoms
    (lambda (x)
      (and (functionp x)
@@ -5736,9 +5863,9 @@ Since it unloads Tramp, it shall be the last test to run."
 ;;   do not work properly for `nextcloud'.
 ;; * Fix `tramp-test29-start-file-process' and
 ;;   `tramp-test30-make-process' on MS Windows (`process-send-eof'?).
+;; * Implement `tramp-test31-interrupt-process' for `adb'.
 ;; * Fix Bug#16928 in `tramp-test43-asynchronous-requests'.  Looks
 ;;   like it is resolved now.  Remove `:unstable' tag?
-;; * Implement `tramp-test31-interrupt-process' for `adb'.
 
 (provide 'tramp-tests)
 ;;; tramp-tests.el ends here
diff --git a/test/lisp/nxml/nxml-mode-tests.el b/test/lisp/nxml/nxml-mode-tests.el
new file mode 100644
index 0000000000..53416b4280
--- /dev/null
+++ b/test/lisp/nxml/nxml-mode-tests.el
@@ -0,0 +1,118 @@
+;;; nxml-mode-tests.el --- Test NXML Mode -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Code:
+
+(require 'ert)
+(require 'nxml-mode)
+
+(defun nxml-mode-tests-correctly-indented-string (str)
+  (with-temp-buffer
+    (nxml-mode)
+    (insert str)
+    (indent-region (point-min) (point-max))
+    (equal (buffer-string) str)))
+
+(ert-deftest nxml-indent-line-after-attribute ()
+  (should (nxml-mode-tests-correctly-indented-string "
+<settings
+    xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"
+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"
+    xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0
+                        https://maven.apache.org/xsd/settings-1.0.0.xsd\">
+  <mirrors>
+    ...
+  </mirrors>
+</settings>
+"))
+  (should (nxml-mode-tests-correctly-indented-string "\
+<x>
+  <abc xx=\"x/x/x/x/x/x/x/
+           y/y/y/y/y/y/
+           \">
+    <zzz/>
+  </abc>
+  <nl>&#10;</nl>
+</x>
+")))
+
+(ert-deftest nxml-balanced-close-start-tag-inline ()
+  (with-temp-buffer
+    (nxml-mode)
+    (insert "<a><b c=\"\"</a>")
+    (search-backward "</a>")
+    (nxml-balanced-close-start-tag-inline)
+    (should (equal (buffer-string) "<a><b c=\"\"></b></a>"))))
+
+(ert-deftest nxml-mode-font-lock-quotes ()
+  (with-temp-buffer
+    (nxml-mode)
+    (insert "<x a=\"dquote attr\" b='squote attr'>\"dquote text\"'squote text'</x>")
+    (font-lock-ensure)
+    (let ((squote-txt-pos (search-backward "squote text"))
+          (dquote-txt-pos (search-backward "dquote text"))
+          (squote-att-pos (search-backward "squote attr"))
+          (dquote-att-pos (search-backward "dquote attr")))
+      ;; Just make sure that each quote uses the same face for quoted
+      ;; attribute values, and a different face for quoted text
+      ;; outside tags.  Don't test `font-lock-string-face' vs
+      ;; `nxml-attribute-value' here.
+      (should (equal (get-text-property squote-att-pos 'face)
+                     (get-text-property dquote-att-pos 'face)))
+      (should (equal (get-text-property squote-txt-pos 'face)
+                     (get-text-property dquote-txt-pos 'face)))
+      (should-not (equal (get-text-property squote-txt-pos 'face)
+                         (get-text-property dquote-att-pos 'face))))))
+
+(ert-deftest nxml-mode-doctype-and-quote-syntax ()
+  (with-temp-buffer
+    (insert "<!DOCTYPE t [\n<!ENTITY f SYSTEM \"f.xml\">\n]>\n<t>'</t>")
+    (nxml-mode)
+    ;; Check that last tag is parsed as a tag.
+    (should (= 1 (car (syntax-ppss (1- (point-max))))))
+    (should (= 0 (car (syntax-ppss (point-max)))))))
+
+(ert-deftest nxml-mode-prolog-comment ()
+  (with-temp-buffer
+    (insert "<?xml version=\"1.0\" encoding=\"utf-8\"?><!-- comment1 -->
+<t><!-- comment2 --></t><!-- comment3 -->")
+    (nxml-mode)
+    ;; Check that all comments are parsed as comments
+    (goto-char (point-min))
+    (search-forward "comment1")
+    (should (nth 4 (syntax-ppss)))
+    (search-forward "comment2")
+    (should (nth 4 (syntax-ppss)))
+    (search-forward "comment3")))
+
+(ert-deftest nxml-mode->-after-quote ()
+  "Reduction from Bug#36092."
+  (with-temp-buffer
+    (insert "<root>\n"
+            (make-string 1794 ?a) "\n"
+            "'>"
+            (make-string 196 ?a) "\n"
+            "</root>")
+    (nxml-mode)
+    (syntax-propertize 2001)
+    (syntax-propertize (point-max))     ; Triggered an assert failure.
+    ;; Check that last tag is parsed as a tag.
+    (should (= 1 (- (car (syntax-ppss (1- (point-max))))
+                    (car (syntax-ppss (point-max))))))))
+
+(provide 'nxml-mode-tests)
+;;; nxml-mode-tests.el ends here
diff --git a/test/lisp/paren-tests.el b/test/lisp/paren-tests.el
new file mode 100644
index 0000000000..5aaea8a7d9
--- /dev/null
+++ b/test/lisp/paren-tests.el
@@ -0,0 +1,121 @@
+;;; paren-tests.el --- Tests for paren.el  -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Simen Heggestøyl <simenheg@gmail.com>
+;; Keywords:
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;
+
+;;; Code:
+
+(require 'ert)
+(require 'paren)
+
+(ert-deftest paren-tests-unescaped-p ()
+  (with-temp-buffer
+    (insert "(insert)")
+    (backward-char)
+    (should (show-paren--unescaped-p (point)))
+    (insert "\\")
+    (should-not (show-paren--unescaped-p (point)))))
+
+(ert-deftest paren-tests-categorize-paren ()
+  (with-temp-buffer
+    (insert "(insert)")
+    (backward-char)
+    (should (equal (show-paren--categorize-paren (point))
+                   (cons -1 (+ (point) 1))))
+    (goto-char (point-min))
+    (should (equal (show-paren--categorize-paren (point))
+                   (cons 1 (point))))))
+
+(ert-deftest paren-tests-locate-near-paren ()
+  (with-temp-buffer
+    (let ((show-paren-when-point-inside-paren nil)
+          (show-paren-when-point-in-periphery nil))
+      (insert "(insert)")
+      (should (equal (show-paren--locate-near-paren)
+                     (cons -1 (point))))
+      (backward-char)
+      (should-not (show-paren--locate-near-paren))
+      (goto-char (point-min))
+      (should (equal (show-paren--locate-near-paren)
+                     (cons 1 (point-min))))
+      (forward-char)
+      (should-not (show-paren--locate-near-paren)))))
+
+(ert-deftest paren-tests-locate-near-paren-inside ()
+  (with-temp-buffer
+    (let ((show-paren-when-point-inside-paren t)
+          (show-paren-when-point-in-periphery nil))
+      (insert "(insert)")
+      (should (equal (show-paren--locate-near-paren)
+                     (cons -1 (point))))
+      (backward-char)
+      (should (equal (show-paren--locate-near-paren)
+                     (cons -1 (+ (point) 1))))
+      (goto-char (point-min))
+      (should (equal (show-paren--locate-near-paren)
+                     (cons 1 (point-min))))
+      (forward-char)
+      (should (equal (show-paren--locate-near-paren)
+                     (cons 1 (point-min)))))))
+
+(ert-deftest paren-tests-locate-near-paren-in-periphery ()
+  (with-temp-buffer
+    (let ((show-paren-when-point-inside-paren nil)
+          (show-paren-when-point-in-periphery t))
+      (insert " (insert) ")
+      (should (equal (show-paren--locate-near-paren)
+                     (cons -1 (- (point) 1))))
+      (backward-char 2)
+      (should-not (show-paren--locate-near-paren))
+      (goto-char (point-min))
+      (should (equal (show-paren--locate-near-paren)
+                     (cons 1 (+ (point) 1))))
+      (forward-char)
+      (should (equal (show-paren--locate-near-paren)
+                     (cons 1 (point))))
+      (forward-char)
+      (should-not (show-paren--locate-near-paren)))))
+
+(ert-deftest paren-tests-default ()
+  (with-temp-buffer
+    (insert "(insert")
+    (goto-char (point-min))
+    (should (equal (show-paren--default)
+                   (list (point) (+ (point) 1)
+                         nil nil
+                         t)))
+    (goto-char (point-max))
+    (insert ")")
+    (should (equal (show-paren--default)
+                   (list (- (point) 1) (point)
+                         (point-min) (+ (point-min) 1)
+                         nil)))
+    (goto-char (point-min))
+    (should (equal (show-paren--default)
+                   (list (point) (+ (point) 1)
+                         (- (point-max) 1) (point-max)
+                         nil)))))
+
+(provide 'paren-tests)
+;;; paren-tests.el ends here
diff --git a/test/lisp/play/morse-tests.el b/test/lisp/play/morse-tests.el
new file mode 100644
index 0000000000..e6129f026f
--- /dev/null
+++ b/test/lisp/play/morse-tests.el
@@ -0,0 +1,60 @@
+;;; morse-tests.el --- Tests for morse.el  -*- lexical-binding: t -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Stefan Kangas <stefankangas@gmail.com>
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;; Code:
+
+(require 'ert)
+(require 'morse)
+
+(ert-deftest morse-tests-morse-region ()
+  (with-temp-buffer
+    (insert "Morse encoded")
+    (morse-region (point-min) (point-max))
+    (should (equal (buffer-string)
+                   "--/---/.-./.../. ./-./-.-./---/-.././-.."))))
+
+(ert-deftest morse-tests-unmorse-region ()
+  (with-temp-buffer
+    (insert "--/---/.-./.../. ./-./-.-./---/-.././-..")
+    (unmorse-region (point-min) (point-max))
+    (should (equal (buffer-string) "morse encoded"))))
+
+(ert-deftest morse-tests-nato-region ()
+  (with-temp-buffer
+    (insert "Nato encoded")
+    (nato-region (point-min) (point-max))
+    (should (equal (buffer-string)
+                   (concat
+                    "November-Alfa-Tango-Oscar Echo-November"
+                    "-Charlie-Oscar-Delta-Echo-Delta")))))
+
+(ert-deftest morse-tests-unnato-region ()
+  (with-temp-buffer
+    (insert (concat
+             "November-Alfa-Tango-Oscar Echo-November"
+             "-Charlie-Oscar-Delta-Echo-Delta"))
+    (denato-region (point-min) (point-max))
+    (should (equal (buffer-string) "nato encoded"))))
+
+(provide 'morse-tests)
+;;; morse-tests.el ends here
diff --git a/test/lisp/play/studly-tests.el b/test/lisp/play/studly-tests.el
new file mode 100644
index 0000000000..10135a0d96
--- /dev/null
+++ b/test/lisp/play/studly-tests.el
@@ -0,0 +1,52 @@
+;;; studly-tests.el --- Tests for studly.el  -*- lexical-binding: t -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Stefan Kangas <stefankangas@gmail.com>
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;; Code:
+
+(require 'ert)
+(require 'studly)
+
+(ert-deftest studly-tests-studlify-region ()
+  (with-temp-buffer
+    (insert "Studlify this string of text")
+    (studlify-region (point-min) (point-max))
+    (should (equal (buffer-string)
+                   "StudliFy this StrinG of tExt"))))
+
+(ert-deftest studly-tests-studlify-word ()
+  (with-temp-buffer
+    (insert "normal studlified normal")
+    (goto-char 8)
+    (studlify-word 1)
+    (should (equal (buffer-string)
+                   "normal stUdlIfIed normal"))))
+
+(ert-deftest studly-tests-nato-region ()
+  (with-temp-buffer
+    (insert "Studlify\n this\n buffer")
+    (studlify-buffer)
+    (should (equal (buffer-string)
+                   "STuDlify\n This\n buffer"))))
+
+(provide 'studly-tests)
+;;; studly-tests.el ends here
diff --git a/test/lisp/progmodes/flymake-tests.el b/test/lisp/progmodes/flymake-tests.el
index 732193476d..3c25e11624 100644
--- a/test/lisp/progmodes/flymake-tests.el
+++ b/test/lisp/progmodes/flymake-tests.el
@@ -111,6 +111,7 @@ SEVERITY-PREDICATE is used to setup
 (ert-deftest perl-backend ()
   "Test the perl backend"
   (skip-unless (executable-find "perl"))
+  (skip-unless (not (getenv "EMACS_HYDRA_CI")))
   (flymake-tests--with-flymake ("test.pl")
     (flymake-goto-next-error)
     (should (eq 'flymake-warning (face-at-point)))
@@ -143,7 +144,8 @@ SEVERITY-PREDICATE is used to setup
 (ert-deftest different-diagnostic-types ()
   "Test GCC warning via function predicate."
   ;; http://lists.gnu.org/archive/html/emacs-devel/2019-03/msg01043.html
-  :expected-result (if (getenv "EMACS_HYDRA_CI") :failed :passed)
+  :expected-result (if (or (getenv "EMACS_HYDRA_CI") (getenv "EMACS_EMBA_CI"))
+                       :failed :passed)
   (skip-unless (and (executable-find "gcc")
                     (version<=
                      "5" (string-trim
@@ -169,6 +171,7 @@ SEVERITY-PREDICATE is used to setup
 (ert-deftest included-c-header-files ()
   "Test inclusion of .h header files."
   (skip-unless (and (executable-find "gcc") (executable-find "make")))
+  (skip-unless (not (getenv "EMACS_HYDRA_CI")))
   (let ((flymake-wrap-around nil))
     (flymake-tests--with-flymake
         ("some-problems.h")
@@ -294,6 +297,7 @@ SEVERITY-PREDICATE is used to setup
 
 (ert-deftest recurrent-backend ()
   "Test a backend that calls REPORT-FN multiple times"
+  (skip-unless (not (getenv "EMACS_HYDRA_CI")))
   (with-temp-buffer
     (let (tick)
       (cl-letf
diff --git a/test/lisp/progmodes/python-tests.el b/test/lisp/progmodes/python-tests.el
index b940f45bb9..a517909717 100644
--- a/test/lisp/progmodes/python-tests.el
+++ b/test/lisp/progmodes/python-tests.el
@@ -260,6 +260,19 @@ foo = long_function_name(
    (should (eq (car (python-indent-context)) :inside-paren-newline-start))
    (should (= (python-indent-calculate-indentation) 4))))
 
+(ert-deftest python-indent-hanging-close-paren ()
+  "Like first pep8 case, but with hanging close paren." ;; See Bug#20742.
+  (python-tests-with-temp-buffer
+   "\
+foo = long_function_name(var_one, var_two,
+                         var_three, var_four
+                         )
+"
+   (should (= (python-indent-calculate-indentation) 0))
+   (python-tests-look-at ")")
+   (should (eq (car (python-indent-context)) :inside-paren-at-closing-paren))
+   (should (= (python-indent-calculate-indentation) 25))))
+
 (ert-deftest python-indent-base-case ()
   "Check base case does not trigger errors."
   (python-tests-with-temp-buffer
diff --git a/test/lisp/progmodes/sql-tests.el b/test/lisp/progmodes/sql-tests.el
index 7a11f762eb..3ac9fb10e4 100644
--- a/test/lisp/progmodes/sql-tests.el
+++ b/test/lisp/progmodes/sql-tests.el
@@ -270,5 +270,146 @@ Perform ACTION and validate results"
   (sql-test-product-feature-harness
       (should-not (sql-get-product-feature 'd :Z))))
 
+;;; SQL Oracle SCAN/DEFINE
+(defmacro sql-tests-placeholder-filter-harness (orig repl outp)
+  "Set-up and tear-down of testing of placeholder filter.
+
+The placeholder in ORIG will be replaced by REPL which should
+yield OUTP."
+
+  (declare (indent 0))
+  `(let ((syntab (syntax-table))
+         (sql-oracle-scan-on t))
+     (set-syntax-table sql-mode-syntax-table)
+
+     (cl-letf
+         (((symbol-function 'read-from-minibuffer)
+           (lambda (&rest _) ,repl)))
+
+       (should (equal (sql-placeholders-filter ,orig) ,outp)))
+
+     (set-syntax-table syntab)))
+
+(ert-deftest sql-tests-placeholder-filter-simple ()
+  "Test that placeholder relacement of simple replacement text."
+  (sql-tests-placeholder-filter-harness
+    "select '&x' from dual;" "XX"
+    "select 'XX' from dual;"))
+
+(ert-deftest sql-tests-placeholder-filter-ampersand ()
+  "Test that placeholder relacement of replacement text with ampersand."
+  (sql-tests-placeholder-filter-harness
+    "select '&x' from dual;" "&Y"
+    "select '&Y' from dual;")
+
+  (sql-tests-placeholder-filter-harness
+    "select '&x' from dual;" "Y&"
+    "select 'Y&' from dual;")
+
+  (sql-tests-placeholder-filter-harness
+    "select '&x' from dual;" "Y&Y"
+    "select 'Y&Y' from dual;"))
+
+(ert-deftest sql-tests-placeholder-filter-period ()
+  "Test that placeholder relacement of token terminated by a period."
+  (sql-tests-placeholder-filter-harness
+    "select '&x.' from dual;" "&Y"
+    "select '&Y' from dual;")
+
+  (sql-tests-placeholder-filter-harness
+    "select '&x.y' from dual;" "&Y"
+    "select '&Yy' from dual;")
+
+  (sql-tests-placeholder-filter-harness
+    "select '&x..y' from dual;" "&Y"
+    "select '&Y.y' from dual;"))
+
+;; Buffer naming
+(defmacro sql-tests-buffer-naming-harness (product &rest action)
+  "Set-up and tear-down of test of buffer naming.
+
+The ACTION will be tested after set-up of PRODUCT."
+
+  (declare (indent 1))
+  `(progn
+     (ert--skip-unless (executable-find sql-sqlite-program))
+     (let (new-bufs)
+       (cl-letf
+           (((symbol-function 'make-comint-in-buffer)
+             (lambda (_name buffer _program &optional _startfile &rest _switches)
+               (let ((b (get-buffer-create buffer)))
+                 (message ">>make-comint-in-buffer %S" b)
+                 (cl-pushnew b new-bufs) ;; Keep track of what we create
+                 b))))
+
+         (let (,(intern (format "sql-%s-login-params" product)))
+           ,@action)
+
+         (let (kill-buffer-query-functions) ;; Kill what we create
+           (mapc #'kill-buffer new-bufs))))))
+
+(ert-deftest sql-tests-buffer-naming-default ()
+  "Test buffer naming."
+  (sql-tests-buffer-naming-harness sqlite
+    (sql-sqlite)
+    (message ">> %S" (current-buffer))
+    (should (equal (buffer-name) "*SQL: SQLite*"))))
+
+(ert-deftest sql-tests-buffer-naming-multiple ()
+  "Test buffer naming of multiple buffers."
+  (sql-tests-buffer-naming-harness sqlite
+    (sql-sqlite)
+    (should (equal (buffer-name) "*SQL: SQLite*"))
+
+    (switch-to-buffer "*scratch*")
+
+    (sql-sqlite)
+    (should (equal (buffer-name) "*SQL: SQLite*"))))
+
+(ert-deftest sql-tests-buffer-naming-explicit ()
+  "Test buffer naming with explicit name."
+  (sql-tests-buffer-naming-harness sqlite
+    (sql-sqlite "A")
+    (should (equal (buffer-name) "*SQL: A*"))
+
+    (switch-to-buffer "*scratch*")
+
+    (sql-sqlite "A")
+    (should (equal (buffer-name) "*SQL: A*"))))
+
+(ert-deftest sql-tests-buffer-naming-universal-argument ()
+  "Test buffer naming with explicit name."
+  (sql-tests-buffer-naming-harness sqlite
+    (cl-letf
+        (((symbol-function 'read-string)
+          (lambda (_prompt &optional _initial-input _history _default-value _inherit-input-method)
+            "1")))
+      (sql-sqlite '(4))
+      (should (equal (buffer-name) "*SQL: 1*")))
+
+    (switch-to-buffer "*scratch*")
+
+    (cl-letf
+        (((symbol-function 'read-string)
+          (lambda (_prompt &optional _initial-input _history _default-value _inherit-input-method)
+            "2")))
+      (sql-sqlite '(16))
+      (should (equal (buffer-name) "*SQL: 2*")))))
+
+(ert-deftest sql-tests-buffer-naming-existing ()
+  "Test buffer naming with an existing non-SQLi buffer."
+  (sql-tests-buffer-naming-harness sqlite
+    (get-buffer-create "*SQL: exist*")
+
+    (cl-letf
+        (((symbol-function 'read-string)
+          (lambda (_prompt &optional _initial-input _history _default-value _inherit-input-method)
+            "exist")))
+      (sql-sqlite '(4))
+      (should (equal (buffer-name) "*SQL: exist-1*")))
+
+    (kill-buffer "*SQL: exist*")))
+
+
 (provide 'sql-tests)
 ;;; sql-tests.el ends here
diff --git a/test/lisp/subr-tests.el b/test/lisp/subr-tests.el
index c458eef2f9..06db8f5c90 100644
--- a/test/lisp/subr-tests.el
+++ b/test/lisp/subr-tests.el
@@ -61,6 +61,9 @@
                      (quote
                       (0 font-lock-keyword-face))))))))
 
+(defalias 'subr-tests--parent-mode
+  (if (fboundp 'prog-mode) 'prog-mode 'fundamental-mode))
+
 (ert-deftest provided-mode-derived-p ()
   ;; base case: `derived-mode' directly derives `prog-mode'
   (should (progn
@@ -68,9 +71,7 @@
             (provided-mode-derived-p 'derived-mode 'prog-mode)))
   ;; edge case: `derived-mode' derives an alias of `prog-mode'
   (should (progn
-            (defalias 'parent-mode
-              (if (fboundp 'prog-mode) 'prog-mode 'fundamental-mode))
-            (define-derived-mode derived-mode parent-mode "test")
+            (define-derived-mode derived-mode subr-tests--parent-mode "test")
             (provided-mode-derived-p 'derived-mode 'prog-mode))))
 
 (ert-deftest number-sequence-test ()
@@ -373,5 +374,31 @@ See https://debbugs.gnu.org/cgi/bugreport.cgi?bug=19350."
   (should (equal (flatten-tree '(1 ("foo" "bar") 2))
                  '(1 "foo" "bar" 2))))
 
+(defvar subr-tests--hook nil)
+
+(ert-deftest subr-tests-add-hook-depth ()
+  "Test the `depth' arg of `add-hook'."
+  (setq-default subr-tests--hook nil)
+  (add-hook 'subr-tests--hook 'f1)
+  (add-hook 'subr-tests--hook 'f2)
+  (should (equal subr-tests--hook '(f2 f1)))
+  (add-hook 'subr-tests--hook 'f3 t)
+  (should (equal subr-tests--hook '(f2 f1 f3)))
+  (add-hook 'subr-tests--hook 'f4 50)
+  (should (equal subr-tests--hook '(f2 f1 f4 f3)))
+  (add-hook 'subr-tests--hook 'f5 -50)
+  (should (equal subr-tests--hook '(f5 f2 f1 f4 f3)))
+  (add-hook 'subr-tests--hook 'f6)
+  (should (equal subr-tests--hook '(f5 f6 f2 f1 f4 f3)))
+  ;; Make sure `t' is equivalent to 90.
+  (add-hook 'subr-tests--hook 'f7 90)
+  (add-hook 'subr-tests--hook 'f8 t)
+  (should (equal subr-tests--hook '(f5 f6 f2 f1 f4 f3 f7 f8)))
+  ;; Make sue `nil' is equivalent to 0.
+  (add-hook 'subr-tests--hook 'f9 0)
+  (add-hook 'subr-tests--hook 'f10)
+  (should (equal subr-tests--hook '(f5 f10 f9 f6 f2 f1 f4 f3 f7 f8)))
+  )
+
 (provide 'subr-tests)
 ;;; subr-tests.el ends here
diff --git a/test/lisp/tabify-tests.el b/test/lisp/tabify-tests.el
new file mode 100644
index 0000000000..db073338b3
--- /dev/null
+++ b/test/lisp/tabify-tests.el
@@ -0,0 +1,79 @@
+;;; tabify-tests.el --- tests for tabify.el  -*- lexical-binding: t -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Stefan Kangas <stefankangas@gmail.com>
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Code:
+
+(require 'ert)
+(require 'tabify)
+
+(defun tabify-tests--test-changes (fun changes width)
+  (with-temp-buffer
+    (let ((tab-width width))
+      (insert (mapconcat #'car changes ""))
+      (funcall fun (point-min) (point-max))
+      (should (equal (buffer-string) (mapconcat #'cadr changes ""))))))
+
+(ert-deftest tabify-tests-untabify ()
+  (let ((changes '(("***\n"        "***\n")
+                   (" ***\n"       " ***\n")
+                   ("\t***\n"      "  ***\n")
+                   ("\t ***\n"     "   ***\n")
+                   ("\t\t***\n"    "    ***\n")
+                   ("\t\t ***\n"   "     ***\n")
+                   ("\t\t\t***\n"  "      ***\n")
+                   ("\t\t\t ***\n" "       ***\n")
+                   ("  ***\n"      "  ***\n")
+                   (" \t ***\n"    "   ***\n")
+                   ("  \t***\n"    "    ***\n")
+                   ("   \t***\n"   "    ***\n"))))
+    (tabify-tests--test-changes #'untabify changes 2)))
+
+(ert-deftest tabify-tests-tabify ()
+  (let ((changes '(("***\n"        "***\n")
+                   (" ***\n"       " ***\n")
+                   ("  ***\n"      "\t***\n")
+                   ("   ***\n"     "\t ***\n")
+                   ("    ***\n"    "\t\t***\n")
+                   ("     ***\n"   "\t\t ***\n")
+                   ("      ***\n"  "\t\t\t***\n")
+                   ("       ***\n" "\t\t\t ***\n")
+                   ("\t***\n"      "\t***\n")
+                   ("\t ***\n"     "\t ***\n")
+                   ("\t\t***\n"    "\t\t***\n"))))
+    (tabify-tests--test-changes #'tabify changes 2)))
+
+(ert-deftest tabify-tests-tabify/all-spaces-on-line ()
+  (with-temp-buffer
+    (let ((tab-width 2))
+      (insert "  **  **  ")
+      (tabify (point-min) (point-max))
+      (should (equal (buffer-string) "\t**\t**\t")))))
+
+(ert-deftest tabify-tests-tabify/only-initial ()
+  (with-temp-buffer
+    (let ((tab-width 2)
+          (tabify-regexp "^\\t* [ \\t]+"))   ; from tabify-regexp docstring
+      (insert "  **  ")
+      (tabify (point-min) (point-max))
+      (should (equal (buffer-string) "\t**  ")))))
+
+(provide 'tabify-tests)
+;;; tabify-tests.el ends here
diff --git a/test/lisp/tempo-tests.el b/test/lisp/tempo-tests.el
new file mode 100644
index 0000000000..6e610ffa6e
--- /dev/null
+++ b/test/lisp/tempo-tests.el
@@ -0,0 +1,228 @@
+;;; tempo-tests.el --- Test suite for tempo.el  -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Federico Tedin <federicotedin@gmail.com>
+;; Keywords: abbrev
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Code:
+
+(require 'tempo)
+(eval-when-compile (require 'cl-lib))
+
+(ert-deftest tempo-string-element-test ()
+  "Test a template containing a string element."
+  (with-temp-buffer
+    (tempo-define-template "test" '("GNU Emacs Tempo test"))
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "GNU Emacs Tempo test"))))
+
+(ert-deftest tempo-p-bare-element-test ()
+  "Test a template containing a bare `p' element."
+  (with-temp-buffer
+    (tempo-define-template "test" '("abcde" p))
+    (tempo-insert-template 'tempo-template-test nil)
+    (tempo-forward-mark)
+    (should (equal (point) 6))))
+
+(ert-deftest tempo-r-bare-element-test ()
+  "Test a template containing a bare `r' element."
+  (with-temp-buffer
+    (tempo-define-template "test" '("abcde" r "ghijk"))
+    (insert "F")
+    (set-mark (point))
+    (goto-char (point-min))
+    (tempo-insert-template 'tempo-template-test t)
+    (should (equal (buffer-string) "abcdeFghijk"))))
+
+(ert-deftest tempo-p-element-test ()
+  "Testing template containing a `p' (prompt) element."
+  (with-temp-buffer
+    (tempo-define-template "test" '("hello " (p ">")))
+    (let ((tempo-interactive t))
+      (cl-letf (((symbol-function 'read-string) (lambda (&rest _) "world")))
+        (tempo-insert-template 'tempo-template-test nil))
+      (should (equal (buffer-string) "hello world")))))
+
+(ert-deftest tempo-P-element-test ()
+  "Testing template containing a `P' (prompt) element."
+  (with-temp-buffer
+    (tempo-define-template "test" '("hello " (P ">")))
+    ;; By default, `tempo-interactive' is nil, `P' should ignore this.
+    (cl-letf (((symbol-function 'read-string) (lambda (&rest _) "world")))
+      (tempo-insert-template 'tempo-template-test nil))
+    (should (equal (buffer-string) "hello world"))))
+
+(ert-deftest tempo-r-element-test ()
+  "Testing template containing an `r' (with prompt) element."
+  (with-temp-buffer
+    (tempo-define-template "test" '("abcde" (r ">") "ghijk"))
+    (let ((tempo-interactive t))
+      (cl-letf (((symbol-function 'read-string) (lambda (&rest _) "F")))
+        (tempo-insert-template 'tempo-template-test nil))
+      (should (equal (buffer-string) "abcdeFghijk")))))
+
+(ert-deftest tempo-s-element-test ()
+  "Testing template containing an `s' element."
+  (with-temp-buffer
+    (tempo-define-template "test" '("hello " (p ">" P1) " " (s P1)))
+    (let ((tempo-interactive t))
+      (cl-letf (((symbol-function 'read-string) (lambda (&rest _) "world!")))
+        (tempo-insert-template 'tempo-template-test nil))
+      (should (equal (buffer-string) "hello world! world!")))))
+
+(ert-deftest tempo-&-element-test ()
+  "Testing template containing an `&' element."
+  (tempo-define-template "test" '(& "test"))
+  (with-temp-buffer
+    (insert "  ")
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "  test")))
+  (with-temp-buffer
+    (insert "hello")
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "hello\ntest"))))
+
+(ert-deftest tempo-%-element-test ()
+  "Testing template containing an `%' element."
+  (tempo-define-template "test" '("test" %))
+  (with-temp-buffer
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "test")))
+  (with-temp-buffer
+    (insert "hello")
+    (goto-char (point-min))
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "test\nhello"))))
+
+(ert-deftest tempo-n-element-test ()
+  "Testing template containing an `n' element."
+  (tempo-define-template "test" '("test" n "test"))
+  (with-temp-buffer
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "test\ntest"))))
+
+(ert-deftest tempo-n>-element-test ()
+  "Testing template containing an `n>' element."
+  (tempo-define-template "test" '("(progn" n> "(list 1 2 3))"))
+  (with-temp-buffer
+    (emacs-lisp-mode)
+    (tempo-insert-template 'tempo-template-test nil)
+    ;; Tempo should have inserted two spaces before (list 1 2 3)
+    (should (equal (buffer-string) "(progn\n  (list 1 2 3))"))))
+
+(ert-deftest tempo->-element-test ()
+  "Testing template containing a `>' element."
+  (with-temp-buffer
+    (emacs-lisp-mode)
+    (insert "(progn\n)")
+    (backward-char)
+    (tempo-define-template "test" '("(list 1 2 3)" >))
+    (tempo-insert-template 'tempo-template-test nil)
+    ;; Tempo should have inserted two spaces before (list 1 2 3)
+    (should (equal (buffer-string) "(progn\n  (list 1 2 3))"))))
+
+(ert-deftest tempo-r>-bare-element-test ()
+  "Testing template containing a bare `r>' element."
+  (with-temp-buffer
+    (tempo-define-template "test" '("(progn" n r> ")"))
+    (emacs-lisp-mode)
+    (insert "(list 1 2 3)")
+    (set-mark (point))
+    (goto-char (point-min))
+    (tempo-insert-template 'tempo-template-test t)
+    ;; Tempo should have inserted two spaces before (list 1 2 3)
+    (should (equal (buffer-string) "(progn\n  (list 1 2 3))"))))
+
+(ert-deftest tempo-r>-element-test ()
+  "Testing template containing an `r>' (with prompt) element."
+  (tempo-define-template "test" '("(progn" n (r> ":") ")"))
+  (with-temp-buffer
+    ;; Test on-region use
+    (emacs-lisp-mode)
+    (insert "(list 1 2 3)")
+    (set-mark (point))
+    (goto-char (point-min))
+    (tempo-insert-template 'tempo-template-test t)
+    (should (equal (buffer-string) "(progn\n  (list 1 2 3))")))
+  (with-temp-buffer
+    ;; Test interactive use
+    (emacs-lisp-mode)
+    (let ((tempo-interactive t))
+      (cl-letf (((symbol-function 'read-string) (lambda (&rest _) "  (list 1 2 3)")))
+        (tempo-insert-template 'tempo-template-test nil))
+      (should (equal (buffer-string) "(progn\n  (list 1 2 3))")))))
+
+(ert-deftest tempo-o-element-test ()
+  "Testing template containing an `o' element."
+  (with-temp-buffer
+    (tempo-define-template "test" '("test" o))
+    (insert "hello")
+    (goto-char (point-min))
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "test\nhello"))
+    (should (equal (point) 5))))
+
+(ert-deftest tempo-nil-element-test ()
+  "Testing template with nil elements."
+  (with-temp-buffer
+    (tempo-define-template "test" '("Hello," nil " World!"))
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "Hello, World!"))))
+
+(ert-deftest tempo-eval-element-test ()
+  "Testing template with Emacs Lisp expressions."
+  (with-temp-buffer
+    (tempo-define-template "test" '((int-to-string (+ 1 1)) "=" (concat "1" "+1")))
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "2=1+1"))))
+
+(ert-deftest tempo-l-element-test ()
+  "Testing template containing an `l' element."
+  (with-temp-buffer
+    (tempo-define-template "test" '("list: " (l "1, " "2, " (int-to-string (+ 1 2)))))
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "list: 1, 2, 3"))))
+
+(ert-deftest tempo-tempo-user-elements-test ()
+  "Testing a template with elements for `tempo-user-elements'."
+  (with-temp-buffer
+    (make-local-variable 'tempo-user-elements)
+    (add-to-list 'tempo-user-elements (lambda (x) (int-to-string (* x x))))
+    (tempo-define-template "test" '(1 " " 2 " " 3 " " 4))
+    (tempo-insert-template 'tempo-template-test nil)
+    (should (equal (buffer-string) "1 4 9 16"))))
+
+(ert-deftest tempo-expand-tag-test ()
+  "Testing expansion of a template with a tag."
+  (with-temp-buffer
+    (tempo-define-template "test" '("Hello, World!") "hello")
+    (insert "hello")
+    (tempo-complete-tag)
+    (should (equal (buffer-string) "Hello, World!"))))
+
+(ert-deftest tempo-expand-partial-tag-test ()
+  "Testing expansion of a template with a tag, with a partial match."
+  (with-temp-buffer
+    (tempo-define-template "test" '("Hello, World!") "hello")
+    (insert "hel")
+    (tempo-complete-tag)
+    (should (equal (buffer-string) "Hello, World!"))))
+
+(provide 'tempo-tests)
+;;; tempo-tests.el ends here
diff --git a/test/lisp/term-tests.el b/test/lisp/term-tests.el
index 9f5dcd559e..6923096d22 100644
--- a/test/lisp/term-tests.el
+++ b/test/lisp/term-tests.el
@@ -119,7 +119,141 @@ line3\r
 line4\r
 line5\r
 line6\r
-"))))
+")))
+
+  ;; test reverse scrolling
+  (should (equal "line1
+line7
+line6
+line2
+line5"
+                 (term-test-screen-from-input 40 5
+                                              '("\e[0;0H"
+                                                "\e[J"
+                                                "line1\r
+line2\r
+line3\r
+line4\r
+line5"
+                                                "\e[2;4r"
+                                                "\e[2;0H"
+                                                "\e[2;0H"
+                                                "\eMline6"
+                                                "\e[2;0H"
+                                                "\eMline7"))))
+
+  ;; test scrolling down
+  (should (equal "line1
+line3
+line4
+line7
+line5"
+                 (term-test-screen-from-input 40 5
+                                              '("\e[0;0H"
+                                                "\e[J"
+                                                "line1\r
+line2\r
+line3\r
+line4\r
+line5"
+                                                "\e[2;4r"
+                                                "\e[2;0H"
+                                                "\e[4;5H"
+                                                "\n\rline7"))))
+
+  ;; setting the scroll region end beyond the max height should not
+  ;; turn on term-scroll-with-delete
+  (should (equal "line1
+line2
+line3
+line4
+line5
+line6
+line7"
+                 (term-test-screen-from-input 40 5
+                                                      '("\e[1;10r"
+                                                        "line1\r
+line2\r
+line3\r
+line4\r
+line5\r
+line6\r
+line7"))))
+
+
+  ;; resetting the terminal should set the scroll region end to (1- term-height).
+  (should (equal "
+line1
+line2
+line3
+line4
+"
+                 (term-test-screen-from-input 40 5
+                                                      '("\e[1;10r"
+                                                        "\ec" ;reset
+                                                        "line1\r
+line2\r
+line3\r
+line4\r
+line5"
+                                                        "\e[1;1H"
+                                                        "\e[L"))))
+
+  ;; scroll region should be limited to the (1- term-height).  Note,
+  ;; this fixes an off by one error when comparing the scroll region
+  ;; end with term-height.
+  (should (equal "
+line1
+line2
+line3
+line4
+"
+                 (term-test-screen-from-input 40 5
+                                              '("\e[1;6r"
+                                                "line1\r
+line2\r
+line3\r
+line4\r
+line5"
+                                                "\e[1;1H" ;go back to home
+                                                "\e[L"    ;insert a new line at the top
+                                                ))))
+
+  ;; setting the scroll region to the entire height should not turn on
+  ;; term-scroll-with-delete
+  (should (equal "line1
+line2
+line3
+line4
+line5
+line6"
+                 (term-test-screen-from-input 40 5
+                                                      '("\e[1;5r"
+                                                        "line1\r
+line2\r
+line3\r
+line4\r
+line5\r
+line6"))))
+
+  ;; reset should reset term-scroll-with-delete
+  (should (equal "line1
+line2
+line3
+line4
+line5
+line6
+line7"
+                 (term-test-screen-from-input 40 5
+                                              '("\e[2;5r" ;set the region
+                                                "\ec" ;reset
+                                                "line1\r
+line2\r
+line3\r
+line4\r
+line5\r
+line6\r
+line7")))))
 
 (ert-deftest term-set-directory ()
   (let ((term-ansi-at-user (user-real-login-name)))
diff --git a/test/lisp/textmodes/page-tests.el b/test/lisp/textmodes/page-tests.el
new file mode 100644
index 0000000000..0834d65433
--- /dev/null
+++ b/test/lisp/textmodes/page-tests.el
@@ -0,0 +1,86 @@
+;;; page-tests.el --- Tests for page.el  -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Simen Heggestøyl <simenheg@gmail.com>
+;; Keywords:
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;
+
+;;; Code:
+
+(require 'ert)
+(require 'page)
+
+(ert-deftest page-tests-forward-page ()
+  (with-temp-buffer
+    (insert "foo\n\nbar\n\nbaz")
+    (forward-page -1)
+    (should (looking-at-p "\nbaz"))
+    (forward-page -2)
+    (should (= (point) (point-min)))
+    (forward-page 1)
+    (should (looking-at-p "\nbar"))
+    (forward-page)
+    (should (looking-at-p "\nbaz"))
+    (forward-page 1)
+    (should (= (point) (point-max)))))
+
+(ert-deftest page-tests-backward-page ()
+  (with-temp-buffer
+    (insert "foo\n\nbar\n\nbaz")
+    (backward-page 1)
+    (should (looking-at-p "\nbaz"))
+    (backward-page)
+    (should (looking-at-p "\nbar"))
+    (backward-page 1)
+    (should (= (point) (point-min)))
+    (backward-page -1)
+    (should (looking-at-p "\nbar"))
+    (backward-page -2)
+    (should (= (point) (point-max)))))
+
+(defun page-tests--region-string ()
+  "Return the contents of the region as a string."
+  (buffer-substring (region-beginning) (region-end)))
+
+(ert-deftest page-tests-mark-page ()
+  (with-temp-buffer
+    (insert "foo\n\nbar\n\nbaz")
+    (mark-page)
+    (should (equal (page-tests--region-string) "\nbaz"))
+    (mark-page -2)
+    (should (equal (page-tests--region-string) "foo\n"))
+    (mark-page 1)
+    (should (equal (page-tests--region-string) "\nbar\n"))))
+
+(ert-deftest page-tests-narrow-to-page ()
+  (with-temp-buffer
+    (insert "foo\n\nbar\n\nbaz")
+    (goto-char (point-min))
+    (narrow-to-page)
+    (should (equal (buffer-string) "foo\n"))
+    (narrow-to-page 2)
+    (should (equal (buffer-string) "baz"))
+    (narrow-to-page -1)
+    (should (equal (buffer-string) "bar\n"))))
+
+(provide 'page-tests)
+;;; page-tests.el ends here
diff --git a/test/lisp/textmodes/paragraphs-tests.el b/test/lisp/textmodes/paragraphs-tests.el
new file mode 100644
index 0000000000..5772756740
--- /dev/null
+++ b/test/lisp/textmodes/paragraphs-tests.el
@@ -0,0 +1,165 @@
+;;; paragraphs-tests.el --- Tests for paragraphs.el  -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Stefan Kangas <stefankangas@gmail.com>
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;;; Code:
+
+(require 'ert)
+;; (require 'paragraphs) ; loaded by default
+
+(ert-deftest paragraphs-tests-sentence-end ()
+  (should (> (length (sentence-end)) 0))
+  (let ((sentence-end "override works"))
+    (should (equal (sentence-end) sentence-end))))
+
+(ert-deftest paragraphs-tests-forward-backward-paragraph ()
+  (with-temp-buffer
+    (insert "AA\nAA\n\nBB\nBB\n")
+    (goto-char (point-min))
+    (forward-paragraph)
+    (should (equal (point) 7))
+    (forward-paragraph)
+    (should (equal (point) 14))
+    (backward-paragraph)
+    (should (equal (point) 7))
+    (backward-paragraph)
+    (should (equal (point) (point-min)))))
+
+(ert-deftest paragraphs-tests-mark-paragraph ()
+  (with-temp-buffer
+    (insert "AA\nAA\n\nBB\nBB\n")
+    (goto-char (point-min))
+    (mark-paragraph)
+    (should mark-active)
+    (should (equal (mark) 7)))
+  (should-error (mark-paragraph 0)))
+
+(ert-deftest paragraphs-tests-kill-paragraph ()
+  (with-temp-buffer
+    (insert "AA\nAA\n\nBB\nBB\n")
+    (goto-char (point-min))
+    (kill-paragraph nil)
+    (should (equal (buffer-string) "\nBB\nBB\n"))))
+
+(ert-deftest paragraphs-tests-backward-kill-paragraph ()
+  (with-temp-buffer
+    (insert "AA\nAA\n\nBB\nBB\n")
+    (goto-char 7)
+    (backward-kill-paragraph nil)
+    (should (equal (buffer-string) "\nBB\nBB\n"))))
+
+(ert-deftest paragraphs-tests-transpose-paragraphs ()
+  (with-temp-buffer
+    (insert "AA\nAA\n\nBB\nBB\n")
+    (goto-char (point-min))
+    (transpose-paragraphs 1)
+    (should (equal (buffer-string) "\nBB\nBB\nAA\nAA\n"))))
+
+(ert-deftest paragraphs-tests-start-of-paragraph-text ()
+  (with-temp-buffer
+    (insert "AA\nAA\n\nBB\nBB\n")
+    (goto-char (point-max))
+    (start-of-paragraph-text)
+    (should (equal (point) 8))))
+
+(ert-deftest paragraphs-tests-end-of-paragraph-text ()
+  (with-temp-buffer
+    (insert "AA\nAA\n\nBB\nBB\n")
+    (goto-char (point-min))
+    (end-of-paragraph-text)
+    (should (equal (point) 6))))
+
+(ert-deftest paragraphs-tests-forward-sentence ()
+  (with-temp-buffer
+    (insert "First sentence.  Second sentence.")
+    (goto-char (point-min))
+    (forward-sentence)
+    (should (equal (point) 16))
+    (goto-char (point-min))
+    (forward-sentence 2)
+    (should (equal (point) 34))))
+
+(ert-deftest paragraphs-tests-repunctuate-sentences ()
+  (with-temp-buffer
+    (insert "Just. Some. Sentences.")
+    (goto-char (point-min))
+    (repunctuate-sentences t)
+    (should (equal (buffer-string) "Just.  Some.  Sentences."))))
+
+(ert-deftest paragraphs-tests-backward-sentence ()
+  (with-temp-buffer
+    (insert "First sentence.  Second sentence.")
+    (goto-char (point-max))
+    (backward-sentence)
+    (should (equal (point) 18))))
+
+(ert-deftest paragraphs-tests-kill-sentence ()
+  (with-temp-buffer
+    (insert "First sentence.  Second sentence.")
+    (goto-char (point-min))
+    (kill-sentence)
+    (should (equal (buffer-string) "  Second sentence."))))
+
+(ert-deftest paragraphs-tests-backward-kill-sentence ()
+  (with-temp-buffer
+    (insert "Should not be killed.  Should be killed.")
+    (goto-char (point-max))
+    (backward-kill-sentence)
+    (should (equal (buffer-string) "Should not be killed.  "))))
+
+(ert-deftest paragraphs-tests-mark-end-of-sentence ()
+  (with-temp-buffer
+    (insert "Example sentence.  Followed by another one.")
+    (goto-char (point-min))
+    (mark-end-of-sentence 1)
+    (should mark-active)
+    (should (equal (mark) 18)))
+  (with-temp-buffer
+    (insert "Example sentence.  Followed by another one.")
+    (goto-char (point-min))
+    (mark-end-of-sentence 2)
+    (should mark-active)
+    (should (equal (mark) 44)))
+  ;; FIXME: This does not work -- how do I do it?
+  (with-temp-buffer ; test repeating the command
+    (insert "Example sentence.  Followed by another one.")
+    (goto-char (point-min))
+    (mark-end-of-sentence 1)
+    (setq last-command 'mark-end-of-sentence) ; hack
+    (mark-end-of-sentence 1)
+    (should mark-active)
+    (should (equal (mark) 18))))
+
+(ert-deftest paragraphs-tests-transpose-sentences ()
+  (with-temp-buffer
+    (insert "First sentence.  Second sentence.  Third sentence.")
+    (goto-char (point-min))
+    (transpose-sentences 1)
+    (should (equal (buffer-string)
+                   "Second sentence.  First sentence.  Third sentence."))
+    (goto-char (point-min))
+    (transpose-sentences 2)
+    (should (equal (buffer-string)
+                   "First sentence.  Third sentence.  Second sentence."))))
+
+(provide 'paragraphs-tests)
+;;; paragraphs-tests.el ends here
diff --git a/test/lisp/textmodes/sgml-mode-tests.el b/test/lisp/textmodes/sgml-mode-tests.el
index 61ae87e36d..34d26480a4 100644
--- a/test/lisp/textmodes/sgml-mode-tests.el
+++ b/test/lisp/textmodes/sgml-mode-tests.el
@@ -125,7 +125,6 @@ The point is set to the beginning of the buffer."
      (should (string= content (buffer-string))))))
 
 (ert-deftest sgml-delete-tag-bug-8203-should-not-delete-apostrophe ()
-  :expected-result :failed
   (sgml-with-content
    "<title>Winter is comin'</title>"
    (sgml-delete-tag 1)
@@ -161,5 +160,47 @@ The point is set to the beginning of the buffer."
       (sgml-quote (point-min) (point-max) t)
       (should (string= "&&" (buffer-string))))))
 
+(ert-deftest sgml-tests--quotes-syntax ()
+  (dolist (str '("a\"b <t>c'd</t>"
+                 "a'b <t>c\"d</t>"
+                 "<t>\"a'</t>"
+                 "<t>'a\"</t>"
+                 "<t>\"a'\"</t>"
+                 "<t>'a\"'</t>"
+                 "a\"b <tag>c'd</tag>"
+                 "<tag>c>'d</tag>"
+                 "<t><!-- \" --></t>"
+                 "<t><!-- ' --></t>"
+                 ))
+   (with-temp-buffer
+     (sgml-mode)
+     (insert str)
+     (ert-info ((format "%S" str) :prefix "Test case: ")
+       ;; Check that last tag is parsed as a tag.
+       (should (= 1 (car (syntax-ppss (1- (point-max))))))
+       (should (= 0 (car (syntax-ppss (point-max)))))))))
+
+(ert-deftest sgml-mode-quote-in-long-text ()
+  (with-temp-buffer
+    (sgml-mode)
+    (insert "<t>"
+            ;; `syntax-propertize-wholelines' extends chunk size based
+            ;; on line length, so newlines are significant!
+            (make-string syntax-propertize-chunk-size ?a) "\n"
+            "'"
+            (make-string syntax-propertize-chunk-size ?a) "\n"
+            "</t>")
+    ;; If we just check (syntax-ppss (point-max)) immediately, then
+    ;; we'll end up propertizing the whole buffer in one chunk (so the
+    ;; test is useless).  Simulate something more like what happens
+    ;; when the buffer is viewed normally.
+    (cl-loop for pos from (point-min) to (point-max)
+             by syntax-propertize-chunk-size
+             do (syntax-ppss pos))
+    (syntax-ppss (point-max))
+    ;; Check that last tag is parsed as a tag.
+    (should (= 1 (- (car (syntax-ppss (1- (point-max))))
+                    (car (syntax-ppss (point-max))))))))
+
 (provide 'sgml-mode-tests)
 ;;; sgml-mode-tests.el ends here
diff --git a/test/lisp/timezone-tests.el b/test/lisp/timezone-tests.el
new file mode 100644
index 0000000000..4b5f5617ec
--- /dev/null
+++ b/test/lisp/timezone-tests.el
@@ -0,0 +1,169 @@
+;;; timezone-tests.el --- Tests for timezone.el  -*- lexical-binding: t; -*-
+
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; Author: Stefan Kangas <stefankangas@gmail.com>
+
+;; This file is part of GNU Emacs.
+
+;; GNU Emacs is free software: you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation, either version 3 of the License, or
+;; (at your option) any later version.
+
+;; GNU Emacs is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+(require 'ert)
+(require 'timezone)
+
+(ert-deftest timezone-tests-make-date-arpa-standard ()
+  (should (equal (timezone-make-date-arpa-standard "14 Apr 89 03:20" "PST" "GMT")
+                 "14 Apr 1989 11:20:00 GMT"))
+  (should (equal (timezone-make-date-arpa-standard "14 Apr 89 03:20" "GMT" "GMT")
+                 "14 Apr 1989 03:20:00 GMT"))
+  (should (equal (timezone-make-date-arpa-standard "14 Apr 89 03:20" nil "GMT") ; assume GMT
+                 "14 Apr 1989 03:20:00 GMT")))
+
+(ert-deftest timezone-tests-make-date-sortable ()
+  (should (equal (timezone-make-date-sortable "14 Apr 89 03:20" "GMT" "GMT")
+                 "1989041403:20:00"))
+  (should (equal (timezone-make-date-sortable "14 Apr 89 03:20" nil "GMT") ; assume GMT
+                 "1989041403:20:00")))
+
+(ert-deftest timezone-tests-make-arpa-date ()
+  (should (equal (timezone-make-arpa-date 2020 1 1 "00:00")
+                 "01 Jan 2020 00:00 +0000"))
+  (should (equal (timezone-make-arpa-date 2020 1 1 "00:00" "GMT")
+                 "01 Jan 2020 00:00 GMT")))
+
+(ert-deftest timezone-tests-make-sortable-date ()
+  (should (equal (timezone-make-sortable-date 2020 1 1 "00:00")
+                 "2020010100:00")))
+
+(ert-deftest timezone-tests-make-time-string ()
+  (should (equal (timezone-make-time-string 1 2 3) "01:02:03")))
+
+(ert-deftest timezone-tests-parse-date ()
+  ;; Accepted style 1 from docstring
+  (should (equal (timezone-parse-date "14 Apr 89 03:20")
+                 ["1989" "4" "14" "03:20" nil]))
+  (should (equal (timezone-parse-date "14 Apr 89 03:20 GMT")
+                 ["1989" "4" "14" "03:20" "GMT"]))
+  (should (equal (timezone-parse-date "14 Apr 89 03:20:12")
+                 ["1989" "4" "14" "03:20:12" nil]))
+  (should (equal (timezone-parse-date "14 Apr 89 03:20:12 GMT")
+                 ["1989" "4" "14" "03:20:12" "GMT"]))
+  ;; Accepted style 2 from docstring
+  (should (equal (timezone-parse-date "Fri, 17 Mar 89 4:01")
+                 ["1989" "3" "17" "4:01" nil]))
+  (should (equal (timezone-parse-date "Fri, 17 Mar 89 4:01 GMT")
+                 ["1989" "3" "17" "4:01" "GMT"]))
+  (should (equal (timezone-parse-date "Fri, 17 Mar 89 4:01:33")
+                 ["1989" "3" "17" "4:01:33" nil]))
+  (should (equal (timezone-parse-date "Fri, 17 Mar 89 4:01:33 GMT")
+                 ["1989" "3" "17" "4:01:33" "GMT"]))
+  ;; Accepted style 3 from docstring
+  (should (equal (timezone-parse-date "Mon Jan 16 16:12 1989")
+                 ["1989" "1" "16" "16:12" nil]))
+  (should (equal (timezone-parse-date "Mon Jan 16 16:12 GMT 1989")
+                 ["1989" "1" "16" "16:12" "GMT"]))
+  (should (equal (timezone-parse-date "Mon Jan 16 16:12:37 1989")
+                 ["1989" "1" "16" "16:12:37" nil]))
+  (should (equal (timezone-parse-date "Mon Jan 16 16:12:37 GMT 1989")
+                 ["1989" "1" "16" "16:12:37" "GMT"]))
+  ;; Accepted style 4 from docstring
+  (should (equal (timezone-parse-date "6 May 1992 1641-JST (Wednesday)")
+                 ["1992" "5" "6" "1641" "-JST"]))
+  ;; Accepted style 5 from docstring
+  (should (equal (timezone-parse-date "22-AUG-1993 10:59:12.82")
+                 ["1993" "8" "22" "10:59:12" nil]))
+  ;; Accepted style 6 from docstring
+  (should (equal (timezone-parse-date "Thu, 11 Apr 16:17:12 91")
+                 ["1991" "4" "11" "16:17:12" nil]))
+  (should (equal (timezone-parse-date "Thu, 11 Apr 16:17:12 91 MET")
+                 ["1991" "4" "11" "16:17:12" "MET"]))
+  ;; Accepted style 7 from docstring
+  (should (equal (timezone-parse-date "Mon, 6  Jul 16:47:20 T 1992")
+                 ["1992" "7" "6" "16:47:20" nil]))
+  (should (equal (timezone-parse-date "Mon, 6  Jul 16:47:20 T 1992 MET")
+                 ["1992" "7" "6" "16:47:20" "MET"]))
+  ;; Accepted style 8 from docstring
+  (should (equal (timezone-parse-date "1996-06-24 21:13")
+                 ["1996" "06" "24" "21:13" nil]))
+  (should (equal (timezone-parse-date "1996-06-24 21:13 GMT")
+                 ["1996" "06" "24" "21:13" "GMT"]))
+  (should (equal (timezone-parse-date "1996-06-24 21:13:12")
+                 ["1996" "06" "24" "21:13:12" nil]))
+  (should (equal (timezone-parse-date "1996-06-24 21:13:12 GMT")
+                 ["1996" "06" "24" "21:13:12" "GMT"]))
+  ;; Accepted style 9 from docstring
+  (should (equal (timezone-parse-date "1996-06-24 21:13-ZONE")
+                 ["1996" "06" "24" "21:13" "-ZONE"]))
+  ;; Accepted style 10 from docstring
+  (should (equal (timezone-parse-date "19960624T211312")
+                 ["1996" "06" "24" "211312" nil]))
+  (should (equal (timezone-parse-date "*invalid*") ["0" "0" "0" "0" nil])))
+
+(ert-deftest timezone-tests-parse-date/windowed-dates ()
+  (should (equal (timezone-parse-date "14 Apr 69 10:00")
+                 ["1969" "4" "14" "10:00" nil]))
+  (should (equal (timezone-parse-date "14 Apr 68 10:00")
+                 ["2068" "4" "14" "10:00" nil]))
+  (should (equal (timezone-parse-date "14 Apr 199 10:00")
+                 ["2099" "4" "14" "10:00" nil])))
+
+(ert-deftest timezone-tests-parse-time ()
+  (should (equal (timezone-parse-time "1234")      ["12" "34" "0"]))
+  (should (equal (timezone-parse-time "12:34")     ["12" "34" "0"]))
+  (should (equal (timezone-parse-time "123456")    ["12" "34" "56"]))
+  (should (equal (timezone-parse-time "12:34:56")  ["12" "34" "56"]))
+  (should (equal (timezone-parse-time "*invalid*") ["0" "0" "0"])))
+
+(ert-deftest timezone-tests-zone-to-minute ()
+  (should (equal (timezone-zone-to-minute "GMT") 0))
+  (should (equal (timezone-zone-to-minute "CDT") -300))
+  (should (equal (timezone-zone-to-minute "+100") 60))
+  (should (equal (timezone-zone-to-minute "-100") -60))
+  (should (equal (timezone-zone-to-minute "*invalid*") 0)))
+
+(ert-deftest timezone-tests-time-from-absolute ()
+  (should (equal (timezone-time-from-absolute (* 2020 365)  ; Jan 1 2020
+                                      (* 12 60 60)) ; 12:00
+                 '(23911 48704 0 0))))
+
+;; TODO: Write tests for timezone-tests-time-zone-from-absolute, which is a
+;;       bit tricky since the results depend on `current-time-zone'.
+
+(ert-deftest timezone-tests-fix-time ()
+  (should (equal (timezone-fix-time "20200501 20:20" "GMT" "GMT")
+                 [2020 5 1 20 20 0 "GMT"]))
+  (should (equal (timezone-fix-time "20200501 20:20" nil "GMT") ; assume GMT
+                 [2020 5 1 20 20 0 "GMT"])))
+
+(ert-deftest timezone-tests-last-day-of-month ()
+  (should (equal (timezone-last-day-of-month 2 1999) 28))
+  (should (equal (timezone-last-day-of-month 2 2000) 29))) ; leap year
+
+(ert-deftest timezone-tests-leap-year-p ()
+  (should (equal (timezone-leap-year-p 1999) nil))
+  (should (equal (timezone-leap-year-p 2000) t))
+  (should (equal (timezone-leap-year-p 2024) t))
+  (should (equal (timezone-leap-year-p 2100) nil)))
+
+(ert-deftest timezone-tests-day-number ()
+  (should (equal (timezone-day-number 5 1 1999) 121))
+  (should (equal (timezone-day-number 5 1 2000) 122))) ; leap year
+
+(ert-deftest timezone-tests-absolute-from-gregorian ()
+  (should (equal (timezone-absolute-from-gregorian 1 1 2020) 737425)))
+
+(provide 'timezone-tests)
+;;; timezone-tests.el ends here
diff --git a/test/lisp/wdired-tests.el b/test/lisp/wdired-tests.el
index dc67796cde..9682843db2 100644
--- a/test/lisp/wdired-tests.el
+++ b/test/lisp/wdired-tests.el
@@ -124,6 +124,51 @@ wdired-mode."
 	    (kill-buffer buf)))
 	(delete-directory test-dir t)))))
 
+(ert-deftest wdired-test-bug34915 ()
+  "Test editing when dired-listing-switches includes -F.
+Appended file indicators should not count as part of the file
+name, either before or after editing.  Since
+dired-move-to-end-of-filename handles indicator characters, it
+suffices to compare the return values of dired-get-filename and
+wdired-get-filename before and after editing."
+  ;; FIXME: Add a test for a door (indicator ">") only under Solaris?
+  (let* ((test-dir (make-temp-file "test-dir-" t))
+         (server-socket-dir test-dir)
+         (dired-listing-switches "-Fl")
+         (buf (find-file-noselect test-dir)))
+    (unwind-protect
+        (progn
+	  (with-current-buffer buf
+            (dired-create-empty-file "foo")
+            (set-file-modes "foo" (file-modes-symbolic-to-number "+x"))
+            (make-symbolic-link "foo" "bar")
+            (make-directory "foodir")
+            (require 'dired-x)
+            (dired-smart-shell-command "mkfifo foopipe")
+            (server-force-delete)
+            (server-start)              ; Add a socket file.
+            (kill-buffer buf))
+          (dired test-dir)
+          (dired-toggle-read-only)
+          (let (names)
+            ;; Test that the file names are the same in Dired and WDired.
+            (while (not (eobp))
+              (should (equal (dired-get-filename 'no-dir t)
+                             (wdired-get-filename t)))
+              (insert "w")
+              (push (wdired-get-filename t) names)
+              (dired-next-line 1))
+            (wdired-finish-edit)
+            ;; Test that editing the file names ignores the indicator
+            ;; character.
+            (let (dir)
+              (while (and (dired-previous-line 1)
+                          (setq dir (dired-get-filename 'no-dir t)))
+                (should (equal dir (pop names)))))))
+      (kill-buffer (get-buffer test-dir))
+      (server-force-delete)
+      (delete-directory test-dir t))))
+
 
 (provide 'wdired-tests)
 ;;; wdired-tests.el ends here
diff --git a/test/lisp/xdg-tests.el b/test/lisp/xdg-tests.el
index 9c815065b2..1b678a0abb 100644
--- a/test/lisp/xdg-tests.el
+++ b/test/lisp/xdg-tests.el
@@ -2,8 +2,8 @@
 
 ;; Copyright (C) 2017-2019 Free Software Foundation, Inc.
 
-;; Maintainer: emacs-devel@gnu.org
 ;; Author: Mark Oteiza <mvoteiza@udel.edu>
+;; Maintainer: emacs-devel@gnu.org
 
 ;; This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/cedet-utests.el b/test/manual/cedet/cedet-utests.el
index 23362db4f2..67a828bb29 100644
--- a/test/manual/cedet/cedet-utests.el
+++ b/test/manual/cedet/cedet-utests.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/ede-tests.el b/test/manual/cedet/ede-tests.el
index 0b5864d736..c8b54db958 100644
--- a/test/manual/cedet/ede-tests.el
+++ b/test/manual/cedet/ede-tests.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/semantic-ia-utest.el b/test/manual/cedet/semantic-ia-utest.el
index 665a538244..10f02b3c34 100644
--- a/test/manual/cedet/semantic-ia-utest.el
+++ b/test/manual/cedet/semantic-ia-utest.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/semantic-utest-c.el b/test/manual/cedet/semantic-utest-c.el
index a24bf10ae9..a79c7c8822 100644
--- a/test/manual/cedet/semantic-utest-c.el
+++ b/test/manual/cedet/semantic-utest-c.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/srecode-tests.el b/test/manual/cedet/srecode-tests.el
index 5d5a970a0a..b849d7a603 100644
--- a/test/manual/cedet/srecode-tests.el
+++ b/test/manual/cedet/srecode-tests.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/test.c b/test/manual/cedet/tests/test.c
index 7d6411e7ae..2e90ef7272 100644
--- a/test/manual/cedet/tests/test.c
+++ b/test/manual/cedet/tests/test.c
@@ -2,7 +2,7 @@
 
    Copyright (C) 2001-2019 Free Software Foundation, Inc.
 
-   Author: Eric M. Ludlam <eric@siege-engine.com>
+   Author: Eric M. Ludlam <zappo@gnu.org>
 
    This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/test.el b/test/manual/cedet/tests/test.el
index 664e6cb453..242186c360 100644
--- a/test/manual/cedet/tests/test.el
+++ b/test/manual/cedet/tests/test.el
@@ -2,7 +2,7 @@
 
 ;; Copyright (C) 2005-2019 Free Software Foundation, Inc.
 
-;; Author: Eric M. Ludlam <eric@siege-engine.com>
+;; Author: Eric M. Ludlam <zappo@gnu.org>
 
 ;; This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/test.make b/test/manual/cedet/tests/test.make
index 60a40704f3..fe0d594c22 100644
--- a/test/manual/cedet/tests/test.make
+++ b/test/manual/cedet/tests/test.make
@@ -2,7 +2,7 @@
 
 # Copyright (C) 2001-2002, 2010-2019 Free Software Foundation, Inc.
 
-# Author: Eric M. Ludlam <eric@siege-engine.com>
+# Author: Eric M. Ludlam <zappo@gnu.org>
 
 # This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/testdoublens.cpp b/test/manual/cedet/tests/testdoublens.cpp
index 62efad454a..4d10644e44 100644
--- a/test/manual/cedet/tests/testdoublens.cpp
+++ b/test/manual/cedet/tests/testdoublens.cpp
@@ -2,7 +2,7 @@
 
 // Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-// Author: Eric M. Ludlam <eric@siege-engine.com>
+// Author: Eric M. Ludlam <zappo@gnu.org>
 
 // This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/testdoublens.hpp b/test/manual/cedet/tests/testdoublens.hpp
index 54f2acf168..507c8342b4 100644
--- a/test/manual/cedet/tests/testdoublens.hpp
+++ b/test/manual/cedet/tests/testdoublens.hpp
@@ -2,7 +2,7 @@
 
 // Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-// Author: Eric M. Ludlam <eric@siege-engine.com>
+// Author: Eric M. Ludlam <zappo@gnu.org>
 
 // This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/testjavacomp.java b/test/manual/cedet/tests/testjavacomp.java
index 1ebd7dc06f..1102e51891 100644
--- a/test/manual/cedet/tests/testjavacomp.java
+++ b/test/manual/cedet/tests/testjavacomp.java
@@ -2,7 +2,7 @@
 
 // Copyright (C) 2009-2019 Free Software Foundation, Inc.
 
-//  Author: Eric M. Ludlam <eric@siege-engine.com>
+//  Author: Eric M. Ludlam <zappo@gnu.org>
 
 //  This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/testpolymorph.cpp b/test/manual/cedet/tests/testpolymorph.cpp
index cf605f60bd..ce40fa30d5 100644
--- a/test/manual/cedet/tests/testpolymorph.cpp
+++ b/test/manual/cedet/tests/testpolymorph.cpp
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2009-2019 Free Software Foundation, Inc.
  *
- * Author: Eric M. Ludlam <eric@siege-engine.com>
+ * Author: Eric M. Ludlam <zappo@gnu.org>
  *
  * This file is part of GNU Emacs.
  *
diff --git a/test/manual/cedet/tests/testspp.c b/test/manual/cedet/tests/testspp.c
index beead02dd2..dafae86499 100644
--- a/test/manual/cedet/tests/testspp.c
+++ b/test/manual/cedet/tests/testspp.c
@@ -2,7 +2,7 @@
 
    Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-   Author: Eric M. Ludlam <eric@siege-engine.com>
+   Author: Eric M. Ludlam <zappo@gnu.org>
 
    This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/testsppreplace.c b/test/manual/cedet/tests/testsppreplace.c
index a76d420430..b25f3d1871 100644
--- a/test/manual/cedet/tests/testsppreplace.c
+++ b/test/manual/cedet/tests/testsppreplace.c
@@ -1,7 +1,7 @@
 /* testsppreplace.c --- unit test for CPP/SPP Replacement
    Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-   Author: Eric M. Ludlam <eric@siege-engine.com>
+   Author: Eric M. Ludlam <zappo@gnu.org>
 
    This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/testsppreplaced.c b/test/manual/cedet/tests/testsppreplaced.c
index ab13b3a817..4106c22ba6 100644
--- a/test/manual/cedet/tests/testsppreplaced.c
+++ b/test/manual/cedet/tests/testsppreplaced.c
@@ -1,7 +1,7 @@
 /* testsppreplaced.c --- unit test for CPP/SPP Replacement
    Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-   Author: Eric M. Ludlam <eric@siege-engine.com>
+   Author: Eric M. Ludlam <zappo@gnu.org>
 
    This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/testsubclass.cpp b/test/manual/cedet/tests/testsubclass.cpp
index ece497b9c2..8ae28bae94 100644
--- a/test/manual/cedet/tests/testsubclass.cpp
+++ b/test/manual/cedet/tests/testsubclass.cpp
@@ -2,7 +2,7 @@
 
 // Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-// Author: Eric M. Ludlam <eric@siege-engine.com>
+// Author: Eric M. Ludlam <zappo@gnu.org>
 
 // This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/testsubclass.hh b/test/manual/cedet/tests/testsubclass.hh
index 1963e156f1..893b33eab7 100644
--- a/test/manual/cedet/tests/testsubclass.hh
+++ b/test/manual/cedet/tests/testsubclass.hh
@@ -2,7 +2,7 @@
 
 // Copyright (C) 2007-2019 Free Software Foundation, Inc.
 
-// Author: Eric M. Ludlam <eric@siege-engine.com>
+// Author: Eric M. Ludlam <zappo@gnu.org>
 
 // This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/testtypedefs.cpp b/test/manual/cedet/tests/testtypedefs.cpp
index f8a3f2e18b..6c6628ddf4 100644
--- a/test/manual/cedet/tests/testtypedefs.cpp
+++ b/test/manual/cedet/tests/testtypedefs.cpp
@@ -2,7 +2,7 @@
 
 // Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-// Author: Eric M. Ludlam <eric@siege-engine.com>
+// Author: Eric M. Ludlam <zappo@gnu.org>
 
 // This file is part of GNU Emacs.
 
diff --git a/test/manual/cedet/tests/testvarnames.c b/test/manual/cedet/tests/testvarnames.c
index 77760724dd..1cbf3c02c4 100644
--- a/test/manual/cedet/tests/testvarnames.c
+++ b/test/manual/cedet/tests/testvarnames.c
@@ -3,7 +3,7 @@
 
    Copyright (C) 2008-2019 Free Software Foundation, Inc.
 
-   Author: Eric M. Ludlam <eric@siege-engine.com>
+   Author: Eric M. Ludlam <zappo@gnu.org>
 
    This file is part of GNU Emacs.
 
diff --git a/test/src/callproc-tests.el b/test/src/callproc-tests.el
index 7b30a251cc..1cad8360de 100644
--- a/test/src/callproc-tests.el
+++ b/test/src/callproc-tests.el
@@ -37,3 +37,26 @@
         (split-string-and-unquote (buffer-string)))
     (should (equal initial-shell "nil"))
     (should-not (equal initial-shell shell))))
+
+(ert-deftest call-process-w32-debug-spawn-error ()
+  "Check that debugger runs on `call-process' failure (Bug#33016)."
+  (skip-unless (eq system-type 'windows-nt))
+  (let* ((debug-on-error t)
+         (have-called-debugger nil)
+         (debugger (lambda (&rest _)
+                     (setq have-called-debugger t)
+                     ;; Allow entering the debugger later in the same
+                     ;; test run, before going back to the command
+                     ;; loop.
+                     (setq internal-when-entered-debugger -1))))
+    (should (eq :got-error ;; NOTE: `should-error' would inhibit debugger.
+                (condition-case-unless-debug ()
+                    ;; On MS-Windows, "nul.FOO" resolves to the null
+                    ;; device, and thus acts like an always-empty
+                    ;; file, for any FOO, in any directory.  So
+                    ;; c:/null.exe passes Emacs' test for the file's
+                    ;; existence, and ensures we hit an error in the
+                    ;; w32 process spawn code.
+                    (call-process "c:/nul.exe")
+                  (error :got-error))))
+    (should have-called-debugger)))
diff --git a/test/src/emacs-module-tests.el b/test/src/emacs-module-tests.el
index 35aaaa64b6..5349de055e 100644
--- a/test/src/emacs-module-tests.el
+++ b/test/src/emacs-module-tests.el
@@ -1,4 +1,4 @@
-;;; Test GNU Emacs modules.
+;;; emacs-module-tests --- Test GNU Emacs modules.  -*- lexical-binding: t; -*-
 
 ;; Copyright 2015-2019 Free Software Foundation, Inc.
 
@@ -17,6 +17,14 @@
 ;; You should have received a copy of the GNU General Public License
 ;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 
+;;; Commentary:
+
+;; Unit tests for the dynamic module facility.  See Info node `(elisp)
+;; Writing Dynamic Modules'.  These tests make use of a small test
+;; module in test/data/emacs-module.
+
+;;; Code:
+
 (require 'cl-lib)
 (require 'ert)
 (require 'help-fns)
@@ -137,8 +145,9 @@ changes."
 ;;
 
 (defun multiply-string (s n)
+  "Return N copies of S concatenated together."
   (let ((res ""))
-    (dotimes (i n)
+    (dotimes (_ n)
       (setq res (concat res s)))
     res))
 
@@ -304,10 +313,68 @@ Interactively, you can try hitting \\[keyboard-quit] to quit."
                          ;; Interactively, run for 5 seconds to give the
                          ;; user time to quit.  In batch mode, run only
                          ;; briefly since the user can't quit.
-                         (float-time (time-add nil (if noninteractive 0.1 5)))
+                         (time-add nil (if noninteractive 0.1 5))
                          ;; should_quit or process_input
                          arg))
                       'finished))
         (quit)))))
 
+(ert-deftest mod-test-add-nanosecond/valid ()
+  (dolist (input (list
+                  ;; Some realistic examples.
+                  (current-time) (time-to-seconds)
+                  (encode-time 12 34 5 6 7 2019 t)
+                  ;; Various legacy timestamp forms.
+                  '(123 456) '(123 456 789) '(123 456 789 6000)
+                  ;; Corner case: this will result in a nanosecond
+                  ;; value of 1000000000 after addition.  The module
+                  ;; code should handle this correctly.
+                  '(123 65535 999999 999000)
+                  ;; Seconds since the epoch.
+                  123 123.45
+                  ;; New (TICKS . HZ) format.
+                  '(123456789 . 1000000000)))
+    (ert-info ((format "input: %s" input))
+      (let ((result (mod-test-add-nanosecond input)))
+        (should (consp result))
+        (should (integerp (car result)))
+        (should (integerp (cdr result)))
+        (should (cl-plusp (cdr result)))
+        (should (time-equal-p result (time-add input '(0 0 0 1000))))))))
+
+(ert-deftest mod-test-add-nanosecond/nil ()
+  (should (<= (float-time (mod-test-add-nanosecond nil))
+              (+ (float-time) 1e-9))))
+
+(ert-deftest mod-test-add-nanosecond/invalid ()
+  (dolist (input '(1.0e+INF 1.0e-INF 0.0e+NaN (123) (123.45 6 7) "foo" [1 2]))
+    (ert-info ((format "input: %s" input))
+      (should-error (mod-test-add-nanosecond input)))))
+
+(ert-deftest mod-test-nanoseconds ()
+  "Test truncation when converting to `struct timespec'."
+  (dolist (test-case '((0 . 0)
+                       (-1 . -1000000000)
+                       ((1 . 1000000000) . 1)
+                       ((-1 . 1000000000) . -1)
+                       ((1 . 1000000000000) . 0)
+                       ((-1 . 1000000000000) . -1)
+                       ((999 . 1000000000000) . 0)
+                       ((-999 . 1000000000000) . -1)
+                       ((1000 . 1000000000000) . 1)
+                       ((-1000 . 1000000000000) . -1)
+                       ((0 0 0 1) . 0)
+                       ((0 0 0 -1) . -1)))
+    (let ((input (car test-case))
+          (expected (cdr test-case)))
+      (ert-info ((format "input: %S, expected result: %d" input expected))
+        (should (eq (mod-test-nanoseconds input) expected))))))
+
+(ert-deftest mod-test-double ()
+  (dolist (input (list 0 1 2 -1 42 12345678901234567890
+                       most-positive-fixnum (1+ most-positive-fixnum)
+                       most-negative-fixnum (1- most-negative-fixnum)))
+    (ert-info ((format "input: %d" input))
+      (should (= (mod-test-double input) (* 2 input))))))
+
 ;;; emacs-module-tests.el ends here
diff --git a/test/src/fns-tests.el b/test/src/fns-tests.el
index 6ebab4287f..a9d4d11795 100644
--- a/test/src/fns-tests.el
+++ b/test/src/fns-tests.el
@@ -614,7 +614,8 @@
     (should (eq x x))
     (should (eql x y))
     (should (equal x y))
-    (should-not (eql x 0.0e+NaN))))
+    (should-not (eql x 0.0e+NaN))
+    (should (memql x (list y)))))
 
 (ert-deftest test-bignum-hash ()
   "Test that hash tables work for bignums."
diff --git a/test/src/json-tests.el b/test/src/json-tests.el
index 542eec11bf..7d824b5c95 100644
--- a/test/src/json-tests.el
+++ b/test/src/json-tests.el
@@ -159,7 +159,7 @@
   (skip-unless (fboundp 'json-parse-string))
   (should-error (json-parse-string "\x00") :type 'wrong-type-argument)
   ;; FIXME: Reconsider whether this is the right behavior.
-  (should-error (json-parse-string "[a\\u0000b]") :type 'json-parse-error))
+  (should-error (json-parse-string "[\"a\\u0000b\"]") :type 'json-parse-error))
 
 (ert-deftest json-parse-string/invalid-unicode ()
   "Some examples from
diff --git a/test/src/lread-tests.el b/test/src/lread-tests.el
index ae918f0312..82b75b195c 100644
--- a/test/src/lread-tests.el
+++ b/test/src/lread-tests.el
@@ -140,7 +140,9 @@ literals (Bug#20852)."
     (should (equal (lread-tests--last-message)
                    (concat (format-message "Loading `%s': " file-name)
                            "unescaped character literals "
-                           "`?\"', `?(', `?)', `?;', `?[', `?]' detected!")))))
+                           "`?\"', `?(', `?)', `?;', `?[', `?]' detected, "
+                           "`?\\\"', `?\\(', `?\\)', `?\\;', `?\\[', `?\\]' "
+                           "expected!")))))
 
 (ert-deftest lread-tests--funny-quote-symbols ()
   "Check that 'smart quotes' or similar trigger errors in symbol names."
diff --git a/test/src/process-tests.el b/test/src/process-tests.el
index 5dbf441e8c..b853f77946 100644
--- a/test/src/process-tests.el
+++ b/test/src/process-tests.el
@@ -215,6 +215,26 @@
                                       (string-to-list "stdout\n")
                                       (string-to-list "stderr\n"))))))
 
+(ert-deftest make-process-w32-debug-spawn-error ()
+  "Check that debugger runs on `make-process' failure (Bug#33016)."
+  (skip-unless (eq system-type 'windows-nt))
+  (let* ((debug-on-error t)
+         (have-called-debugger nil)
+         (debugger (lambda (&rest _)
+                     (setq have-called-debugger t)
+                     ;; Allow entering the debugger later in the same
+                     ;; test run, before going back to the command
+                     ;; loop.
+                     (setq internal-when-entered-debugger -1))))
+    (should (eq :got-error ;; NOTE: `should-error' would inhibit debugger.
+                (condition-case-unless-debug ()
+                    ;; Emacs doesn't search for absolute filenames, so
+                    ;; the error will be hit in the w32 process spawn
+                    ;; code.
+                    (make-process :name "test" :command '("c:/No-Such-Command"))
+                  (error :got-error))))
+    (should have-called-debugger)))
+
 (ert-deftest make-process/file-handler/found ()
   "Check that the ‘:file-handler’ argument of ‘make-process’
 works as expected if a file name handler is found."
@@ -264,5 +284,14 @@ file name handler."
 (put #'process-tests--file-handler 'operations
      '(unhandled-file-name-directory make-process))
 
+(ert-deftest make-process/stop ()
+  "Check that `make-process' doesn't accept a `:stop' key.
+See Bug#30460."
+  (should-error
+   (make-process :name "test"
+                 :command (list (expand-file-name invocation-name
+                                                  invocation-directory))
+                 :stop t)))
+
 (provide 'process-tests)
 ;; process-tests.el ends here.
diff --git a/test/src/timefns-tests.el b/test/src/timefns-tests.el
index 5c858ef3bd..2c90af757f 100644
--- a/test/src/timefns-tests.el
+++ b/test/src/timefns-tests.el
@@ -142,3 +142,9 @@
 		      (< 0.99 (/ x y) 1.01)
 		      (< 0.99 (/ (- (float-time a)) (float-time b))
 			 1.01))))))))
+
+(ert-deftest encode-time-dst-numeric-zone ()
+    "Check for Bug#35502."
+    (should (time-equal-p
+             (encode-time '(29 31 17 30 4 2019 2 t 7200))
+             '(23752 27217))))
